/**
 * Client
 **/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model NotificationEvent
 *
 */
export type NotificationEvent = $Result.DefaultSelection<Prisma.$NotificationEventPayload>;
/**
 * Model NotificationPreference
 *
 */
export type NotificationPreference =
  $Result.DefaultSelection<Prisma.$NotificationPreferencePayload>;
/**
 * Model Notification
 *
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>;
/**
 * Model NotificationDelivery
 *
 */
export type NotificationDelivery = $Result.DefaultSelection<Prisma.$NotificationDeliveryPayload>;
/**
 * Model NotificationTemplate
 *
 */
export type NotificationTemplate = $Result.DefaultSelection<Prisma.$NotificationTemplatePayload>;
/**
 * Model NotificationProvider
 *
 */
export type NotificationProvider = $Result.DefaultSelection<Prisma.$NotificationProviderPayload>;
/**
 * Model HelixUserNotificationProfile
 *
 */
export type HelixUserNotificationProfile =
  $Result.DefaultSelection<Prisma.$HelixUserNotificationProfilePayload>;
/**
 * Model NotificationQueue
 *
 */
export type NotificationQueue = $Result.DefaultSelection<Prisma.$NotificationQueuePayload>;
/**
 * Model NotificationRoleDefault
 *
 */
export type NotificationRoleDefault =
  $Result.DefaultSelection<Prisma.$NotificationRoleDefaultPayload>;
/**
 * Model NotificationAuditLog
 *
 */
export type NotificationAuditLog = $Result.DefaultSelection<Prisma.$NotificationAuditLogPayload>;
/**
 * Model RoleNotificationDefaults
 *
 */
export type RoleNotificationDefaults =
  $Result.DefaultSelection<Prisma.$RoleNotificationDefaultsPayload>;
/**
 * Model NotificationAnalytics
 *
 */
export type NotificationAnalytics = $Result.DefaultSelection<Prisma.$NotificationAnalyticsPayload>;

/**
 * Enums
 */
export namespace $Enums {
  export const NotificationChannel: {
    EMAIL: 'EMAIL';
    SMS: 'SMS';
    PUSH: 'PUSH';
    IN_APP: 'IN_APP';
    SLACK: 'SLACK';
    TEAMS: 'TEAMS';
    DISCORD: 'DISCORD';
    WEBHOOK: 'WEBHOOK';
    PHONE_CALL: 'PHONE_CALL';
    PAGER: 'PAGER';
  };

  export type NotificationChannel = (typeof NotificationChannel)[keyof typeof NotificationChannel];

  export const NotificationPriority: {
    CRITICAL: 'CRITICAL';
    HIGH: 'HIGH';
    NORMAL: 'NORMAL';
    LOW: 'LOW';
  };

  export type NotificationPriority =
    (typeof NotificationPriority)[keyof typeof NotificationPriority];

  export const NotificationStatus: {
    PENDING: 'PENDING';
    SCHEDULED: 'SCHEDULED';
    SENT: 'SENT';
    DELIVERED: 'DELIVERED';
    READ: 'READ';
    CLICKED: 'CLICKED';
    DISMISSED: 'DISMISSED';
    FAILED: 'FAILED';
    EXPIRED: 'EXPIRED';
    CANCELLED: 'CANCELLED';
  };

  export type NotificationStatus = (typeof NotificationStatus)[keyof typeof NotificationStatus];

  export const EventStatus: {
    PENDING: 'PENDING';
    PROCESSING: 'PROCESSING';
    COMPLETED: 'COMPLETED';
    FAILED: 'FAILED';
    CANCELLED: 'CANCELLED';
    SCHEDULED: 'SCHEDULED';
  };

  export type EventStatus = (typeof EventStatus)[keyof typeof EventStatus];

  export const DeliveryStatus: {
    PENDING: 'PENDING';
    SENDING: 'SENDING';
    SENT: 'SENT';
    DELIVERED: 'DELIVERED';
    FAILED: 'FAILED';
    BOUNCED: 'BOUNCED';
    REJECTED: 'REJECTED';
  };

  export type DeliveryStatus = (typeof DeliveryStatus)[keyof typeof DeliveryStatus];

  export const DigestFrequency: {
    IMMEDIATELY: 'IMMEDIATELY';
    HOURLY: 'HOURLY';
    DAILY: 'DAILY';
    WEEKLY: 'WEEKLY';
  };

  export type DigestFrequency = (typeof DigestFrequency)[keyof typeof DigestFrequency];

  export const AiGroupingLevel: {
    DISABLED: 'DISABLED';
    EVENT_TYPE: 'EVENT_TYPE';
    MODULE: 'MODULE';
    PRIORITY: 'PRIORITY';
    GLOBAL: 'GLOBAL';
  };

  export type AiGroupingLevel = (typeof AiGroupingLevel)[keyof typeof AiGroupingLevel];

  export const ProviderHealth: {
    HEALTHY: 'HEALTHY';
    DEGRADED: 'DEGRADED';
    UNHEALTHY: 'UNHEALTHY';
    UNKNOWN: 'UNKNOWN';
  };

  export type ProviderHealth = (typeof ProviderHealth)[keyof typeof ProviderHealth];
}

export type NotificationChannel = $Enums.NotificationChannel;

export const NotificationChannel: typeof $Enums.NotificationChannel;

export type NotificationPriority = $Enums.NotificationPriority;

export const NotificationPriority: typeof $Enums.NotificationPriority;

export type NotificationStatus = $Enums.NotificationStatus;

export const NotificationStatus: typeof $Enums.NotificationStatus;

export type EventStatus = $Enums.EventStatus;

export const EventStatus: typeof $Enums.EventStatus;

export type DeliveryStatus = $Enums.DeliveryStatus;

export const DeliveryStatus: typeof $Enums.DeliveryStatus;

export type DigestFrequency = $Enums.DigestFrequency;

export const DigestFrequency: typeof $Enums.DigestFrequency;

export type AiGroupingLevel = $Enums.AiGroupingLevel;

export const AiGroupingLevel: typeof $Enums.AiGroupingLevel;

export type ProviderHealth = $Enums.ProviderHealth;

export const ProviderHealth: typeof $Enums.ProviderHealth;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more NotificationEvents
 * const notificationEvents = await prisma.notificationEvent.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions
    ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions['log']>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] };

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more NotificationEvents
   * const notificationEvents = await prisma.notificationEvent.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(
    eventType: V,
    callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void,
  ): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel },
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>,
    options?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    },
  ): $Utils.JsPromise<R>;

  $extends: $Extensions.ExtendsHook<
    'extends',
    Prisma.TypeMapCb<ClientOptions>,
    ExtArgs,
    $Utils.Call<
      Prisma.TypeMapCb<ClientOptions>,
      {
        extArgs: ExtArgs;
      }
    >
  >;

  /**
   * `prisma.notificationEvent`: Exposes CRUD operations for the **NotificationEvent** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more NotificationEvents
   * const notificationEvents = await prisma.notificationEvent.findMany()
   * ```
   */
  get notificationEvent(): Prisma.NotificationEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationPreference`: Exposes CRUD operations for the **NotificationPreference** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more NotificationPreferences
   * const notificationPreferences = await prisma.notificationPreference.findMany()
   * ```
   */
  get notificationPreference(): Prisma.NotificationPreferenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Notifications
   * const notifications = await prisma.notification.findMany()
   * ```
   */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationDelivery`: Exposes CRUD operations for the **NotificationDelivery** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more NotificationDeliveries
   * const notificationDeliveries = await prisma.notificationDelivery.findMany()
   * ```
   */
  get notificationDelivery(): Prisma.NotificationDeliveryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationTemplate`: Exposes CRUD operations for the **NotificationTemplate** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more NotificationTemplates
   * const notificationTemplates = await prisma.notificationTemplate.findMany()
   * ```
   */
  get notificationTemplate(): Prisma.NotificationTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationProvider`: Exposes CRUD operations for the **NotificationProvider** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more NotificationProviders
   * const notificationProviders = await prisma.notificationProvider.findMany()
   * ```
   */
  get notificationProvider(): Prisma.NotificationProviderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.helixUserNotificationProfile`: Exposes CRUD operations for the **HelixUserNotificationProfile** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more HelixUserNotificationProfiles
   * const helixUserNotificationProfiles = await prisma.helixUserNotificationProfile.findMany()
   * ```
   */
  get helixUserNotificationProfile(): Prisma.HelixUserNotificationProfileDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.notificationQueue`: Exposes CRUD operations for the **NotificationQueue** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more NotificationQueues
   * const notificationQueues = await prisma.notificationQueue.findMany()
   * ```
   */
  get notificationQueue(): Prisma.NotificationQueueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationRoleDefault`: Exposes CRUD operations for the **NotificationRoleDefault** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more NotificationRoleDefaults
   * const notificationRoleDefaults = await prisma.notificationRoleDefault.findMany()
   * ```
   */
  get notificationRoleDefault(): Prisma.NotificationRoleDefaultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationAuditLog`: Exposes CRUD operations for the **NotificationAuditLog** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more NotificationAuditLogs
   * const notificationAuditLogs = await prisma.notificationAuditLog.findMany()
   * ```
   */
  get notificationAuditLog(): Prisma.NotificationAuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roleNotificationDefaults`: Exposes CRUD operations for the **RoleNotificationDefaults** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more RoleNotificationDefaults
   * const roleNotificationDefaults = await prisma.roleNotificationDefaults.findMany()
   * ```
   */
  get roleNotificationDefaults(): Prisma.RoleNotificationDefaultsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationAnalytics`: Exposes CRUD operations for the **NotificationAnalytics** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more NotificationAnalytics
   * const notificationAnalytics = await prisma.notificationAnalytics.findMany()
   * ```
   */
  get notificationAnalytics(): Prisma.NotificationAnalyticsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;

  export type PrismaPromise<T> = $Public.PrismaPromise<T>;

  /**
   * Validator
   */
  export import validator = runtime.Public.validator;

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  export type DecimalJsLike = runtime.DecimalJsLike;

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics;
  export type Metric<T> = runtime.Metric<T>;
  export type MetricHistogram = runtime.MetricHistogram;
  export type MetricHistogramBucket = runtime.MetricHistogramBucket;

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs;
  export import getExtensionContext = runtime.Extensions.getExtensionContext;
  export import Args = $Public.Args;
  export import Payload = $Public.Payload;
  export import Result = $Public.Result;
  export import Exact = $Public.Exact;

  /**
   * Prisma Client JS version: 6.14.0
   * Query Engine version: 717184b7b35ea05dfa71a3236b7af656013e1e49
   */
  export type PrismaVersion = {
    client: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  export import JsonObject = runtime.JsonObject;
  export import JsonArray = runtime.JsonArray;
  export import JsonValue = runtime.JsonValue;
  export import InputJsonObject = runtime.InputJsonObject;
  export import InputJsonArray = runtime.InputJsonArray;
  export import InputJsonValue = runtime.InputJsonValue;

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never;
      private constructor();
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull;

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull;

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull;

  type SelectAndInclude = {
    select: any;
    include: any;
  };

  type SelectAndOmit = {
    select: any;
    omit: any;
  };

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<
    ReturnType<T>
  >;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
  };

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends BigInt
            ? False
            : T extends object
              ? True
              : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<O extends object, K extends Key, strict extends Boolean = 1> = O extends unknown
    ? _Either<O, K, strict>
    : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (U extends unknown ? (k: U) => void : never) extends (
    k: infer I,
  ) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
      : never
  >;

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0;

  export type Has<U extends Union, U1 extends Union> = Not<Extends<Exclude<U1, U>, U1>>;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<T, U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>> =
    IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<Or<Extends<'OR', K>, Extends<'AND', K>>, Extends<'NOT', K>> extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<
    T,
    MaybeTupleToUnion<K>
  >;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T;

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>;

  export const ModelName: {
    NotificationEvent: 'NotificationEvent';
    NotificationPreference: 'NotificationPreference';
    Notification: 'Notification';
    NotificationDelivery: 'NotificationDelivery';
    NotificationTemplate: 'NotificationTemplate';
    NotificationProvider: 'NotificationProvider';
    HelixUserNotificationProfile: 'HelixUserNotificationProfile';
    NotificationQueue: 'NotificationQueue';
    NotificationRoleDefault: 'NotificationRoleDefault';
    NotificationAuditLog: 'NotificationAuditLog';
    RoleNotificationDefaults: 'RoleNotificationDefaults';
    NotificationAnalytics: 'NotificationAnalytics';
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName];

  export type Datasources = {
    notification_db?: Datasource;
  };

  interface TypeMapCb<ClientOptions = {}>
    extends $Utils.Fn<{ extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<
      this['params']['extArgs'],
      ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}
    >;
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > = {
    globalOmitOptions: {
      omit: GlobalOmitOptions;
    };
    meta: {
      modelProps:
        | 'notificationEvent'
        | 'notificationPreference'
        | 'notification'
        | 'notificationDelivery'
        | 'notificationTemplate'
        | 'notificationProvider'
        | 'helixUserNotificationProfile'
        | 'notificationQueue'
        | 'notificationRoleDefault'
        | 'notificationAuditLog'
        | 'roleNotificationDefaults'
        | 'notificationAnalytics';
      txIsolationLevel: Prisma.TransactionIsolationLevel;
    };
    model: {
      NotificationEvent: {
        payload: Prisma.$NotificationEventPayload<ExtArgs>;
        fields: Prisma.NotificationEventFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.NotificationEventFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationEventPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.NotificationEventFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationEventPayload>;
          };
          findFirst: {
            args: Prisma.NotificationEventFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationEventPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.NotificationEventFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationEventPayload>;
          };
          findMany: {
            args: Prisma.NotificationEventFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationEventPayload>[];
          };
          create: {
            args: Prisma.NotificationEventCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationEventPayload>;
          };
          createMany: {
            args: Prisma.NotificationEventCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.NotificationEventCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationEventPayload>[];
          };
          delete: {
            args: Prisma.NotificationEventDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationEventPayload>;
          };
          update: {
            args: Prisma.NotificationEventUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationEventPayload>;
          };
          deleteMany: {
            args: Prisma.NotificationEventDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.NotificationEventUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.NotificationEventUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationEventPayload>[];
          };
          upsert: {
            args: Prisma.NotificationEventUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationEventPayload>;
          };
          aggregate: {
            args: Prisma.NotificationEventAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateNotificationEvent>;
          };
          groupBy: {
            args: Prisma.NotificationEventGroupByArgs<ExtArgs>;
            result: $Utils.Optional<NotificationEventGroupByOutputType>[];
          };
          count: {
            args: Prisma.NotificationEventCountArgs<ExtArgs>;
            result: $Utils.Optional<NotificationEventCountAggregateOutputType> | number;
          };
        };
      };
      NotificationPreference: {
        payload: Prisma.$NotificationPreferencePayload<ExtArgs>;
        fields: Prisma.NotificationPreferenceFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.NotificationPreferenceFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>;
          };
          findFirst: {
            args: Prisma.NotificationPreferenceFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>;
          };
          findMany: {
            args: Prisma.NotificationPreferenceFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[];
          };
          create: {
            args: Prisma.NotificationPreferenceCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>;
          };
          createMany: {
            args: Prisma.NotificationPreferenceCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[];
          };
          delete: {
            args: Prisma.NotificationPreferenceDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>;
          };
          update: {
            args: Prisma.NotificationPreferenceUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>;
          };
          deleteMany: {
            args: Prisma.NotificationPreferenceDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.NotificationPreferenceUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[];
          };
          upsert: {
            args: Prisma.NotificationPreferenceUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>;
          };
          aggregate: {
            args: Prisma.NotificationPreferenceAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateNotificationPreference>;
          };
          groupBy: {
            args: Prisma.NotificationPreferenceGroupByArgs<ExtArgs>;
            result: $Utils.Optional<NotificationPreferenceGroupByOutputType>[];
          };
          count: {
            args: Prisma.NotificationPreferenceCountArgs<ExtArgs>;
            result: $Utils.Optional<NotificationPreferenceCountAggregateOutputType> | number;
          };
        };
      };
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>;
        fields: Prisma.NotificationFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[];
          };
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[];
          };
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[];
          };
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateNotification>;
          };
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>;
            result: $Utils.Optional<NotificationGroupByOutputType>[];
          };
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>;
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number;
          };
        };
      };
      NotificationDelivery: {
        payload: Prisma.$NotificationDeliveryPayload<ExtArgs>;
        fields: Prisma.NotificationDeliveryFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.NotificationDeliveryFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationDeliveryPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.NotificationDeliveryFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationDeliveryPayload>;
          };
          findFirst: {
            args: Prisma.NotificationDeliveryFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationDeliveryPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.NotificationDeliveryFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationDeliveryPayload>;
          };
          findMany: {
            args: Prisma.NotificationDeliveryFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationDeliveryPayload>[];
          };
          create: {
            args: Prisma.NotificationDeliveryCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationDeliveryPayload>;
          };
          createMany: {
            args: Prisma.NotificationDeliveryCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.NotificationDeliveryCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationDeliveryPayload>[];
          };
          delete: {
            args: Prisma.NotificationDeliveryDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationDeliveryPayload>;
          };
          update: {
            args: Prisma.NotificationDeliveryUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationDeliveryPayload>;
          };
          deleteMany: {
            args: Prisma.NotificationDeliveryDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.NotificationDeliveryUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.NotificationDeliveryUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationDeliveryPayload>[];
          };
          upsert: {
            args: Prisma.NotificationDeliveryUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationDeliveryPayload>;
          };
          aggregate: {
            args: Prisma.NotificationDeliveryAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateNotificationDelivery>;
          };
          groupBy: {
            args: Prisma.NotificationDeliveryGroupByArgs<ExtArgs>;
            result: $Utils.Optional<NotificationDeliveryGroupByOutputType>[];
          };
          count: {
            args: Prisma.NotificationDeliveryCountArgs<ExtArgs>;
            result: $Utils.Optional<NotificationDeliveryCountAggregateOutputType> | number;
          };
        };
      };
      NotificationTemplate: {
        payload: Prisma.$NotificationTemplatePayload<ExtArgs>;
        fields: Prisma.NotificationTemplateFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.NotificationTemplateFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.NotificationTemplateFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>;
          };
          findFirst: {
            args: Prisma.NotificationTemplateFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.NotificationTemplateFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>;
          };
          findMany: {
            args: Prisma.NotificationTemplateFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>[];
          };
          create: {
            args: Prisma.NotificationTemplateCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>;
          };
          createMany: {
            args: Prisma.NotificationTemplateCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.NotificationTemplateCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>[];
          };
          delete: {
            args: Prisma.NotificationTemplateDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>;
          };
          update: {
            args: Prisma.NotificationTemplateUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>;
          };
          deleteMany: {
            args: Prisma.NotificationTemplateDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.NotificationTemplateUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.NotificationTemplateUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>[];
          };
          upsert: {
            args: Prisma.NotificationTemplateUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>;
          };
          aggregate: {
            args: Prisma.NotificationTemplateAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateNotificationTemplate>;
          };
          groupBy: {
            args: Prisma.NotificationTemplateGroupByArgs<ExtArgs>;
            result: $Utils.Optional<NotificationTemplateGroupByOutputType>[];
          };
          count: {
            args: Prisma.NotificationTemplateCountArgs<ExtArgs>;
            result: $Utils.Optional<NotificationTemplateCountAggregateOutputType> | number;
          };
        };
      };
      NotificationProvider: {
        payload: Prisma.$NotificationProviderPayload<ExtArgs>;
        fields: Prisma.NotificationProviderFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.NotificationProviderFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationProviderPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.NotificationProviderFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationProviderPayload>;
          };
          findFirst: {
            args: Prisma.NotificationProviderFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationProviderPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.NotificationProviderFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationProviderPayload>;
          };
          findMany: {
            args: Prisma.NotificationProviderFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationProviderPayload>[];
          };
          create: {
            args: Prisma.NotificationProviderCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationProviderPayload>;
          };
          createMany: {
            args: Prisma.NotificationProviderCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.NotificationProviderCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationProviderPayload>[];
          };
          delete: {
            args: Prisma.NotificationProviderDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationProviderPayload>;
          };
          update: {
            args: Prisma.NotificationProviderUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationProviderPayload>;
          };
          deleteMany: {
            args: Prisma.NotificationProviderDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.NotificationProviderUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.NotificationProviderUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationProviderPayload>[];
          };
          upsert: {
            args: Prisma.NotificationProviderUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationProviderPayload>;
          };
          aggregate: {
            args: Prisma.NotificationProviderAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateNotificationProvider>;
          };
          groupBy: {
            args: Prisma.NotificationProviderGroupByArgs<ExtArgs>;
            result: $Utils.Optional<NotificationProviderGroupByOutputType>[];
          };
          count: {
            args: Prisma.NotificationProviderCountArgs<ExtArgs>;
            result: $Utils.Optional<NotificationProviderCountAggregateOutputType> | number;
          };
        };
      };
      HelixUserNotificationProfile: {
        payload: Prisma.$HelixUserNotificationProfilePayload<ExtArgs>;
        fields: Prisma.HelixUserNotificationProfileFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.HelixUserNotificationProfileFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HelixUserNotificationProfilePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.HelixUserNotificationProfileFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HelixUserNotificationProfilePayload>;
          };
          findFirst: {
            args: Prisma.HelixUserNotificationProfileFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HelixUserNotificationProfilePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.HelixUserNotificationProfileFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HelixUserNotificationProfilePayload>;
          };
          findMany: {
            args: Prisma.HelixUserNotificationProfileFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HelixUserNotificationProfilePayload>[];
          };
          create: {
            args: Prisma.HelixUserNotificationProfileCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HelixUserNotificationProfilePayload>;
          };
          createMany: {
            args: Prisma.HelixUserNotificationProfileCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.HelixUserNotificationProfileCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HelixUserNotificationProfilePayload>[];
          };
          delete: {
            args: Prisma.HelixUserNotificationProfileDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HelixUserNotificationProfilePayload>;
          };
          update: {
            args: Prisma.HelixUserNotificationProfileUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HelixUserNotificationProfilePayload>;
          };
          deleteMany: {
            args: Prisma.HelixUserNotificationProfileDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.HelixUserNotificationProfileUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.HelixUserNotificationProfileUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HelixUserNotificationProfilePayload>[];
          };
          upsert: {
            args: Prisma.HelixUserNotificationProfileUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HelixUserNotificationProfilePayload>;
          };
          aggregate: {
            args: Prisma.HelixUserNotificationProfileAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateHelixUserNotificationProfile>;
          };
          groupBy: {
            args: Prisma.HelixUserNotificationProfileGroupByArgs<ExtArgs>;
            result: $Utils.Optional<HelixUserNotificationProfileGroupByOutputType>[];
          };
          count: {
            args: Prisma.HelixUserNotificationProfileCountArgs<ExtArgs>;
            result: $Utils.Optional<HelixUserNotificationProfileCountAggregateOutputType> | number;
          };
        };
      };
      NotificationQueue: {
        payload: Prisma.$NotificationQueuePayload<ExtArgs>;
        fields: Prisma.NotificationQueueFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.NotificationQueueFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.NotificationQueueFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>;
          };
          findFirst: {
            args: Prisma.NotificationQueueFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.NotificationQueueFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>;
          };
          findMany: {
            args: Prisma.NotificationQueueFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>[];
          };
          create: {
            args: Prisma.NotificationQueueCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>;
          };
          createMany: {
            args: Prisma.NotificationQueueCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.NotificationQueueCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>[];
          };
          delete: {
            args: Prisma.NotificationQueueDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>;
          };
          update: {
            args: Prisma.NotificationQueueUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>;
          };
          deleteMany: {
            args: Prisma.NotificationQueueDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.NotificationQueueUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.NotificationQueueUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>[];
          };
          upsert: {
            args: Prisma.NotificationQueueUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationQueuePayload>;
          };
          aggregate: {
            args: Prisma.NotificationQueueAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateNotificationQueue>;
          };
          groupBy: {
            args: Prisma.NotificationQueueGroupByArgs<ExtArgs>;
            result: $Utils.Optional<NotificationQueueGroupByOutputType>[];
          };
          count: {
            args: Prisma.NotificationQueueCountArgs<ExtArgs>;
            result: $Utils.Optional<NotificationQueueCountAggregateOutputType> | number;
          };
        };
      };
      NotificationRoleDefault: {
        payload: Prisma.$NotificationRoleDefaultPayload<ExtArgs>;
        fields: Prisma.NotificationRoleDefaultFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.NotificationRoleDefaultFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationRoleDefaultPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.NotificationRoleDefaultFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationRoleDefaultPayload>;
          };
          findFirst: {
            args: Prisma.NotificationRoleDefaultFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationRoleDefaultPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.NotificationRoleDefaultFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationRoleDefaultPayload>;
          };
          findMany: {
            args: Prisma.NotificationRoleDefaultFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationRoleDefaultPayload>[];
          };
          create: {
            args: Prisma.NotificationRoleDefaultCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationRoleDefaultPayload>;
          };
          createMany: {
            args: Prisma.NotificationRoleDefaultCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.NotificationRoleDefaultCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationRoleDefaultPayload>[];
          };
          delete: {
            args: Prisma.NotificationRoleDefaultDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationRoleDefaultPayload>;
          };
          update: {
            args: Prisma.NotificationRoleDefaultUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationRoleDefaultPayload>;
          };
          deleteMany: {
            args: Prisma.NotificationRoleDefaultDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.NotificationRoleDefaultUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.NotificationRoleDefaultUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationRoleDefaultPayload>[];
          };
          upsert: {
            args: Prisma.NotificationRoleDefaultUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationRoleDefaultPayload>;
          };
          aggregate: {
            args: Prisma.NotificationRoleDefaultAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateNotificationRoleDefault>;
          };
          groupBy: {
            args: Prisma.NotificationRoleDefaultGroupByArgs<ExtArgs>;
            result: $Utils.Optional<NotificationRoleDefaultGroupByOutputType>[];
          };
          count: {
            args: Prisma.NotificationRoleDefaultCountArgs<ExtArgs>;
            result: $Utils.Optional<NotificationRoleDefaultCountAggregateOutputType> | number;
          };
        };
      };
      NotificationAuditLog: {
        payload: Prisma.$NotificationAuditLogPayload<ExtArgs>;
        fields: Prisma.NotificationAuditLogFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.NotificationAuditLogFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationAuditLogPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.NotificationAuditLogFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationAuditLogPayload>;
          };
          findFirst: {
            args: Prisma.NotificationAuditLogFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationAuditLogPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.NotificationAuditLogFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationAuditLogPayload>;
          };
          findMany: {
            args: Prisma.NotificationAuditLogFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationAuditLogPayload>[];
          };
          create: {
            args: Prisma.NotificationAuditLogCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationAuditLogPayload>;
          };
          createMany: {
            args: Prisma.NotificationAuditLogCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.NotificationAuditLogCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationAuditLogPayload>[];
          };
          delete: {
            args: Prisma.NotificationAuditLogDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationAuditLogPayload>;
          };
          update: {
            args: Prisma.NotificationAuditLogUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationAuditLogPayload>;
          };
          deleteMany: {
            args: Prisma.NotificationAuditLogDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.NotificationAuditLogUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.NotificationAuditLogUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationAuditLogPayload>[];
          };
          upsert: {
            args: Prisma.NotificationAuditLogUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationAuditLogPayload>;
          };
          aggregate: {
            args: Prisma.NotificationAuditLogAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateNotificationAuditLog>;
          };
          groupBy: {
            args: Prisma.NotificationAuditLogGroupByArgs<ExtArgs>;
            result: $Utils.Optional<NotificationAuditLogGroupByOutputType>[];
          };
          count: {
            args: Prisma.NotificationAuditLogCountArgs<ExtArgs>;
            result: $Utils.Optional<NotificationAuditLogCountAggregateOutputType> | number;
          };
        };
      };
      RoleNotificationDefaults: {
        payload: Prisma.$RoleNotificationDefaultsPayload<ExtArgs>;
        fields: Prisma.RoleNotificationDefaultsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.RoleNotificationDefaultsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RoleNotificationDefaultsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.RoleNotificationDefaultsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RoleNotificationDefaultsPayload>;
          };
          findFirst: {
            args: Prisma.RoleNotificationDefaultsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RoleNotificationDefaultsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.RoleNotificationDefaultsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RoleNotificationDefaultsPayload>;
          };
          findMany: {
            args: Prisma.RoleNotificationDefaultsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RoleNotificationDefaultsPayload>[];
          };
          create: {
            args: Prisma.RoleNotificationDefaultsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RoleNotificationDefaultsPayload>;
          };
          createMany: {
            args: Prisma.RoleNotificationDefaultsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.RoleNotificationDefaultsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RoleNotificationDefaultsPayload>[];
          };
          delete: {
            args: Prisma.RoleNotificationDefaultsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RoleNotificationDefaultsPayload>;
          };
          update: {
            args: Prisma.RoleNotificationDefaultsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RoleNotificationDefaultsPayload>;
          };
          deleteMany: {
            args: Prisma.RoleNotificationDefaultsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.RoleNotificationDefaultsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.RoleNotificationDefaultsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RoleNotificationDefaultsPayload>[];
          };
          upsert: {
            args: Prisma.RoleNotificationDefaultsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RoleNotificationDefaultsPayload>;
          };
          aggregate: {
            args: Prisma.RoleNotificationDefaultsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateRoleNotificationDefaults>;
          };
          groupBy: {
            args: Prisma.RoleNotificationDefaultsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<RoleNotificationDefaultsGroupByOutputType>[];
          };
          count: {
            args: Prisma.RoleNotificationDefaultsCountArgs<ExtArgs>;
            result: $Utils.Optional<RoleNotificationDefaultsCountAggregateOutputType> | number;
          };
        };
      };
      NotificationAnalytics: {
        payload: Prisma.$NotificationAnalyticsPayload<ExtArgs>;
        fields: Prisma.NotificationAnalyticsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.NotificationAnalyticsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationAnalyticsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.NotificationAnalyticsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationAnalyticsPayload>;
          };
          findFirst: {
            args: Prisma.NotificationAnalyticsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationAnalyticsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.NotificationAnalyticsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationAnalyticsPayload>;
          };
          findMany: {
            args: Prisma.NotificationAnalyticsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationAnalyticsPayload>[];
          };
          create: {
            args: Prisma.NotificationAnalyticsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationAnalyticsPayload>;
          };
          createMany: {
            args: Prisma.NotificationAnalyticsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.NotificationAnalyticsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationAnalyticsPayload>[];
          };
          delete: {
            args: Prisma.NotificationAnalyticsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationAnalyticsPayload>;
          };
          update: {
            args: Prisma.NotificationAnalyticsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationAnalyticsPayload>;
          };
          deleteMany: {
            args: Prisma.NotificationAnalyticsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.NotificationAnalyticsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.NotificationAnalyticsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationAnalyticsPayload>[];
          };
          upsert: {
            args: Prisma.NotificationAnalyticsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationAnalyticsPayload>;
          };
          aggregate: {
            args: Prisma.NotificationAnalyticsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateNotificationAnalytics>;
          };
          groupBy: {
            args: Prisma.NotificationAnalyticsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<NotificationAnalyticsGroupByOutputType>[];
          };
          count: {
            args: Prisma.NotificationAnalyticsCountArgs<ExtArgs>;
            result: $Utils.Optional<NotificationAnalyticsCountAggregateOutputType> | number;
          };
        };
      };
    };
  } & {
    other: {
      payload: any;
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
      };
    };
  };
  export const defineExtension: $Extensions.ExtendsHook<
    'define',
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >;
  export type DefaultPrismaClient = PrismaClient;
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal';
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources;
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string;
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     *
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     *
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    };
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig;
  }
  export type GlobalOmitConfig = {
    notificationEvent?: NotificationEventOmit;
    notificationPreference?: NotificationPreferenceOmit;
    notification?: NotificationOmit;
    notificationDelivery?: NotificationDeliveryOmit;
    notificationTemplate?: NotificationTemplateOmit;
    notificationProvider?: NotificationProviderOmit;
    helixUserNotificationProfile?: HelixUserNotificationProfileOmit;
    notificationQueue?: NotificationQueueOmit;
    notificationRoleDefault?: NotificationRoleDefaultOmit;
    notificationAuditLog?: NotificationAuditLogOmit;
    roleNotificationDefaults?: RoleNotificationDefaultsOmit;
    notificationAnalytics?: NotificationAnalyticsOmit;
  };

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error';
  export type LogDefinition = {
    level: LogLevel;
    emit: 'stdout' | 'event';
  };

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<T extends LogDefinition ? T['level'] : T>;

  export type GetEvents<T extends any[]> =
    T extends Array<LogLevel | LogDefinition> ? GetLogType<T[number]> : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy';

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>;

  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type NotificationEventCountOutputType
   */

  export type NotificationEventCountOutputType = {
    notifications: number;
    deliveries: number;
    queue: number;
    auditLogs: number;
  };

  export type NotificationEventCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    notifications?: boolean | NotificationEventCountOutputTypeCountNotificationsArgs;
    deliveries?: boolean | NotificationEventCountOutputTypeCountDeliveriesArgs;
    queue?: boolean | NotificationEventCountOutputTypeCountQueueArgs;
    auditLogs?: boolean | NotificationEventCountOutputTypeCountAuditLogsArgs;
  };

  // Custom InputTypes
  /**
   * NotificationEventCountOutputType without action
   */
  export type NotificationEventCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationEventCountOutputType
     */
    select?: NotificationEventCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * NotificationEventCountOutputType without action
   */
  export type NotificationEventCountOutputTypeCountNotificationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificationWhereInput;
  };

  /**
   * NotificationEventCountOutputType without action
   */
  export type NotificationEventCountOutputTypeCountDeliveriesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificationDeliveryWhereInput;
  };

  /**
   * NotificationEventCountOutputType without action
   */
  export type NotificationEventCountOutputTypeCountQueueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificationQueueWhereInput;
  };

  /**
   * NotificationEventCountOutputType without action
   */
  export type NotificationEventCountOutputTypeCountAuditLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificationAuditLogWhereInput;
  };

  /**
   * Count Type NotificationCountOutputType
   */

  export type NotificationCountOutputType = {
    deliveries: number;
    queue: number;
  };

  export type NotificationCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    deliveries?: boolean | NotificationCountOutputTypeCountDeliveriesArgs;
    queue?: boolean | NotificationCountOutputTypeCountQueueArgs;
  };

  // Custom InputTypes
  /**
   * NotificationCountOutputType without action
   */
  export type NotificationCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationCountOutputType
     */
    select?: NotificationCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * NotificationCountOutputType without action
   */
  export type NotificationCountOutputTypeCountDeliveriesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificationDeliveryWhereInput;
  };

  /**
   * NotificationCountOutputType without action
   */
  export type NotificationCountOutputTypeCountQueueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificationQueueWhereInput;
  };

  /**
   * Count Type HelixUserNotificationProfileCountOutputType
   */

  export type HelixUserNotificationProfileCountOutputType = {
    preferences: number;
  };

  export type HelixUserNotificationProfileCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    preferences?: boolean | HelixUserNotificationProfileCountOutputTypeCountPreferencesArgs;
  };

  // Custom InputTypes
  /**
   * HelixUserNotificationProfileCountOutputType without action
   */
  export type HelixUserNotificationProfileCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HelixUserNotificationProfileCountOutputType
     */
    select?: HelixUserNotificationProfileCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * HelixUserNotificationProfileCountOutputType without action
   */
  export type HelixUserNotificationProfileCountOutputTypeCountPreferencesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificationPreferenceWhereInput;
  };

  /**
   * Models
   */

  /**
   * Model NotificationEvent
   */

  export type AggregateNotificationEvent = {
    _count: NotificationEventCountAggregateOutputType | null;
    _min: NotificationEventMinAggregateOutputType | null;
    _max: NotificationEventMaxAggregateOutputType | null;
  };

  export type NotificationEventMinAggregateOutputType = {
    id: string | null;
    eventId: string | null;
    module: string | null;
    eventType: string | null;
    priority: $Enums.NotificationPriority | null;
    title: string | null;
    message: string | null;
    details: string | null;
    tenantId: string | null;
    status: $Enums.EventStatus | null;
    scheduledFor: Date | null;
    expiresAt: Date | null;
    createdAt: Date | null;
    createdBy: string | null;
    processedAt: Date | null;
  };

  export type NotificationEventMaxAggregateOutputType = {
    id: string | null;
    eventId: string | null;
    module: string | null;
    eventType: string | null;
    priority: $Enums.NotificationPriority | null;
    title: string | null;
    message: string | null;
    details: string | null;
    tenantId: string | null;
    status: $Enums.EventStatus | null;
    scheduledFor: Date | null;
    expiresAt: Date | null;
    createdAt: Date | null;
    createdBy: string | null;
    processedAt: Date | null;
  };

  export type NotificationEventCountAggregateOutputType = {
    id: number;
    eventId: number;
    module: number;
    eventType: number;
    priority: number;
    title: number;
    message: number;
    details: number;
    recipientRoles: number;
    recipientUsers: number;
    tenantId: number;
    actions: number;
    metadata: number;
    status: number;
    scheduledFor: number;
    expiresAt: number;
    createdAt: number;
    createdBy: number;
    processedAt: number;
    _all: number;
  };

  export type NotificationEventMinAggregateInputType = {
    id?: true;
    eventId?: true;
    module?: true;
    eventType?: true;
    priority?: true;
    title?: true;
    message?: true;
    details?: true;
    tenantId?: true;
    status?: true;
    scheduledFor?: true;
    expiresAt?: true;
    createdAt?: true;
    createdBy?: true;
    processedAt?: true;
  };

  export type NotificationEventMaxAggregateInputType = {
    id?: true;
    eventId?: true;
    module?: true;
    eventType?: true;
    priority?: true;
    title?: true;
    message?: true;
    details?: true;
    tenantId?: true;
    status?: true;
    scheduledFor?: true;
    expiresAt?: true;
    createdAt?: true;
    createdBy?: true;
    processedAt?: true;
  };

  export type NotificationEventCountAggregateInputType = {
    id?: true;
    eventId?: true;
    module?: true;
    eventType?: true;
    priority?: true;
    title?: true;
    message?: true;
    details?: true;
    recipientRoles?: true;
    recipientUsers?: true;
    tenantId?: true;
    actions?: true;
    metadata?: true;
    status?: true;
    scheduledFor?: true;
    expiresAt?: true;
    createdAt?: true;
    createdBy?: true;
    processedAt?: true;
    _all?: true;
  };

  export type NotificationEventAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which NotificationEvent to aggregate.
     */
    where?: NotificationEventWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationEvents to fetch.
     */
    orderBy?:
      | NotificationEventOrderByWithRelationInput
      | NotificationEventOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: NotificationEventWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationEvents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationEvents.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned NotificationEvents
     **/
    _count?: true | NotificationEventCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: NotificationEventMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: NotificationEventMaxAggregateInputType;
  };

  export type GetNotificationEventAggregateType<T extends NotificationEventAggregateArgs> = {
    [P in keyof T & keyof AggregateNotificationEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationEvent[P]>
      : GetScalarType<T[P], AggregateNotificationEvent[P]>;
  };

  export type NotificationEventGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificationEventWhereInput;
    orderBy?:
      | NotificationEventOrderByWithAggregationInput
      | NotificationEventOrderByWithAggregationInput[];
    by: NotificationEventScalarFieldEnum[] | NotificationEventScalarFieldEnum;
    having?: NotificationEventScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: NotificationEventCountAggregateInputType | true;
    _min?: NotificationEventMinAggregateInputType;
    _max?: NotificationEventMaxAggregateInputType;
  };

  export type NotificationEventGroupByOutputType = {
    id: string;
    eventId: string;
    module: string;
    eventType: string;
    priority: $Enums.NotificationPriority;
    title: string;
    message: string;
    details: string | null;
    recipientRoles: string[];
    recipientUsers: string[];
    tenantId: string | null;
    actions: JsonValue | null;
    metadata: JsonValue | null;
    status: $Enums.EventStatus;
    scheduledFor: Date | null;
    expiresAt: Date | null;
    createdAt: Date;
    createdBy: string | null;
    processedAt: Date | null;
    _count: NotificationEventCountAggregateOutputType | null;
    _min: NotificationEventMinAggregateOutputType | null;
    _max: NotificationEventMaxAggregateOutputType | null;
  };

  type GetNotificationEventGroupByPayload<T extends NotificationEventGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<NotificationEventGroupByOutputType, T['by']> & {
          [P in keyof T & keyof NotificationEventGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationEventGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationEventGroupByOutputType[P]>;
        }
      >
    >;

  export type NotificationEventSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      eventId?: boolean;
      module?: boolean;
      eventType?: boolean;
      priority?: boolean;
      title?: boolean;
      message?: boolean;
      details?: boolean;
      recipientRoles?: boolean;
      recipientUsers?: boolean;
      tenantId?: boolean;
      actions?: boolean;
      metadata?: boolean;
      status?: boolean;
      scheduledFor?: boolean;
      expiresAt?: boolean;
      createdAt?: boolean;
      createdBy?: boolean;
      processedAt?: boolean;
      notifications?: boolean | NotificationEvent$notificationsArgs<ExtArgs>;
      deliveries?: boolean | NotificationEvent$deliveriesArgs<ExtArgs>;
      queue?: boolean | NotificationEvent$queueArgs<ExtArgs>;
      auditLogs?: boolean | NotificationEvent$auditLogsArgs<ExtArgs>;
      _count?: boolean | NotificationEventCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notificationEvent']
  >;

  export type NotificationEventSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      eventId?: boolean;
      module?: boolean;
      eventType?: boolean;
      priority?: boolean;
      title?: boolean;
      message?: boolean;
      details?: boolean;
      recipientRoles?: boolean;
      recipientUsers?: boolean;
      tenantId?: boolean;
      actions?: boolean;
      metadata?: boolean;
      status?: boolean;
      scheduledFor?: boolean;
      expiresAt?: boolean;
      createdAt?: boolean;
      createdBy?: boolean;
      processedAt?: boolean;
    },
    ExtArgs['result']['notificationEvent']
  >;

  export type NotificationEventSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      eventId?: boolean;
      module?: boolean;
      eventType?: boolean;
      priority?: boolean;
      title?: boolean;
      message?: boolean;
      details?: boolean;
      recipientRoles?: boolean;
      recipientUsers?: boolean;
      tenantId?: boolean;
      actions?: boolean;
      metadata?: boolean;
      status?: boolean;
      scheduledFor?: boolean;
      expiresAt?: boolean;
      createdAt?: boolean;
      createdBy?: boolean;
      processedAt?: boolean;
    },
    ExtArgs['result']['notificationEvent']
  >;

  export type NotificationEventSelectScalar = {
    id?: boolean;
    eventId?: boolean;
    module?: boolean;
    eventType?: boolean;
    priority?: boolean;
    title?: boolean;
    message?: boolean;
    details?: boolean;
    recipientRoles?: boolean;
    recipientUsers?: boolean;
    tenantId?: boolean;
    actions?: boolean;
    metadata?: boolean;
    status?: boolean;
    scheduledFor?: boolean;
    expiresAt?: boolean;
    createdAt?: boolean;
    createdBy?: boolean;
    processedAt?: boolean;
  };

  export type NotificationEventOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'eventId'
    | 'module'
    | 'eventType'
    | 'priority'
    | 'title'
    | 'message'
    | 'details'
    | 'recipientRoles'
    | 'recipientUsers'
    | 'tenantId'
    | 'actions'
    | 'metadata'
    | 'status'
    | 'scheduledFor'
    | 'expiresAt'
    | 'createdAt'
    | 'createdBy'
    | 'processedAt',
    ExtArgs['result']['notificationEvent']
  >;
  export type NotificationEventInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    notifications?: boolean | NotificationEvent$notificationsArgs<ExtArgs>;
    deliveries?: boolean | NotificationEvent$deliveriesArgs<ExtArgs>;
    queue?: boolean | NotificationEvent$queueArgs<ExtArgs>;
    auditLogs?: boolean | NotificationEvent$auditLogsArgs<ExtArgs>;
    _count?: boolean | NotificationEventCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type NotificationEventIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type NotificationEventIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $NotificationEventPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'NotificationEvent';
    objects: {
      notifications: Prisma.$NotificationPayload<ExtArgs>[];
      deliveries: Prisma.$NotificationDeliveryPayload<ExtArgs>[];
      queue: Prisma.$NotificationQueuePayload<ExtArgs>[];
      auditLogs: Prisma.$NotificationAuditLogPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        eventId: string;
        module: string;
        eventType: string;
        priority: $Enums.NotificationPriority;
        title: string;
        message: string;
        details: string | null;
        recipientRoles: string[];
        recipientUsers: string[];
        tenantId: string | null;
        actions: Prisma.JsonValue | null;
        metadata: Prisma.JsonValue | null;
        status: $Enums.EventStatus;
        scheduledFor: Date | null;
        expiresAt: Date | null;
        createdAt: Date;
        createdBy: string | null;
        processedAt: Date | null;
      },
      ExtArgs['result']['notificationEvent']
    >;
    composites: {};
  };

  type NotificationEventGetPayload<
    S extends boolean | null | undefined | NotificationEventDefaultArgs,
  > = $Result.GetResult<Prisma.$NotificationEventPayload, S>;

  type NotificationEventCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<NotificationEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: NotificationEventCountAggregateInputType | true;
  };

  export interface NotificationEventDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['NotificationEvent'];
      meta: { name: 'NotificationEvent' };
    };
    /**
     * Find zero or one NotificationEvent that matches the filter.
     * @param {NotificationEventFindUniqueArgs} args - Arguments to find a NotificationEvent
     * @example
     * // Get one NotificationEvent
     * const notificationEvent = await prisma.notificationEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationEventFindUniqueArgs>(
      args: SelectSubset<T, NotificationEventFindUniqueArgs<ExtArgs>>,
    ): Prisma__NotificationEventClient<
      $Result.GetResult<
        Prisma.$NotificationEventPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one NotificationEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationEventFindUniqueOrThrowArgs} args - Arguments to find a NotificationEvent
     * @example
     * // Get one NotificationEvent
     * const notificationEvent = await prisma.notificationEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationEventFindUniqueOrThrowArgs>(
      args: SelectSubset<T, NotificationEventFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__NotificationEventClient<
      $Result.GetResult<
        Prisma.$NotificationEventPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first NotificationEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationEventFindFirstArgs} args - Arguments to find a NotificationEvent
     * @example
     * // Get one NotificationEvent
     * const notificationEvent = await prisma.notificationEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationEventFindFirstArgs>(
      args?: SelectSubset<T, NotificationEventFindFirstArgs<ExtArgs>>,
    ): Prisma__NotificationEventClient<
      $Result.GetResult<
        Prisma.$NotificationEventPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first NotificationEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationEventFindFirstOrThrowArgs} args - Arguments to find a NotificationEvent
     * @example
     * // Get one NotificationEvent
     * const notificationEvent = await prisma.notificationEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationEventFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NotificationEventFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__NotificationEventClient<
      $Result.GetResult<
        Prisma.$NotificationEventPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more NotificationEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationEvents
     * const notificationEvents = await prisma.notificationEvent.findMany()
     *
     * // Get first 10 NotificationEvents
     * const notificationEvents = await prisma.notificationEvent.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const notificationEventWithIdOnly = await prisma.notificationEvent.findMany({ select: { id: true } })
     *
     */
    findMany<T extends NotificationEventFindManyArgs>(
      args?: SelectSubset<T, NotificationEventFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$NotificationEventPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a NotificationEvent.
     * @param {NotificationEventCreateArgs} args - Arguments to create a NotificationEvent.
     * @example
     * // Create one NotificationEvent
     * const NotificationEvent = await prisma.notificationEvent.create({
     *   data: {
     *     // ... data to create a NotificationEvent
     *   }
     * })
     *
     */
    create<T extends NotificationEventCreateArgs>(
      args: SelectSubset<T, NotificationEventCreateArgs<ExtArgs>>,
    ): Prisma__NotificationEventClient<
      $Result.GetResult<Prisma.$NotificationEventPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many NotificationEvents.
     * @param {NotificationEventCreateManyArgs} args - Arguments to create many NotificationEvents.
     * @example
     * // Create many NotificationEvents
     * const notificationEvent = await prisma.notificationEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends NotificationEventCreateManyArgs>(
      args?: SelectSubset<T, NotificationEventCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many NotificationEvents and returns the data saved in the database.
     * @param {NotificationEventCreateManyAndReturnArgs} args - Arguments to create many NotificationEvents.
     * @example
     * // Create many NotificationEvents
     * const notificationEvent = await prisma.notificationEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many NotificationEvents and only return the `id`
     * const notificationEventWithIdOnly = await prisma.notificationEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends NotificationEventCreateManyAndReturnArgs>(
      args?: SelectSubset<T, NotificationEventCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationEventPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a NotificationEvent.
     * @param {NotificationEventDeleteArgs} args - Arguments to delete one NotificationEvent.
     * @example
     * // Delete one NotificationEvent
     * const NotificationEvent = await prisma.notificationEvent.delete({
     *   where: {
     *     // ... filter to delete one NotificationEvent
     *   }
     * })
     *
     */
    delete<T extends NotificationEventDeleteArgs>(
      args: SelectSubset<T, NotificationEventDeleteArgs<ExtArgs>>,
    ): Prisma__NotificationEventClient<
      $Result.GetResult<Prisma.$NotificationEventPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one NotificationEvent.
     * @param {NotificationEventUpdateArgs} args - Arguments to update one NotificationEvent.
     * @example
     * // Update one NotificationEvent
     * const notificationEvent = await prisma.notificationEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends NotificationEventUpdateArgs>(
      args: SelectSubset<T, NotificationEventUpdateArgs<ExtArgs>>,
    ): Prisma__NotificationEventClient<
      $Result.GetResult<Prisma.$NotificationEventPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more NotificationEvents.
     * @param {NotificationEventDeleteManyArgs} args - Arguments to filter NotificationEvents to delete.
     * @example
     * // Delete a few NotificationEvents
     * const { count } = await prisma.notificationEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends NotificationEventDeleteManyArgs>(
      args?: SelectSubset<T, NotificationEventDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more NotificationEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationEvents
     * const notificationEvent = await prisma.notificationEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends NotificationEventUpdateManyArgs>(
      args: SelectSubset<T, NotificationEventUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more NotificationEvents and returns the data updated in the database.
     * @param {NotificationEventUpdateManyAndReturnArgs} args - Arguments to update many NotificationEvents.
     * @example
     * // Update many NotificationEvents
     * const notificationEvent = await prisma.notificationEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more NotificationEvents and only return the `id`
     * const notificationEventWithIdOnly = await prisma.notificationEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends NotificationEventUpdateManyAndReturnArgs>(
      args: SelectSubset<T, NotificationEventUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationEventPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one NotificationEvent.
     * @param {NotificationEventUpsertArgs} args - Arguments to update or create a NotificationEvent.
     * @example
     * // Update or create a NotificationEvent
     * const notificationEvent = await prisma.notificationEvent.upsert({
     *   create: {
     *     // ... data to create a NotificationEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationEvent we want to update
     *   }
     * })
     */
    upsert<T extends NotificationEventUpsertArgs>(
      args: SelectSubset<T, NotificationEventUpsertArgs<ExtArgs>>,
    ): Prisma__NotificationEventClient<
      $Result.GetResult<Prisma.$NotificationEventPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of NotificationEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationEventCountArgs} args - Arguments to filter NotificationEvents to count.
     * @example
     * // Count the number of NotificationEvents
     * const count = await prisma.notificationEvent.count({
     *   where: {
     *     // ... the filter for the NotificationEvents we want to count
     *   }
     * })
     **/
    count<T extends NotificationEventCountArgs>(
      args?: Subset<T, NotificationEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationEventCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a NotificationEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends NotificationEventAggregateArgs>(
      args: Subset<T, NotificationEventAggregateArgs>,
    ): Prisma.PrismaPromise<GetNotificationEventAggregateType<T>>;

    /**
     * Group by NotificationEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends NotificationEventGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationEventGroupByArgs['orderBy'] }
        : { orderBy?: NotificationEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, NotificationEventGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetNotificationEventGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the NotificationEvent model
     */
    readonly fields: NotificationEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationEventClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    notifications<T extends NotificationEvent$notificationsArgs<ExtArgs> = {}>(
      args?: Subset<T, NotificationEvent$notificationsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    deliveries<T extends NotificationEvent$deliveriesArgs<ExtArgs> = {}>(
      args?: Subset<T, NotificationEvent$deliveriesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$NotificationDeliveryPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    queue<T extends NotificationEvent$queueArgs<ExtArgs> = {}>(
      args?: Subset<T, NotificationEvent$queueArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$NotificationQueuePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    auditLogs<T extends NotificationEvent$auditLogsArgs<ExtArgs> = {}>(
      args?: Subset<T, NotificationEvent$auditLogsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$NotificationAuditLogPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the NotificationEvent model
   */
  interface NotificationEventFieldRefs {
    readonly id: FieldRef<'NotificationEvent', 'String'>;
    readonly eventId: FieldRef<'NotificationEvent', 'String'>;
    readonly module: FieldRef<'NotificationEvent', 'String'>;
    readonly eventType: FieldRef<'NotificationEvent', 'String'>;
    readonly priority: FieldRef<'NotificationEvent', 'NotificationPriority'>;
    readonly title: FieldRef<'NotificationEvent', 'String'>;
    readonly message: FieldRef<'NotificationEvent', 'String'>;
    readonly details: FieldRef<'NotificationEvent', 'String'>;
    readonly recipientRoles: FieldRef<'NotificationEvent', 'String[]'>;
    readonly recipientUsers: FieldRef<'NotificationEvent', 'String[]'>;
    readonly tenantId: FieldRef<'NotificationEvent', 'String'>;
    readonly actions: FieldRef<'NotificationEvent', 'Json'>;
    readonly metadata: FieldRef<'NotificationEvent', 'Json'>;
    readonly status: FieldRef<'NotificationEvent', 'EventStatus'>;
    readonly scheduledFor: FieldRef<'NotificationEvent', 'DateTime'>;
    readonly expiresAt: FieldRef<'NotificationEvent', 'DateTime'>;
    readonly createdAt: FieldRef<'NotificationEvent', 'DateTime'>;
    readonly createdBy: FieldRef<'NotificationEvent', 'String'>;
    readonly processedAt: FieldRef<'NotificationEvent', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * NotificationEvent findUnique
   */
  export type NotificationEventFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationEvent
     */
    select?: NotificationEventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationEvent
     */
    omit?: NotificationEventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEventInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationEvent to fetch.
     */
    where: NotificationEventWhereUniqueInput;
  };

  /**
   * NotificationEvent findUniqueOrThrow
   */
  export type NotificationEventFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationEvent
     */
    select?: NotificationEventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationEvent
     */
    omit?: NotificationEventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEventInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationEvent to fetch.
     */
    where: NotificationEventWhereUniqueInput;
  };

  /**
   * NotificationEvent findFirst
   */
  export type NotificationEventFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationEvent
     */
    select?: NotificationEventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationEvent
     */
    omit?: NotificationEventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEventInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationEvent to fetch.
     */
    where?: NotificationEventWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationEvents to fetch.
     */
    orderBy?:
      | NotificationEventOrderByWithRelationInput
      | NotificationEventOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for NotificationEvents.
     */
    cursor?: NotificationEventWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationEvents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationEvents.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of NotificationEvents.
     */
    distinct?: NotificationEventScalarFieldEnum | NotificationEventScalarFieldEnum[];
  };

  /**
   * NotificationEvent findFirstOrThrow
   */
  export type NotificationEventFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationEvent
     */
    select?: NotificationEventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationEvent
     */
    omit?: NotificationEventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEventInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationEvent to fetch.
     */
    where?: NotificationEventWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationEvents to fetch.
     */
    orderBy?:
      | NotificationEventOrderByWithRelationInput
      | NotificationEventOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for NotificationEvents.
     */
    cursor?: NotificationEventWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationEvents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationEvents.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of NotificationEvents.
     */
    distinct?: NotificationEventScalarFieldEnum | NotificationEventScalarFieldEnum[];
  };

  /**
   * NotificationEvent findMany
   */
  export type NotificationEventFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationEvent
     */
    select?: NotificationEventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationEvent
     */
    omit?: NotificationEventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEventInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationEvents to fetch.
     */
    where?: NotificationEventWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationEvents to fetch.
     */
    orderBy?:
      | NotificationEventOrderByWithRelationInput
      | NotificationEventOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing NotificationEvents.
     */
    cursor?: NotificationEventWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationEvents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationEvents.
     */
    skip?: number;
    distinct?: NotificationEventScalarFieldEnum | NotificationEventScalarFieldEnum[];
  };

  /**
   * NotificationEvent create
   */
  export type NotificationEventCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationEvent
     */
    select?: NotificationEventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationEvent
     */
    omit?: NotificationEventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEventInclude<ExtArgs> | null;
    /**
     * The data needed to create a NotificationEvent.
     */
    data: XOR<NotificationEventCreateInput, NotificationEventUncheckedCreateInput>;
  };

  /**
   * NotificationEvent createMany
   */
  export type NotificationEventCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many NotificationEvents.
     */
    data: NotificationEventCreateManyInput | NotificationEventCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * NotificationEvent createManyAndReturn
   */
  export type NotificationEventCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationEvent
     */
    select?: NotificationEventSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationEvent
     */
    omit?: NotificationEventOmit<ExtArgs> | null;
    /**
     * The data used to create many NotificationEvents.
     */
    data: NotificationEventCreateManyInput | NotificationEventCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * NotificationEvent update
   */
  export type NotificationEventUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationEvent
     */
    select?: NotificationEventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationEvent
     */
    omit?: NotificationEventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEventInclude<ExtArgs> | null;
    /**
     * The data needed to update a NotificationEvent.
     */
    data: XOR<NotificationEventUpdateInput, NotificationEventUncheckedUpdateInput>;
    /**
     * Choose, which NotificationEvent to update.
     */
    where: NotificationEventWhereUniqueInput;
  };

  /**
   * NotificationEvent updateMany
   */
  export type NotificationEventUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update NotificationEvents.
     */
    data: XOR<NotificationEventUpdateManyMutationInput, NotificationEventUncheckedUpdateManyInput>;
    /**
     * Filter which NotificationEvents to update
     */
    where?: NotificationEventWhereInput;
    /**
     * Limit how many NotificationEvents to update.
     */
    limit?: number;
  };

  /**
   * NotificationEvent updateManyAndReturn
   */
  export type NotificationEventUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationEvent
     */
    select?: NotificationEventSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationEvent
     */
    omit?: NotificationEventOmit<ExtArgs> | null;
    /**
     * The data used to update NotificationEvents.
     */
    data: XOR<NotificationEventUpdateManyMutationInput, NotificationEventUncheckedUpdateManyInput>;
    /**
     * Filter which NotificationEvents to update
     */
    where?: NotificationEventWhereInput;
    /**
     * Limit how many NotificationEvents to update.
     */
    limit?: number;
  };

  /**
   * NotificationEvent upsert
   */
  export type NotificationEventUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationEvent
     */
    select?: NotificationEventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationEvent
     */
    omit?: NotificationEventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEventInclude<ExtArgs> | null;
    /**
     * The filter to search for the NotificationEvent to update in case it exists.
     */
    where: NotificationEventWhereUniqueInput;
    /**
     * In case the NotificationEvent found by the `where` argument doesn't exist, create a new NotificationEvent with this data.
     */
    create: XOR<NotificationEventCreateInput, NotificationEventUncheckedCreateInput>;
    /**
     * In case the NotificationEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationEventUpdateInput, NotificationEventUncheckedUpdateInput>;
  };

  /**
   * NotificationEvent delete
   */
  export type NotificationEventDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationEvent
     */
    select?: NotificationEventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationEvent
     */
    omit?: NotificationEventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEventInclude<ExtArgs> | null;
    /**
     * Filter which NotificationEvent to delete.
     */
    where: NotificationEventWhereUniqueInput;
  };

  /**
   * NotificationEvent deleteMany
   */
  export type NotificationEventDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which NotificationEvents to delete
     */
    where?: NotificationEventWhereInput;
    /**
     * Limit how many NotificationEvents to delete.
     */
    limit?: number;
  };

  /**
   * NotificationEvent.notifications
   */
  export type NotificationEvent$notificationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[];
    cursor?: NotificationWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * NotificationEvent.deliveries
   */
  export type NotificationEvent$deliveriesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationDelivery
     */
    select?: NotificationDeliverySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationDelivery
     */
    omit?: NotificationDeliveryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDeliveryInclude<ExtArgs> | null;
    where?: NotificationDeliveryWhereInput;
    orderBy?:
      | NotificationDeliveryOrderByWithRelationInput
      | NotificationDeliveryOrderByWithRelationInput[];
    cursor?: NotificationDeliveryWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: NotificationDeliveryScalarFieldEnum | NotificationDeliveryScalarFieldEnum[];
  };

  /**
   * NotificationEvent.queue
   */
  export type NotificationEvent$queueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationQueueInclude<ExtArgs> | null;
    where?: NotificationQueueWhereInput;
    orderBy?:
      | NotificationQueueOrderByWithRelationInput
      | NotificationQueueOrderByWithRelationInput[];
    cursor?: NotificationQueueWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: NotificationQueueScalarFieldEnum | NotificationQueueScalarFieldEnum[];
  };

  /**
   * NotificationEvent.auditLogs
   */
  export type NotificationEvent$auditLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationAuditLog
     */
    select?: NotificationAuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationAuditLog
     */
    omit?: NotificationAuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationAuditLogInclude<ExtArgs> | null;
    where?: NotificationAuditLogWhereInput;
    orderBy?:
      | NotificationAuditLogOrderByWithRelationInput
      | NotificationAuditLogOrderByWithRelationInput[];
    cursor?: NotificationAuditLogWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: NotificationAuditLogScalarFieldEnum | NotificationAuditLogScalarFieldEnum[];
  };

  /**
   * NotificationEvent without action
   */
  export type NotificationEventDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationEvent
     */
    select?: NotificationEventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationEvent
     */
    omit?: NotificationEventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEventInclude<ExtArgs> | null;
  };

  /**
   * Model NotificationPreference
   */

  export type AggregateNotificationPreference = {
    _count: NotificationPreferenceCountAggregateOutputType | null;
    _min: NotificationPreferenceMinAggregateOutputType | null;
    _max: NotificationPreferenceMaxAggregateOutputType | null;
  };

  export type NotificationPreferenceMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    module: string | null;
    eventType: string | null;
    priority: $Enums.NotificationPriority | null;
    digestEnabled: boolean | null;
    digestFrequency: $Enums.DigestFrequency | null;
    dndEnabled: boolean | null;
    dndStartTime: string | null;
    dndEndTime: string | null;
    aiSummaryEnabled: boolean | null;
    aiGroupingEnabled: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type NotificationPreferenceMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    module: string | null;
    eventType: string | null;
    priority: $Enums.NotificationPriority | null;
    digestEnabled: boolean | null;
    digestFrequency: $Enums.DigestFrequency | null;
    dndEnabled: boolean | null;
    dndStartTime: string | null;
    dndEndTime: string | null;
    aiSummaryEnabled: boolean | null;
    aiGroupingEnabled: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type NotificationPreferenceCountAggregateOutputType = {
    id: number;
    userId: number;
    module: number;
    eventType: number;
    channels: number;
    priority: number;
    digestEnabled: number;
    digestFrequency: number;
    dndEnabled: number;
    dndStartTime: number;
    dndEndTime: number;
    dndDays: number;
    aiSummaryEnabled: number;
    aiGroupingEnabled: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type NotificationPreferenceMinAggregateInputType = {
    id?: true;
    userId?: true;
    module?: true;
    eventType?: true;
    priority?: true;
    digestEnabled?: true;
    digestFrequency?: true;
    dndEnabled?: true;
    dndStartTime?: true;
    dndEndTime?: true;
    aiSummaryEnabled?: true;
    aiGroupingEnabled?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type NotificationPreferenceMaxAggregateInputType = {
    id?: true;
    userId?: true;
    module?: true;
    eventType?: true;
    priority?: true;
    digestEnabled?: true;
    digestFrequency?: true;
    dndEnabled?: true;
    dndStartTime?: true;
    dndEndTime?: true;
    aiSummaryEnabled?: true;
    aiGroupingEnabled?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type NotificationPreferenceCountAggregateInputType = {
    id?: true;
    userId?: true;
    module?: true;
    eventType?: true;
    channels?: true;
    priority?: true;
    digestEnabled?: true;
    digestFrequency?: true;
    dndEnabled?: true;
    dndStartTime?: true;
    dndEndTime?: true;
    dndDays?: true;
    aiSummaryEnabled?: true;
    aiGroupingEnabled?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type NotificationPreferenceAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which NotificationPreference to aggregate.
     */
    where?: NotificationPreferenceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?:
      | NotificationPreferenceOrderByWithRelationInput
      | NotificationPreferenceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: NotificationPreferenceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned NotificationPreferences
     **/
    _count?: true | NotificationPreferenceCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: NotificationPreferenceMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: NotificationPreferenceMaxAggregateInputType;
  };

  export type GetNotificationPreferenceAggregateType<
    T extends NotificationPreferenceAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateNotificationPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationPreference[P]>
      : GetScalarType<T[P], AggregateNotificationPreference[P]>;
  };

  export type NotificationPreferenceGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificationPreferenceWhereInput;
    orderBy?:
      | NotificationPreferenceOrderByWithAggregationInput
      | NotificationPreferenceOrderByWithAggregationInput[];
    by: NotificationPreferenceScalarFieldEnum[] | NotificationPreferenceScalarFieldEnum;
    having?: NotificationPreferenceScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: NotificationPreferenceCountAggregateInputType | true;
    _min?: NotificationPreferenceMinAggregateInputType;
    _max?: NotificationPreferenceMaxAggregateInputType;
  };

  export type NotificationPreferenceGroupByOutputType = {
    id: string;
    userId: string;
    module: string;
    eventType: string;
    channels: $Enums.NotificationChannel[];
    priority: $Enums.NotificationPriority;
    digestEnabled: boolean;
    digestFrequency: $Enums.DigestFrequency | null;
    dndEnabled: boolean;
    dndStartTime: string | null;
    dndEndTime: string | null;
    dndDays: string[];
    aiSummaryEnabled: boolean;
    aiGroupingEnabled: boolean;
    createdAt: Date;
    updatedAt: Date;
    _count: NotificationPreferenceCountAggregateOutputType | null;
    _min: NotificationPreferenceMinAggregateOutputType | null;
    _max: NotificationPreferenceMaxAggregateOutputType | null;
  };

  type GetNotificationPreferenceGroupByPayload<T extends NotificationPreferenceGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<NotificationPreferenceGroupByOutputType, T['by']> & {
          [P in keyof T & keyof NotificationPreferenceGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>;
        }
      >
    >;

  export type NotificationPreferenceSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      module?: boolean;
      eventType?: boolean;
      channels?: boolean;
      priority?: boolean;
      digestEnabled?: boolean;
      digestFrequency?: boolean;
      dndEnabled?: boolean;
      dndStartTime?: boolean;
      dndEndTime?: boolean;
      dndDays?: boolean;
      aiSummaryEnabled?: boolean;
      aiGroupingEnabled?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      helixProfile?: boolean | NotificationPreference$helixProfileArgs<ExtArgs>;
    },
    ExtArgs['result']['notificationPreference']
  >;

  export type NotificationPreferenceSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      module?: boolean;
      eventType?: boolean;
      channels?: boolean;
      priority?: boolean;
      digestEnabled?: boolean;
      digestFrequency?: boolean;
      dndEnabled?: boolean;
      dndStartTime?: boolean;
      dndEndTime?: boolean;
      dndDays?: boolean;
      aiSummaryEnabled?: boolean;
      aiGroupingEnabled?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      helixProfile?: boolean | NotificationPreference$helixProfileArgs<ExtArgs>;
    },
    ExtArgs['result']['notificationPreference']
  >;

  export type NotificationPreferenceSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      module?: boolean;
      eventType?: boolean;
      channels?: boolean;
      priority?: boolean;
      digestEnabled?: boolean;
      digestFrequency?: boolean;
      dndEnabled?: boolean;
      dndStartTime?: boolean;
      dndEndTime?: boolean;
      dndDays?: boolean;
      aiSummaryEnabled?: boolean;
      aiGroupingEnabled?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      helixProfile?: boolean | NotificationPreference$helixProfileArgs<ExtArgs>;
    },
    ExtArgs['result']['notificationPreference']
  >;

  export type NotificationPreferenceSelectScalar = {
    id?: boolean;
    userId?: boolean;
    module?: boolean;
    eventType?: boolean;
    channels?: boolean;
    priority?: boolean;
    digestEnabled?: boolean;
    digestFrequency?: boolean;
    dndEnabled?: boolean;
    dndStartTime?: boolean;
    dndEndTime?: boolean;
    dndDays?: boolean;
    aiSummaryEnabled?: boolean;
    aiGroupingEnabled?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type NotificationPreferenceOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'userId'
    | 'module'
    | 'eventType'
    | 'channels'
    | 'priority'
    | 'digestEnabled'
    | 'digestFrequency'
    | 'dndEnabled'
    | 'dndStartTime'
    | 'dndEndTime'
    | 'dndDays'
    | 'aiSummaryEnabled'
    | 'aiGroupingEnabled'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['notificationPreference']
  >;
  export type NotificationPreferenceInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    helixProfile?: boolean | NotificationPreference$helixProfileArgs<ExtArgs>;
  };
  export type NotificationPreferenceIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    helixProfile?: boolean | NotificationPreference$helixProfileArgs<ExtArgs>;
  };
  export type NotificationPreferenceIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    helixProfile?: boolean | NotificationPreference$helixProfileArgs<ExtArgs>;
  };

  export type $NotificationPreferencePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'NotificationPreference';
    objects: {
      helixProfile: Prisma.$HelixUserNotificationProfilePayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        module: string;
        eventType: string;
        channels: $Enums.NotificationChannel[];
        priority: $Enums.NotificationPriority;
        digestEnabled: boolean;
        digestFrequency: $Enums.DigestFrequency | null;
        dndEnabled: boolean;
        dndStartTime: string | null;
        dndEndTime: string | null;
        dndDays: string[];
        aiSummaryEnabled: boolean;
        aiGroupingEnabled: boolean;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['notificationPreference']
    >;
    composites: {};
  };

  type NotificationPreferenceGetPayload<
    S extends boolean | null | undefined | NotificationPreferenceDefaultArgs,
  > = $Result.GetResult<Prisma.$NotificationPreferencePayload, S>;

  type NotificationPreferenceCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<NotificationPreferenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: NotificationPreferenceCountAggregateInputType | true;
  };

  export interface NotificationPreferenceDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['NotificationPreference'];
      meta: { name: 'NotificationPreference' };
    };
    /**
     * Find zero or one NotificationPreference that matches the filter.
     * @param {NotificationPreferenceFindUniqueArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationPreferenceFindUniqueArgs>(
      args: SelectSubset<T, NotificationPreferenceFindUniqueArgs<ExtArgs>>,
    ): Prisma__NotificationPreferenceClient<
      $Result.GetResult<
        Prisma.$NotificationPreferencePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one NotificationPreference that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationPreferenceFindUniqueOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationPreferenceFindUniqueOrThrowArgs>(
      args: SelectSubset<T, NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__NotificationPreferenceClient<
      $Result.GetResult<
        Prisma.$NotificationPreferencePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first NotificationPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationPreferenceFindFirstArgs>(
      args?: SelectSubset<T, NotificationPreferenceFindFirstArgs<ExtArgs>>,
    ): Prisma__NotificationPreferenceClient<
      $Result.GetResult<
        Prisma.$NotificationPreferencePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first NotificationPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationPreferenceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__NotificationPreferenceClient<
      $Result.GetResult<
        Prisma.$NotificationPreferencePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more NotificationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany()
     *
     * // Get first 10 NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.findMany({ select: { id: true } })
     *
     */
    findMany<T extends NotificationPreferenceFindManyArgs>(
      args?: SelectSubset<T, NotificationPreferenceFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationPreferencePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a NotificationPreference.
     * @param {NotificationPreferenceCreateArgs} args - Arguments to create a NotificationPreference.
     * @example
     * // Create one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.create({
     *   data: {
     *     // ... data to create a NotificationPreference
     *   }
     * })
     *
     */
    create<T extends NotificationPreferenceCreateArgs>(
      args: SelectSubset<T, NotificationPreferenceCreateArgs<ExtArgs>>,
    ): Prisma__NotificationPreferenceClient<
      $Result.GetResult<
        Prisma.$NotificationPreferencePayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many NotificationPreferences.
     * @param {NotificationPreferenceCreateManyArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends NotificationPreferenceCreateManyArgs>(
      args?: SelectSubset<T, NotificationPreferenceCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many NotificationPreferences and returns the data saved in the database.
     * @param {NotificationPreferenceCreateManyAndReturnArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many NotificationPreferences and only return the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends NotificationPreferenceCreateManyAndReturnArgs>(
      args?: SelectSubset<T, NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationPreferencePayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a NotificationPreference.
     * @param {NotificationPreferenceDeleteArgs} args - Arguments to delete one NotificationPreference.
     * @example
     * // Delete one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.delete({
     *   where: {
     *     // ... filter to delete one NotificationPreference
     *   }
     * })
     *
     */
    delete<T extends NotificationPreferenceDeleteArgs>(
      args: SelectSubset<T, NotificationPreferenceDeleteArgs<ExtArgs>>,
    ): Prisma__NotificationPreferenceClient<
      $Result.GetResult<
        Prisma.$NotificationPreferencePayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one NotificationPreference.
     * @param {NotificationPreferenceUpdateArgs} args - Arguments to update one NotificationPreference.
     * @example
     * // Update one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends NotificationPreferenceUpdateArgs>(
      args: SelectSubset<T, NotificationPreferenceUpdateArgs<ExtArgs>>,
    ): Prisma__NotificationPreferenceClient<
      $Result.GetResult<
        Prisma.$NotificationPreferencePayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more NotificationPreferences.
     * @param {NotificationPreferenceDeleteManyArgs} args - Arguments to filter NotificationPreferences to delete.
     * @example
     * // Delete a few NotificationPreferences
     * const { count } = await prisma.notificationPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends NotificationPreferenceDeleteManyArgs>(
      args?: SelectSubset<T, NotificationPreferenceDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends NotificationPreferenceUpdateManyArgs>(
      args: SelectSubset<T, NotificationPreferenceUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more NotificationPreferences and returns the data updated in the database.
     * @param {NotificationPreferenceUpdateManyAndReturnArgs} args - Arguments to update many NotificationPreferences.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more NotificationPreferences and only return the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends NotificationPreferenceUpdateManyAndReturnArgs>(
      args: SelectSubset<T, NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationPreferencePayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one NotificationPreference.
     * @param {NotificationPreferenceUpsertArgs} args - Arguments to update or create a NotificationPreference.
     * @example
     * // Update or create a NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.upsert({
     *   create: {
     *     // ... data to create a NotificationPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationPreference we want to update
     *   }
     * })
     */
    upsert<T extends NotificationPreferenceUpsertArgs>(
      args: SelectSubset<T, NotificationPreferenceUpsertArgs<ExtArgs>>,
    ): Prisma__NotificationPreferenceClient<
      $Result.GetResult<
        Prisma.$NotificationPreferencePayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceCountArgs} args - Arguments to filter NotificationPreferences to count.
     * @example
     * // Count the number of NotificationPreferences
     * const count = await prisma.notificationPreference.count({
     *   where: {
     *     // ... the filter for the NotificationPreferences we want to count
     *   }
     * })
     **/
    count<T extends NotificationPreferenceCountArgs>(
      args?: Subset<T, NotificationPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationPreferenceCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends NotificationPreferenceAggregateArgs>(
      args: Subset<T, NotificationPreferenceAggregateArgs>,
    ): Prisma.PrismaPromise<GetNotificationPreferenceAggregateType<T>>;

    /**
     * Group by NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends NotificationPreferenceGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: NotificationPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, NotificationPreferenceGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetNotificationPreferenceGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the NotificationPreference model
     */
    readonly fields: NotificationPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationPreferenceClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    helixProfile<T extends NotificationPreference$helixProfileArgs<ExtArgs> = {}>(
      args?: Subset<T, NotificationPreference$helixProfileArgs<ExtArgs>>,
    ): Prisma__HelixUserNotificationProfileClient<
      $Result.GetResult<
        Prisma.$HelixUserNotificationProfilePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the NotificationPreference model
   */
  interface NotificationPreferenceFieldRefs {
    readonly id: FieldRef<'NotificationPreference', 'String'>;
    readonly userId: FieldRef<'NotificationPreference', 'String'>;
    readonly module: FieldRef<'NotificationPreference', 'String'>;
    readonly eventType: FieldRef<'NotificationPreference', 'String'>;
    readonly channels: FieldRef<'NotificationPreference', 'NotificationChannel[]'>;
    readonly priority: FieldRef<'NotificationPreference', 'NotificationPriority'>;
    readonly digestEnabled: FieldRef<'NotificationPreference', 'Boolean'>;
    readonly digestFrequency: FieldRef<'NotificationPreference', 'DigestFrequency'>;
    readonly dndEnabled: FieldRef<'NotificationPreference', 'Boolean'>;
    readonly dndStartTime: FieldRef<'NotificationPreference', 'String'>;
    readonly dndEndTime: FieldRef<'NotificationPreference', 'String'>;
    readonly dndDays: FieldRef<'NotificationPreference', 'String[]'>;
    readonly aiSummaryEnabled: FieldRef<'NotificationPreference', 'Boolean'>;
    readonly aiGroupingEnabled: FieldRef<'NotificationPreference', 'Boolean'>;
    readonly createdAt: FieldRef<'NotificationPreference', 'DateTime'>;
    readonly updatedAt: FieldRef<'NotificationPreference', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * NotificationPreference findUnique
   */
  export type NotificationPreferenceFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput;
  };

  /**
   * NotificationPreference findUniqueOrThrow
   */
  export type NotificationPreferenceFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput;
  };

  /**
   * NotificationPreference findFirst
   */
  export type NotificationPreferenceFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?:
      | NotificationPreferenceOrderByWithRelationInput
      | NotificationPreferenceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[];
  };

  /**
   * NotificationPreference findFirstOrThrow
   */
  export type NotificationPreferenceFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?:
      | NotificationPreferenceOrderByWithRelationInput
      | NotificationPreferenceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[];
  };

  /**
   * NotificationPreference findMany
   */
  export type NotificationPreferenceFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationPreferences to fetch.
     */
    where?: NotificationPreferenceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?:
      | NotificationPreferenceOrderByWithRelationInput
      | NotificationPreferenceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number;
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[];
  };

  /**
   * NotificationPreference create
   */
  export type NotificationPreferenceCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null;
    /**
     * The data needed to create a NotificationPreference.
     */
    data: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>;
  };

  /**
   * NotificationPreference createMany
   */
  export type NotificationPreferenceCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * NotificationPreference createManyAndReturn
   */
  export type NotificationPreferenceCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null;
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * NotificationPreference update
   */
  export type NotificationPreferenceUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null;
    /**
     * The data needed to update a NotificationPreference.
     */
    data: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>;
    /**
     * Choose, which NotificationPreference to update.
     */
    where: NotificationPreferenceWhereUniqueInput;
  };

  /**
   * NotificationPreference updateMany
   */
  export type NotificationPreferenceUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<
      NotificationPreferenceUpdateManyMutationInput,
      NotificationPreferenceUncheckedUpdateManyInput
    >;
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput;
    /**
     * Limit how many NotificationPreferences to update.
     */
    limit?: number;
  };

  /**
   * NotificationPreference updateManyAndReturn
   */
  export type NotificationPreferenceUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null;
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<
      NotificationPreferenceUpdateManyMutationInput,
      NotificationPreferenceUncheckedUpdateManyInput
    >;
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput;
    /**
     * Limit how many NotificationPreferences to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * NotificationPreference upsert
   */
  export type NotificationPreferenceUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null;
    /**
     * The filter to search for the NotificationPreference to update in case it exists.
     */
    where: NotificationPreferenceWhereUniqueInput;
    /**
     * In case the NotificationPreference found by the `where` argument doesn't exist, create a new NotificationPreference with this data.
     */
    create: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>;
    /**
     * In case the NotificationPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>;
  };

  /**
   * NotificationPreference delete
   */
  export type NotificationPreferenceDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null;
    /**
     * Filter which NotificationPreference to delete.
     */
    where: NotificationPreferenceWhereUniqueInput;
  };

  /**
   * NotificationPreference deleteMany
   */
  export type NotificationPreferenceDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which NotificationPreferences to delete
     */
    where?: NotificationPreferenceWhereInput;
    /**
     * Limit how many NotificationPreferences to delete.
     */
    limit?: number;
  };

  /**
   * NotificationPreference.helixProfile
   */
  export type NotificationPreference$helixProfileArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HelixUserNotificationProfile
     */
    select?: HelixUserNotificationProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HelixUserNotificationProfile
     */
    omit?: HelixUserNotificationProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelixUserNotificationProfileInclude<ExtArgs> | null;
    where?: HelixUserNotificationProfileWhereInput;
  };

  /**
   * NotificationPreference without action
   */
  export type NotificationPreferenceDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null;
  };

  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null;
    _avg: NotificationAvgAggregateOutputType | null;
    _sum: NotificationSumAggregateOutputType | null;
    _min: NotificationMinAggregateOutputType | null;
    _max: NotificationMaxAggregateOutputType | null;
  };

  export type NotificationAvgAggregateOutputType = {
    retryCount: number | null;
    maxRetries: number | null;
  };

  export type NotificationSumAggregateOutputType = {
    retryCount: number | null;
    maxRetries: number | null;
  };

  export type NotificationMinAggregateOutputType = {
    id: string | null;
    eventId: string | null;
    userId: string | null;
    channel: $Enums.NotificationChannel | null;
    title: string | null;
    message: string | null;
    details: string | null;
    status: $Enums.NotificationStatus | null;
    priority: $Enums.NotificationPriority | null;
    scheduledFor: Date | null;
    deliveredAt: Date | null;
    readAt: Date | null;
    clickedAt: Date | null;
    dismissedAt: Date | null;
    retryCount: number | null;
    maxRetries: number | null;
    nextRetry: Date | null;
    aiSummary: string | null;
    groupId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type NotificationMaxAggregateOutputType = {
    id: string | null;
    eventId: string | null;
    userId: string | null;
    channel: $Enums.NotificationChannel | null;
    title: string | null;
    message: string | null;
    details: string | null;
    status: $Enums.NotificationStatus | null;
    priority: $Enums.NotificationPriority | null;
    scheduledFor: Date | null;
    deliveredAt: Date | null;
    readAt: Date | null;
    clickedAt: Date | null;
    dismissedAt: Date | null;
    retryCount: number | null;
    maxRetries: number | null;
    nextRetry: Date | null;
    aiSummary: string | null;
    groupId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type NotificationCountAggregateOutputType = {
    id: number;
    eventId: number;
    userId: number;
    channel: number;
    title: number;
    message: number;
    details: number;
    actions: number;
    status: number;
    priority: number;
    scheduledFor: number;
    deliveredAt: number;
    readAt: number;
    clickedAt: number;
    dismissedAt: number;
    retryCount: number;
    maxRetries: number;
    nextRetry: number;
    aiSummary: number;
    groupId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type NotificationAvgAggregateInputType = {
    retryCount?: true;
    maxRetries?: true;
  };

  export type NotificationSumAggregateInputType = {
    retryCount?: true;
    maxRetries?: true;
  };

  export type NotificationMinAggregateInputType = {
    id?: true;
    eventId?: true;
    userId?: true;
    channel?: true;
    title?: true;
    message?: true;
    details?: true;
    status?: true;
    priority?: true;
    scheduledFor?: true;
    deliveredAt?: true;
    readAt?: true;
    clickedAt?: true;
    dismissedAt?: true;
    retryCount?: true;
    maxRetries?: true;
    nextRetry?: true;
    aiSummary?: true;
    groupId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type NotificationMaxAggregateInputType = {
    id?: true;
    eventId?: true;
    userId?: true;
    channel?: true;
    title?: true;
    message?: true;
    details?: true;
    status?: true;
    priority?: true;
    scheduledFor?: true;
    deliveredAt?: true;
    readAt?: true;
    clickedAt?: true;
    dismissedAt?: true;
    retryCount?: true;
    maxRetries?: true;
    nextRetry?: true;
    aiSummary?: true;
    groupId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type NotificationCountAggregateInputType = {
    id?: true;
    eventId?: true;
    userId?: true;
    channel?: true;
    title?: true;
    message?: true;
    details?: true;
    actions?: true;
    status?: true;
    priority?: true;
    scheduledFor?: true;
    deliveredAt?: true;
    readAt?: true;
    clickedAt?: true;
    dismissedAt?: true;
    retryCount?: true;
    maxRetries?: true;
    nextRetry?: true;
    aiSummary?: true;
    groupId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type NotificationAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Notifications
     **/
    _count?: true | NotificationCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: NotificationAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: NotificationSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: NotificationMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: NotificationMaxAggregateInputType;
  };

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
    [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>;
  };

  export type NotificationGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[];
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum;
    having?: NotificationScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: NotificationCountAggregateInputType | true;
    _avg?: NotificationAvgAggregateInputType;
    _sum?: NotificationSumAggregateInputType;
    _min?: NotificationMinAggregateInputType;
    _max?: NotificationMaxAggregateInputType;
  };

  export type NotificationGroupByOutputType = {
    id: string;
    eventId: string;
    userId: string;
    channel: $Enums.NotificationChannel;
    title: string;
    message: string;
    details: string | null;
    actions: JsonValue | null;
    status: $Enums.NotificationStatus;
    priority: $Enums.NotificationPriority;
    scheduledFor: Date | null;
    deliveredAt: Date | null;
    readAt: Date | null;
    clickedAt: Date | null;
    dismissedAt: Date | null;
    retryCount: number;
    maxRetries: number;
    nextRetry: Date | null;
    aiSummary: string | null;
    groupId: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: NotificationCountAggregateOutputType | null;
    _avg: NotificationAvgAggregateOutputType | null;
    _sum: NotificationSumAggregateOutputType | null;
    _min: NotificationMinAggregateOutputType | null;
    _max: NotificationMaxAggregateOutputType | null;
  };

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> & {
        [P in keyof T & keyof NotificationGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
          : GetScalarType<T[P], NotificationGroupByOutputType[P]>;
      }
    >
  >;

  export type NotificationSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      eventId?: boolean;
      userId?: boolean;
      channel?: boolean;
      title?: boolean;
      message?: boolean;
      details?: boolean;
      actions?: boolean;
      status?: boolean;
      priority?: boolean;
      scheduledFor?: boolean;
      deliveredAt?: boolean;
      readAt?: boolean;
      clickedAt?: boolean;
      dismissedAt?: boolean;
      retryCount?: boolean;
      maxRetries?: boolean;
      nextRetry?: boolean;
      aiSummary?: boolean;
      groupId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      event?: boolean | NotificationEventDefaultArgs<ExtArgs>;
      deliveries?: boolean | Notification$deliveriesArgs<ExtArgs>;
      queue?: boolean | Notification$queueArgs<ExtArgs>;
      _count?: boolean | NotificationCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notification']
  >;

  export type NotificationSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      eventId?: boolean;
      userId?: boolean;
      channel?: boolean;
      title?: boolean;
      message?: boolean;
      details?: boolean;
      actions?: boolean;
      status?: boolean;
      priority?: boolean;
      scheduledFor?: boolean;
      deliveredAt?: boolean;
      readAt?: boolean;
      clickedAt?: boolean;
      dismissedAt?: boolean;
      retryCount?: boolean;
      maxRetries?: boolean;
      nextRetry?: boolean;
      aiSummary?: boolean;
      groupId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      event?: boolean | NotificationEventDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notification']
  >;

  export type NotificationSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      eventId?: boolean;
      userId?: boolean;
      channel?: boolean;
      title?: boolean;
      message?: boolean;
      details?: boolean;
      actions?: boolean;
      status?: boolean;
      priority?: boolean;
      scheduledFor?: boolean;
      deliveredAt?: boolean;
      readAt?: boolean;
      clickedAt?: boolean;
      dismissedAt?: boolean;
      retryCount?: boolean;
      maxRetries?: boolean;
      nextRetry?: boolean;
      aiSummary?: boolean;
      groupId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      event?: boolean | NotificationEventDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notification']
  >;

  export type NotificationSelectScalar = {
    id?: boolean;
    eventId?: boolean;
    userId?: boolean;
    channel?: boolean;
    title?: boolean;
    message?: boolean;
    details?: boolean;
    actions?: boolean;
    status?: boolean;
    priority?: boolean;
    scheduledFor?: boolean;
    deliveredAt?: boolean;
    readAt?: boolean;
    clickedAt?: boolean;
    dismissedAt?: boolean;
    retryCount?: boolean;
    maxRetries?: boolean;
    nextRetry?: boolean;
    aiSummary?: boolean;
    groupId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'eventId'
      | 'userId'
      | 'channel'
      | 'title'
      | 'message'
      | 'details'
      | 'actions'
      | 'status'
      | 'priority'
      | 'scheduledFor'
      | 'deliveredAt'
      | 'readAt'
      | 'clickedAt'
      | 'dismissedAt'
      | 'retryCount'
      | 'maxRetries'
      | 'nextRetry'
      | 'aiSummary'
      | 'groupId'
      | 'createdAt'
      | 'updatedAt',
      ExtArgs['result']['notification']
    >;
  export type NotificationInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    event?: boolean | NotificationEventDefaultArgs<ExtArgs>;
    deliveries?: boolean | Notification$deliveriesArgs<ExtArgs>;
    queue?: boolean | Notification$queueArgs<ExtArgs>;
    _count?: boolean | NotificationCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type NotificationIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    event?: boolean | NotificationEventDefaultArgs<ExtArgs>;
  };
  export type NotificationIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    event?: boolean | NotificationEventDefaultArgs<ExtArgs>;
  };

  export type $NotificationPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Notification';
    objects: {
      event: Prisma.$NotificationEventPayload<ExtArgs>;
      deliveries: Prisma.$NotificationDeliveryPayload<ExtArgs>[];
      queue: Prisma.$NotificationQueuePayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        eventId: string;
        userId: string;
        channel: $Enums.NotificationChannel;
        title: string;
        message: string;
        details: string | null;
        actions: Prisma.JsonValue | null;
        status: $Enums.NotificationStatus;
        priority: $Enums.NotificationPriority;
        scheduledFor: Date | null;
        deliveredAt: Date | null;
        readAt: Date | null;
        clickedAt: Date | null;
        dismissedAt: Date | null;
        retryCount: number;
        maxRetries: number;
        nextRetry: Date | null;
        aiSummary: string | null;
        groupId: string | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['notification']
    >;
    composites: {};
  };

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> =
    $Result.GetResult<Prisma.$NotificationPayload, S>;

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true;
    };

  export interface NotificationDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Notification'];
      meta: { name: 'Notification' };
    };
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(
      args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>,
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(
      args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(
      args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>,
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     *
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     *
     */
    findMany<T extends NotificationFindManyArgs>(
      args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     *
     */
    create<T extends NotificationCreateArgs>(
      args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>,
    ): Prisma__NotificationClient<
      $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends NotificationCreateManyArgs>(
      args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(
      args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     *
     */
    delete<T extends NotificationDeleteArgs>(
      args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>,
    ): Prisma__NotificationClient<
      $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends NotificationUpdateArgs>(
      args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>,
    ): Prisma__NotificationClient<
      $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends NotificationDeleteManyArgs>(
      args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends NotificationUpdateManyArgs>(
      args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(
      args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(
      args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>,
    ): Prisma__NotificationClient<
      $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
     **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends NotificationAggregateArgs>(
      args: Subset<T, NotificationAggregateArgs>,
    ): Prisma.PrismaPromise<GetNotificationAggregateType<T>>;

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetNotificationGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Notification model
     */
    readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    event<T extends NotificationEventDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, NotificationEventDefaultArgs<ExtArgs>>,
    ): Prisma__NotificationEventClient<
      | $Result.GetResult<
          Prisma.$NotificationEventPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    deliveries<T extends Notification$deliveriesArgs<ExtArgs> = {}>(
      args?: Subset<T, Notification$deliveriesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$NotificationDeliveryPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    queue<T extends Notification$queueArgs<ExtArgs> = {}>(
      args?: Subset<T, Notification$queueArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$NotificationQueuePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<'Notification', 'String'>;
    readonly eventId: FieldRef<'Notification', 'String'>;
    readonly userId: FieldRef<'Notification', 'String'>;
    readonly channel: FieldRef<'Notification', 'NotificationChannel'>;
    readonly title: FieldRef<'Notification', 'String'>;
    readonly message: FieldRef<'Notification', 'String'>;
    readonly details: FieldRef<'Notification', 'String'>;
    readonly actions: FieldRef<'Notification', 'Json'>;
    readonly status: FieldRef<'Notification', 'NotificationStatus'>;
    readonly priority: FieldRef<'Notification', 'NotificationPriority'>;
    readonly scheduledFor: FieldRef<'Notification', 'DateTime'>;
    readonly deliveredAt: FieldRef<'Notification', 'DateTime'>;
    readonly readAt: FieldRef<'Notification', 'DateTime'>;
    readonly clickedAt: FieldRef<'Notification', 'DateTime'>;
    readonly dismissedAt: FieldRef<'Notification', 'DateTime'>;
    readonly retryCount: FieldRef<'Notification', 'Int'>;
    readonly maxRetries: FieldRef<'Notification', 'Int'>;
    readonly nextRetry: FieldRef<'Notification', 'DateTime'>;
    readonly aiSummary: FieldRef<'Notification', 'String'>;
    readonly groupId: FieldRef<'Notification', 'String'>;
    readonly createdAt: FieldRef<'Notification', 'DateTime'>;
    readonly updatedAt: FieldRef<'Notification', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * Notification create
   */
  export type NotificationCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>;
  };

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>;
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>;
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput;
    /**
     * Limit how many Notifications to update.
     */
    limit?: number;
  };

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>;
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput;
    /**
     * Limit how many Notifications to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput;
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>;
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>;
  };

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput;
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number;
  };

  /**
   * Notification.deliveries
   */
  export type Notification$deliveriesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationDelivery
     */
    select?: NotificationDeliverySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationDelivery
     */
    omit?: NotificationDeliveryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDeliveryInclude<ExtArgs> | null;
    where?: NotificationDeliveryWhereInput;
    orderBy?:
      | NotificationDeliveryOrderByWithRelationInput
      | NotificationDeliveryOrderByWithRelationInput[];
    cursor?: NotificationDeliveryWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: NotificationDeliveryScalarFieldEnum | NotificationDeliveryScalarFieldEnum[];
  };

  /**
   * Notification.queue
   */
  export type Notification$queueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationQueueInclude<ExtArgs> | null;
    where?: NotificationQueueWhereInput;
    orderBy?:
      | NotificationQueueOrderByWithRelationInput
      | NotificationQueueOrderByWithRelationInput[];
    cursor?: NotificationQueueWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: NotificationQueueScalarFieldEnum | NotificationQueueScalarFieldEnum[];
  };

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
  };

  /**
   * Model NotificationDelivery
   */

  export type AggregateNotificationDelivery = {
    _count: NotificationDeliveryCountAggregateOutputType | null;
    _avg: NotificationDeliveryAvgAggregateOutputType | null;
    _sum: NotificationDeliverySumAggregateOutputType | null;
    _min: NotificationDeliveryMinAggregateOutputType | null;
    _max: NotificationDeliveryMaxAggregateOutputType | null;
  };

  export type NotificationDeliveryAvgAggregateOutputType = {
    responseTime: number | null;
  };

  export type NotificationDeliverySumAggregateOutputType = {
    responseTime: number | null;
  };

  export type NotificationDeliveryMinAggregateOutputType = {
    id: string | null;
    notificationId: string | null;
    eventId: string | null;
    userId: string | null;
    channel: $Enums.NotificationChannel | null;
    provider: string | null;
    status: $Enums.DeliveryStatus | null;
    deliveredAt: Date | null;
    failedAt: Date | null;
    errorMessage: string | null;
    errorCode: string | null;
    messageId: string | null;
    responseTime: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type NotificationDeliveryMaxAggregateOutputType = {
    id: string | null;
    notificationId: string | null;
    eventId: string | null;
    userId: string | null;
    channel: $Enums.NotificationChannel | null;
    provider: string | null;
    status: $Enums.DeliveryStatus | null;
    deliveredAt: Date | null;
    failedAt: Date | null;
    errorMessage: string | null;
    errorCode: string | null;
    messageId: string | null;
    responseTime: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type NotificationDeliveryCountAggregateOutputType = {
    id: number;
    notificationId: number;
    eventId: number;
    userId: number;
    channel: number;
    provider: number;
    providerConfig: number;
    status: number;
    deliveredAt: number;
    failedAt: number;
    errorMessage: number;
    errorCode: number;
    providerResponse: number;
    messageId: number;
    responseTime: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type NotificationDeliveryAvgAggregateInputType = {
    responseTime?: true;
  };

  export type NotificationDeliverySumAggregateInputType = {
    responseTime?: true;
  };

  export type NotificationDeliveryMinAggregateInputType = {
    id?: true;
    notificationId?: true;
    eventId?: true;
    userId?: true;
    channel?: true;
    provider?: true;
    status?: true;
    deliveredAt?: true;
    failedAt?: true;
    errorMessage?: true;
    errorCode?: true;
    messageId?: true;
    responseTime?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type NotificationDeliveryMaxAggregateInputType = {
    id?: true;
    notificationId?: true;
    eventId?: true;
    userId?: true;
    channel?: true;
    provider?: true;
    status?: true;
    deliveredAt?: true;
    failedAt?: true;
    errorMessage?: true;
    errorCode?: true;
    messageId?: true;
    responseTime?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type NotificationDeliveryCountAggregateInputType = {
    id?: true;
    notificationId?: true;
    eventId?: true;
    userId?: true;
    channel?: true;
    provider?: true;
    providerConfig?: true;
    status?: true;
    deliveredAt?: true;
    failedAt?: true;
    errorMessage?: true;
    errorCode?: true;
    providerResponse?: true;
    messageId?: true;
    responseTime?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type NotificationDeliveryAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which NotificationDelivery to aggregate.
     */
    where?: NotificationDeliveryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationDeliveries to fetch.
     */
    orderBy?:
      | NotificationDeliveryOrderByWithRelationInput
      | NotificationDeliveryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: NotificationDeliveryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationDeliveries from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationDeliveries.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned NotificationDeliveries
     **/
    _count?: true | NotificationDeliveryCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: NotificationDeliveryAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: NotificationDeliverySumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: NotificationDeliveryMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: NotificationDeliveryMaxAggregateInputType;
  };

  export type GetNotificationDeliveryAggregateType<T extends NotificationDeliveryAggregateArgs> = {
    [P in keyof T & keyof AggregateNotificationDelivery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationDelivery[P]>
      : GetScalarType<T[P], AggregateNotificationDelivery[P]>;
  };

  export type NotificationDeliveryGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificationDeliveryWhereInput;
    orderBy?:
      | NotificationDeliveryOrderByWithAggregationInput
      | NotificationDeliveryOrderByWithAggregationInput[];
    by: NotificationDeliveryScalarFieldEnum[] | NotificationDeliveryScalarFieldEnum;
    having?: NotificationDeliveryScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: NotificationDeliveryCountAggregateInputType | true;
    _avg?: NotificationDeliveryAvgAggregateInputType;
    _sum?: NotificationDeliverySumAggregateInputType;
    _min?: NotificationDeliveryMinAggregateInputType;
    _max?: NotificationDeliveryMaxAggregateInputType;
  };

  export type NotificationDeliveryGroupByOutputType = {
    id: string;
    notificationId: string;
    eventId: string;
    userId: string;
    channel: $Enums.NotificationChannel;
    provider: string | null;
    providerConfig: JsonValue | null;
    status: $Enums.DeliveryStatus;
    deliveredAt: Date | null;
    failedAt: Date | null;
    errorMessage: string | null;
    errorCode: string | null;
    providerResponse: JsonValue | null;
    messageId: string | null;
    responseTime: number | null;
    createdAt: Date;
    updatedAt: Date;
    _count: NotificationDeliveryCountAggregateOutputType | null;
    _avg: NotificationDeliveryAvgAggregateOutputType | null;
    _sum: NotificationDeliverySumAggregateOutputType | null;
    _min: NotificationDeliveryMinAggregateOutputType | null;
    _max: NotificationDeliveryMaxAggregateOutputType | null;
  };

  type GetNotificationDeliveryGroupByPayload<T extends NotificationDeliveryGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<NotificationDeliveryGroupByOutputType, T['by']> & {
          [P in keyof T & keyof NotificationDeliveryGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationDeliveryGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationDeliveryGroupByOutputType[P]>;
        }
      >
    >;

  export type NotificationDeliverySelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      notificationId?: boolean;
      eventId?: boolean;
      userId?: boolean;
      channel?: boolean;
      provider?: boolean;
      providerConfig?: boolean;
      status?: boolean;
      deliveredAt?: boolean;
      failedAt?: boolean;
      errorMessage?: boolean;
      errorCode?: boolean;
      providerResponse?: boolean;
      messageId?: boolean;
      responseTime?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      notification?: boolean | NotificationDefaultArgs<ExtArgs>;
      event?: boolean | NotificationEventDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notificationDelivery']
  >;

  export type NotificationDeliverySelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      notificationId?: boolean;
      eventId?: boolean;
      userId?: boolean;
      channel?: boolean;
      provider?: boolean;
      providerConfig?: boolean;
      status?: boolean;
      deliveredAt?: boolean;
      failedAt?: boolean;
      errorMessage?: boolean;
      errorCode?: boolean;
      providerResponse?: boolean;
      messageId?: boolean;
      responseTime?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      notification?: boolean | NotificationDefaultArgs<ExtArgs>;
      event?: boolean | NotificationEventDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notificationDelivery']
  >;

  export type NotificationDeliverySelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      notificationId?: boolean;
      eventId?: boolean;
      userId?: boolean;
      channel?: boolean;
      provider?: boolean;
      providerConfig?: boolean;
      status?: boolean;
      deliveredAt?: boolean;
      failedAt?: boolean;
      errorMessage?: boolean;
      errorCode?: boolean;
      providerResponse?: boolean;
      messageId?: boolean;
      responseTime?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      notification?: boolean | NotificationDefaultArgs<ExtArgs>;
      event?: boolean | NotificationEventDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notificationDelivery']
  >;

  export type NotificationDeliverySelectScalar = {
    id?: boolean;
    notificationId?: boolean;
    eventId?: boolean;
    userId?: boolean;
    channel?: boolean;
    provider?: boolean;
    providerConfig?: boolean;
    status?: boolean;
    deliveredAt?: boolean;
    failedAt?: boolean;
    errorMessage?: boolean;
    errorCode?: boolean;
    providerResponse?: boolean;
    messageId?: boolean;
    responseTime?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type NotificationDeliveryOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'notificationId'
    | 'eventId'
    | 'userId'
    | 'channel'
    | 'provider'
    | 'providerConfig'
    | 'status'
    | 'deliveredAt'
    | 'failedAt'
    | 'errorMessage'
    | 'errorCode'
    | 'providerResponse'
    | 'messageId'
    | 'responseTime'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['notificationDelivery']
  >;
  export type NotificationDeliveryInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    notification?: boolean | NotificationDefaultArgs<ExtArgs>;
    event?: boolean | NotificationEventDefaultArgs<ExtArgs>;
  };
  export type NotificationDeliveryIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    notification?: boolean | NotificationDefaultArgs<ExtArgs>;
    event?: boolean | NotificationEventDefaultArgs<ExtArgs>;
  };
  export type NotificationDeliveryIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    notification?: boolean | NotificationDefaultArgs<ExtArgs>;
    event?: boolean | NotificationEventDefaultArgs<ExtArgs>;
  };

  export type $NotificationDeliveryPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'NotificationDelivery';
    objects: {
      notification: Prisma.$NotificationPayload<ExtArgs>;
      event: Prisma.$NotificationEventPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        notificationId: string;
        eventId: string;
        userId: string;
        channel: $Enums.NotificationChannel;
        provider: string | null;
        providerConfig: Prisma.JsonValue | null;
        status: $Enums.DeliveryStatus;
        deliveredAt: Date | null;
        failedAt: Date | null;
        errorMessage: string | null;
        errorCode: string | null;
        providerResponse: Prisma.JsonValue | null;
        messageId: string | null;
        responseTime: number | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['notificationDelivery']
    >;
    composites: {};
  };

  type NotificationDeliveryGetPayload<
    S extends boolean | null | undefined | NotificationDeliveryDefaultArgs,
  > = $Result.GetResult<Prisma.$NotificationDeliveryPayload, S>;

  type NotificationDeliveryCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<NotificationDeliveryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: NotificationDeliveryCountAggregateInputType | true;
  };

  export interface NotificationDeliveryDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['NotificationDelivery'];
      meta: { name: 'NotificationDelivery' };
    };
    /**
     * Find zero or one NotificationDelivery that matches the filter.
     * @param {NotificationDeliveryFindUniqueArgs} args - Arguments to find a NotificationDelivery
     * @example
     * // Get one NotificationDelivery
     * const notificationDelivery = await prisma.notificationDelivery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationDeliveryFindUniqueArgs>(
      args: SelectSubset<T, NotificationDeliveryFindUniqueArgs<ExtArgs>>,
    ): Prisma__NotificationDeliveryClient<
      $Result.GetResult<
        Prisma.$NotificationDeliveryPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one NotificationDelivery that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationDeliveryFindUniqueOrThrowArgs} args - Arguments to find a NotificationDelivery
     * @example
     * // Get one NotificationDelivery
     * const notificationDelivery = await prisma.notificationDelivery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationDeliveryFindUniqueOrThrowArgs>(
      args: SelectSubset<T, NotificationDeliveryFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__NotificationDeliveryClient<
      $Result.GetResult<
        Prisma.$NotificationDeliveryPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first NotificationDelivery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationDeliveryFindFirstArgs} args - Arguments to find a NotificationDelivery
     * @example
     * // Get one NotificationDelivery
     * const notificationDelivery = await prisma.notificationDelivery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationDeliveryFindFirstArgs>(
      args?: SelectSubset<T, NotificationDeliveryFindFirstArgs<ExtArgs>>,
    ): Prisma__NotificationDeliveryClient<
      $Result.GetResult<
        Prisma.$NotificationDeliveryPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first NotificationDelivery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationDeliveryFindFirstOrThrowArgs} args - Arguments to find a NotificationDelivery
     * @example
     * // Get one NotificationDelivery
     * const notificationDelivery = await prisma.notificationDelivery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationDeliveryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NotificationDeliveryFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__NotificationDeliveryClient<
      $Result.GetResult<
        Prisma.$NotificationDeliveryPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more NotificationDeliveries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationDeliveryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationDeliveries
     * const notificationDeliveries = await prisma.notificationDelivery.findMany()
     *
     * // Get first 10 NotificationDeliveries
     * const notificationDeliveries = await prisma.notificationDelivery.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const notificationDeliveryWithIdOnly = await prisma.notificationDelivery.findMany({ select: { id: true } })
     *
     */
    findMany<T extends NotificationDeliveryFindManyArgs>(
      args?: SelectSubset<T, NotificationDeliveryFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationDeliveryPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a NotificationDelivery.
     * @param {NotificationDeliveryCreateArgs} args - Arguments to create a NotificationDelivery.
     * @example
     * // Create one NotificationDelivery
     * const NotificationDelivery = await prisma.notificationDelivery.create({
     *   data: {
     *     // ... data to create a NotificationDelivery
     *   }
     * })
     *
     */
    create<T extends NotificationDeliveryCreateArgs>(
      args: SelectSubset<T, NotificationDeliveryCreateArgs<ExtArgs>>,
    ): Prisma__NotificationDeliveryClient<
      $Result.GetResult<
        Prisma.$NotificationDeliveryPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many NotificationDeliveries.
     * @param {NotificationDeliveryCreateManyArgs} args - Arguments to create many NotificationDeliveries.
     * @example
     * // Create many NotificationDeliveries
     * const notificationDelivery = await prisma.notificationDelivery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends NotificationDeliveryCreateManyArgs>(
      args?: SelectSubset<T, NotificationDeliveryCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many NotificationDeliveries and returns the data saved in the database.
     * @param {NotificationDeliveryCreateManyAndReturnArgs} args - Arguments to create many NotificationDeliveries.
     * @example
     * // Create many NotificationDeliveries
     * const notificationDelivery = await prisma.notificationDelivery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many NotificationDeliveries and only return the `id`
     * const notificationDeliveryWithIdOnly = await prisma.notificationDelivery.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends NotificationDeliveryCreateManyAndReturnArgs>(
      args?: SelectSubset<T, NotificationDeliveryCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationDeliveryPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a NotificationDelivery.
     * @param {NotificationDeliveryDeleteArgs} args - Arguments to delete one NotificationDelivery.
     * @example
     * // Delete one NotificationDelivery
     * const NotificationDelivery = await prisma.notificationDelivery.delete({
     *   where: {
     *     // ... filter to delete one NotificationDelivery
     *   }
     * })
     *
     */
    delete<T extends NotificationDeliveryDeleteArgs>(
      args: SelectSubset<T, NotificationDeliveryDeleteArgs<ExtArgs>>,
    ): Prisma__NotificationDeliveryClient<
      $Result.GetResult<
        Prisma.$NotificationDeliveryPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one NotificationDelivery.
     * @param {NotificationDeliveryUpdateArgs} args - Arguments to update one NotificationDelivery.
     * @example
     * // Update one NotificationDelivery
     * const notificationDelivery = await prisma.notificationDelivery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends NotificationDeliveryUpdateArgs>(
      args: SelectSubset<T, NotificationDeliveryUpdateArgs<ExtArgs>>,
    ): Prisma__NotificationDeliveryClient<
      $Result.GetResult<
        Prisma.$NotificationDeliveryPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more NotificationDeliveries.
     * @param {NotificationDeliveryDeleteManyArgs} args - Arguments to filter NotificationDeliveries to delete.
     * @example
     * // Delete a few NotificationDeliveries
     * const { count } = await prisma.notificationDelivery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends NotificationDeliveryDeleteManyArgs>(
      args?: SelectSubset<T, NotificationDeliveryDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more NotificationDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationDeliveryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationDeliveries
     * const notificationDelivery = await prisma.notificationDelivery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends NotificationDeliveryUpdateManyArgs>(
      args: SelectSubset<T, NotificationDeliveryUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more NotificationDeliveries and returns the data updated in the database.
     * @param {NotificationDeliveryUpdateManyAndReturnArgs} args - Arguments to update many NotificationDeliveries.
     * @example
     * // Update many NotificationDeliveries
     * const notificationDelivery = await prisma.notificationDelivery.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more NotificationDeliveries and only return the `id`
     * const notificationDeliveryWithIdOnly = await prisma.notificationDelivery.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends NotificationDeliveryUpdateManyAndReturnArgs>(
      args: SelectSubset<T, NotificationDeliveryUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationDeliveryPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one NotificationDelivery.
     * @param {NotificationDeliveryUpsertArgs} args - Arguments to update or create a NotificationDelivery.
     * @example
     * // Update or create a NotificationDelivery
     * const notificationDelivery = await prisma.notificationDelivery.upsert({
     *   create: {
     *     // ... data to create a NotificationDelivery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationDelivery we want to update
     *   }
     * })
     */
    upsert<T extends NotificationDeliveryUpsertArgs>(
      args: SelectSubset<T, NotificationDeliveryUpsertArgs<ExtArgs>>,
    ): Prisma__NotificationDeliveryClient<
      $Result.GetResult<
        Prisma.$NotificationDeliveryPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of NotificationDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationDeliveryCountArgs} args - Arguments to filter NotificationDeliveries to count.
     * @example
     * // Count the number of NotificationDeliveries
     * const count = await prisma.notificationDelivery.count({
     *   where: {
     *     // ... the filter for the NotificationDeliveries we want to count
     *   }
     * })
     **/
    count<T extends NotificationDeliveryCountArgs>(
      args?: Subset<T, NotificationDeliveryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationDeliveryCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a NotificationDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationDeliveryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends NotificationDeliveryAggregateArgs>(
      args: Subset<T, NotificationDeliveryAggregateArgs>,
    ): Prisma.PrismaPromise<GetNotificationDeliveryAggregateType<T>>;

    /**
     * Group by NotificationDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationDeliveryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends NotificationDeliveryGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationDeliveryGroupByArgs['orderBy'] }
        : { orderBy?: NotificationDeliveryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, NotificationDeliveryGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetNotificationDeliveryGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the NotificationDelivery model
     */
    readonly fields: NotificationDeliveryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationDelivery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationDeliveryClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    notification<T extends NotificationDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, NotificationDefaultArgs<ExtArgs>>,
    ): Prisma__NotificationClient<
      | $Result.GetResult<
          Prisma.$NotificationPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    event<T extends NotificationEventDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, NotificationEventDefaultArgs<ExtArgs>>,
    ): Prisma__NotificationEventClient<
      | $Result.GetResult<
          Prisma.$NotificationEventPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the NotificationDelivery model
   */
  interface NotificationDeliveryFieldRefs {
    readonly id: FieldRef<'NotificationDelivery', 'String'>;
    readonly notificationId: FieldRef<'NotificationDelivery', 'String'>;
    readonly eventId: FieldRef<'NotificationDelivery', 'String'>;
    readonly userId: FieldRef<'NotificationDelivery', 'String'>;
    readonly channel: FieldRef<'NotificationDelivery', 'NotificationChannel'>;
    readonly provider: FieldRef<'NotificationDelivery', 'String'>;
    readonly providerConfig: FieldRef<'NotificationDelivery', 'Json'>;
    readonly status: FieldRef<'NotificationDelivery', 'DeliveryStatus'>;
    readonly deliveredAt: FieldRef<'NotificationDelivery', 'DateTime'>;
    readonly failedAt: FieldRef<'NotificationDelivery', 'DateTime'>;
    readonly errorMessage: FieldRef<'NotificationDelivery', 'String'>;
    readonly errorCode: FieldRef<'NotificationDelivery', 'String'>;
    readonly providerResponse: FieldRef<'NotificationDelivery', 'Json'>;
    readonly messageId: FieldRef<'NotificationDelivery', 'String'>;
    readonly responseTime: FieldRef<'NotificationDelivery', 'Int'>;
    readonly createdAt: FieldRef<'NotificationDelivery', 'DateTime'>;
    readonly updatedAt: FieldRef<'NotificationDelivery', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * NotificationDelivery findUnique
   */
  export type NotificationDeliveryFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationDelivery
     */
    select?: NotificationDeliverySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationDelivery
     */
    omit?: NotificationDeliveryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDeliveryInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationDelivery to fetch.
     */
    where: NotificationDeliveryWhereUniqueInput;
  };

  /**
   * NotificationDelivery findUniqueOrThrow
   */
  export type NotificationDeliveryFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationDelivery
     */
    select?: NotificationDeliverySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationDelivery
     */
    omit?: NotificationDeliveryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDeliveryInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationDelivery to fetch.
     */
    where: NotificationDeliveryWhereUniqueInput;
  };

  /**
   * NotificationDelivery findFirst
   */
  export type NotificationDeliveryFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationDelivery
     */
    select?: NotificationDeliverySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationDelivery
     */
    omit?: NotificationDeliveryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDeliveryInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationDelivery to fetch.
     */
    where?: NotificationDeliveryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationDeliveries to fetch.
     */
    orderBy?:
      | NotificationDeliveryOrderByWithRelationInput
      | NotificationDeliveryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for NotificationDeliveries.
     */
    cursor?: NotificationDeliveryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationDeliveries from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationDeliveries.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of NotificationDeliveries.
     */
    distinct?: NotificationDeliveryScalarFieldEnum | NotificationDeliveryScalarFieldEnum[];
  };

  /**
   * NotificationDelivery findFirstOrThrow
   */
  export type NotificationDeliveryFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationDelivery
     */
    select?: NotificationDeliverySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationDelivery
     */
    omit?: NotificationDeliveryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDeliveryInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationDelivery to fetch.
     */
    where?: NotificationDeliveryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationDeliveries to fetch.
     */
    orderBy?:
      | NotificationDeliveryOrderByWithRelationInput
      | NotificationDeliveryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for NotificationDeliveries.
     */
    cursor?: NotificationDeliveryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationDeliveries from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationDeliveries.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of NotificationDeliveries.
     */
    distinct?: NotificationDeliveryScalarFieldEnum | NotificationDeliveryScalarFieldEnum[];
  };

  /**
   * NotificationDelivery findMany
   */
  export type NotificationDeliveryFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationDelivery
     */
    select?: NotificationDeliverySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationDelivery
     */
    omit?: NotificationDeliveryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDeliveryInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationDeliveries to fetch.
     */
    where?: NotificationDeliveryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationDeliveries to fetch.
     */
    orderBy?:
      | NotificationDeliveryOrderByWithRelationInput
      | NotificationDeliveryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing NotificationDeliveries.
     */
    cursor?: NotificationDeliveryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationDeliveries from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationDeliveries.
     */
    skip?: number;
    distinct?: NotificationDeliveryScalarFieldEnum | NotificationDeliveryScalarFieldEnum[];
  };

  /**
   * NotificationDelivery create
   */
  export type NotificationDeliveryCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationDelivery
     */
    select?: NotificationDeliverySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationDelivery
     */
    omit?: NotificationDeliveryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDeliveryInclude<ExtArgs> | null;
    /**
     * The data needed to create a NotificationDelivery.
     */
    data: XOR<NotificationDeliveryCreateInput, NotificationDeliveryUncheckedCreateInput>;
  };

  /**
   * NotificationDelivery createMany
   */
  export type NotificationDeliveryCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many NotificationDeliveries.
     */
    data: NotificationDeliveryCreateManyInput | NotificationDeliveryCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * NotificationDelivery createManyAndReturn
   */
  export type NotificationDeliveryCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationDelivery
     */
    select?: NotificationDeliverySelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationDelivery
     */
    omit?: NotificationDeliveryOmit<ExtArgs> | null;
    /**
     * The data used to create many NotificationDeliveries.
     */
    data: NotificationDeliveryCreateManyInput | NotificationDeliveryCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDeliveryIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * NotificationDelivery update
   */
  export type NotificationDeliveryUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationDelivery
     */
    select?: NotificationDeliverySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationDelivery
     */
    omit?: NotificationDeliveryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDeliveryInclude<ExtArgs> | null;
    /**
     * The data needed to update a NotificationDelivery.
     */
    data: XOR<NotificationDeliveryUpdateInput, NotificationDeliveryUncheckedUpdateInput>;
    /**
     * Choose, which NotificationDelivery to update.
     */
    where: NotificationDeliveryWhereUniqueInput;
  };

  /**
   * NotificationDelivery updateMany
   */
  export type NotificationDeliveryUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update NotificationDeliveries.
     */
    data: XOR<
      NotificationDeliveryUpdateManyMutationInput,
      NotificationDeliveryUncheckedUpdateManyInput
    >;
    /**
     * Filter which NotificationDeliveries to update
     */
    where?: NotificationDeliveryWhereInput;
    /**
     * Limit how many NotificationDeliveries to update.
     */
    limit?: number;
  };

  /**
   * NotificationDelivery updateManyAndReturn
   */
  export type NotificationDeliveryUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationDelivery
     */
    select?: NotificationDeliverySelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationDelivery
     */
    omit?: NotificationDeliveryOmit<ExtArgs> | null;
    /**
     * The data used to update NotificationDeliveries.
     */
    data: XOR<
      NotificationDeliveryUpdateManyMutationInput,
      NotificationDeliveryUncheckedUpdateManyInput
    >;
    /**
     * Filter which NotificationDeliveries to update
     */
    where?: NotificationDeliveryWhereInput;
    /**
     * Limit how many NotificationDeliveries to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDeliveryIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * NotificationDelivery upsert
   */
  export type NotificationDeliveryUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationDelivery
     */
    select?: NotificationDeliverySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationDelivery
     */
    omit?: NotificationDeliveryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDeliveryInclude<ExtArgs> | null;
    /**
     * The filter to search for the NotificationDelivery to update in case it exists.
     */
    where: NotificationDeliveryWhereUniqueInput;
    /**
     * In case the NotificationDelivery found by the `where` argument doesn't exist, create a new NotificationDelivery with this data.
     */
    create: XOR<NotificationDeliveryCreateInput, NotificationDeliveryUncheckedCreateInput>;
    /**
     * In case the NotificationDelivery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationDeliveryUpdateInput, NotificationDeliveryUncheckedUpdateInput>;
  };

  /**
   * NotificationDelivery delete
   */
  export type NotificationDeliveryDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationDelivery
     */
    select?: NotificationDeliverySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationDelivery
     */
    omit?: NotificationDeliveryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDeliveryInclude<ExtArgs> | null;
    /**
     * Filter which NotificationDelivery to delete.
     */
    where: NotificationDeliveryWhereUniqueInput;
  };

  /**
   * NotificationDelivery deleteMany
   */
  export type NotificationDeliveryDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which NotificationDeliveries to delete
     */
    where?: NotificationDeliveryWhereInput;
    /**
     * Limit how many NotificationDeliveries to delete.
     */
    limit?: number;
  };

  /**
   * NotificationDelivery without action
   */
  export type NotificationDeliveryDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationDelivery
     */
    select?: NotificationDeliverySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationDelivery
     */
    omit?: NotificationDeliveryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDeliveryInclude<ExtArgs> | null;
  };

  /**
   * Model NotificationTemplate
   */

  export type AggregateNotificationTemplate = {
    _count: NotificationTemplateCountAggregateOutputType | null;
    _avg: NotificationTemplateAvgAggregateOutputType | null;
    _sum: NotificationTemplateSumAggregateOutputType | null;
    _min: NotificationTemplateMinAggregateOutputType | null;
    _max: NotificationTemplateMaxAggregateOutputType | null;
  };

  export type NotificationTemplateAvgAggregateOutputType = {
    version: number | null;
  };

  export type NotificationTemplateSumAggregateOutputType = {
    version: number | null;
  };

  export type NotificationTemplateMinAggregateOutputType = {
    id: string | null;
    module: string | null;
    eventType: string | null;
    channel: $Enums.NotificationChannel | null;
    name: string | null;
    description: string | null;
    titleTemplate: string | null;
    messageTemplate: string | null;
    detailsTemplate: string | null;
    isDefault: boolean | null;
    isActive: boolean | null;
    version: number | null;
    locale: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    createdBy: string | null;
  };

  export type NotificationTemplateMaxAggregateOutputType = {
    id: string | null;
    module: string | null;
    eventType: string | null;
    channel: $Enums.NotificationChannel | null;
    name: string | null;
    description: string | null;
    titleTemplate: string | null;
    messageTemplate: string | null;
    detailsTemplate: string | null;
    isDefault: boolean | null;
    isActive: boolean | null;
    version: number | null;
    locale: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    createdBy: string | null;
  };

  export type NotificationTemplateCountAggregateOutputType = {
    id: number;
    module: number;
    eventType: number;
    channel: number;
    name: number;
    description: number;
    titleTemplate: number;
    messageTemplate: number;
    detailsTemplate: number;
    isDefault: number;
    isActive: number;
    version: number;
    locale: number;
    variables: number;
    actions: number;
    createdAt: number;
    updatedAt: number;
    createdBy: number;
    _all: number;
  };

  export type NotificationTemplateAvgAggregateInputType = {
    version?: true;
  };

  export type NotificationTemplateSumAggregateInputType = {
    version?: true;
  };

  export type NotificationTemplateMinAggregateInputType = {
    id?: true;
    module?: true;
    eventType?: true;
    channel?: true;
    name?: true;
    description?: true;
    titleTemplate?: true;
    messageTemplate?: true;
    detailsTemplate?: true;
    isDefault?: true;
    isActive?: true;
    version?: true;
    locale?: true;
    createdAt?: true;
    updatedAt?: true;
    createdBy?: true;
  };

  export type NotificationTemplateMaxAggregateInputType = {
    id?: true;
    module?: true;
    eventType?: true;
    channel?: true;
    name?: true;
    description?: true;
    titleTemplate?: true;
    messageTemplate?: true;
    detailsTemplate?: true;
    isDefault?: true;
    isActive?: true;
    version?: true;
    locale?: true;
    createdAt?: true;
    updatedAt?: true;
    createdBy?: true;
  };

  export type NotificationTemplateCountAggregateInputType = {
    id?: true;
    module?: true;
    eventType?: true;
    channel?: true;
    name?: true;
    description?: true;
    titleTemplate?: true;
    messageTemplate?: true;
    detailsTemplate?: true;
    isDefault?: true;
    isActive?: true;
    version?: true;
    locale?: true;
    variables?: true;
    actions?: true;
    createdAt?: true;
    updatedAt?: true;
    createdBy?: true;
    _all?: true;
  };

  export type NotificationTemplateAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which NotificationTemplate to aggregate.
     */
    where?: NotificationTemplateWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationTemplates to fetch.
     */
    orderBy?:
      | NotificationTemplateOrderByWithRelationInput
      | NotificationTemplateOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: NotificationTemplateWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationTemplates from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationTemplates.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned NotificationTemplates
     **/
    _count?: true | NotificationTemplateCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: NotificationTemplateAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: NotificationTemplateSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: NotificationTemplateMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: NotificationTemplateMaxAggregateInputType;
  };

  export type GetNotificationTemplateAggregateType<T extends NotificationTemplateAggregateArgs> = {
    [P in keyof T & keyof AggregateNotificationTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationTemplate[P]>
      : GetScalarType<T[P], AggregateNotificationTemplate[P]>;
  };

  export type NotificationTemplateGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificationTemplateWhereInput;
    orderBy?:
      | NotificationTemplateOrderByWithAggregationInput
      | NotificationTemplateOrderByWithAggregationInput[];
    by: NotificationTemplateScalarFieldEnum[] | NotificationTemplateScalarFieldEnum;
    having?: NotificationTemplateScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: NotificationTemplateCountAggregateInputType | true;
    _avg?: NotificationTemplateAvgAggregateInputType;
    _sum?: NotificationTemplateSumAggregateInputType;
    _min?: NotificationTemplateMinAggregateInputType;
    _max?: NotificationTemplateMaxAggregateInputType;
  };

  export type NotificationTemplateGroupByOutputType = {
    id: string;
    module: string;
    eventType: string;
    channel: $Enums.NotificationChannel;
    name: string;
    description: string | null;
    titleTemplate: string;
    messageTemplate: string;
    detailsTemplate: string | null;
    isDefault: boolean;
    isActive: boolean;
    version: number;
    locale: string;
    variables: JsonValue | null;
    actions: JsonValue | null;
    createdAt: Date;
    updatedAt: Date;
    createdBy: string | null;
    _count: NotificationTemplateCountAggregateOutputType | null;
    _avg: NotificationTemplateAvgAggregateOutputType | null;
    _sum: NotificationTemplateSumAggregateOutputType | null;
    _min: NotificationTemplateMinAggregateOutputType | null;
    _max: NotificationTemplateMaxAggregateOutputType | null;
  };

  type GetNotificationTemplateGroupByPayload<T extends NotificationTemplateGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<NotificationTemplateGroupByOutputType, T['by']> & {
          [P in keyof T & keyof NotificationTemplateGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationTemplateGroupByOutputType[P]>;
        }
      >
    >;

  export type NotificationTemplateSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      module?: boolean;
      eventType?: boolean;
      channel?: boolean;
      name?: boolean;
      description?: boolean;
      titleTemplate?: boolean;
      messageTemplate?: boolean;
      detailsTemplate?: boolean;
      isDefault?: boolean;
      isActive?: boolean;
      version?: boolean;
      locale?: boolean;
      variables?: boolean;
      actions?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      createdBy?: boolean;
    },
    ExtArgs['result']['notificationTemplate']
  >;

  export type NotificationTemplateSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      module?: boolean;
      eventType?: boolean;
      channel?: boolean;
      name?: boolean;
      description?: boolean;
      titleTemplate?: boolean;
      messageTemplate?: boolean;
      detailsTemplate?: boolean;
      isDefault?: boolean;
      isActive?: boolean;
      version?: boolean;
      locale?: boolean;
      variables?: boolean;
      actions?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      createdBy?: boolean;
    },
    ExtArgs['result']['notificationTemplate']
  >;

  export type NotificationTemplateSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      module?: boolean;
      eventType?: boolean;
      channel?: boolean;
      name?: boolean;
      description?: boolean;
      titleTemplate?: boolean;
      messageTemplate?: boolean;
      detailsTemplate?: boolean;
      isDefault?: boolean;
      isActive?: boolean;
      version?: boolean;
      locale?: boolean;
      variables?: boolean;
      actions?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      createdBy?: boolean;
    },
    ExtArgs['result']['notificationTemplate']
  >;

  export type NotificationTemplateSelectScalar = {
    id?: boolean;
    module?: boolean;
    eventType?: boolean;
    channel?: boolean;
    name?: boolean;
    description?: boolean;
    titleTemplate?: boolean;
    messageTemplate?: boolean;
    detailsTemplate?: boolean;
    isDefault?: boolean;
    isActive?: boolean;
    version?: boolean;
    locale?: boolean;
    variables?: boolean;
    actions?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    createdBy?: boolean;
  };

  export type NotificationTemplateOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'module'
    | 'eventType'
    | 'channel'
    | 'name'
    | 'description'
    | 'titleTemplate'
    | 'messageTemplate'
    | 'detailsTemplate'
    | 'isDefault'
    | 'isActive'
    | 'version'
    | 'locale'
    | 'variables'
    | 'actions'
    | 'createdAt'
    | 'updatedAt'
    | 'createdBy',
    ExtArgs['result']['notificationTemplate']
  >;

  export type $NotificationTemplatePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'NotificationTemplate';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        module: string;
        eventType: string;
        channel: $Enums.NotificationChannel;
        name: string;
        description: string | null;
        titleTemplate: string;
        messageTemplate: string;
        detailsTemplate: string | null;
        isDefault: boolean;
        isActive: boolean;
        version: number;
        locale: string;
        variables: Prisma.JsonValue | null;
        actions: Prisma.JsonValue | null;
        createdAt: Date;
        updatedAt: Date;
        createdBy: string | null;
      },
      ExtArgs['result']['notificationTemplate']
    >;
    composites: {};
  };

  type NotificationTemplateGetPayload<
    S extends boolean | null | undefined | NotificationTemplateDefaultArgs,
  > = $Result.GetResult<Prisma.$NotificationTemplatePayload, S>;

  type NotificationTemplateCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<NotificationTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: NotificationTemplateCountAggregateInputType | true;
  };

  export interface NotificationTemplateDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['NotificationTemplate'];
      meta: { name: 'NotificationTemplate' };
    };
    /**
     * Find zero or one NotificationTemplate that matches the filter.
     * @param {NotificationTemplateFindUniqueArgs} args - Arguments to find a NotificationTemplate
     * @example
     * // Get one NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationTemplateFindUniqueArgs>(
      args: SelectSubset<T, NotificationTemplateFindUniqueArgs<ExtArgs>>,
    ): Prisma__NotificationTemplateClient<
      $Result.GetResult<
        Prisma.$NotificationTemplatePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one NotificationTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationTemplateFindUniqueOrThrowArgs} args - Arguments to find a NotificationTemplate
     * @example
     * // Get one NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationTemplateFindUniqueOrThrowArgs>(
      args: SelectSubset<T, NotificationTemplateFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__NotificationTemplateClient<
      $Result.GetResult<
        Prisma.$NotificationTemplatePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first NotificationTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateFindFirstArgs} args - Arguments to find a NotificationTemplate
     * @example
     * // Get one NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationTemplateFindFirstArgs>(
      args?: SelectSubset<T, NotificationTemplateFindFirstArgs<ExtArgs>>,
    ): Prisma__NotificationTemplateClient<
      $Result.GetResult<
        Prisma.$NotificationTemplatePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first NotificationTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateFindFirstOrThrowArgs} args - Arguments to find a NotificationTemplate
     * @example
     * // Get one NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationTemplateFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NotificationTemplateFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__NotificationTemplateClient<
      $Result.GetResult<
        Prisma.$NotificationTemplatePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more NotificationTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationTemplates
     * const notificationTemplates = await prisma.notificationTemplate.findMany()
     *
     * // Get first 10 NotificationTemplates
     * const notificationTemplates = await prisma.notificationTemplate.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const notificationTemplateWithIdOnly = await prisma.notificationTemplate.findMany({ select: { id: true } })
     *
     */
    findMany<T extends NotificationTemplateFindManyArgs>(
      args?: SelectSubset<T, NotificationTemplateFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationTemplatePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a NotificationTemplate.
     * @param {NotificationTemplateCreateArgs} args - Arguments to create a NotificationTemplate.
     * @example
     * // Create one NotificationTemplate
     * const NotificationTemplate = await prisma.notificationTemplate.create({
     *   data: {
     *     // ... data to create a NotificationTemplate
     *   }
     * })
     *
     */
    create<T extends NotificationTemplateCreateArgs>(
      args: SelectSubset<T, NotificationTemplateCreateArgs<ExtArgs>>,
    ): Prisma__NotificationTemplateClient<
      $Result.GetResult<
        Prisma.$NotificationTemplatePayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many NotificationTemplates.
     * @param {NotificationTemplateCreateManyArgs} args - Arguments to create many NotificationTemplates.
     * @example
     * // Create many NotificationTemplates
     * const notificationTemplate = await prisma.notificationTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends NotificationTemplateCreateManyArgs>(
      args?: SelectSubset<T, NotificationTemplateCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many NotificationTemplates and returns the data saved in the database.
     * @param {NotificationTemplateCreateManyAndReturnArgs} args - Arguments to create many NotificationTemplates.
     * @example
     * // Create many NotificationTemplates
     * const notificationTemplate = await prisma.notificationTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many NotificationTemplates and only return the `id`
     * const notificationTemplateWithIdOnly = await prisma.notificationTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends NotificationTemplateCreateManyAndReturnArgs>(
      args?: SelectSubset<T, NotificationTemplateCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationTemplatePayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a NotificationTemplate.
     * @param {NotificationTemplateDeleteArgs} args - Arguments to delete one NotificationTemplate.
     * @example
     * // Delete one NotificationTemplate
     * const NotificationTemplate = await prisma.notificationTemplate.delete({
     *   where: {
     *     // ... filter to delete one NotificationTemplate
     *   }
     * })
     *
     */
    delete<T extends NotificationTemplateDeleteArgs>(
      args: SelectSubset<T, NotificationTemplateDeleteArgs<ExtArgs>>,
    ): Prisma__NotificationTemplateClient<
      $Result.GetResult<
        Prisma.$NotificationTemplatePayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one NotificationTemplate.
     * @param {NotificationTemplateUpdateArgs} args - Arguments to update one NotificationTemplate.
     * @example
     * // Update one NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends NotificationTemplateUpdateArgs>(
      args: SelectSubset<T, NotificationTemplateUpdateArgs<ExtArgs>>,
    ): Prisma__NotificationTemplateClient<
      $Result.GetResult<
        Prisma.$NotificationTemplatePayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more NotificationTemplates.
     * @param {NotificationTemplateDeleteManyArgs} args - Arguments to filter NotificationTemplates to delete.
     * @example
     * // Delete a few NotificationTemplates
     * const { count } = await prisma.notificationTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends NotificationTemplateDeleteManyArgs>(
      args?: SelectSubset<T, NotificationTemplateDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more NotificationTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationTemplates
     * const notificationTemplate = await prisma.notificationTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends NotificationTemplateUpdateManyArgs>(
      args: SelectSubset<T, NotificationTemplateUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more NotificationTemplates and returns the data updated in the database.
     * @param {NotificationTemplateUpdateManyAndReturnArgs} args - Arguments to update many NotificationTemplates.
     * @example
     * // Update many NotificationTemplates
     * const notificationTemplate = await prisma.notificationTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more NotificationTemplates and only return the `id`
     * const notificationTemplateWithIdOnly = await prisma.notificationTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends NotificationTemplateUpdateManyAndReturnArgs>(
      args: SelectSubset<T, NotificationTemplateUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationTemplatePayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one NotificationTemplate.
     * @param {NotificationTemplateUpsertArgs} args - Arguments to update or create a NotificationTemplate.
     * @example
     * // Update or create a NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.upsert({
     *   create: {
     *     // ... data to create a NotificationTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationTemplate we want to update
     *   }
     * })
     */
    upsert<T extends NotificationTemplateUpsertArgs>(
      args: SelectSubset<T, NotificationTemplateUpsertArgs<ExtArgs>>,
    ): Prisma__NotificationTemplateClient<
      $Result.GetResult<
        Prisma.$NotificationTemplatePayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of NotificationTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateCountArgs} args - Arguments to filter NotificationTemplates to count.
     * @example
     * // Count the number of NotificationTemplates
     * const count = await prisma.notificationTemplate.count({
     *   where: {
     *     // ... the filter for the NotificationTemplates we want to count
     *   }
     * })
     **/
    count<T extends NotificationTemplateCountArgs>(
      args?: Subset<T, NotificationTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationTemplateCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a NotificationTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends NotificationTemplateAggregateArgs>(
      args: Subset<T, NotificationTemplateAggregateArgs>,
    ): Prisma.PrismaPromise<GetNotificationTemplateAggregateType<T>>;

    /**
     * Group by NotificationTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends NotificationTemplateGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationTemplateGroupByArgs['orderBy'] }
        : { orderBy?: NotificationTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, NotificationTemplateGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetNotificationTemplateGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the NotificationTemplate model
     */
    readonly fields: NotificationTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationTemplateClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the NotificationTemplate model
   */
  interface NotificationTemplateFieldRefs {
    readonly id: FieldRef<'NotificationTemplate', 'String'>;
    readonly module: FieldRef<'NotificationTemplate', 'String'>;
    readonly eventType: FieldRef<'NotificationTemplate', 'String'>;
    readonly channel: FieldRef<'NotificationTemplate', 'NotificationChannel'>;
    readonly name: FieldRef<'NotificationTemplate', 'String'>;
    readonly description: FieldRef<'NotificationTemplate', 'String'>;
    readonly titleTemplate: FieldRef<'NotificationTemplate', 'String'>;
    readonly messageTemplate: FieldRef<'NotificationTemplate', 'String'>;
    readonly detailsTemplate: FieldRef<'NotificationTemplate', 'String'>;
    readonly isDefault: FieldRef<'NotificationTemplate', 'Boolean'>;
    readonly isActive: FieldRef<'NotificationTemplate', 'Boolean'>;
    readonly version: FieldRef<'NotificationTemplate', 'Int'>;
    readonly locale: FieldRef<'NotificationTemplate', 'String'>;
    readonly variables: FieldRef<'NotificationTemplate', 'Json'>;
    readonly actions: FieldRef<'NotificationTemplate', 'Json'>;
    readonly createdAt: FieldRef<'NotificationTemplate', 'DateTime'>;
    readonly updatedAt: FieldRef<'NotificationTemplate', 'DateTime'>;
    readonly createdBy: FieldRef<'NotificationTemplate', 'String'>;
  }

  // Custom InputTypes
  /**
   * NotificationTemplate findUnique
   */
  export type NotificationTemplateFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null;
    /**
     * Filter, which NotificationTemplate to fetch.
     */
    where: NotificationTemplateWhereUniqueInput;
  };

  /**
   * NotificationTemplate findUniqueOrThrow
   */
  export type NotificationTemplateFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null;
    /**
     * Filter, which NotificationTemplate to fetch.
     */
    where: NotificationTemplateWhereUniqueInput;
  };

  /**
   * NotificationTemplate findFirst
   */
  export type NotificationTemplateFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null;
    /**
     * Filter, which NotificationTemplate to fetch.
     */
    where?: NotificationTemplateWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationTemplates to fetch.
     */
    orderBy?:
      | NotificationTemplateOrderByWithRelationInput
      | NotificationTemplateOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for NotificationTemplates.
     */
    cursor?: NotificationTemplateWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationTemplates from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationTemplates.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of NotificationTemplates.
     */
    distinct?: NotificationTemplateScalarFieldEnum | NotificationTemplateScalarFieldEnum[];
  };

  /**
   * NotificationTemplate findFirstOrThrow
   */
  export type NotificationTemplateFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null;
    /**
     * Filter, which NotificationTemplate to fetch.
     */
    where?: NotificationTemplateWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationTemplates to fetch.
     */
    orderBy?:
      | NotificationTemplateOrderByWithRelationInput
      | NotificationTemplateOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for NotificationTemplates.
     */
    cursor?: NotificationTemplateWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationTemplates from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationTemplates.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of NotificationTemplates.
     */
    distinct?: NotificationTemplateScalarFieldEnum | NotificationTemplateScalarFieldEnum[];
  };

  /**
   * NotificationTemplate findMany
   */
  export type NotificationTemplateFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null;
    /**
     * Filter, which NotificationTemplates to fetch.
     */
    where?: NotificationTemplateWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationTemplates to fetch.
     */
    orderBy?:
      | NotificationTemplateOrderByWithRelationInput
      | NotificationTemplateOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing NotificationTemplates.
     */
    cursor?: NotificationTemplateWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationTemplates from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationTemplates.
     */
    skip?: number;
    distinct?: NotificationTemplateScalarFieldEnum | NotificationTemplateScalarFieldEnum[];
  };

  /**
   * NotificationTemplate create
   */
  export type NotificationTemplateCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null;
    /**
     * The data needed to create a NotificationTemplate.
     */
    data: XOR<NotificationTemplateCreateInput, NotificationTemplateUncheckedCreateInput>;
  };

  /**
   * NotificationTemplate createMany
   */
  export type NotificationTemplateCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many NotificationTemplates.
     */
    data: NotificationTemplateCreateManyInput | NotificationTemplateCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * NotificationTemplate createManyAndReturn
   */
  export type NotificationTemplateCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null;
    /**
     * The data used to create many NotificationTemplates.
     */
    data: NotificationTemplateCreateManyInput | NotificationTemplateCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * NotificationTemplate update
   */
  export type NotificationTemplateUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null;
    /**
     * The data needed to update a NotificationTemplate.
     */
    data: XOR<NotificationTemplateUpdateInput, NotificationTemplateUncheckedUpdateInput>;
    /**
     * Choose, which NotificationTemplate to update.
     */
    where: NotificationTemplateWhereUniqueInput;
  };

  /**
   * NotificationTemplate updateMany
   */
  export type NotificationTemplateUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update NotificationTemplates.
     */
    data: XOR<
      NotificationTemplateUpdateManyMutationInput,
      NotificationTemplateUncheckedUpdateManyInput
    >;
    /**
     * Filter which NotificationTemplates to update
     */
    where?: NotificationTemplateWhereInput;
    /**
     * Limit how many NotificationTemplates to update.
     */
    limit?: number;
  };

  /**
   * NotificationTemplate updateManyAndReturn
   */
  export type NotificationTemplateUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null;
    /**
     * The data used to update NotificationTemplates.
     */
    data: XOR<
      NotificationTemplateUpdateManyMutationInput,
      NotificationTemplateUncheckedUpdateManyInput
    >;
    /**
     * Filter which NotificationTemplates to update
     */
    where?: NotificationTemplateWhereInput;
    /**
     * Limit how many NotificationTemplates to update.
     */
    limit?: number;
  };

  /**
   * NotificationTemplate upsert
   */
  export type NotificationTemplateUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null;
    /**
     * The filter to search for the NotificationTemplate to update in case it exists.
     */
    where: NotificationTemplateWhereUniqueInput;
    /**
     * In case the NotificationTemplate found by the `where` argument doesn't exist, create a new NotificationTemplate with this data.
     */
    create: XOR<NotificationTemplateCreateInput, NotificationTemplateUncheckedCreateInput>;
    /**
     * In case the NotificationTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationTemplateUpdateInput, NotificationTemplateUncheckedUpdateInput>;
  };

  /**
   * NotificationTemplate delete
   */
  export type NotificationTemplateDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null;
    /**
     * Filter which NotificationTemplate to delete.
     */
    where: NotificationTemplateWhereUniqueInput;
  };

  /**
   * NotificationTemplate deleteMany
   */
  export type NotificationTemplateDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which NotificationTemplates to delete
     */
    where?: NotificationTemplateWhereInput;
    /**
     * Limit how many NotificationTemplates to delete.
     */
    limit?: number;
  };

  /**
   * NotificationTemplate without action
   */
  export type NotificationTemplateDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null;
  };

  /**
   * Model NotificationProvider
   */

  export type AggregateNotificationProvider = {
    _count: NotificationProviderCountAggregateOutputType | null;
    _avg: NotificationProviderAvgAggregateOutputType | null;
    _sum: NotificationProviderSumAggregateOutputType | null;
    _min: NotificationProviderMinAggregateOutputType | null;
    _max: NotificationProviderMaxAggregateOutputType | null;
  };

  export type NotificationProviderAvgAggregateOutputType = {
    priority: number | null;
    rateLimitPerHour: number | null;
    rateLimitPerDay: number | null;
    errorCount: number | null;
  };

  export type NotificationProviderSumAggregateOutputType = {
    priority: number | null;
    rateLimitPerHour: number | null;
    rateLimitPerDay: number | null;
    errorCount: number | null;
  };

  export type NotificationProviderMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    type: $Enums.NotificationChannel | null;
    isActive: boolean | null;
    isDefault: boolean | null;
    priority: number | null;
    rateLimitPerHour: number | null;
    rateLimitPerDay: number | null;
    lastHealthCheck: Date | null;
    healthStatus: $Enums.ProviderHealth | null;
    errorCount: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    createdBy: string | null;
  };

  export type NotificationProviderMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    type: $Enums.NotificationChannel | null;
    isActive: boolean | null;
    isDefault: boolean | null;
    priority: number | null;
    rateLimitPerHour: number | null;
    rateLimitPerDay: number | null;
    lastHealthCheck: Date | null;
    healthStatus: $Enums.ProviderHealth | null;
    errorCount: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    createdBy: string | null;
  };

  export type NotificationProviderCountAggregateOutputType = {
    id: number;
    name: number;
    type: number;
    config: number;
    credentials: number;
    isActive: number;
    isDefault: number;
    priority: number;
    rateLimitPerHour: number;
    rateLimitPerDay: number;
    lastHealthCheck: number;
    healthStatus: number;
    errorCount: number;
    createdAt: number;
    updatedAt: number;
    createdBy: number;
    _all: number;
  };

  export type NotificationProviderAvgAggregateInputType = {
    priority?: true;
    rateLimitPerHour?: true;
    rateLimitPerDay?: true;
    errorCount?: true;
  };

  export type NotificationProviderSumAggregateInputType = {
    priority?: true;
    rateLimitPerHour?: true;
    rateLimitPerDay?: true;
    errorCount?: true;
  };

  export type NotificationProviderMinAggregateInputType = {
    id?: true;
    name?: true;
    type?: true;
    isActive?: true;
    isDefault?: true;
    priority?: true;
    rateLimitPerHour?: true;
    rateLimitPerDay?: true;
    lastHealthCheck?: true;
    healthStatus?: true;
    errorCount?: true;
    createdAt?: true;
    updatedAt?: true;
    createdBy?: true;
  };

  export type NotificationProviderMaxAggregateInputType = {
    id?: true;
    name?: true;
    type?: true;
    isActive?: true;
    isDefault?: true;
    priority?: true;
    rateLimitPerHour?: true;
    rateLimitPerDay?: true;
    lastHealthCheck?: true;
    healthStatus?: true;
    errorCount?: true;
    createdAt?: true;
    updatedAt?: true;
    createdBy?: true;
  };

  export type NotificationProviderCountAggregateInputType = {
    id?: true;
    name?: true;
    type?: true;
    config?: true;
    credentials?: true;
    isActive?: true;
    isDefault?: true;
    priority?: true;
    rateLimitPerHour?: true;
    rateLimitPerDay?: true;
    lastHealthCheck?: true;
    healthStatus?: true;
    errorCount?: true;
    createdAt?: true;
    updatedAt?: true;
    createdBy?: true;
    _all?: true;
  };

  export type NotificationProviderAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which NotificationProvider to aggregate.
     */
    where?: NotificationProviderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationProviders to fetch.
     */
    orderBy?:
      | NotificationProviderOrderByWithRelationInput
      | NotificationProviderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: NotificationProviderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationProviders from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationProviders.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned NotificationProviders
     **/
    _count?: true | NotificationProviderCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: NotificationProviderAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: NotificationProviderSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: NotificationProviderMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: NotificationProviderMaxAggregateInputType;
  };

  export type GetNotificationProviderAggregateType<T extends NotificationProviderAggregateArgs> = {
    [P in keyof T & keyof AggregateNotificationProvider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationProvider[P]>
      : GetScalarType<T[P], AggregateNotificationProvider[P]>;
  };

  export type NotificationProviderGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificationProviderWhereInput;
    orderBy?:
      | NotificationProviderOrderByWithAggregationInput
      | NotificationProviderOrderByWithAggregationInput[];
    by: NotificationProviderScalarFieldEnum[] | NotificationProviderScalarFieldEnum;
    having?: NotificationProviderScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: NotificationProviderCountAggregateInputType | true;
    _avg?: NotificationProviderAvgAggregateInputType;
    _sum?: NotificationProviderSumAggregateInputType;
    _min?: NotificationProviderMinAggregateInputType;
    _max?: NotificationProviderMaxAggregateInputType;
  };

  export type NotificationProviderGroupByOutputType = {
    id: string;
    name: string;
    type: $Enums.NotificationChannel;
    config: JsonValue;
    credentials: JsonValue | null;
    isActive: boolean;
    isDefault: boolean;
    priority: number;
    rateLimitPerHour: number | null;
    rateLimitPerDay: number | null;
    lastHealthCheck: Date | null;
    healthStatus: $Enums.ProviderHealth;
    errorCount: number;
    createdAt: Date;
    updatedAt: Date;
    createdBy: string | null;
    _count: NotificationProviderCountAggregateOutputType | null;
    _avg: NotificationProviderAvgAggregateOutputType | null;
    _sum: NotificationProviderSumAggregateOutputType | null;
    _min: NotificationProviderMinAggregateOutputType | null;
    _max: NotificationProviderMaxAggregateOutputType | null;
  };

  type GetNotificationProviderGroupByPayload<T extends NotificationProviderGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<NotificationProviderGroupByOutputType, T['by']> & {
          [P in keyof T & keyof NotificationProviderGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationProviderGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationProviderGroupByOutputType[P]>;
        }
      >
    >;

  export type NotificationProviderSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      type?: boolean;
      config?: boolean;
      credentials?: boolean;
      isActive?: boolean;
      isDefault?: boolean;
      priority?: boolean;
      rateLimitPerHour?: boolean;
      rateLimitPerDay?: boolean;
      lastHealthCheck?: boolean;
      healthStatus?: boolean;
      errorCount?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      createdBy?: boolean;
    },
    ExtArgs['result']['notificationProvider']
  >;

  export type NotificationProviderSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      type?: boolean;
      config?: boolean;
      credentials?: boolean;
      isActive?: boolean;
      isDefault?: boolean;
      priority?: boolean;
      rateLimitPerHour?: boolean;
      rateLimitPerDay?: boolean;
      lastHealthCheck?: boolean;
      healthStatus?: boolean;
      errorCount?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      createdBy?: boolean;
    },
    ExtArgs['result']['notificationProvider']
  >;

  export type NotificationProviderSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      type?: boolean;
      config?: boolean;
      credentials?: boolean;
      isActive?: boolean;
      isDefault?: boolean;
      priority?: boolean;
      rateLimitPerHour?: boolean;
      rateLimitPerDay?: boolean;
      lastHealthCheck?: boolean;
      healthStatus?: boolean;
      errorCount?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      createdBy?: boolean;
    },
    ExtArgs['result']['notificationProvider']
  >;

  export type NotificationProviderSelectScalar = {
    id?: boolean;
    name?: boolean;
    type?: boolean;
    config?: boolean;
    credentials?: boolean;
    isActive?: boolean;
    isDefault?: boolean;
    priority?: boolean;
    rateLimitPerHour?: boolean;
    rateLimitPerDay?: boolean;
    lastHealthCheck?: boolean;
    healthStatus?: boolean;
    errorCount?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    createdBy?: boolean;
  };

  export type NotificationProviderOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'name'
    | 'type'
    | 'config'
    | 'credentials'
    | 'isActive'
    | 'isDefault'
    | 'priority'
    | 'rateLimitPerHour'
    | 'rateLimitPerDay'
    | 'lastHealthCheck'
    | 'healthStatus'
    | 'errorCount'
    | 'createdAt'
    | 'updatedAt'
    | 'createdBy',
    ExtArgs['result']['notificationProvider']
  >;

  export type $NotificationProviderPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'NotificationProvider';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        type: $Enums.NotificationChannel;
        config: Prisma.JsonValue;
        credentials: Prisma.JsonValue | null;
        isActive: boolean;
        isDefault: boolean;
        priority: number;
        rateLimitPerHour: number | null;
        rateLimitPerDay: number | null;
        lastHealthCheck: Date | null;
        healthStatus: $Enums.ProviderHealth;
        errorCount: number;
        createdAt: Date;
        updatedAt: Date;
        createdBy: string | null;
      },
      ExtArgs['result']['notificationProvider']
    >;
    composites: {};
  };

  type NotificationProviderGetPayload<
    S extends boolean | null | undefined | NotificationProviderDefaultArgs,
  > = $Result.GetResult<Prisma.$NotificationProviderPayload, S>;

  type NotificationProviderCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<NotificationProviderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: NotificationProviderCountAggregateInputType | true;
  };

  export interface NotificationProviderDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['NotificationProvider'];
      meta: { name: 'NotificationProvider' };
    };
    /**
     * Find zero or one NotificationProvider that matches the filter.
     * @param {NotificationProviderFindUniqueArgs} args - Arguments to find a NotificationProvider
     * @example
     * // Get one NotificationProvider
     * const notificationProvider = await prisma.notificationProvider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationProviderFindUniqueArgs>(
      args: SelectSubset<T, NotificationProviderFindUniqueArgs<ExtArgs>>,
    ): Prisma__NotificationProviderClient<
      $Result.GetResult<
        Prisma.$NotificationProviderPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one NotificationProvider that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationProviderFindUniqueOrThrowArgs} args - Arguments to find a NotificationProvider
     * @example
     * // Get one NotificationProvider
     * const notificationProvider = await prisma.notificationProvider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationProviderFindUniqueOrThrowArgs>(
      args: SelectSubset<T, NotificationProviderFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__NotificationProviderClient<
      $Result.GetResult<
        Prisma.$NotificationProviderPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first NotificationProvider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationProviderFindFirstArgs} args - Arguments to find a NotificationProvider
     * @example
     * // Get one NotificationProvider
     * const notificationProvider = await prisma.notificationProvider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationProviderFindFirstArgs>(
      args?: SelectSubset<T, NotificationProviderFindFirstArgs<ExtArgs>>,
    ): Prisma__NotificationProviderClient<
      $Result.GetResult<
        Prisma.$NotificationProviderPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first NotificationProvider that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationProviderFindFirstOrThrowArgs} args - Arguments to find a NotificationProvider
     * @example
     * // Get one NotificationProvider
     * const notificationProvider = await prisma.notificationProvider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationProviderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NotificationProviderFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__NotificationProviderClient<
      $Result.GetResult<
        Prisma.$NotificationProviderPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more NotificationProviders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationProviderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationProviders
     * const notificationProviders = await prisma.notificationProvider.findMany()
     *
     * // Get first 10 NotificationProviders
     * const notificationProviders = await prisma.notificationProvider.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const notificationProviderWithIdOnly = await prisma.notificationProvider.findMany({ select: { id: true } })
     *
     */
    findMany<T extends NotificationProviderFindManyArgs>(
      args?: SelectSubset<T, NotificationProviderFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationProviderPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a NotificationProvider.
     * @param {NotificationProviderCreateArgs} args - Arguments to create a NotificationProvider.
     * @example
     * // Create one NotificationProvider
     * const NotificationProvider = await prisma.notificationProvider.create({
     *   data: {
     *     // ... data to create a NotificationProvider
     *   }
     * })
     *
     */
    create<T extends NotificationProviderCreateArgs>(
      args: SelectSubset<T, NotificationProviderCreateArgs<ExtArgs>>,
    ): Prisma__NotificationProviderClient<
      $Result.GetResult<
        Prisma.$NotificationProviderPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many NotificationProviders.
     * @param {NotificationProviderCreateManyArgs} args - Arguments to create many NotificationProviders.
     * @example
     * // Create many NotificationProviders
     * const notificationProvider = await prisma.notificationProvider.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends NotificationProviderCreateManyArgs>(
      args?: SelectSubset<T, NotificationProviderCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many NotificationProviders and returns the data saved in the database.
     * @param {NotificationProviderCreateManyAndReturnArgs} args - Arguments to create many NotificationProviders.
     * @example
     * // Create many NotificationProviders
     * const notificationProvider = await prisma.notificationProvider.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many NotificationProviders and only return the `id`
     * const notificationProviderWithIdOnly = await prisma.notificationProvider.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends NotificationProviderCreateManyAndReturnArgs>(
      args?: SelectSubset<T, NotificationProviderCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationProviderPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a NotificationProvider.
     * @param {NotificationProviderDeleteArgs} args - Arguments to delete one NotificationProvider.
     * @example
     * // Delete one NotificationProvider
     * const NotificationProvider = await prisma.notificationProvider.delete({
     *   where: {
     *     // ... filter to delete one NotificationProvider
     *   }
     * })
     *
     */
    delete<T extends NotificationProviderDeleteArgs>(
      args: SelectSubset<T, NotificationProviderDeleteArgs<ExtArgs>>,
    ): Prisma__NotificationProviderClient<
      $Result.GetResult<
        Prisma.$NotificationProviderPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one NotificationProvider.
     * @param {NotificationProviderUpdateArgs} args - Arguments to update one NotificationProvider.
     * @example
     * // Update one NotificationProvider
     * const notificationProvider = await prisma.notificationProvider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends NotificationProviderUpdateArgs>(
      args: SelectSubset<T, NotificationProviderUpdateArgs<ExtArgs>>,
    ): Prisma__NotificationProviderClient<
      $Result.GetResult<
        Prisma.$NotificationProviderPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more NotificationProviders.
     * @param {NotificationProviderDeleteManyArgs} args - Arguments to filter NotificationProviders to delete.
     * @example
     * // Delete a few NotificationProviders
     * const { count } = await prisma.notificationProvider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends NotificationProviderDeleteManyArgs>(
      args?: SelectSubset<T, NotificationProviderDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more NotificationProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationProviderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationProviders
     * const notificationProvider = await prisma.notificationProvider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends NotificationProviderUpdateManyArgs>(
      args: SelectSubset<T, NotificationProviderUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more NotificationProviders and returns the data updated in the database.
     * @param {NotificationProviderUpdateManyAndReturnArgs} args - Arguments to update many NotificationProviders.
     * @example
     * // Update many NotificationProviders
     * const notificationProvider = await prisma.notificationProvider.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more NotificationProviders and only return the `id`
     * const notificationProviderWithIdOnly = await prisma.notificationProvider.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends NotificationProviderUpdateManyAndReturnArgs>(
      args: SelectSubset<T, NotificationProviderUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationProviderPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one NotificationProvider.
     * @param {NotificationProviderUpsertArgs} args - Arguments to update or create a NotificationProvider.
     * @example
     * // Update or create a NotificationProvider
     * const notificationProvider = await prisma.notificationProvider.upsert({
     *   create: {
     *     // ... data to create a NotificationProvider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationProvider we want to update
     *   }
     * })
     */
    upsert<T extends NotificationProviderUpsertArgs>(
      args: SelectSubset<T, NotificationProviderUpsertArgs<ExtArgs>>,
    ): Prisma__NotificationProviderClient<
      $Result.GetResult<
        Prisma.$NotificationProviderPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of NotificationProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationProviderCountArgs} args - Arguments to filter NotificationProviders to count.
     * @example
     * // Count the number of NotificationProviders
     * const count = await prisma.notificationProvider.count({
     *   where: {
     *     // ... the filter for the NotificationProviders we want to count
     *   }
     * })
     **/
    count<T extends NotificationProviderCountArgs>(
      args?: Subset<T, NotificationProviderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationProviderCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a NotificationProvider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationProviderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends NotificationProviderAggregateArgs>(
      args: Subset<T, NotificationProviderAggregateArgs>,
    ): Prisma.PrismaPromise<GetNotificationProviderAggregateType<T>>;

    /**
     * Group by NotificationProvider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationProviderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends NotificationProviderGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationProviderGroupByArgs['orderBy'] }
        : { orderBy?: NotificationProviderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, NotificationProviderGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetNotificationProviderGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the NotificationProvider model
     */
    readonly fields: NotificationProviderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationProvider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationProviderClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the NotificationProvider model
   */
  interface NotificationProviderFieldRefs {
    readonly id: FieldRef<'NotificationProvider', 'String'>;
    readonly name: FieldRef<'NotificationProvider', 'String'>;
    readonly type: FieldRef<'NotificationProvider', 'NotificationChannel'>;
    readonly config: FieldRef<'NotificationProvider', 'Json'>;
    readonly credentials: FieldRef<'NotificationProvider', 'Json'>;
    readonly isActive: FieldRef<'NotificationProvider', 'Boolean'>;
    readonly isDefault: FieldRef<'NotificationProvider', 'Boolean'>;
    readonly priority: FieldRef<'NotificationProvider', 'Int'>;
    readonly rateLimitPerHour: FieldRef<'NotificationProvider', 'Int'>;
    readonly rateLimitPerDay: FieldRef<'NotificationProvider', 'Int'>;
    readonly lastHealthCheck: FieldRef<'NotificationProvider', 'DateTime'>;
    readonly healthStatus: FieldRef<'NotificationProvider', 'ProviderHealth'>;
    readonly errorCount: FieldRef<'NotificationProvider', 'Int'>;
    readonly createdAt: FieldRef<'NotificationProvider', 'DateTime'>;
    readonly updatedAt: FieldRef<'NotificationProvider', 'DateTime'>;
    readonly createdBy: FieldRef<'NotificationProvider', 'String'>;
  }

  // Custom InputTypes
  /**
   * NotificationProvider findUnique
   */
  export type NotificationProviderFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationProvider
     */
    select?: NotificationProviderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationProvider
     */
    omit?: NotificationProviderOmit<ExtArgs> | null;
    /**
     * Filter, which NotificationProvider to fetch.
     */
    where: NotificationProviderWhereUniqueInput;
  };

  /**
   * NotificationProvider findUniqueOrThrow
   */
  export type NotificationProviderFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationProvider
     */
    select?: NotificationProviderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationProvider
     */
    omit?: NotificationProviderOmit<ExtArgs> | null;
    /**
     * Filter, which NotificationProvider to fetch.
     */
    where: NotificationProviderWhereUniqueInput;
  };

  /**
   * NotificationProvider findFirst
   */
  export type NotificationProviderFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationProvider
     */
    select?: NotificationProviderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationProvider
     */
    omit?: NotificationProviderOmit<ExtArgs> | null;
    /**
     * Filter, which NotificationProvider to fetch.
     */
    where?: NotificationProviderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationProviders to fetch.
     */
    orderBy?:
      | NotificationProviderOrderByWithRelationInput
      | NotificationProviderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for NotificationProviders.
     */
    cursor?: NotificationProviderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationProviders from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationProviders.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of NotificationProviders.
     */
    distinct?: NotificationProviderScalarFieldEnum | NotificationProviderScalarFieldEnum[];
  };

  /**
   * NotificationProvider findFirstOrThrow
   */
  export type NotificationProviderFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationProvider
     */
    select?: NotificationProviderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationProvider
     */
    omit?: NotificationProviderOmit<ExtArgs> | null;
    /**
     * Filter, which NotificationProvider to fetch.
     */
    where?: NotificationProviderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationProviders to fetch.
     */
    orderBy?:
      | NotificationProviderOrderByWithRelationInput
      | NotificationProviderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for NotificationProviders.
     */
    cursor?: NotificationProviderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationProviders from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationProviders.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of NotificationProviders.
     */
    distinct?: NotificationProviderScalarFieldEnum | NotificationProviderScalarFieldEnum[];
  };

  /**
   * NotificationProvider findMany
   */
  export type NotificationProviderFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationProvider
     */
    select?: NotificationProviderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationProvider
     */
    omit?: NotificationProviderOmit<ExtArgs> | null;
    /**
     * Filter, which NotificationProviders to fetch.
     */
    where?: NotificationProviderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationProviders to fetch.
     */
    orderBy?:
      | NotificationProviderOrderByWithRelationInput
      | NotificationProviderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing NotificationProviders.
     */
    cursor?: NotificationProviderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationProviders from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationProviders.
     */
    skip?: number;
    distinct?: NotificationProviderScalarFieldEnum | NotificationProviderScalarFieldEnum[];
  };

  /**
   * NotificationProvider create
   */
  export type NotificationProviderCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationProvider
     */
    select?: NotificationProviderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationProvider
     */
    omit?: NotificationProviderOmit<ExtArgs> | null;
    /**
     * The data needed to create a NotificationProvider.
     */
    data: XOR<NotificationProviderCreateInput, NotificationProviderUncheckedCreateInput>;
  };

  /**
   * NotificationProvider createMany
   */
  export type NotificationProviderCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many NotificationProviders.
     */
    data: NotificationProviderCreateManyInput | NotificationProviderCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * NotificationProvider createManyAndReturn
   */
  export type NotificationProviderCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationProvider
     */
    select?: NotificationProviderSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationProvider
     */
    omit?: NotificationProviderOmit<ExtArgs> | null;
    /**
     * The data used to create many NotificationProviders.
     */
    data: NotificationProviderCreateManyInput | NotificationProviderCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * NotificationProvider update
   */
  export type NotificationProviderUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationProvider
     */
    select?: NotificationProviderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationProvider
     */
    omit?: NotificationProviderOmit<ExtArgs> | null;
    /**
     * The data needed to update a NotificationProvider.
     */
    data: XOR<NotificationProviderUpdateInput, NotificationProviderUncheckedUpdateInput>;
    /**
     * Choose, which NotificationProvider to update.
     */
    where: NotificationProviderWhereUniqueInput;
  };

  /**
   * NotificationProvider updateMany
   */
  export type NotificationProviderUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update NotificationProviders.
     */
    data: XOR<
      NotificationProviderUpdateManyMutationInput,
      NotificationProviderUncheckedUpdateManyInput
    >;
    /**
     * Filter which NotificationProviders to update
     */
    where?: NotificationProviderWhereInput;
    /**
     * Limit how many NotificationProviders to update.
     */
    limit?: number;
  };

  /**
   * NotificationProvider updateManyAndReturn
   */
  export type NotificationProviderUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationProvider
     */
    select?: NotificationProviderSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationProvider
     */
    omit?: NotificationProviderOmit<ExtArgs> | null;
    /**
     * The data used to update NotificationProviders.
     */
    data: XOR<
      NotificationProviderUpdateManyMutationInput,
      NotificationProviderUncheckedUpdateManyInput
    >;
    /**
     * Filter which NotificationProviders to update
     */
    where?: NotificationProviderWhereInput;
    /**
     * Limit how many NotificationProviders to update.
     */
    limit?: number;
  };

  /**
   * NotificationProvider upsert
   */
  export type NotificationProviderUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationProvider
     */
    select?: NotificationProviderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationProvider
     */
    omit?: NotificationProviderOmit<ExtArgs> | null;
    /**
     * The filter to search for the NotificationProvider to update in case it exists.
     */
    where: NotificationProviderWhereUniqueInput;
    /**
     * In case the NotificationProvider found by the `where` argument doesn't exist, create a new NotificationProvider with this data.
     */
    create: XOR<NotificationProviderCreateInput, NotificationProviderUncheckedCreateInput>;
    /**
     * In case the NotificationProvider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationProviderUpdateInput, NotificationProviderUncheckedUpdateInput>;
  };

  /**
   * NotificationProvider delete
   */
  export type NotificationProviderDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationProvider
     */
    select?: NotificationProviderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationProvider
     */
    omit?: NotificationProviderOmit<ExtArgs> | null;
    /**
     * Filter which NotificationProvider to delete.
     */
    where: NotificationProviderWhereUniqueInput;
  };

  /**
   * NotificationProvider deleteMany
   */
  export type NotificationProviderDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which NotificationProviders to delete
     */
    where?: NotificationProviderWhereInput;
    /**
     * Limit how many NotificationProviders to delete.
     */
    limit?: number;
  };

  /**
   * NotificationProvider without action
   */
  export type NotificationProviderDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationProvider
     */
    select?: NotificationProviderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationProvider
     */
    omit?: NotificationProviderOmit<ExtArgs> | null;
  };

  /**
   * Model HelixUserNotificationProfile
   */

  export type AggregateHelixUserNotificationProfile = {
    _count: HelixUserNotificationProfileCountAggregateOutputType | null;
    _min: HelixUserNotificationProfileMinAggregateOutputType | null;
    _max: HelixUserNotificationProfileMaxAggregateOutputType | null;
  };

  export type HelixUserNotificationProfileMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    globalEnabled: boolean | null;
    timezone: string | null;
    digestEnabled: boolean | null;
    digestFrequency: $Enums.DigestFrequency | null;
    digestTime: string | null;
    dndEnabled: boolean | null;
    dndStartTime: string | null;
    dndEndTime: string | null;
    goalertEnabled: boolean | null;
    pagerEnabled: boolean | null;
    synthEnabled: boolean | null;
    aiDigestEnabled: boolean | null;
    aiGroupingLevel: $Enums.AiGroupingLevel | null;
    muteRepetitive: boolean | null;
    sentinelEnabled: boolean | null;
    complianceEvents: boolean | null;
    pushEnabled: boolean | null;
    phoneNumber: string | null;
    slackUserId: string | null;
    teamsUserId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type HelixUserNotificationProfileMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    globalEnabled: boolean | null;
    timezone: string | null;
    digestEnabled: boolean | null;
    digestFrequency: $Enums.DigestFrequency | null;
    digestTime: string | null;
    dndEnabled: boolean | null;
    dndStartTime: string | null;
    dndEndTime: string | null;
    goalertEnabled: boolean | null;
    pagerEnabled: boolean | null;
    synthEnabled: boolean | null;
    aiDigestEnabled: boolean | null;
    aiGroupingLevel: $Enums.AiGroupingLevel | null;
    muteRepetitive: boolean | null;
    sentinelEnabled: boolean | null;
    complianceEvents: boolean | null;
    pushEnabled: boolean | null;
    phoneNumber: string | null;
    slackUserId: string | null;
    teamsUserId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type HelixUserNotificationProfileCountAggregateOutputType = {
    id: number;
    userId: number;
    globalEnabled: number;
    defaultChannels: number;
    timezone: number;
    digestEnabled: number;
    digestFrequency: number;
    digestTime: number;
    dndEnabled: number;
    dndStartTime: number;
    dndEndTime: number;
    dndDays: number;
    goalertEnabled: number;
    goalertSchedules: number;
    goalertPolicies: number;
    pagerEnabled: number;
    synthEnabled: number;
    aiDigestEnabled: number;
    aiGroupingLevel: number;
    muteRepetitive: number;
    sentinelEnabled: number;
    securityEvents: number;
    complianceEvents: number;
    deviceTokens: number;
    pushEnabled: number;
    phoneNumber: number;
    slackUserId: number;
    teamsUserId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type HelixUserNotificationProfileMinAggregateInputType = {
    id?: true;
    userId?: true;
    globalEnabled?: true;
    timezone?: true;
    digestEnabled?: true;
    digestFrequency?: true;
    digestTime?: true;
    dndEnabled?: true;
    dndStartTime?: true;
    dndEndTime?: true;
    goalertEnabled?: true;
    pagerEnabled?: true;
    synthEnabled?: true;
    aiDigestEnabled?: true;
    aiGroupingLevel?: true;
    muteRepetitive?: true;
    sentinelEnabled?: true;
    complianceEvents?: true;
    pushEnabled?: true;
    phoneNumber?: true;
    slackUserId?: true;
    teamsUserId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type HelixUserNotificationProfileMaxAggregateInputType = {
    id?: true;
    userId?: true;
    globalEnabled?: true;
    timezone?: true;
    digestEnabled?: true;
    digestFrequency?: true;
    digestTime?: true;
    dndEnabled?: true;
    dndStartTime?: true;
    dndEndTime?: true;
    goalertEnabled?: true;
    pagerEnabled?: true;
    synthEnabled?: true;
    aiDigestEnabled?: true;
    aiGroupingLevel?: true;
    muteRepetitive?: true;
    sentinelEnabled?: true;
    complianceEvents?: true;
    pushEnabled?: true;
    phoneNumber?: true;
    slackUserId?: true;
    teamsUserId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type HelixUserNotificationProfileCountAggregateInputType = {
    id?: true;
    userId?: true;
    globalEnabled?: true;
    defaultChannels?: true;
    timezone?: true;
    digestEnabled?: true;
    digestFrequency?: true;
    digestTime?: true;
    dndEnabled?: true;
    dndStartTime?: true;
    dndEndTime?: true;
    dndDays?: true;
    goalertEnabled?: true;
    goalertSchedules?: true;
    goalertPolicies?: true;
    pagerEnabled?: true;
    synthEnabled?: true;
    aiDigestEnabled?: true;
    aiGroupingLevel?: true;
    muteRepetitive?: true;
    sentinelEnabled?: true;
    securityEvents?: true;
    complianceEvents?: true;
    deviceTokens?: true;
    pushEnabled?: true;
    phoneNumber?: true;
    slackUserId?: true;
    teamsUserId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type HelixUserNotificationProfileAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which HelixUserNotificationProfile to aggregate.
     */
    where?: HelixUserNotificationProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of HelixUserNotificationProfiles to fetch.
     */
    orderBy?:
      | HelixUserNotificationProfileOrderByWithRelationInput
      | HelixUserNotificationProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: HelixUserNotificationProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` HelixUserNotificationProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` HelixUserNotificationProfiles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned HelixUserNotificationProfiles
     **/
    _count?: true | HelixUserNotificationProfileCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: HelixUserNotificationProfileMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: HelixUserNotificationProfileMaxAggregateInputType;
  };

  export type GetHelixUserNotificationProfileAggregateType<
    T extends HelixUserNotificationProfileAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateHelixUserNotificationProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHelixUserNotificationProfile[P]>
      : GetScalarType<T[P], AggregateHelixUserNotificationProfile[P]>;
  };

  export type HelixUserNotificationProfileGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: HelixUserNotificationProfileWhereInput;
    orderBy?:
      | HelixUserNotificationProfileOrderByWithAggregationInput
      | HelixUserNotificationProfileOrderByWithAggregationInput[];
    by: HelixUserNotificationProfileScalarFieldEnum[] | HelixUserNotificationProfileScalarFieldEnum;
    having?: HelixUserNotificationProfileScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: HelixUserNotificationProfileCountAggregateInputType | true;
    _min?: HelixUserNotificationProfileMinAggregateInputType;
    _max?: HelixUserNotificationProfileMaxAggregateInputType;
  };

  export type HelixUserNotificationProfileGroupByOutputType = {
    id: string;
    userId: string;
    globalEnabled: boolean;
    defaultChannels: $Enums.NotificationChannel[];
    timezone: string;
    digestEnabled: boolean;
    digestFrequency: $Enums.DigestFrequency;
    digestTime: string;
    dndEnabled: boolean;
    dndStartTime: string | null;
    dndEndTime: string | null;
    dndDays: string[];
    goalertEnabled: boolean;
    goalertSchedules: string[];
    goalertPolicies: string[];
    pagerEnabled: boolean;
    synthEnabled: boolean;
    aiDigestEnabled: boolean;
    aiGroupingLevel: $Enums.AiGroupingLevel;
    muteRepetitive: boolean;
    sentinelEnabled: boolean;
    securityEvents: string[];
    complianceEvents: boolean;
    deviceTokens: JsonValue | null;
    pushEnabled: boolean;
    phoneNumber: string | null;
    slackUserId: string | null;
    teamsUserId: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: HelixUserNotificationProfileCountAggregateOutputType | null;
    _min: HelixUserNotificationProfileMinAggregateOutputType | null;
    _max: HelixUserNotificationProfileMaxAggregateOutputType | null;
  };

  type GetHelixUserNotificationProfileGroupByPayload<
    T extends HelixUserNotificationProfileGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HelixUserNotificationProfileGroupByOutputType, T['by']> & {
        [P in keyof T & keyof HelixUserNotificationProfileGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], HelixUserNotificationProfileGroupByOutputType[P]>
          : GetScalarType<T[P], HelixUserNotificationProfileGroupByOutputType[P]>;
      }
    >
  >;

  export type HelixUserNotificationProfileSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      globalEnabled?: boolean;
      defaultChannels?: boolean;
      timezone?: boolean;
      digestEnabled?: boolean;
      digestFrequency?: boolean;
      digestTime?: boolean;
      dndEnabled?: boolean;
      dndStartTime?: boolean;
      dndEndTime?: boolean;
      dndDays?: boolean;
      goalertEnabled?: boolean;
      goalertSchedules?: boolean;
      goalertPolicies?: boolean;
      pagerEnabled?: boolean;
      synthEnabled?: boolean;
      aiDigestEnabled?: boolean;
      aiGroupingLevel?: boolean;
      muteRepetitive?: boolean;
      sentinelEnabled?: boolean;
      securityEvents?: boolean;
      complianceEvents?: boolean;
      deviceTokens?: boolean;
      pushEnabled?: boolean;
      phoneNumber?: boolean;
      slackUserId?: boolean;
      teamsUserId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      preferences?: boolean | HelixUserNotificationProfile$preferencesArgs<ExtArgs>;
      _count?: boolean | HelixUserNotificationProfileCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['helixUserNotificationProfile']
  >;

  export type HelixUserNotificationProfileSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      globalEnabled?: boolean;
      defaultChannels?: boolean;
      timezone?: boolean;
      digestEnabled?: boolean;
      digestFrequency?: boolean;
      digestTime?: boolean;
      dndEnabled?: boolean;
      dndStartTime?: boolean;
      dndEndTime?: boolean;
      dndDays?: boolean;
      goalertEnabled?: boolean;
      goalertSchedules?: boolean;
      goalertPolicies?: boolean;
      pagerEnabled?: boolean;
      synthEnabled?: boolean;
      aiDigestEnabled?: boolean;
      aiGroupingLevel?: boolean;
      muteRepetitive?: boolean;
      sentinelEnabled?: boolean;
      securityEvents?: boolean;
      complianceEvents?: boolean;
      deviceTokens?: boolean;
      pushEnabled?: boolean;
      phoneNumber?: boolean;
      slackUserId?: boolean;
      teamsUserId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['helixUserNotificationProfile']
  >;

  export type HelixUserNotificationProfileSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      globalEnabled?: boolean;
      defaultChannels?: boolean;
      timezone?: boolean;
      digestEnabled?: boolean;
      digestFrequency?: boolean;
      digestTime?: boolean;
      dndEnabled?: boolean;
      dndStartTime?: boolean;
      dndEndTime?: boolean;
      dndDays?: boolean;
      goalertEnabled?: boolean;
      goalertSchedules?: boolean;
      goalertPolicies?: boolean;
      pagerEnabled?: boolean;
      synthEnabled?: boolean;
      aiDigestEnabled?: boolean;
      aiGroupingLevel?: boolean;
      muteRepetitive?: boolean;
      sentinelEnabled?: boolean;
      securityEvents?: boolean;
      complianceEvents?: boolean;
      deviceTokens?: boolean;
      pushEnabled?: boolean;
      phoneNumber?: boolean;
      slackUserId?: boolean;
      teamsUserId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['helixUserNotificationProfile']
  >;

  export type HelixUserNotificationProfileSelectScalar = {
    id?: boolean;
    userId?: boolean;
    globalEnabled?: boolean;
    defaultChannels?: boolean;
    timezone?: boolean;
    digestEnabled?: boolean;
    digestFrequency?: boolean;
    digestTime?: boolean;
    dndEnabled?: boolean;
    dndStartTime?: boolean;
    dndEndTime?: boolean;
    dndDays?: boolean;
    goalertEnabled?: boolean;
    goalertSchedules?: boolean;
    goalertPolicies?: boolean;
    pagerEnabled?: boolean;
    synthEnabled?: boolean;
    aiDigestEnabled?: boolean;
    aiGroupingLevel?: boolean;
    muteRepetitive?: boolean;
    sentinelEnabled?: boolean;
    securityEvents?: boolean;
    complianceEvents?: boolean;
    deviceTokens?: boolean;
    pushEnabled?: boolean;
    phoneNumber?: boolean;
    slackUserId?: boolean;
    teamsUserId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type HelixUserNotificationProfileOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'userId'
    | 'globalEnabled'
    | 'defaultChannels'
    | 'timezone'
    | 'digestEnabled'
    | 'digestFrequency'
    | 'digestTime'
    | 'dndEnabled'
    | 'dndStartTime'
    | 'dndEndTime'
    | 'dndDays'
    | 'goalertEnabled'
    | 'goalertSchedules'
    | 'goalertPolicies'
    | 'pagerEnabled'
    | 'synthEnabled'
    | 'aiDigestEnabled'
    | 'aiGroupingLevel'
    | 'muteRepetitive'
    | 'sentinelEnabled'
    | 'securityEvents'
    | 'complianceEvents'
    | 'deviceTokens'
    | 'pushEnabled'
    | 'phoneNumber'
    | 'slackUserId'
    | 'teamsUserId'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['helixUserNotificationProfile']
  >;
  export type HelixUserNotificationProfileInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    preferences?: boolean | HelixUserNotificationProfile$preferencesArgs<ExtArgs>;
    _count?: boolean | HelixUserNotificationProfileCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type HelixUserNotificationProfileIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type HelixUserNotificationProfileIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $HelixUserNotificationProfilePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'HelixUserNotificationProfile';
    objects: {
      preferences: Prisma.$NotificationPreferencePayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        globalEnabled: boolean;
        defaultChannels: $Enums.NotificationChannel[];
        timezone: string;
        digestEnabled: boolean;
        digestFrequency: $Enums.DigestFrequency;
        digestTime: string;
        dndEnabled: boolean;
        dndStartTime: string | null;
        dndEndTime: string | null;
        dndDays: string[];
        goalertEnabled: boolean;
        goalertSchedules: string[];
        goalertPolicies: string[];
        pagerEnabled: boolean;
        synthEnabled: boolean;
        aiDigestEnabled: boolean;
        aiGroupingLevel: $Enums.AiGroupingLevel;
        muteRepetitive: boolean;
        sentinelEnabled: boolean;
        securityEvents: string[];
        complianceEvents: boolean;
        deviceTokens: Prisma.JsonValue | null;
        pushEnabled: boolean;
        phoneNumber: string | null;
        slackUserId: string | null;
        teamsUserId: string | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['helixUserNotificationProfile']
    >;
    composites: {};
  };

  type HelixUserNotificationProfileGetPayload<
    S extends boolean | null | undefined | HelixUserNotificationProfileDefaultArgs,
  > = $Result.GetResult<Prisma.$HelixUserNotificationProfilePayload, S>;

  type HelixUserNotificationProfileCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<HelixUserNotificationProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: HelixUserNotificationProfileCountAggregateInputType | true;
  };

  export interface HelixUserNotificationProfileDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['HelixUserNotificationProfile'];
      meta: { name: 'HelixUserNotificationProfile' };
    };
    /**
     * Find zero or one HelixUserNotificationProfile that matches the filter.
     * @param {HelixUserNotificationProfileFindUniqueArgs} args - Arguments to find a HelixUserNotificationProfile
     * @example
     * // Get one HelixUserNotificationProfile
     * const helixUserNotificationProfile = await prisma.helixUserNotificationProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HelixUserNotificationProfileFindUniqueArgs>(
      args: SelectSubset<T, HelixUserNotificationProfileFindUniqueArgs<ExtArgs>>,
    ): Prisma__HelixUserNotificationProfileClient<
      $Result.GetResult<
        Prisma.$HelixUserNotificationProfilePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one HelixUserNotificationProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HelixUserNotificationProfileFindUniqueOrThrowArgs} args - Arguments to find a HelixUserNotificationProfile
     * @example
     * // Get one HelixUserNotificationProfile
     * const helixUserNotificationProfile = await prisma.helixUserNotificationProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HelixUserNotificationProfileFindUniqueOrThrowArgs>(
      args: SelectSubset<T, HelixUserNotificationProfileFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__HelixUserNotificationProfileClient<
      $Result.GetResult<
        Prisma.$HelixUserNotificationProfilePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first HelixUserNotificationProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelixUserNotificationProfileFindFirstArgs} args - Arguments to find a HelixUserNotificationProfile
     * @example
     * // Get one HelixUserNotificationProfile
     * const helixUserNotificationProfile = await prisma.helixUserNotificationProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HelixUserNotificationProfileFindFirstArgs>(
      args?: SelectSubset<T, HelixUserNotificationProfileFindFirstArgs<ExtArgs>>,
    ): Prisma__HelixUserNotificationProfileClient<
      $Result.GetResult<
        Prisma.$HelixUserNotificationProfilePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first HelixUserNotificationProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelixUserNotificationProfileFindFirstOrThrowArgs} args - Arguments to find a HelixUserNotificationProfile
     * @example
     * // Get one HelixUserNotificationProfile
     * const helixUserNotificationProfile = await prisma.helixUserNotificationProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HelixUserNotificationProfileFindFirstOrThrowArgs>(
      args?: SelectSubset<T, HelixUserNotificationProfileFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__HelixUserNotificationProfileClient<
      $Result.GetResult<
        Prisma.$HelixUserNotificationProfilePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more HelixUserNotificationProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelixUserNotificationProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HelixUserNotificationProfiles
     * const helixUserNotificationProfiles = await prisma.helixUserNotificationProfile.findMany()
     *
     * // Get first 10 HelixUserNotificationProfiles
     * const helixUserNotificationProfiles = await prisma.helixUserNotificationProfile.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const helixUserNotificationProfileWithIdOnly = await prisma.helixUserNotificationProfile.findMany({ select: { id: true } })
     *
     */
    findMany<T extends HelixUserNotificationProfileFindManyArgs>(
      args?: SelectSubset<T, HelixUserNotificationProfileFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$HelixUserNotificationProfilePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a HelixUserNotificationProfile.
     * @param {HelixUserNotificationProfileCreateArgs} args - Arguments to create a HelixUserNotificationProfile.
     * @example
     * // Create one HelixUserNotificationProfile
     * const HelixUserNotificationProfile = await prisma.helixUserNotificationProfile.create({
     *   data: {
     *     // ... data to create a HelixUserNotificationProfile
     *   }
     * })
     *
     */
    create<T extends HelixUserNotificationProfileCreateArgs>(
      args: SelectSubset<T, HelixUserNotificationProfileCreateArgs<ExtArgs>>,
    ): Prisma__HelixUserNotificationProfileClient<
      $Result.GetResult<
        Prisma.$HelixUserNotificationProfilePayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many HelixUserNotificationProfiles.
     * @param {HelixUserNotificationProfileCreateManyArgs} args - Arguments to create many HelixUserNotificationProfiles.
     * @example
     * // Create many HelixUserNotificationProfiles
     * const helixUserNotificationProfile = await prisma.helixUserNotificationProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends HelixUserNotificationProfileCreateManyArgs>(
      args?: SelectSubset<T, HelixUserNotificationProfileCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many HelixUserNotificationProfiles and returns the data saved in the database.
     * @param {HelixUserNotificationProfileCreateManyAndReturnArgs} args - Arguments to create many HelixUserNotificationProfiles.
     * @example
     * // Create many HelixUserNotificationProfiles
     * const helixUserNotificationProfile = await prisma.helixUserNotificationProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many HelixUserNotificationProfiles and only return the `id`
     * const helixUserNotificationProfileWithIdOnly = await prisma.helixUserNotificationProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends HelixUserNotificationProfileCreateManyAndReturnArgs>(
      args?: SelectSubset<T, HelixUserNotificationProfileCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$HelixUserNotificationProfilePayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a HelixUserNotificationProfile.
     * @param {HelixUserNotificationProfileDeleteArgs} args - Arguments to delete one HelixUserNotificationProfile.
     * @example
     * // Delete one HelixUserNotificationProfile
     * const HelixUserNotificationProfile = await prisma.helixUserNotificationProfile.delete({
     *   where: {
     *     // ... filter to delete one HelixUserNotificationProfile
     *   }
     * })
     *
     */
    delete<T extends HelixUserNotificationProfileDeleteArgs>(
      args: SelectSubset<T, HelixUserNotificationProfileDeleteArgs<ExtArgs>>,
    ): Prisma__HelixUserNotificationProfileClient<
      $Result.GetResult<
        Prisma.$HelixUserNotificationProfilePayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one HelixUserNotificationProfile.
     * @param {HelixUserNotificationProfileUpdateArgs} args - Arguments to update one HelixUserNotificationProfile.
     * @example
     * // Update one HelixUserNotificationProfile
     * const helixUserNotificationProfile = await prisma.helixUserNotificationProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends HelixUserNotificationProfileUpdateArgs>(
      args: SelectSubset<T, HelixUserNotificationProfileUpdateArgs<ExtArgs>>,
    ): Prisma__HelixUserNotificationProfileClient<
      $Result.GetResult<
        Prisma.$HelixUserNotificationProfilePayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more HelixUserNotificationProfiles.
     * @param {HelixUserNotificationProfileDeleteManyArgs} args - Arguments to filter HelixUserNotificationProfiles to delete.
     * @example
     * // Delete a few HelixUserNotificationProfiles
     * const { count } = await prisma.helixUserNotificationProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends HelixUserNotificationProfileDeleteManyArgs>(
      args?: SelectSubset<T, HelixUserNotificationProfileDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more HelixUserNotificationProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelixUserNotificationProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HelixUserNotificationProfiles
     * const helixUserNotificationProfile = await prisma.helixUserNotificationProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends HelixUserNotificationProfileUpdateManyArgs>(
      args: SelectSubset<T, HelixUserNotificationProfileUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more HelixUserNotificationProfiles and returns the data updated in the database.
     * @param {HelixUserNotificationProfileUpdateManyAndReturnArgs} args - Arguments to update many HelixUserNotificationProfiles.
     * @example
     * // Update many HelixUserNotificationProfiles
     * const helixUserNotificationProfile = await prisma.helixUserNotificationProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more HelixUserNotificationProfiles and only return the `id`
     * const helixUserNotificationProfileWithIdOnly = await prisma.helixUserNotificationProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends HelixUserNotificationProfileUpdateManyAndReturnArgs>(
      args: SelectSubset<T, HelixUserNotificationProfileUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$HelixUserNotificationProfilePayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one HelixUserNotificationProfile.
     * @param {HelixUserNotificationProfileUpsertArgs} args - Arguments to update or create a HelixUserNotificationProfile.
     * @example
     * // Update or create a HelixUserNotificationProfile
     * const helixUserNotificationProfile = await prisma.helixUserNotificationProfile.upsert({
     *   create: {
     *     // ... data to create a HelixUserNotificationProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HelixUserNotificationProfile we want to update
     *   }
     * })
     */
    upsert<T extends HelixUserNotificationProfileUpsertArgs>(
      args: SelectSubset<T, HelixUserNotificationProfileUpsertArgs<ExtArgs>>,
    ): Prisma__HelixUserNotificationProfileClient<
      $Result.GetResult<
        Prisma.$HelixUserNotificationProfilePayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of HelixUserNotificationProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelixUserNotificationProfileCountArgs} args - Arguments to filter HelixUserNotificationProfiles to count.
     * @example
     * // Count the number of HelixUserNotificationProfiles
     * const count = await prisma.helixUserNotificationProfile.count({
     *   where: {
     *     // ... the filter for the HelixUserNotificationProfiles we want to count
     *   }
     * })
     **/
    count<T extends HelixUserNotificationProfileCountArgs>(
      args?: Subset<T, HelixUserNotificationProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HelixUserNotificationProfileCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a HelixUserNotificationProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelixUserNotificationProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends HelixUserNotificationProfileAggregateArgs>(
      args: Subset<T, HelixUserNotificationProfileAggregateArgs>,
    ): Prisma.PrismaPromise<GetHelixUserNotificationProfileAggregateType<T>>;

    /**
     * Group by HelixUserNotificationProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelixUserNotificationProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends HelixUserNotificationProfileGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HelixUserNotificationProfileGroupByArgs['orderBy'] }
        : { orderBy?: HelixUserNotificationProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, HelixUserNotificationProfileGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetHelixUserNotificationProfileGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the HelixUserNotificationProfile model
     */
    readonly fields: HelixUserNotificationProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HelixUserNotificationProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HelixUserNotificationProfileClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    preferences<T extends HelixUserNotificationProfile$preferencesArgs<ExtArgs> = {}>(
      args?: Subset<T, HelixUserNotificationProfile$preferencesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$NotificationPreferencePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the HelixUserNotificationProfile model
   */
  interface HelixUserNotificationProfileFieldRefs {
    readonly id: FieldRef<'HelixUserNotificationProfile', 'String'>;
    readonly userId: FieldRef<'HelixUserNotificationProfile', 'String'>;
    readonly globalEnabled: FieldRef<'HelixUserNotificationProfile', 'Boolean'>;
    readonly defaultChannels: FieldRef<'HelixUserNotificationProfile', 'NotificationChannel[]'>;
    readonly timezone: FieldRef<'HelixUserNotificationProfile', 'String'>;
    readonly digestEnabled: FieldRef<'HelixUserNotificationProfile', 'Boolean'>;
    readonly digestFrequency: FieldRef<'HelixUserNotificationProfile', 'DigestFrequency'>;
    readonly digestTime: FieldRef<'HelixUserNotificationProfile', 'String'>;
    readonly dndEnabled: FieldRef<'HelixUserNotificationProfile', 'Boolean'>;
    readonly dndStartTime: FieldRef<'HelixUserNotificationProfile', 'String'>;
    readonly dndEndTime: FieldRef<'HelixUserNotificationProfile', 'String'>;
    readonly dndDays: FieldRef<'HelixUserNotificationProfile', 'String[]'>;
    readonly goalertEnabled: FieldRef<'HelixUserNotificationProfile', 'Boolean'>;
    readonly goalertSchedules: FieldRef<'HelixUserNotificationProfile', 'String[]'>;
    readonly goalertPolicies: FieldRef<'HelixUserNotificationProfile', 'String[]'>;
    readonly pagerEnabled: FieldRef<'HelixUserNotificationProfile', 'Boolean'>;
    readonly synthEnabled: FieldRef<'HelixUserNotificationProfile', 'Boolean'>;
    readonly aiDigestEnabled: FieldRef<'HelixUserNotificationProfile', 'Boolean'>;
    readonly aiGroupingLevel: FieldRef<'HelixUserNotificationProfile', 'AiGroupingLevel'>;
    readonly muteRepetitive: FieldRef<'HelixUserNotificationProfile', 'Boolean'>;
    readonly sentinelEnabled: FieldRef<'HelixUserNotificationProfile', 'Boolean'>;
    readonly securityEvents: FieldRef<'HelixUserNotificationProfile', 'String[]'>;
    readonly complianceEvents: FieldRef<'HelixUserNotificationProfile', 'Boolean'>;
    readonly deviceTokens: FieldRef<'HelixUserNotificationProfile', 'Json'>;
    readonly pushEnabled: FieldRef<'HelixUserNotificationProfile', 'Boolean'>;
    readonly phoneNumber: FieldRef<'HelixUserNotificationProfile', 'String'>;
    readonly slackUserId: FieldRef<'HelixUserNotificationProfile', 'String'>;
    readonly teamsUserId: FieldRef<'HelixUserNotificationProfile', 'String'>;
    readonly createdAt: FieldRef<'HelixUserNotificationProfile', 'DateTime'>;
    readonly updatedAt: FieldRef<'HelixUserNotificationProfile', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * HelixUserNotificationProfile findUnique
   */
  export type HelixUserNotificationProfileFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HelixUserNotificationProfile
     */
    select?: HelixUserNotificationProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HelixUserNotificationProfile
     */
    omit?: HelixUserNotificationProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelixUserNotificationProfileInclude<ExtArgs> | null;
    /**
     * Filter, which HelixUserNotificationProfile to fetch.
     */
    where: HelixUserNotificationProfileWhereUniqueInput;
  };

  /**
   * HelixUserNotificationProfile findUniqueOrThrow
   */
  export type HelixUserNotificationProfileFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HelixUserNotificationProfile
     */
    select?: HelixUserNotificationProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HelixUserNotificationProfile
     */
    omit?: HelixUserNotificationProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelixUserNotificationProfileInclude<ExtArgs> | null;
    /**
     * Filter, which HelixUserNotificationProfile to fetch.
     */
    where: HelixUserNotificationProfileWhereUniqueInput;
  };

  /**
   * HelixUserNotificationProfile findFirst
   */
  export type HelixUserNotificationProfileFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HelixUserNotificationProfile
     */
    select?: HelixUserNotificationProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HelixUserNotificationProfile
     */
    omit?: HelixUserNotificationProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelixUserNotificationProfileInclude<ExtArgs> | null;
    /**
     * Filter, which HelixUserNotificationProfile to fetch.
     */
    where?: HelixUserNotificationProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of HelixUserNotificationProfiles to fetch.
     */
    orderBy?:
      | HelixUserNotificationProfileOrderByWithRelationInput
      | HelixUserNotificationProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for HelixUserNotificationProfiles.
     */
    cursor?: HelixUserNotificationProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` HelixUserNotificationProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` HelixUserNotificationProfiles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of HelixUserNotificationProfiles.
     */
    distinct?:
      | HelixUserNotificationProfileScalarFieldEnum
      | HelixUserNotificationProfileScalarFieldEnum[];
  };

  /**
   * HelixUserNotificationProfile findFirstOrThrow
   */
  export type HelixUserNotificationProfileFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HelixUserNotificationProfile
     */
    select?: HelixUserNotificationProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HelixUserNotificationProfile
     */
    omit?: HelixUserNotificationProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelixUserNotificationProfileInclude<ExtArgs> | null;
    /**
     * Filter, which HelixUserNotificationProfile to fetch.
     */
    where?: HelixUserNotificationProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of HelixUserNotificationProfiles to fetch.
     */
    orderBy?:
      | HelixUserNotificationProfileOrderByWithRelationInput
      | HelixUserNotificationProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for HelixUserNotificationProfiles.
     */
    cursor?: HelixUserNotificationProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` HelixUserNotificationProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` HelixUserNotificationProfiles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of HelixUserNotificationProfiles.
     */
    distinct?:
      | HelixUserNotificationProfileScalarFieldEnum
      | HelixUserNotificationProfileScalarFieldEnum[];
  };

  /**
   * HelixUserNotificationProfile findMany
   */
  export type HelixUserNotificationProfileFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HelixUserNotificationProfile
     */
    select?: HelixUserNotificationProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HelixUserNotificationProfile
     */
    omit?: HelixUserNotificationProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelixUserNotificationProfileInclude<ExtArgs> | null;
    /**
     * Filter, which HelixUserNotificationProfiles to fetch.
     */
    where?: HelixUserNotificationProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of HelixUserNotificationProfiles to fetch.
     */
    orderBy?:
      | HelixUserNotificationProfileOrderByWithRelationInput
      | HelixUserNotificationProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing HelixUserNotificationProfiles.
     */
    cursor?: HelixUserNotificationProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` HelixUserNotificationProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` HelixUserNotificationProfiles.
     */
    skip?: number;
    distinct?:
      | HelixUserNotificationProfileScalarFieldEnum
      | HelixUserNotificationProfileScalarFieldEnum[];
  };

  /**
   * HelixUserNotificationProfile create
   */
  export type HelixUserNotificationProfileCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HelixUserNotificationProfile
     */
    select?: HelixUserNotificationProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HelixUserNotificationProfile
     */
    omit?: HelixUserNotificationProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelixUserNotificationProfileInclude<ExtArgs> | null;
    /**
     * The data needed to create a HelixUserNotificationProfile.
     */
    data: XOR<
      HelixUserNotificationProfileCreateInput,
      HelixUserNotificationProfileUncheckedCreateInput
    >;
  };

  /**
   * HelixUserNotificationProfile createMany
   */
  export type HelixUserNotificationProfileCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many HelixUserNotificationProfiles.
     */
    data:
      | HelixUserNotificationProfileCreateManyInput
      | HelixUserNotificationProfileCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * HelixUserNotificationProfile createManyAndReturn
   */
  export type HelixUserNotificationProfileCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HelixUserNotificationProfile
     */
    select?: HelixUserNotificationProfileSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the HelixUserNotificationProfile
     */
    omit?: HelixUserNotificationProfileOmit<ExtArgs> | null;
    /**
     * The data used to create many HelixUserNotificationProfiles.
     */
    data:
      | HelixUserNotificationProfileCreateManyInput
      | HelixUserNotificationProfileCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * HelixUserNotificationProfile update
   */
  export type HelixUserNotificationProfileUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HelixUserNotificationProfile
     */
    select?: HelixUserNotificationProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HelixUserNotificationProfile
     */
    omit?: HelixUserNotificationProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelixUserNotificationProfileInclude<ExtArgs> | null;
    /**
     * The data needed to update a HelixUserNotificationProfile.
     */
    data: XOR<
      HelixUserNotificationProfileUpdateInput,
      HelixUserNotificationProfileUncheckedUpdateInput
    >;
    /**
     * Choose, which HelixUserNotificationProfile to update.
     */
    where: HelixUserNotificationProfileWhereUniqueInput;
  };

  /**
   * HelixUserNotificationProfile updateMany
   */
  export type HelixUserNotificationProfileUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update HelixUserNotificationProfiles.
     */
    data: XOR<
      HelixUserNotificationProfileUpdateManyMutationInput,
      HelixUserNotificationProfileUncheckedUpdateManyInput
    >;
    /**
     * Filter which HelixUserNotificationProfiles to update
     */
    where?: HelixUserNotificationProfileWhereInput;
    /**
     * Limit how many HelixUserNotificationProfiles to update.
     */
    limit?: number;
  };

  /**
   * HelixUserNotificationProfile updateManyAndReturn
   */
  export type HelixUserNotificationProfileUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HelixUserNotificationProfile
     */
    select?: HelixUserNotificationProfileSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the HelixUserNotificationProfile
     */
    omit?: HelixUserNotificationProfileOmit<ExtArgs> | null;
    /**
     * The data used to update HelixUserNotificationProfiles.
     */
    data: XOR<
      HelixUserNotificationProfileUpdateManyMutationInput,
      HelixUserNotificationProfileUncheckedUpdateManyInput
    >;
    /**
     * Filter which HelixUserNotificationProfiles to update
     */
    where?: HelixUserNotificationProfileWhereInput;
    /**
     * Limit how many HelixUserNotificationProfiles to update.
     */
    limit?: number;
  };

  /**
   * HelixUserNotificationProfile upsert
   */
  export type HelixUserNotificationProfileUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HelixUserNotificationProfile
     */
    select?: HelixUserNotificationProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HelixUserNotificationProfile
     */
    omit?: HelixUserNotificationProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelixUserNotificationProfileInclude<ExtArgs> | null;
    /**
     * The filter to search for the HelixUserNotificationProfile to update in case it exists.
     */
    where: HelixUserNotificationProfileWhereUniqueInput;
    /**
     * In case the HelixUserNotificationProfile found by the `where` argument doesn't exist, create a new HelixUserNotificationProfile with this data.
     */
    create: XOR<
      HelixUserNotificationProfileCreateInput,
      HelixUserNotificationProfileUncheckedCreateInput
    >;
    /**
     * In case the HelixUserNotificationProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      HelixUserNotificationProfileUpdateInput,
      HelixUserNotificationProfileUncheckedUpdateInput
    >;
  };

  /**
   * HelixUserNotificationProfile delete
   */
  export type HelixUserNotificationProfileDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HelixUserNotificationProfile
     */
    select?: HelixUserNotificationProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HelixUserNotificationProfile
     */
    omit?: HelixUserNotificationProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelixUserNotificationProfileInclude<ExtArgs> | null;
    /**
     * Filter which HelixUserNotificationProfile to delete.
     */
    where: HelixUserNotificationProfileWhereUniqueInput;
  };

  /**
   * HelixUserNotificationProfile deleteMany
   */
  export type HelixUserNotificationProfileDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which HelixUserNotificationProfiles to delete
     */
    where?: HelixUserNotificationProfileWhereInput;
    /**
     * Limit how many HelixUserNotificationProfiles to delete.
     */
    limit?: number;
  };

  /**
   * HelixUserNotificationProfile.preferences
   */
  export type HelixUserNotificationProfile$preferencesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null;
    where?: NotificationPreferenceWhereInput;
    orderBy?:
      | NotificationPreferenceOrderByWithRelationInput
      | NotificationPreferenceOrderByWithRelationInput[];
    cursor?: NotificationPreferenceWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[];
  };

  /**
   * HelixUserNotificationProfile without action
   */
  export type HelixUserNotificationProfileDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HelixUserNotificationProfile
     */
    select?: HelixUserNotificationProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HelixUserNotificationProfile
     */
    omit?: HelixUserNotificationProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelixUserNotificationProfileInclude<ExtArgs> | null;
  };

  /**
   * Model NotificationQueue
   */

  export type AggregateNotificationQueue = {
    _count: NotificationQueueCountAggregateOutputType | null;
    _avg: NotificationQueueAvgAggregateOutputType | null;
    _sum: NotificationQueueSumAggregateOutputType | null;
    _min: NotificationQueueMinAggregateOutputType | null;
    _max: NotificationQueueMaxAggregateOutputType | null;
  };

  export type NotificationQueueAvgAggregateOutputType = {
    attempts: number | null;
    maxAttempts: number | null;
  };

  export type NotificationQueueSumAggregateOutputType = {
    attempts: number | null;
    maxAttempts: number | null;
  };

  export type NotificationQueueMinAggregateOutputType = {
    id: string | null;
    eventId: string | null;
    deliveryId: string | null;
    priority: $Enums.NotificationPriority | null;
    scheduledFor: Date | null;
    attempts: number | null;
    maxAttempts: number | null;
    lastAttemptAt: Date | null;
    nextAttemptAt: Date | null;
    status: string | null;
    error: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type NotificationQueueMaxAggregateOutputType = {
    id: string | null;
    eventId: string | null;
    deliveryId: string | null;
    priority: $Enums.NotificationPriority | null;
    scheduledFor: Date | null;
    attempts: number | null;
    maxAttempts: number | null;
    lastAttemptAt: Date | null;
    nextAttemptAt: Date | null;
    status: string | null;
    error: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type NotificationQueueCountAggregateOutputType = {
    id: number;
    eventId: number;
    deliveryId: number;
    priority: number;
    scheduledFor: number;
    attempts: number;
    maxAttempts: number;
    lastAttemptAt: number;
    nextAttemptAt: number;
    status: number;
    error: number;
    metadata: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type NotificationQueueAvgAggregateInputType = {
    attempts?: true;
    maxAttempts?: true;
  };

  export type NotificationQueueSumAggregateInputType = {
    attempts?: true;
    maxAttempts?: true;
  };

  export type NotificationQueueMinAggregateInputType = {
    id?: true;
    eventId?: true;
    deliveryId?: true;
    priority?: true;
    scheduledFor?: true;
    attempts?: true;
    maxAttempts?: true;
    lastAttemptAt?: true;
    nextAttemptAt?: true;
    status?: true;
    error?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type NotificationQueueMaxAggregateInputType = {
    id?: true;
    eventId?: true;
    deliveryId?: true;
    priority?: true;
    scheduledFor?: true;
    attempts?: true;
    maxAttempts?: true;
    lastAttemptAt?: true;
    nextAttemptAt?: true;
    status?: true;
    error?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type NotificationQueueCountAggregateInputType = {
    id?: true;
    eventId?: true;
    deliveryId?: true;
    priority?: true;
    scheduledFor?: true;
    attempts?: true;
    maxAttempts?: true;
    lastAttemptAt?: true;
    nextAttemptAt?: true;
    status?: true;
    error?: true;
    metadata?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type NotificationQueueAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which NotificationQueue to aggregate.
     */
    where?: NotificationQueueWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationQueues to fetch.
     */
    orderBy?:
      | NotificationQueueOrderByWithRelationInput
      | NotificationQueueOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: NotificationQueueWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationQueues from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationQueues.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned NotificationQueues
     **/
    _count?: true | NotificationQueueCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: NotificationQueueAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: NotificationQueueSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: NotificationQueueMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: NotificationQueueMaxAggregateInputType;
  };

  export type GetNotificationQueueAggregateType<T extends NotificationQueueAggregateArgs> = {
    [P in keyof T & keyof AggregateNotificationQueue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationQueue[P]>
      : GetScalarType<T[P], AggregateNotificationQueue[P]>;
  };

  export type NotificationQueueGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificationQueueWhereInput;
    orderBy?:
      | NotificationQueueOrderByWithAggregationInput
      | NotificationQueueOrderByWithAggregationInput[];
    by: NotificationQueueScalarFieldEnum[] | NotificationQueueScalarFieldEnum;
    having?: NotificationQueueScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: NotificationQueueCountAggregateInputType | true;
    _avg?: NotificationQueueAvgAggregateInputType;
    _sum?: NotificationQueueSumAggregateInputType;
    _min?: NotificationQueueMinAggregateInputType;
    _max?: NotificationQueueMaxAggregateInputType;
  };

  export type NotificationQueueGroupByOutputType = {
    id: string;
    eventId: string;
    deliveryId: string;
    priority: $Enums.NotificationPriority;
    scheduledFor: Date;
    attempts: number;
    maxAttempts: number;
    lastAttemptAt: Date | null;
    nextAttemptAt: Date | null;
    status: string;
    error: string | null;
    metadata: JsonValue | null;
    createdAt: Date;
    updatedAt: Date;
    _count: NotificationQueueCountAggregateOutputType | null;
    _avg: NotificationQueueAvgAggregateOutputType | null;
    _sum: NotificationQueueSumAggregateOutputType | null;
    _min: NotificationQueueMinAggregateOutputType | null;
    _max: NotificationQueueMaxAggregateOutputType | null;
  };

  type GetNotificationQueueGroupByPayload<T extends NotificationQueueGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<NotificationQueueGroupByOutputType, T['by']> & {
          [P in keyof T & keyof NotificationQueueGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationQueueGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationQueueGroupByOutputType[P]>;
        }
      >
    >;

  export type NotificationQueueSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      eventId?: boolean;
      deliveryId?: boolean;
      priority?: boolean;
      scheduledFor?: boolean;
      attempts?: boolean;
      maxAttempts?: boolean;
      lastAttemptAt?: boolean;
      nextAttemptAt?: boolean;
      status?: boolean;
      error?: boolean;
      metadata?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      event?: boolean | NotificationEventDefaultArgs<ExtArgs>;
      delivery?: boolean | NotificationDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notificationQueue']
  >;

  export type NotificationQueueSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      eventId?: boolean;
      deliveryId?: boolean;
      priority?: boolean;
      scheduledFor?: boolean;
      attempts?: boolean;
      maxAttempts?: boolean;
      lastAttemptAt?: boolean;
      nextAttemptAt?: boolean;
      status?: boolean;
      error?: boolean;
      metadata?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      event?: boolean | NotificationEventDefaultArgs<ExtArgs>;
      delivery?: boolean | NotificationDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notificationQueue']
  >;

  export type NotificationQueueSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      eventId?: boolean;
      deliveryId?: boolean;
      priority?: boolean;
      scheduledFor?: boolean;
      attempts?: boolean;
      maxAttempts?: boolean;
      lastAttemptAt?: boolean;
      nextAttemptAt?: boolean;
      status?: boolean;
      error?: boolean;
      metadata?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      event?: boolean | NotificationEventDefaultArgs<ExtArgs>;
      delivery?: boolean | NotificationDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notificationQueue']
  >;

  export type NotificationQueueSelectScalar = {
    id?: boolean;
    eventId?: boolean;
    deliveryId?: boolean;
    priority?: boolean;
    scheduledFor?: boolean;
    attempts?: boolean;
    maxAttempts?: boolean;
    lastAttemptAt?: boolean;
    nextAttemptAt?: boolean;
    status?: boolean;
    error?: boolean;
    metadata?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type NotificationQueueOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'eventId'
    | 'deliveryId'
    | 'priority'
    | 'scheduledFor'
    | 'attempts'
    | 'maxAttempts'
    | 'lastAttemptAt'
    | 'nextAttemptAt'
    | 'status'
    | 'error'
    | 'metadata'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['notificationQueue']
  >;
  export type NotificationQueueInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    event?: boolean | NotificationEventDefaultArgs<ExtArgs>;
    delivery?: boolean | NotificationDefaultArgs<ExtArgs>;
  };
  export type NotificationQueueIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    event?: boolean | NotificationEventDefaultArgs<ExtArgs>;
    delivery?: boolean | NotificationDefaultArgs<ExtArgs>;
  };
  export type NotificationQueueIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    event?: boolean | NotificationEventDefaultArgs<ExtArgs>;
    delivery?: boolean | NotificationDefaultArgs<ExtArgs>;
  };

  export type $NotificationQueuePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'NotificationQueue';
    objects: {
      event: Prisma.$NotificationEventPayload<ExtArgs>;
      delivery: Prisma.$NotificationPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        eventId: string;
        deliveryId: string;
        priority: $Enums.NotificationPriority;
        scheduledFor: Date;
        attempts: number;
        maxAttempts: number;
        lastAttemptAt: Date | null;
        nextAttemptAt: Date | null;
        status: string;
        error: string | null;
        metadata: Prisma.JsonValue | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['notificationQueue']
    >;
    composites: {};
  };

  type NotificationQueueGetPayload<
    S extends boolean | null | undefined | NotificationQueueDefaultArgs,
  > = $Result.GetResult<Prisma.$NotificationQueuePayload, S>;

  type NotificationQueueCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<NotificationQueueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: NotificationQueueCountAggregateInputType | true;
  };

  export interface NotificationQueueDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['NotificationQueue'];
      meta: { name: 'NotificationQueue' };
    };
    /**
     * Find zero or one NotificationQueue that matches the filter.
     * @param {NotificationQueueFindUniqueArgs} args - Arguments to find a NotificationQueue
     * @example
     * // Get one NotificationQueue
     * const notificationQueue = await prisma.notificationQueue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationQueueFindUniqueArgs>(
      args: SelectSubset<T, NotificationQueueFindUniqueArgs<ExtArgs>>,
    ): Prisma__NotificationQueueClient<
      $Result.GetResult<
        Prisma.$NotificationQueuePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one NotificationQueue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationQueueFindUniqueOrThrowArgs} args - Arguments to find a NotificationQueue
     * @example
     * // Get one NotificationQueue
     * const notificationQueue = await prisma.notificationQueue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationQueueFindUniqueOrThrowArgs>(
      args: SelectSubset<T, NotificationQueueFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__NotificationQueueClient<
      $Result.GetResult<
        Prisma.$NotificationQueuePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first NotificationQueue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationQueueFindFirstArgs} args - Arguments to find a NotificationQueue
     * @example
     * // Get one NotificationQueue
     * const notificationQueue = await prisma.notificationQueue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationQueueFindFirstArgs>(
      args?: SelectSubset<T, NotificationQueueFindFirstArgs<ExtArgs>>,
    ): Prisma__NotificationQueueClient<
      $Result.GetResult<
        Prisma.$NotificationQueuePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first NotificationQueue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationQueueFindFirstOrThrowArgs} args - Arguments to find a NotificationQueue
     * @example
     * // Get one NotificationQueue
     * const notificationQueue = await prisma.notificationQueue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationQueueFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NotificationQueueFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__NotificationQueueClient<
      $Result.GetResult<
        Prisma.$NotificationQueuePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more NotificationQueues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationQueueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationQueues
     * const notificationQueues = await prisma.notificationQueue.findMany()
     *
     * // Get first 10 NotificationQueues
     * const notificationQueues = await prisma.notificationQueue.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const notificationQueueWithIdOnly = await prisma.notificationQueue.findMany({ select: { id: true } })
     *
     */
    findMany<T extends NotificationQueueFindManyArgs>(
      args?: SelectSubset<T, NotificationQueueFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a NotificationQueue.
     * @param {NotificationQueueCreateArgs} args - Arguments to create a NotificationQueue.
     * @example
     * // Create one NotificationQueue
     * const NotificationQueue = await prisma.notificationQueue.create({
     *   data: {
     *     // ... data to create a NotificationQueue
     *   }
     * })
     *
     */
    create<T extends NotificationQueueCreateArgs>(
      args: SelectSubset<T, NotificationQueueCreateArgs<ExtArgs>>,
    ): Prisma__NotificationQueueClient<
      $Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many NotificationQueues.
     * @param {NotificationQueueCreateManyArgs} args - Arguments to create many NotificationQueues.
     * @example
     * // Create many NotificationQueues
     * const notificationQueue = await prisma.notificationQueue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends NotificationQueueCreateManyArgs>(
      args?: SelectSubset<T, NotificationQueueCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many NotificationQueues and returns the data saved in the database.
     * @param {NotificationQueueCreateManyAndReturnArgs} args - Arguments to create many NotificationQueues.
     * @example
     * // Create many NotificationQueues
     * const notificationQueue = await prisma.notificationQueue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many NotificationQueues and only return the `id`
     * const notificationQueueWithIdOnly = await prisma.notificationQueue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends NotificationQueueCreateManyAndReturnArgs>(
      args?: SelectSubset<T, NotificationQueueCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationQueuePayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a NotificationQueue.
     * @param {NotificationQueueDeleteArgs} args - Arguments to delete one NotificationQueue.
     * @example
     * // Delete one NotificationQueue
     * const NotificationQueue = await prisma.notificationQueue.delete({
     *   where: {
     *     // ... filter to delete one NotificationQueue
     *   }
     * })
     *
     */
    delete<T extends NotificationQueueDeleteArgs>(
      args: SelectSubset<T, NotificationQueueDeleteArgs<ExtArgs>>,
    ): Prisma__NotificationQueueClient<
      $Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one NotificationQueue.
     * @param {NotificationQueueUpdateArgs} args - Arguments to update one NotificationQueue.
     * @example
     * // Update one NotificationQueue
     * const notificationQueue = await prisma.notificationQueue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends NotificationQueueUpdateArgs>(
      args: SelectSubset<T, NotificationQueueUpdateArgs<ExtArgs>>,
    ): Prisma__NotificationQueueClient<
      $Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more NotificationQueues.
     * @param {NotificationQueueDeleteManyArgs} args - Arguments to filter NotificationQueues to delete.
     * @example
     * // Delete a few NotificationQueues
     * const { count } = await prisma.notificationQueue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends NotificationQueueDeleteManyArgs>(
      args?: SelectSubset<T, NotificationQueueDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more NotificationQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationQueueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationQueues
     * const notificationQueue = await prisma.notificationQueue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends NotificationQueueUpdateManyArgs>(
      args: SelectSubset<T, NotificationQueueUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more NotificationQueues and returns the data updated in the database.
     * @param {NotificationQueueUpdateManyAndReturnArgs} args - Arguments to update many NotificationQueues.
     * @example
     * // Update many NotificationQueues
     * const notificationQueue = await prisma.notificationQueue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more NotificationQueues and only return the `id`
     * const notificationQueueWithIdOnly = await prisma.notificationQueue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends NotificationQueueUpdateManyAndReturnArgs>(
      args: SelectSubset<T, NotificationQueueUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationQueuePayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one NotificationQueue.
     * @param {NotificationQueueUpsertArgs} args - Arguments to update or create a NotificationQueue.
     * @example
     * // Update or create a NotificationQueue
     * const notificationQueue = await prisma.notificationQueue.upsert({
     *   create: {
     *     // ... data to create a NotificationQueue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationQueue we want to update
     *   }
     * })
     */
    upsert<T extends NotificationQueueUpsertArgs>(
      args: SelectSubset<T, NotificationQueueUpsertArgs<ExtArgs>>,
    ): Prisma__NotificationQueueClient<
      $Result.GetResult<Prisma.$NotificationQueuePayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of NotificationQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationQueueCountArgs} args - Arguments to filter NotificationQueues to count.
     * @example
     * // Count the number of NotificationQueues
     * const count = await prisma.notificationQueue.count({
     *   where: {
     *     // ... the filter for the NotificationQueues we want to count
     *   }
     * })
     **/
    count<T extends NotificationQueueCountArgs>(
      args?: Subset<T, NotificationQueueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationQueueCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a NotificationQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationQueueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends NotificationQueueAggregateArgs>(
      args: Subset<T, NotificationQueueAggregateArgs>,
    ): Prisma.PrismaPromise<GetNotificationQueueAggregateType<T>>;

    /**
     * Group by NotificationQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationQueueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends NotificationQueueGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationQueueGroupByArgs['orderBy'] }
        : { orderBy?: NotificationQueueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, NotificationQueueGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetNotificationQueueGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the NotificationQueue model
     */
    readonly fields: NotificationQueueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationQueue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationQueueClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    event<T extends NotificationEventDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, NotificationEventDefaultArgs<ExtArgs>>,
    ): Prisma__NotificationEventClient<
      | $Result.GetResult<
          Prisma.$NotificationEventPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    delivery<T extends NotificationDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, NotificationDefaultArgs<ExtArgs>>,
    ): Prisma__NotificationClient<
      | $Result.GetResult<
          Prisma.$NotificationPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the NotificationQueue model
   */
  interface NotificationQueueFieldRefs {
    readonly id: FieldRef<'NotificationQueue', 'String'>;
    readonly eventId: FieldRef<'NotificationQueue', 'String'>;
    readonly deliveryId: FieldRef<'NotificationQueue', 'String'>;
    readonly priority: FieldRef<'NotificationQueue', 'NotificationPriority'>;
    readonly scheduledFor: FieldRef<'NotificationQueue', 'DateTime'>;
    readonly attempts: FieldRef<'NotificationQueue', 'Int'>;
    readonly maxAttempts: FieldRef<'NotificationQueue', 'Int'>;
    readonly lastAttemptAt: FieldRef<'NotificationQueue', 'DateTime'>;
    readonly nextAttemptAt: FieldRef<'NotificationQueue', 'DateTime'>;
    readonly status: FieldRef<'NotificationQueue', 'String'>;
    readonly error: FieldRef<'NotificationQueue', 'String'>;
    readonly metadata: FieldRef<'NotificationQueue', 'Json'>;
    readonly createdAt: FieldRef<'NotificationQueue', 'DateTime'>;
    readonly updatedAt: FieldRef<'NotificationQueue', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * NotificationQueue findUnique
   */
  export type NotificationQueueFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationQueueInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationQueue to fetch.
     */
    where: NotificationQueueWhereUniqueInput;
  };

  /**
   * NotificationQueue findUniqueOrThrow
   */
  export type NotificationQueueFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationQueueInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationQueue to fetch.
     */
    where: NotificationQueueWhereUniqueInput;
  };

  /**
   * NotificationQueue findFirst
   */
  export type NotificationQueueFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationQueueInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationQueue to fetch.
     */
    where?: NotificationQueueWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationQueues to fetch.
     */
    orderBy?:
      | NotificationQueueOrderByWithRelationInput
      | NotificationQueueOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for NotificationQueues.
     */
    cursor?: NotificationQueueWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationQueues from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationQueues.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of NotificationQueues.
     */
    distinct?: NotificationQueueScalarFieldEnum | NotificationQueueScalarFieldEnum[];
  };

  /**
   * NotificationQueue findFirstOrThrow
   */
  export type NotificationQueueFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationQueueInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationQueue to fetch.
     */
    where?: NotificationQueueWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationQueues to fetch.
     */
    orderBy?:
      | NotificationQueueOrderByWithRelationInput
      | NotificationQueueOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for NotificationQueues.
     */
    cursor?: NotificationQueueWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationQueues from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationQueues.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of NotificationQueues.
     */
    distinct?: NotificationQueueScalarFieldEnum | NotificationQueueScalarFieldEnum[];
  };

  /**
   * NotificationQueue findMany
   */
  export type NotificationQueueFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationQueueInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationQueues to fetch.
     */
    where?: NotificationQueueWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationQueues to fetch.
     */
    orderBy?:
      | NotificationQueueOrderByWithRelationInput
      | NotificationQueueOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing NotificationQueues.
     */
    cursor?: NotificationQueueWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationQueues from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationQueues.
     */
    skip?: number;
    distinct?: NotificationQueueScalarFieldEnum | NotificationQueueScalarFieldEnum[];
  };

  /**
   * NotificationQueue create
   */
  export type NotificationQueueCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationQueueInclude<ExtArgs> | null;
    /**
     * The data needed to create a NotificationQueue.
     */
    data: XOR<NotificationQueueCreateInput, NotificationQueueUncheckedCreateInput>;
  };

  /**
   * NotificationQueue createMany
   */
  export type NotificationQueueCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many NotificationQueues.
     */
    data: NotificationQueueCreateManyInput | NotificationQueueCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * NotificationQueue createManyAndReturn
   */
  export type NotificationQueueCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null;
    /**
     * The data used to create many NotificationQueues.
     */
    data: NotificationQueueCreateManyInput | NotificationQueueCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationQueueIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * NotificationQueue update
   */
  export type NotificationQueueUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationQueueInclude<ExtArgs> | null;
    /**
     * The data needed to update a NotificationQueue.
     */
    data: XOR<NotificationQueueUpdateInput, NotificationQueueUncheckedUpdateInput>;
    /**
     * Choose, which NotificationQueue to update.
     */
    where: NotificationQueueWhereUniqueInput;
  };

  /**
   * NotificationQueue updateMany
   */
  export type NotificationQueueUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update NotificationQueues.
     */
    data: XOR<NotificationQueueUpdateManyMutationInput, NotificationQueueUncheckedUpdateManyInput>;
    /**
     * Filter which NotificationQueues to update
     */
    where?: NotificationQueueWhereInput;
    /**
     * Limit how many NotificationQueues to update.
     */
    limit?: number;
  };

  /**
   * NotificationQueue updateManyAndReturn
   */
  export type NotificationQueueUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null;
    /**
     * The data used to update NotificationQueues.
     */
    data: XOR<NotificationQueueUpdateManyMutationInput, NotificationQueueUncheckedUpdateManyInput>;
    /**
     * Filter which NotificationQueues to update
     */
    where?: NotificationQueueWhereInput;
    /**
     * Limit how many NotificationQueues to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationQueueIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * NotificationQueue upsert
   */
  export type NotificationQueueUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationQueueInclude<ExtArgs> | null;
    /**
     * The filter to search for the NotificationQueue to update in case it exists.
     */
    where: NotificationQueueWhereUniqueInput;
    /**
     * In case the NotificationQueue found by the `where` argument doesn't exist, create a new NotificationQueue with this data.
     */
    create: XOR<NotificationQueueCreateInput, NotificationQueueUncheckedCreateInput>;
    /**
     * In case the NotificationQueue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationQueueUpdateInput, NotificationQueueUncheckedUpdateInput>;
  };

  /**
   * NotificationQueue delete
   */
  export type NotificationQueueDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationQueueInclude<ExtArgs> | null;
    /**
     * Filter which NotificationQueue to delete.
     */
    where: NotificationQueueWhereUniqueInput;
  };

  /**
   * NotificationQueue deleteMany
   */
  export type NotificationQueueDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which NotificationQueues to delete
     */
    where?: NotificationQueueWhereInput;
    /**
     * Limit how many NotificationQueues to delete.
     */
    limit?: number;
  };

  /**
   * NotificationQueue without action
   */
  export type NotificationQueueDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationQueue
     */
    select?: NotificationQueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationQueue
     */
    omit?: NotificationQueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationQueueInclude<ExtArgs> | null;
  };

  /**
   * Model NotificationRoleDefault
   */

  export type AggregateNotificationRoleDefault = {
    _count: NotificationRoleDefaultCountAggregateOutputType | null;
    _min: NotificationRoleDefaultMinAggregateOutputType | null;
    _max: NotificationRoleDefaultMaxAggregateOutputType | null;
  };

  export type NotificationRoleDefaultMinAggregateOutputType = {
    id: string | null;
    roleName: string | null;
    module: string | null;
    eventType: string | null;
    enabled: boolean | null;
    priority: $Enums.NotificationPriority | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type NotificationRoleDefaultMaxAggregateOutputType = {
    id: string | null;
    roleName: string | null;
    module: string | null;
    eventType: string | null;
    enabled: boolean | null;
    priority: $Enums.NotificationPriority | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type NotificationRoleDefaultCountAggregateOutputType = {
    id: number;
    roleName: number;
    module: number;
    eventType: number;
    channels: number;
    enabled: number;
    priority: number;
    metadata: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type NotificationRoleDefaultMinAggregateInputType = {
    id?: true;
    roleName?: true;
    module?: true;
    eventType?: true;
    enabled?: true;
    priority?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type NotificationRoleDefaultMaxAggregateInputType = {
    id?: true;
    roleName?: true;
    module?: true;
    eventType?: true;
    enabled?: true;
    priority?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type NotificationRoleDefaultCountAggregateInputType = {
    id?: true;
    roleName?: true;
    module?: true;
    eventType?: true;
    channels?: true;
    enabled?: true;
    priority?: true;
    metadata?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type NotificationRoleDefaultAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which NotificationRoleDefault to aggregate.
     */
    where?: NotificationRoleDefaultWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationRoleDefaults to fetch.
     */
    orderBy?:
      | NotificationRoleDefaultOrderByWithRelationInput
      | NotificationRoleDefaultOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: NotificationRoleDefaultWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationRoleDefaults from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationRoleDefaults.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned NotificationRoleDefaults
     **/
    _count?: true | NotificationRoleDefaultCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: NotificationRoleDefaultMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: NotificationRoleDefaultMaxAggregateInputType;
  };

  export type GetNotificationRoleDefaultAggregateType<
    T extends NotificationRoleDefaultAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateNotificationRoleDefault]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationRoleDefault[P]>
      : GetScalarType<T[P], AggregateNotificationRoleDefault[P]>;
  };

  export type NotificationRoleDefaultGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificationRoleDefaultWhereInput;
    orderBy?:
      | NotificationRoleDefaultOrderByWithAggregationInput
      | NotificationRoleDefaultOrderByWithAggregationInput[];
    by: NotificationRoleDefaultScalarFieldEnum[] | NotificationRoleDefaultScalarFieldEnum;
    having?: NotificationRoleDefaultScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: NotificationRoleDefaultCountAggregateInputType | true;
    _min?: NotificationRoleDefaultMinAggregateInputType;
    _max?: NotificationRoleDefaultMaxAggregateInputType;
  };

  export type NotificationRoleDefaultGroupByOutputType = {
    id: string;
    roleName: string;
    module: string;
    eventType: string;
    channels: $Enums.NotificationChannel[];
    enabled: boolean;
    priority: $Enums.NotificationPriority | null;
    metadata: JsonValue | null;
    createdAt: Date;
    updatedAt: Date;
    _count: NotificationRoleDefaultCountAggregateOutputType | null;
    _min: NotificationRoleDefaultMinAggregateOutputType | null;
    _max: NotificationRoleDefaultMaxAggregateOutputType | null;
  };

  type GetNotificationRoleDefaultGroupByPayload<T extends NotificationRoleDefaultGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<NotificationRoleDefaultGroupByOutputType, T['by']> & {
          [P in keyof T & keyof NotificationRoleDefaultGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationRoleDefaultGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationRoleDefaultGroupByOutputType[P]>;
        }
      >
    >;

  export type NotificationRoleDefaultSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      roleName?: boolean;
      module?: boolean;
      eventType?: boolean;
      channels?: boolean;
      enabled?: boolean;
      priority?: boolean;
      metadata?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['notificationRoleDefault']
  >;

  export type NotificationRoleDefaultSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      roleName?: boolean;
      module?: boolean;
      eventType?: boolean;
      channels?: boolean;
      enabled?: boolean;
      priority?: boolean;
      metadata?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['notificationRoleDefault']
  >;

  export type NotificationRoleDefaultSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      roleName?: boolean;
      module?: boolean;
      eventType?: boolean;
      channels?: boolean;
      enabled?: boolean;
      priority?: boolean;
      metadata?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['notificationRoleDefault']
  >;

  export type NotificationRoleDefaultSelectScalar = {
    id?: boolean;
    roleName?: boolean;
    module?: boolean;
    eventType?: boolean;
    channels?: boolean;
    enabled?: boolean;
    priority?: boolean;
    metadata?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type NotificationRoleDefaultOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'roleName'
    | 'module'
    | 'eventType'
    | 'channels'
    | 'enabled'
    | 'priority'
    | 'metadata'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['notificationRoleDefault']
  >;

  export type $NotificationRoleDefaultPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'NotificationRoleDefault';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        roleName: string;
        module: string;
        eventType: string;
        channels: $Enums.NotificationChannel[];
        enabled: boolean;
        priority: $Enums.NotificationPriority | null;
        metadata: Prisma.JsonValue | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['notificationRoleDefault']
    >;
    composites: {};
  };

  type NotificationRoleDefaultGetPayload<
    S extends boolean | null | undefined | NotificationRoleDefaultDefaultArgs,
  > = $Result.GetResult<Prisma.$NotificationRoleDefaultPayload, S>;

  type NotificationRoleDefaultCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<NotificationRoleDefaultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: NotificationRoleDefaultCountAggregateInputType | true;
  };

  export interface NotificationRoleDefaultDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['NotificationRoleDefault'];
      meta: { name: 'NotificationRoleDefault' };
    };
    /**
     * Find zero or one NotificationRoleDefault that matches the filter.
     * @param {NotificationRoleDefaultFindUniqueArgs} args - Arguments to find a NotificationRoleDefault
     * @example
     * // Get one NotificationRoleDefault
     * const notificationRoleDefault = await prisma.notificationRoleDefault.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationRoleDefaultFindUniqueArgs>(
      args: SelectSubset<T, NotificationRoleDefaultFindUniqueArgs<ExtArgs>>,
    ): Prisma__NotificationRoleDefaultClient<
      $Result.GetResult<
        Prisma.$NotificationRoleDefaultPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one NotificationRoleDefault that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationRoleDefaultFindUniqueOrThrowArgs} args - Arguments to find a NotificationRoleDefault
     * @example
     * // Get one NotificationRoleDefault
     * const notificationRoleDefault = await prisma.notificationRoleDefault.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationRoleDefaultFindUniqueOrThrowArgs>(
      args: SelectSubset<T, NotificationRoleDefaultFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__NotificationRoleDefaultClient<
      $Result.GetResult<
        Prisma.$NotificationRoleDefaultPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first NotificationRoleDefault that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRoleDefaultFindFirstArgs} args - Arguments to find a NotificationRoleDefault
     * @example
     * // Get one NotificationRoleDefault
     * const notificationRoleDefault = await prisma.notificationRoleDefault.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationRoleDefaultFindFirstArgs>(
      args?: SelectSubset<T, NotificationRoleDefaultFindFirstArgs<ExtArgs>>,
    ): Prisma__NotificationRoleDefaultClient<
      $Result.GetResult<
        Prisma.$NotificationRoleDefaultPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first NotificationRoleDefault that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRoleDefaultFindFirstOrThrowArgs} args - Arguments to find a NotificationRoleDefault
     * @example
     * // Get one NotificationRoleDefault
     * const notificationRoleDefault = await prisma.notificationRoleDefault.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationRoleDefaultFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NotificationRoleDefaultFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__NotificationRoleDefaultClient<
      $Result.GetResult<
        Prisma.$NotificationRoleDefaultPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more NotificationRoleDefaults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRoleDefaultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationRoleDefaults
     * const notificationRoleDefaults = await prisma.notificationRoleDefault.findMany()
     *
     * // Get first 10 NotificationRoleDefaults
     * const notificationRoleDefaults = await prisma.notificationRoleDefault.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const notificationRoleDefaultWithIdOnly = await prisma.notificationRoleDefault.findMany({ select: { id: true } })
     *
     */
    findMany<T extends NotificationRoleDefaultFindManyArgs>(
      args?: SelectSubset<T, NotificationRoleDefaultFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationRoleDefaultPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a NotificationRoleDefault.
     * @param {NotificationRoleDefaultCreateArgs} args - Arguments to create a NotificationRoleDefault.
     * @example
     * // Create one NotificationRoleDefault
     * const NotificationRoleDefault = await prisma.notificationRoleDefault.create({
     *   data: {
     *     // ... data to create a NotificationRoleDefault
     *   }
     * })
     *
     */
    create<T extends NotificationRoleDefaultCreateArgs>(
      args: SelectSubset<T, NotificationRoleDefaultCreateArgs<ExtArgs>>,
    ): Prisma__NotificationRoleDefaultClient<
      $Result.GetResult<
        Prisma.$NotificationRoleDefaultPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many NotificationRoleDefaults.
     * @param {NotificationRoleDefaultCreateManyArgs} args - Arguments to create many NotificationRoleDefaults.
     * @example
     * // Create many NotificationRoleDefaults
     * const notificationRoleDefault = await prisma.notificationRoleDefault.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends NotificationRoleDefaultCreateManyArgs>(
      args?: SelectSubset<T, NotificationRoleDefaultCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many NotificationRoleDefaults and returns the data saved in the database.
     * @param {NotificationRoleDefaultCreateManyAndReturnArgs} args - Arguments to create many NotificationRoleDefaults.
     * @example
     * // Create many NotificationRoleDefaults
     * const notificationRoleDefault = await prisma.notificationRoleDefault.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many NotificationRoleDefaults and only return the `id`
     * const notificationRoleDefaultWithIdOnly = await prisma.notificationRoleDefault.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends NotificationRoleDefaultCreateManyAndReturnArgs>(
      args?: SelectSubset<T, NotificationRoleDefaultCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationRoleDefaultPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a NotificationRoleDefault.
     * @param {NotificationRoleDefaultDeleteArgs} args - Arguments to delete one NotificationRoleDefault.
     * @example
     * // Delete one NotificationRoleDefault
     * const NotificationRoleDefault = await prisma.notificationRoleDefault.delete({
     *   where: {
     *     // ... filter to delete one NotificationRoleDefault
     *   }
     * })
     *
     */
    delete<T extends NotificationRoleDefaultDeleteArgs>(
      args: SelectSubset<T, NotificationRoleDefaultDeleteArgs<ExtArgs>>,
    ): Prisma__NotificationRoleDefaultClient<
      $Result.GetResult<
        Prisma.$NotificationRoleDefaultPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one NotificationRoleDefault.
     * @param {NotificationRoleDefaultUpdateArgs} args - Arguments to update one NotificationRoleDefault.
     * @example
     * // Update one NotificationRoleDefault
     * const notificationRoleDefault = await prisma.notificationRoleDefault.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends NotificationRoleDefaultUpdateArgs>(
      args: SelectSubset<T, NotificationRoleDefaultUpdateArgs<ExtArgs>>,
    ): Prisma__NotificationRoleDefaultClient<
      $Result.GetResult<
        Prisma.$NotificationRoleDefaultPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more NotificationRoleDefaults.
     * @param {NotificationRoleDefaultDeleteManyArgs} args - Arguments to filter NotificationRoleDefaults to delete.
     * @example
     * // Delete a few NotificationRoleDefaults
     * const { count } = await prisma.notificationRoleDefault.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends NotificationRoleDefaultDeleteManyArgs>(
      args?: SelectSubset<T, NotificationRoleDefaultDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more NotificationRoleDefaults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRoleDefaultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationRoleDefaults
     * const notificationRoleDefault = await prisma.notificationRoleDefault.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends NotificationRoleDefaultUpdateManyArgs>(
      args: SelectSubset<T, NotificationRoleDefaultUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more NotificationRoleDefaults and returns the data updated in the database.
     * @param {NotificationRoleDefaultUpdateManyAndReturnArgs} args - Arguments to update many NotificationRoleDefaults.
     * @example
     * // Update many NotificationRoleDefaults
     * const notificationRoleDefault = await prisma.notificationRoleDefault.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more NotificationRoleDefaults and only return the `id`
     * const notificationRoleDefaultWithIdOnly = await prisma.notificationRoleDefault.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends NotificationRoleDefaultUpdateManyAndReturnArgs>(
      args: SelectSubset<T, NotificationRoleDefaultUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationRoleDefaultPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one NotificationRoleDefault.
     * @param {NotificationRoleDefaultUpsertArgs} args - Arguments to update or create a NotificationRoleDefault.
     * @example
     * // Update or create a NotificationRoleDefault
     * const notificationRoleDefault = await prisma.notificationRoleDefault.upsert({
     *   create: {
     *     // ... data to create a NotificationRoleDefault
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationRoleDefault we want to update
     *   }
     * })
     */
    upsert<T extends NotificationRoleDefaultUpsertArgs>(
      args: SelectSubset<T, NotificationRoleDefaultUpsertArgs<ExtArgs>>,
    ): Prisma__NotificationRoleDefaultClient<
      $Result.GetResult<
        Prisma.$NotificationRoleDefaultPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of NotificationRoleDefaults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRoleDefaultCountArgs} args - Arguments to filter NotificationRoleDefaults to count.
     * @example
     * // Count the number of NotificationRoleDefaults
     * const count = await prisma.notificationRoleDefault.count({
     *   where: {
     *     // ... the filter for the NotificationRoleDefaults we want to count
     *   }
     * })
     **/
    count<T extends NotificationRoleDefaultCountArgs>(
      args?: Subset<T, NotificationRoleDefaultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationRoleDefaultCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a NotificationRoleDefault.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRoleDefaultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends NotificationRoleDefaultAggregateArgs>(
      args: Subset<T, NotificationRoleDefaultAggregateArgs>,
    ): Prisma.PrismaPromise<GetNotificationRoleDefaultAggregateType<T>>;

    /**
     * Group by NotificationRoleDefault.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRoleDefaultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends NotificationRoleDefaultGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationRoleDefaultGroupByArgs['orderBy'] }
        : { orderBy?: NotificationRoleDefaultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, NotificationRoleDefaultGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetNotificationRoleDefaultGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the NotificationRoleDefault model
     */
    readonly fields: NotificationRoleDefaultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationRoleDefault.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationRoleDefaultClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the NotificationRoleDefault model
   */
  interface NotificationRoleDefaultFieldRefs {
    readonly id: FieldRef<'NotificationRoleDefault', 'String'>;
    readonly roleName: FieldRef<'NotificationRoleDefault', 'String'>;
    readonly module: FieldRef<'NotificationRoleDefault', 'String'>;
    readonly eventType: FieldRef<'NotificationRoleDefault', 'String'>;
    readonly channels: FieldRef<'NotificationRoleDefault', 'NotificationChannel[]'>;
    readonly enabled: FieldRef<'NotificationRoleDefault', 'Boolean'>;
    readonly priority: FieldRef<'NotificationRoleDefault', 'NotificationPriority'>;
    readonly metadata: FieldRef<'NotificationRoleDefault', 'Json'>;
    readonly createdAt: FieldRef<'NotificationRoleDefault', 'DateTime'>;
    readonly updatedAt: FieldRef<'NotificationRoleDefault', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * NotificationRoleDefault findUnique
   */
  export type NotificationRoleDefaultFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationRoleDefault
     */
    select?: NotificationRoleDefaultSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationRoleDefault
     */
    omit?: NotificationRoleDefaultOmit<ExtArgs> | null;
    /**
     * Filter, which NotificationRoleDefault to fetch.
     */
    where: NotificationRoleDefaultWhereUniqueInput;
  };

  /**
   * NotificationRoleDefault findUniqueOrThrow
   */
  export type NotificationRoleDefaultFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationRoleDefault
     */
    select?: NotificationRoleDefaultSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationRoleDefault
     */
    omit?: NotificationRoleDefaultOmit<ExtArgs> | null;
    /**
     * Filter, which NotificationRoleDefault to fetch.
     */
    where: NotificationRoleDefaultWhereUniqueInput;
  };

  /**
   * NotificationRoleDefault findFirst
   */
  export type NotificationRoleDefaultFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationRoleDefault
     */
    select?: NotificationRoleDefaultSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationRoleDefault
     */
    omit?: NotificationRoleDefaultOmit<ExtArgs> | null;
    /**
     * Filter, which NotificationRoleDefault to fetch.
     */
    where?: NotificationRoleDefaultWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationRoleDefaults to fetch.
     */
    orderBy?:
      | NotificationRoleDefaultOrderByWithRelationInput
      | NotificationRoleDefaultOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for NotificationRoleDefaults.
     */
    cursor?: NotificationRoleDefaultWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationRoleDefaults from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationRoleDefaults.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of NotificationRoleDefaults.
     */
    distinct?: NotificationRoleDefaultScalarFieldEnum | NotificationRoleDefaultScalarFieldEnum[];
  };

  /**
   * NotificationRoleDefault findFirstOrThrow
   */
  export type NotificationRoleDefaultFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationRoleDefault
     */
    select?: NotificationRoleDefaultSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationRoleDefault
     */
    omit?: NotificationRoleDefaultOmit<ExtArgs> | null;
    /**
     * Filter, which NotificationRoleDefault to fetch.
     */
    where?: NotificationRoleDefaultWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationRoleDefaults to fetch.
     */
    orderBy?:
      | NotificationRoleDefaultOrderByWithRelationInput
      | NotificationRoleDefaultOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for NotificationRoleDefaults.
     */
    cursor?: NotificationRoleDefaultWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationRoleDefaults from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationRoleDefaults.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of NotificationRoleDefaults.
     */
    distinct?: NotificationRoleDefaultScalarFieldEnum | NotificationRoleDefaultScalarFieldEnum[];
  };

  /**
   * NotificationRoleDefault findMany
   */
  export type NotificationRoleDefaultFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationRoleDefault
     */
    select?: NotificationRoleDefaultSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationRoleDefault
     */
    omit?: NotificationRoleDefaultOmit<ExtArgs> | null;
    /**
     * Filter, which NotificationRoleDefaults to fetch.
     */
    where?: NotificationRoleDefaultWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationRoleDefaults to fetch.
     */
    orderBy?:
      | NotificationRoleDefaultOrderByWithRelationInput
      | NotificationRoleDefaultOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing NotificationRoleDefaults.
     */
    cursor?: NotificationRoleDefaultWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationRoleDefaults from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationRoleDefaults.
     */
    skip?: number;
    distinct?: NotificationRoleDefaultScalarFieldEnum | NotificationRoleDefaultScalarFieldEnum[];
  };

  /**
   * NotificationRoleDefault create
   */
  export type NotificationRoleDefaultCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationRoleDefault
     */
    select?: NotificationRoleDefaultSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationRoleDefault
     */
    omit?: NotificationRoleDefaultOmit<ExtArgs> | null;
    /**
     * The data needed to create a NotificationRoleDefault.
     */
    data: XOR<NotificationRoleDefaultCreateInput, NotificationRoleDefaultUncheckedCreateInput>;
  };

  /**
   * NotificationRoleDefault createMany
   */
  export type NotificationRoleDefaultCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many NotificationRoleDefaults.
     */
    data: NotificationRoleDefaultCreateManyInput | NotificationRoleDefaultCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * NotificationRoleDefault createManyAndReturn
   */
  export type NotificationRoleDefaultCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationRoleDefault
     */
    select?: NotificationRoleDefaultSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationRoleDefault
     */
    omit?: NotificationRoleDefaultOmit<ExtArgs> | null;
    /**
     * The data used to create many NotificationRoleDefaults.
     */
    data: NotificationRoleDefaultCreateManyInput | NotificationRoleDefaultCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * NotificationRoleDefault update
   */
  export type NotificationRoleDefaultUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationRoleDefault
     */
    select?: NotificationRoleDefaultSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationRoleDefault
     */
    omit?: NotificationRoleDefaultOmit<ExtArgs> | null;
    /**
     * The data needed to update a NotificationRoleDefault.
     */
    data: XOR<NotificationRoleDefaultUpdateInput, NotificationRoleDefaultUncheckedUpdateInput>;
    /**
     * Choose, which NotificationRoleDefault to update.
     */
    where: NotificationRoleDefaultWhereUniqueInput;
  };

  /**
   * NotificationRoleDefault updateMany
   */
  export type NotificationRoleDefaultUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update NotificationRoleDefaults.
     */
    data: XOR<
      NotificationRoleDefaultUpdateManyMutationInput,
      NotificationRoleDefaultUncheckedUpdateManyInput
    >;
    /**
     * Filter which NotificationRoleDefaults to update
     */
    where?: NotificationRoleDefaultWhereInput;
    /**
     * Limit how many NotificationRoleDefaults to update.
     */
    limit?: number;
  };

  /**
   * NotificationRoleDefault updateManyAndReturn
   */
  export type NotificationRoleDefaultUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationRoleDefault
     */
    select?: NotificationRoleDefaultSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationRoleDefault
     */
    omit?: NotificationRoleDefaultOmit<ExtArgs> | null;
    /**
     * The data used to update NotificationRoleDefaults.
     */
    data: XOR<
      NotificationRoleDefaultUpdateManyMutationInput,
      NotificationRoleDefaultUncheckedUpdateManyInput
    >;
    /**
     * Filter which NotificationRoleDefaults to update
     */
    where?: NotificationRoleDefaultWhereInput;
    /**
     * Limit how many NotificationRoleDefaults to update.
     */
    limit?: number;
  };

  /**
   * NotificationRoleDefault upsert
   */
  export type NotificationRoleDefaultUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationRoleDefault
     */
    select?: NotificationRoleDefaultSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationRoleDefault
     */
    omit?: NotificationRoleDefaultOmit<ExtArgs> | null;
    /**
     * The filter to search for the NotificationRoleDefault to update in case it exists.
     */
    where: NotificationRoleDefaultWhereUniqueInput;
    /**
     * In case the NotificationRoleDefault found by the `where` argument doesn't exist, create a new NotificationRoleDefault with this data.
     */
    create: XOR<NotificationRoleDefaultCreateInput, NotificationRoleDefaultUncheckedCreateInput>;
    /**
     * In case the NotificationRoleDefault was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationRoleDefaultUpdateInput, NotificationRoleDefaultUncheckedUpdateInput>;
  };

  /**
   * NotificationRoleDefault delete
   */
  export type NotificationRoleDefaultDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationRoleDefault
     */
    select?: NotificationRoleDefaultSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationRoleDefault
     */
    omit?: NotificationRoleDefaultOmit<ExtArgs> | null;
    /**
     * Filter which NotificationRoleDefault to delete.
     */
    where: NotificationRoleDefaultWhereUniqueInput;
  };

  /**
   * NotificationRoleDefault deleteMany
   */
  export type NotificationRoleDefaultDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which NotificationRoleDefaults to delete
     */
    where?: NotificationRoleDefaultWhereInput;
    /**
     * Limit how many NotificationRoleDefaults to delete.
     */
    limit?: number;
  };

  /**
   * NotificationRoleDefault without action
   */
  export type NotificationRoleDefaultDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationRoleDefault
     */
    select?: NotificationRoleDefaultSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationRoleDefault
     */
    omit?: NotificationRoleDefaultOmit<ExtArgs> | null;
  };

  /**
   * Model NotificationAuditLog
   */

  export type AggregateNotificationAuditLog = {
    _count: NotificationAuditLogCountAggregateOutputType | null;
    _min: NotificationAuditLogMinAggregateOutputType | null;
    _max: NotificationAuditLogMaxAggregateOutputType | null;
  };

  export type NotificationAuditLogMinAggregateOutputType = {
    id: string | null;
    eventId: string | null;
    action: string | null;
    userId: string | null;
    ipAddress: string | null;
    userAgent: string | null;
    timestamp: Date | null;
  };

  export type NotificationAuditLogMaxAggregateOutputType = {
    id: string | null;
    eventId: string | null;
    action: string | null;
    userId: string | null;
    ipAddress: string | null;
    userAgent: string | null;
    timestamp: Date | null;
  };

  export type NotificationAuditLogCountAggregateOutputType = {
    id: number;
    eventId: number;
    action: number;
    userId: number;
    metadata: number;
    ipAddress: number;
    userAgent: number;
    timestamp: number;
    _all: number;
  };

  export type NotificationAuditLogMinAggregateInputType = {
    id?: true;
    eventId?: true;
    action?: true;
    userId?: true;
    ipAddress?: true;
    userAgent?: true;
    timestamp?: true;
  };

  export type NotificationAuditLogMaxAggregateInputType = {
    id?: true;
    eventId?: true;
    action?: true;
    userId?: true;
    ipAddress?: true;
    userAgent?: true;
    timestamp?: true;
  };

  export type NotificationAuditLogCountAggregateInputType = {
    id?: true;
    eventId?: true;
    action?: true;
    userId?: true;
    metadata?: true;
    ipAddress?: true;
    userAgent?: true;
    timestamp?: true;
    _all?: true;
  };

  export type NotificationAuditLogAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which NotificationAuditLog to aggregate.
     */
    where?: NotificationAuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationAuditLogs to fetch.
     */
    orderBy?:
      | NotificationAuditLogOrderByWithRelationInput
      | NotificationAuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: NotificationAuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationAuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationAuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned NotificationAuditLogs
     **/
    _count?: true | NotificationAuditLogCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: NotificationAuditLogMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: NotificationAuditLogMaxAggregateInputType;
  };

  export type GetNotificationAuditLogAggregateType<T extends NotificationAuditLogAggregateArgs> = {
    [P in keyof T & keyof AggregateNotificationAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationAuditLog[P]>
      : GetScalarType<T[P], AggregateNotificationAuditLog[P]>;
  };

  export type NotificationAuditLogGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificationAuditLogWhereInput;
    orderBy?:
      | NotificationAuditLogOrderByWithAggregationInput
      | NotificationAuditLogOrderByWithAggregationInput[];
    by: NotificationAuditLogScalarFieldEnum[] | NotificationAuditLogScalarFieldEnum;
    having?: NotificationAuditLogScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: NotificationAuditLogCountAggregateInputType | true;
    _min?: NotificationAuditLogMinAggregateInputType;
    _max?: NotificationAuditLogMaxAggregateInputType;
  };

  export type NotificationAuditLogGroupByOutputType = {
    id: string;
    eventId: string;
    action: string;
    userId: string | null;
    metadata: JsonValue | null;
    ipAddress: string | null;
    userAgent: string | null;
    timestamp: Date;
    _count: NotificationAuditLogCountAggregateOutputType | null;
    _min: NotificationAuditLogMinAggregateOutputType | null;
    _max: NotificationAuditLogMaxAggregateOutputType | null;
  };

  type GetNotificationAuditLogGroupByPayload<T extends NotificationAuditLogGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<NotificationAuditLogGroupByOutputType, T['by']> & {
          [P in keyof T & keyof NotificationAuditLogGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationAuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationAuditLogGroupByOutputType[P]>;
        }
      >
    >;

  export type NotificationAuditLogSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      eventId?: boolean;
      action?: boolean;
      userId?: boolean;
      metadata?: boolean;
      ipAddress?: boolean;
      userAgent?: boolean;
      timestamp?: boolean;
      event?: boolean | NotificationEventDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notificationAuditLog']
  >;

  export type NotificationAuditLogSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      eventId?: boolean;
      action?: boolean;
      userId?: boolean;
      metadata?: boolean;
      ipAddress?: boolean;
      userAgent?: boolean;
      timestamp?: boolean;
      event?: boolean | NotificationEventDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notificationAuditLog']
  >;

  export type NotificationAuditLogSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      eventId?: boolean;
      action?: boolean;
      userId?: boolean;
      metadata?: boolean;
      ipAddress?: boolean;
      userAgent?: boolean;
      timestamp?: boolean;
      event?: boolean | NotificationEventDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notificationAuditLog']
  >;

  export type NotificationAuditLogSelectScalar = {
    id?: boolean;
    eventId?: boolean;
    action?: boolean;
    userId?: boolean;
    metadata?: boolean;
    ipAddress?: boolean;
    userAgent?: boolean;
    timestamp?: boolean;
  };

  export type NotificationAuditLogOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'eventId' | 'action' | 'userId' | 'metadata' | 'ipAddress' | 'userAgent' | 'timestamp',
    ExtArgs['result']['notificationAuditLog']
  >;
  export type NotificationAuditLogInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    event?: boolean | NotificationEventDefaultArgs<ExtArgs>;
  };
  export type NotificationAuditLogIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    event?: boolean | NotificationEventDefaultArgs<ExtArgs>;
  };
  export type NotificationAuditLogIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    event?: boolean | NotificationEventDefaultArgs<ExtArgs>;
  };

  export type $NotificationAuditLogPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'NotificationAuditLog';
    objects: {
      event: Prisma.$NotificationEventPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        eventId: string;
        action: string;
        userId: string | null;
        metadata: Prisma.JsonValue | null;
        ipAddress: string | null;
        userAgent: string | null;
        timestamp: Date;
      },
      ExtArgs['result']['notificationAuditLog']
    >;
    composites: {};
  };

  type NotificationAuditLogGetPayload<
    S extends boolean | null | undefined | NotificationAuditLogDefaultArgs,
  > = $Result.GetResult<Prisma.$NotificationAuditLogPayload, S>;

  type NotificationAuditLogCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<NotificationAuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: NotificationAuditLogCountAggregateInputType | true;
  };

  export interface NotificationAuditLogDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['NotificationAuditLog'];
      meta: { name: 'NotificationAuditLog' };
    };
    /**
     * Find zero or one NotificationAuditLog that matches the filter.
     * @param {NotificationAuditLogFindUniqueArgs} args - Arguments to find a NotificationAuditLog
     * @example
     * // Get one NotificationAuditLog
     * const notificationAuditLog = await prisma.notificationAuditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationAuditLogFindUniqueArgs>(
      args: SelectSubset<T, NotificationAuditLogFindUniqueArgs<ExtArgs>>,
    ): Prisma__NotificationAuditLogClient<
      $Result.GetResult<
        Prisma.$NotificationAuditLogPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one NotificationAuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationAuditLogFindUniqueOrThrowArgs} args - Arguments to find a NotificationAuditLog
     * @example
     * // Get one NotificationAuditLog
     * const notificationAuditLog = await prisma.notificationAuditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationAuditLogFindUniqueOrThrowArgs>(
      args: SelectSubset<T, NotificationAuditLogFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__NotificationAuditLogClient<
      $Result.GetResult<
        Prisma.$NotificationAuditLogPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first NotificationAuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAuditLogFindFirstArgs} args - Arguments to find a NotificationAuditLog
     * @example
     * // Get one NotificationAuditLog
     * const notificationAuditLog = await prisma.notificationAuditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationAuditLogFindFirstArgs>(
      args?: SelectSubset<T, NotificationAuditLogFindFirstArgs<ExtArgs>>,
    ): Prisma__NotificationAuditLogClient<
      $Result.GetResult<
        Prisma.$NotificationAuditLogPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first NotificationAuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAuditLogFindFirstOrThrowArgs} args - Arguments to find a NotificationAuditLog
     * @example
     * // Get one NotificationAuditLog
     * const notificationAuditLog = await prisma.notificationAuditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationAuditLogFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NotificationAuditLogFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__NotificationAuditLogClient<
      $Result.GetResult<
        Prisma.$NotificationAuditLogPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more NotificationAuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationAuditLogs
     * const notificationAuditLogs = await prisma.notificationAuditLog.findMany()
     *
     * // Get first 10 NotificationAuditLogs
     * const notificationAuditLogs = await prisma.notificationAuditLog.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const notificationAuditLogWithIdOnly = await prisma.notificationAuditLog.findMany({ select: { id: true } })
     *
     */
    findMany<T extends NotificationAuditLogFindManyArgs>(
      args?: SelectSubset<T, NotificationAuditLogFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationAuditLogPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a NotificationAuditLog.
     * @param {NotificationAuditLogCreateArgs} args - Arguments to create a NotificationAuditLog.
     * @example
     * // Create one NotificationAuditLog
     * const NotificationAuditLog = await prisma.notificationAuditLog.create({
     *   data: {
     *     // ... data to create a NotificationAuditLog
     *   }
     * })
     *
     */
    create<T extends NotificationAuditLogCreateArgs>(
      args: SelectSubset<T, NotificationAuditLogCreateArgs<ExtArgs>>,
    ): Prisma__NotificationAuditLogClient<
      $Result.GetResult<
        Prisma.$NotificationAuditLogPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many NotificationAuditLogs.
     * @param {NotificationAuditLogCreateManyArgs} args - Arguments to create many NotificationAuditLogs.
     * @example
     * // Create many NotificationAuditLogs
     * const notificationAuditLog = await prisma.notificationAuditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends NotificationAuditLogCreateManyArgs>(
      args?: SelectSubset<T, NotificationAuditLogCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many NotificationAuditLogs and returns the data saved in the database.
     * @param {NotificationAuditLogCreateManyAndReturnArgs} args - Arguments to create many NotificationAuditLogs.
     * @example
     * // Create many NotificationAuditLogs
     * const notificationAuditLog = await prisma.notificationAuditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many NotificationAuditLogs and only return the `id`
     * const notificationAuditLogWithIdOnly = await prisma.notificationAuditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends NotificationAuditLogCreateManyAndReturnArgs>(
      args?: SelectSubset<T, NotificationAuditLogCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationAuditLogPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a NotificationAuditLog.
     * @param {NotificationAuditLogDeleteArgs} args - Arguments to delete one NotificationAuditLog.
     * @example
     * // Delete one NotificationAuditLog
     * const NotificationAuditLog = await prisma.notificationAuditLog.delete({
     *   where: {
     *     // ... filter to delete one NotificationAuditLog
     *   }
     * })
     *
     */
    delete<T extends NotificationAuditLogDeleteArgs>(
      args: SelectSubset<T, NotificationAuditLogDeleteArgs<ExtArgs>>,
    ): Prisma__NotificationAuditLogClient<
      $Result.GetResult<
        Prisma.$NotificationAuditLogPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one NotificationAuditLog.
     * @param {NotificationAuditLogUpdateArgs} args - Arguments to update one NotificationAuditLog.
     * @example
     * // Update one NotificationAuditLog
     * const notificationAuditLog = await prisma.notificationAuditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends NotificationAuditLogUpdateArgs>(
      args: SelectSubset<T, NotificationAuditLogUpdateArgs<ExtArgs>>,
    ): Prisma__NotificationAuditLogClient<
      $Result.GetResult<
        Prisma.$NotificationAuditLogPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more NotificationAuditLogs.
     * @param {NotificationAuditLogDeleteManyArgs} args - Arguments to filter NotificationAuditLogs to delete.
     * @example
     * // Delete a few NotificationAuditLogs
     * const { count } = await prisma.notificationAuditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends NotificationAuditLogDeleteManyArgs>(
      args?: SelectSubset<T, NotificationAuditLogDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more NotificationAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationAuditLogs
     * const notificationAuditLog = await prisma.notificationAuditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends NotificationAuditLogUpdateManyArgs>(
      args: SelectSubset<T, NotificationAuditLogUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more NotificationAuditLogs and returns the data updated in the database.
     * @param {NotificationAuditLogUpdateManyAndReturnArgs} args - Arguments to update many NotificationAuditLogs.
     * @example
     * // Update many NotificationAuditLogs
     * const notificationAuditLog = await prisma.notificationAuditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more NotificationAuditLogs and only return the `id`
     * const notificationAuditLogWithIdOnly = await prisma.notificationAuditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends NotificationAuditLogUpdateManyAndReturnArgs>(
      args: SelectSubset<T, NotificationAuditLogUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationAuditLogPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one NotificationAuditLog.
     * @param {NotificationAuditLogUpsertArgs} args - Arguments to update or create a NotificationAuditLog.
     * @example
     * // Update or create a NotificationAuditLog
     * const notificationAuditLog = await prisma.notificationAuditLog.upsert({
     *   create: {
     *     // ... data to create a NotificationAuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationAuditLog we want to update
     *   }
     * })
     */
    upsert<T extends NotificationAuditLogUpsertArgs>(
      args: SelectSubset<T, NotificationAuditLogUpsertArgs<ExtArgs>>,
    ): Prisma__NotificationAuditLogClient<
      $Result.GetResult<
        Prisma.$NotificationAuditLogPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of NotificationAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAuditLogCountArgs} args - Arguments to filter NotificationAuditLogs to count.
     * @example
     * // Count the number of NotificationAuditLogs
     * const count = await prisma.notificationAuditLog.count({
     *   where: {
     *     // ... the filter for the NotificationAuditLogs we want to count
     *   }
     * })
     **/
    count<T extends NotificationAuditLogCountArgs>(
      args?: Subset<T, NotificationAuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationAuditLogCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a NotificationAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends NotificationAuditLogAggregateArgs>(
      args: Subset<T, NotificationAuditLogAggregateArgs>,
    ): Prisma.PrismaPromise<GetNotificationAuditLogAggregateType<T>>;

    /**
     * Group by NotificationAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends NotificationAuditLogGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationAuditLogGroupByArgs['orderBy'] }
        : { orderBy?: NotificationAuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, NotificationAuditLogGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetNotificationAuditLogGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the NotificationAuditLog model
     */
    readonly fields: NotificationAuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationAuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationAuditLogClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    event<T extends NotificationEventDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, NotificationEventDefaultArgs<ExtArgs>>,
    ): Prisma__NotificationEventClient<
      | $Result.GetResult<
          Prisma.$NotificationEventPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the NotificationAuditLog model
   */
  interface NotificationAuditLogFieldRefs {
    readonly id: FieldRef<'NotificationAuditLog', 'String'>;
    readonly eventId: FieldRef<'NotificationAuditLog', 'String'>;
    readonly action: FieldRef<'NotificationAuditLog', 'String'>;
    readonly userId: FieldRef<'NotificationAuditLog', 'String'>;
    readonly metadata: FieldRef<'NotificationAuditLog', 'Json'>;
    readonly ipAddress: FieldRef<'NotificationAuditLog', 'String'>;
    readonly userAgent: FieldRef<'NotificationAuditLog', 'String'>;
    readonly timestamp: FieldRef<'NotificationAuditLog', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * NotificationAuditLog findUnique
   */
  export type NotificationAuditLogFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationAuditLog
     */
    select?: NotificationAuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationAuditLog
     */
    omit?: NotificationAuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationAuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationAuditLog to fetch.
     */
    where: NotificationAuditLogWhereUniqueInput;
  };

  /**
   * NotificationAuditLog findUniqueOrThrow
   */
  export type NotificationAuditLogFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationAuditLog
     */
    select?: NotificationAuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationAuditLog
     */
    omit?: NotificationAuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationAuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationAuditLog to fetch.
     */
    where: NotificationAuditLogWhereUniqueInput;
  };

  /**
   * NotificationAuditLog findFirst
   */
  export type NotificationAuditLogFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationAuditLog
     */
    select?: NotificationAuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationAuditLog
     */
    omit?: NotificationAuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationAuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationAuditLog to fetch.
     */
    where?: NotificationAuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationAuditLogs to fetch.
     */
    orderBy?:
      | NotificationAuditLogOrderByWithRelationInput
      | NotificationAuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for NotificationAuditLogs.
     */
    cursor?: NotificationAuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationAuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationAuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of NotificationAuditLogs.
     */
    distinct?: NotificationAuditLogScalarFieldEnum | NotificationAuditLogScalarFieldEnum[];
  };

  /**
   * NotificationAuditLog findFirstOrThrow
   */
  export type NotificationAuditLogFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationAuditLog
     */
    select?: NotificationAuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationAuditLog
     */
    omit?: NotificationAuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationAuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationAuditLog to fetch.
     */
    where?: NotificationAuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationAuditLogs to fetch.
     */
    orderBy?:
      | NotificationAuditLogOrderByWithRelationInput
      | NotificationAuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for NotificationAuditLogs.
     */
    cursor?: NotificationAuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationAuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationAuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of NotificationAuditLogs.
     */
    distinct?: NotificationAuditLogScalarFieldEnum | NotificationAuditLogScalarFieldEnum[];
  };

  /**
   * NotificationAuditLog findMany
   */
  export type NotificationAuditLogFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationAuditLog
     */
    select?: NotificationAuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationAuditLog
     */
    omit?: NotificationAuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationAuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which NotificationAuditLogs to fetch.
     */
    where?: NotificationAuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationAuditLogs to fetch.
     */
    orderBy?:
      | NotificationAuditLogOrderByWithRelationInput
      | NotificationAuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing NotificationAuditLogs.
     */
    cursor?: NotificationAuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationAuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationAuditLogs.
     */
    skip?: number;
    distinct?: NotificationAuditLogScalarFieldEnum | NotificationAuditLogScalarFieldEnum[];
  };

  /**
   * NotificationAuditLog create
   */
  export type NotificationAuditLogCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationAuditLog
     */
    select?: NotificationAuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationAuditLog
     */
    omit?: NotificationAuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationAuditLogInclude<ExtArgs> | null;
    /**
     * The data needed to create a NotificationAuditLog.
     */
    data: XOR<NotificationAuditLogCreateInput, NotificationAuditLogUncheckedCreateInput>;
  };

  /**
   * NotificationAuditLog createMany
   */
  export type NotificationAuditLogCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many NotificationAuditLogs.
     */
    data: NotificationAuditLogCreateManyInput | NotificationAuditLogCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * NotificationAuditLog createManyAndReturn
   */
  export type NotificationAuditLogCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationAuditLog
     */
    select?: NotificationAuditLogSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationAuditLog
     */
    omit?: NotificationAuditLogOmit<ExtArgs> | null;
    /**
     * The data used to create many NotificationAuditLogs.
     */
    data: NotificationAuditLogCreateManyInput | NotificationAuditLogCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationAuditLogIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * NotificationAuditLog update
   */
  export type NotificationAuditLogUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationAuditLog
     */
    select?: NotificationAuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationAuditLog
     */
    omit?: NotificationAuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationAuditLogInclude<ExtArgs> | null;
    /**
     * The data needed to update a NotificationAuditLog.
     */
    data: XOR<NotificationAuditLogUpdateInput, NotificationAuditLogUncheckedUpdateInput>;
    /**
     * Choose, which NotificationAuditLog to update.
     */
    where: NotificationAuditLogWhereUniqueInput;
  };

  /**
   * NotificationAuditLog updateMany
   */
  export type NotificationAuditLogUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update NotificationAuditLogs.
     */
    data: XOR<
      NotificationAuditLogUpdateManyMutationInput,
      NotificationAuditLogUncheckedUpdateManyInput
    >;
    /**
     * Filter which NotificationAuditLogs to update
     */
    where?: NotificationAuditLogWhereInput;
    /**
     * Limit how many NotificationAuditLogs to update.
     */
    limit?: number;
  };

  /**
   * NotificationAuditLog updateManyAndReturn
   */
  export type NotificationAuditLogUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationAuditLog
     */
    select?: NotificationAuditLogSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationAuditLog
     */
    omit?: NotificationAuditLogOmit<ExtArgs> | null;
    /**
     * The data used to update NotificationAuditLogs.
     */
    data: XOR<
      NotificationAuditLogUpdateManyMutationInput,
      NotificationAuditLogUncheckedUpdateManyInput
    >;
    /**
     * Filter which NotificationAuditLogs to update
     */
    where?: NotificationAuditLogWhereInput;
    /**
     * Limit how many NotificationAuditLogs to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationAuditLogIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * NotificationAuditLog upsert
   */
  export type NotificationAuditLogUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationAuditLog
     */
    select?: NotificationAuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationAuditLog
     */
    omit?: NotificationAuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationAuditLogInclude<ExtArgs> | null;
    /**
     * The filter to search for the NotificationAuditLog to update in case it exists.
     */
    where: NotificationAuditLogWhereUniqueInput;
    /**
     * In case the NotificationAuditLog found by the `where` argument doesn't exist, create a new NotificationAuditLog with this data.
     */
    create: XOR<NotificationAuditLogCreateInput, NotificationAuditLogUncheckedCreateInput>;
    /**
     * In case the NotificationAuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationAuditLogUpdateInput, NotificationAuditLogUncheckedUpdateInput>;
  };

  /**
   * NotificationAuditLog delete
   */
  export type NotificationAuditLogDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationAuditLog
     */
    select?: NotificationAuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationAuditLog
     */
    omit?: NotificationAuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationAuditLogInclude<ExtArgs> | null;
    /**
     * Filter which NotificationAuditLog to delete.
     */
    where: NotificationAuditLogWhereUniqueInput;
  };

  /**
   * NotificationAuditLog deleteMany
   */
  export type NotificationAuditLogDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which NotificationAuditLogs to delete
     */
    where?: NotificationAuditLogWhereInput;
    /**
     * Limit how many NotificationAuditLogs to delete.
     */
    limit?: number;
  };

  /**
   * NotificationAuditLog without action
   */
  export type NotificationAuditLogDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationAuditLog
     */
    select?: NotificationAuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationAuditLog
     */
    omit?: NotificationAuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationAuditLogInclude<ExtArgs> | null;
  };

  /**
   * Model RoleNotificationDefaults
   */

  export type AggregateRoleNotificationDefaults = {
    _count: RoleNotificationDefaultsCountAggregateOutputType | null;
    _min: RoleNotificationDefaultsMinAggregateOutputType | null;
    _max: RoleNotificationDefaultsMaxAggregateOutputType | null;
  };

  export type RoleNotificationDefaultsMinAggregateOutputType = {
    id: string | null;
    roleId: string | null;
    module: string | null;
    eventType: string | null;
    priority: $Enums.NotificationPriority | null;
    digestEnabled: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    createdBy: string | null;
  };

  export type RoleNotificationDefaultsMaxAggregateOutputType = {
    id: string | null;
    roleId: string | null;
    module: string | null;
    eventType: string | null;
    priority: $Enums.NotificationPriority | null;
    digestEnabled: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    createdBy: string | null;
  };

  export type RoleNotificationDefaultsCountAggregateOutputType = {
    id: number;
    roleId: number;
    module: number;
    eventType: number;
    channels: number;
    priority: number;
    digestEnabled: number;
    createdAt: number;
    updatedAt: number;
    createdBy: number;
    _all: number;
  };

  export type RoleNotificationDefaultsMinAggregateInputType = {
    id?: true;
    roleId?: true;
    module?: true;
    eventType?: true;
    priority?: true;
    digestEnabled?: true;
    createdAt?: true;
    updatedAt?: true;
    createdBy?: true;
  };

  export type RoleNotificationDefaultsMaxAggregateInputType = {
    id?: true;
    roleId?: true;
    module?: true;
    eventType?: true;
    priority?: true;
    digestEnabled?: true;
    createdAt?: true;
    updatedAt?: true;
    createdBy?: true;
  };

  export type RoleNotificationDefaultsCountAggregateInputType = {
    id?: true;
    roleId?: true;
    module?: true;
    eventType?: true;
    channels?: true;
    priority?: true;
    digestEnabled?: true;
    createdAt?: true;
    updatedAt?: true;
    createdBy?: true;
    _all?: true;
  };

  export type RoleNotificationDefaultsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which RoleNotificationDefaults to aggregate.
     */
    where?: RoleNotificationDefaultsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RoleNotificationDefaults to fetch.
     */
    orderBy?:
      | RoleNotificationDefaultsOrderByWithRelationInput
      | RoleNotificationDefaultsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: RoleNotificationDefaultsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RoleNotificationDefaults from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RoleNotificationDefaults.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned RoleNotificationDefaults
     **/
    _count?: true | RoleNotificationDefaultsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: RoleNotificationDefaultsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: RoleNotificationDefaultsMaxAggregateInputType;
  };

  export type GetRoleNotificationDefaultsAggregateType<
    T extends RoleNotificationDefaultsAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateRoleNotificationDefaults]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoleNotificationDefaults[P]>
      : GetScalarType<T[P], AggregateRoleNotificationDefaults[P]>;
  };

  export type RoleNotificationDefaultsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RoleNotificationDefaultsWhereInput;
    orderBy?:
      | RoleNotificationDefaultsOrderByWithAggregationInput
      | RoleNotificationDefaultsOrderByWithAggregationInput[];
    by: RoleNotificationDefaultsScalarFieldEnum[] | RoleNotificationDefaultsScalarFieldEnum;
    having?: RoleNotificationDefaultsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: RoleNotificationDefaultsCountAggregateInputType | true;
    _min?: RoleNotificationDefaultsMinAggregateInputType;
    _max?: RoleNotificationDefaultsMaxAggregateInputType;
  };

  export type RoleNotificationDefaultsGroupByOutputType = {
    id: string;
    roleId: string;
    module: string;
    eventType: string;
    channels: $Enums.NotificationChannel[];
    priority: $Enums.NotificationPriority;
    digestEnabled: boolean;
    createdAt: Date;
    updatedAt: Date;
    createdBy: string | null;
    _count: RoleNotificationDefaultsCountAggregateOutputType | null;
    _min: RoleNotificationDefaultsMinAggregateOutputType | null;
    _max: RoleNotificationDefaultsMaxAggregateOutputType | null;
  };

  type GetRoleNotificationDefaultsGroupByPayload<T extends RoleNotificationDefaultsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<RoleNotificationDefaultsGroupByOutputType, T['by']> & {
          [P in keyof T & keyof RoleNotificationDefaultsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleNotificationDefaultsGroupByOutputType[P]>
            : GetScalarType<T[P], RoleNotificationDefaultsGroupByOutputType[P]>;
        }
      >
    >;

  export type RoleNotificationDefaultsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      roleId?: boolean;
      module?: boolean;
      eventType?: boolean;
      channels?: boolean;
      priority?: boolean;
      digestEnabled?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      createdBy?: boolean;
    },
    ExtArgs['result']['roleNotificationDefaults']
  >;

  export type RoleNotificationDefaultsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      roleId?: boolean;
      module?: boolean;
      eventType?: boolean;
      channels?: boolean;
      priority?: boolean;
      digestEnabled?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      createdBy?: boolean;
    },
    ExtArgs['result']['roleNotificationDefaults']
  >;

  export type RoleNotificationDefaultsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      roleId?: boolean;
      module?: boolean;
      eventType?: boolean;
      channels?: boolean;
      priority?: boolean;
      digestEnabled?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      createdBy?: boolean;
    },
    ExtArgs['result']['roleNotificationDefaults']
  >;

  export type RoleNotificationDefaultsSelectScalar = {
    id?: boolean;
    roleId?: boolean;
    module?: boolean;
    eventType?: boolean;
    channels?: boolean;
    priority?: boolean;
    digestEnabled?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    createdBy?: boolean;
  };

  export type RoleNotificationDefaultsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'roleId'
    | 'module'
    | 'eventType'
    | 'channels'
    | 'priority'
    | 'digestEnabled'
    | 'createdAt'
    | 'updatedAt'
    | 'createdBy',
    ExtArgs['result']['roleNotificationDefaults']
  >;

  export type $RoleNotificationDefaultsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'RoleNotificationDefaults';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        roleId: string;
        module: string;
        eventType: string;
        channels: $Enums.NotificationChannel[];
        priority: $Enums.NotificationPriority;
        digestEnabled: boolean;
        createdAt: Date;
        updatedAt: Date;
        createdBy: string | null;
      },
      ExtArgs['result']['roleNotificationDefaults']
    >;
    composites: {};
  };

  type RoleNotificationDefaultsGetPayload<
    S extends boolean | null | undefined | RoleNotificationDefaultsDefaultArgs,
  > = $Result.GetResult<Prisma.$RoleNotificationDefaultsPayload, S>;

  type RoleNotificationDefaultsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<RoleNotificationDefaultsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: RoleNotificationDefaultsCountAggregateInputType | true;
  };

  export interface RoleNotificationDefaultsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['RoleNotificationDefaults'];
      meta: { name: 'RoleNotificationDefaults' };
    };
    /**
     * Find zero or one RoleNotificationDefaults that matches the filter.
     * @param {RoleNotificationDefaultsFindUniqueArgs} args - Arguments to find a RoleNotificationDefaults
     * @example
     * // Get one RoleNotificationDefaults
     * const roleNotificationDefaults = await prisma.roleNotificationDefaults.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleNotificationDefaultsFindUniqueArgs>(
      args: SelectSubset<T, RoleNotificationDefaultsFindUniqueArgs<ExtArgs>>,
    ): Prisma__RoleNotificationDefaultsClient<
      $Result.GetResult<
        Prisma.$RoleNotificationDefaultsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one RoleNotificationDefaults that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleNotificationDefaultsFindUniqueOrThrowArgs} args - Arguments to find a RoleNotificationDefaults
     * @example
     * // Get one RoleNotificationDefaults
     * const roleNotificationDefaults = await prisma.roleNotificationDefaults.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleNotificationDefaultsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, RoleNotificationDefaultsFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__RoleNotificationDefaultsClient<
      $Result.GetResult<
        Prisma.$RoleNotificationDefaultsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first RoleNotificationDefaults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleNotificationDefaultsFindFirstArgs} args - Arguments to find a RoleNotificationDefaults
     * @example
     * // Get one RoleNotificationDefaults
     * const roleNotificationDefaults = await prisma.roleNotificationDefaults.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleNotificationDefaultsFindFirstArgs>(
      args?: SelectSubset<T, RoleNotificationDefaultsFindFirstArgs<ExtArgs>>,
    ): Prisma__RoleNotificationDefaultsClient<
      $Result.GetResult<
        Prisma.$RoleNotificationDefaultsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first RoleNotificationDefaults that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleNotificationDefaultsFindFirstOrThrowArgs} args - Arguments to find a RoleNotificationDefaults
     * @example
     * // Get one RoleNotificationDefaults
     * const roleNotificationDefaults = await prisma.roleNotificationDefaults.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleNotificationDefaultsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RoleNotificationDefaultsFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__RoleNotificationDefaultsClient<
      $Result.GetResult<
        Prisma.$RoleNotificationDefaultsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more RoleNotificationDefaults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleNotificationDefaultsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoleNotificationDefaults
     * const roleNotificationDefaults = await prisma.roleNotificationDefaults.findMany()
     *
     * // Get first 10 RoleNotificationDefaults
     * const roleNotificationDefaults = await prisma.roleNotificationDefaults.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const roleNotificationDefaultsWithIdOnly = await prisma.roleNotificationDefaults.findMany({ select: { id: true } })
     *
     */
    findMany<T extends RoleNotificationDefaultsFindManyArgs>(
      args?: SelectSubset<T, RoleNotificationDefaultsFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$RoleNotificationDefaultsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a RoleNotificationDefaults.
     * @param {RoleNotificationDefaultsCreateArgs} args - Arguments to create a RoleNotificationDefaults.
     * @example
     * // Create one RoleNotificationDefaults
     * const RoleNotificationDefaults = await prisma.roleNotificationDefaults.create({
     *   data: {
     *     // ... data to create a RoleNotificationDefaults
     *   }
     * })
     *
     */
    create<T extends RoleNotificationDefaultsCreateArgs>(
      args: SelectSubset<T, RoleNotificationDefaultsCreateArgs<ExtArgs>>,
    ): Prisma__RoleNotificationDefaultsClient<
      $Result.GetResult<
        Prisma.$RoleNotificationDefaultsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many RoleNotificationDefaults.
     * @param {RoleNotificationDefaultsCreateManyArgs} args - Arguments to create many RoleNotificationDefaults.
     * @example
     * // Create many RoleNotificationDefaults
     * const roleNotificationDefaults = await prisma.roleNotificationDefaults.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends RoleNotificationDefaultsCreateManyArgs>(
      args?: SelectSubset<T, RoleNotificationDefaultsCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many RoleNotificationDefaults and returns the data saved in the database.
     * @param {RoleNotificationDefaultsCreateManyAndReturnArgs} args - Arguments to create many RoleNotificationDefaults.
     * @example
     * // Create many RoleNotificationDefaults
     * const roleNotificationDefaults = await prisma.roleNotificationDefaults.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many RoleNotificationDefaults and only return the `id`
     * const roleNotificationDefaultsWithIdOnly = await prisma.roleNotificationDefaults.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends RoleNotificationDefaultsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, RoleNotificationDefaultsCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$RoleNotificationDefaultsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a RoleNotificationDefaults.
     * @param {RoleNotificationDefaultsDeleteArgs} args - Arguments to delete one RoleNotificationDefaults.
     * @example
     * // Delete one RoleNotificationDefaults
     * const RoleNotificationDefaults = await prisma.roleNotificationDefaults.delete({
     *   where: {
     *     // ... filter to delete one RoleNotificationDefaults
     *   }
     * })
     *
     */
    delete<T extends RoleNotificationDefaultsDeleteArgs>(
      args: SelectSubset<T, RoleNotificationDefaultsDeleteArgs<ExtArgs>>,
    ): Prisma__RoleNotificationDefaultsClient<
      $Result.GetResult<
        Prisma.$RoleNotificationDefaultsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one RoleNotificationDefaults.
     * @param {RoleNotificationDefaultsUpdateArgs} args - Arguments to update one RoleNotificationDefaults.
     * @example
     * // Update one RoleNotificationDefaults
     * const roleNotificationDefaults = await prisma.roleNotificationDefaults.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends RoleNotificationDefaultsUpdateArgs>(
      args: SelectSubset<T, RoleNotificationDefaultsUpdateArgs<ExtArgs>>,
    ): Prisma__RoleNotificationDefaultsClient<
      $Result.GetResult<
        Prisma.$RoleNotificationDefaultsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more RoleNotificationDefaults.
     * @param {RoleNotificationDefaultsDeleteManyArgs} args - Arguments to filter RoleNotificationDefaults to delete.
     * @example
     * // Delete a few RoleNotificationDefaults
     * const { count } = await prisma.roleNotificationDefaults.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends RoleNotificationDefaultsDeleteManyArgs>(
      args?: SelectSubset<T, RoleNotificationDefaultsDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more RoleNotificationDefaults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleNotificationDefaultsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoleNotificationDefaults
     * const roleNotificationDefaults = await prisma.roleNotificationDefaults.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends RoleNotificationDefaultsUpdateManyArgs>(
      args: SelectSubset<T, RoleNotificationDefaultsUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more RoleNotificationDefaults and returns the data updated in the database.
     * @param {RoleNotificationDefaultsUpdateManyAndReturnArgs} args - Arguments to update many RoleNotificationDefaults.
     * @example
     * // Update many RoleNotificationDefaults
     * const roleNotificationDefaults = await prisma.roleNotificationDefaults.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more RoleNotificationDefaults and only return the `id`
     * const roleNotificationDefaultsWithIdOnly = await prisma.roleNotificationDefaults.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends RoleNotificationDefaultsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, RoleNotificationDefaultsUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$RoleNotificationDefaultsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one RoleNotificationDefaults.
     * @param {RoleNotificationDefaultsUpsertArgs} args - Arguments to update or create a RoleNotificationDefaults.
     * @example
     * // Update or create a RoleNotificationDefaults
     * const roleNotificationDefaults = await prisma.roleNotificationDefaults.upsert({
     *   create: {
     *     // ... data to create a RoleNotificationDefaults
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoleNotificationDefaults we want to update
     *   }
     * })
     */
    upsert<T extends RoleNotificationDefaultsUpsertArgs>(
      args: SelectSubset<T, RoleNotificationDefaultsUpsertArgs<ExtArgs>>,
    ): Prisma__RoleNotificationDefaultsClient<
      $Result.GetResult<
        Prisma.$RoleNotificationDefaultsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of RoleNotificationDefaults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleNotificationDefaultsCountArgs} args - Arguments to filter RoleNotificationDefaults to count.
     * @example
     * // Count the number of RoleNotificationDefaults
     * const count = await prisma.roleNotificationDefaults.count({
     *   where: {
     *     // ... the filter for the RoleNotificationDefaults we want to count
     *   }
     * })
     **/
    count<T extends RoleNotificationDefaultsCountArgs>(
      args?: Subset<T, RoleNotificationDefaultsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleNotificationDefaultsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a RoleNotificationDefaults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleNotificationDefaultsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends RoleNotificationDefaultsAggregateArgs>(
      args: Subset<T, RoleNotificationDefaultsAggregateArgs>,
    ): Prisma.PrismaPromise<GetRoleNotificationDefaultsAggregateType<T>>;

    /**
     * Group by RoleNotificationDefaults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleNotificationDefaultsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends RoleNotificationDefaultsGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleNotificationDefaultsGroupByArgs['orderBy'] }
        : { orderBy?: RoleNotificationDefaultsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, RoleNotificationDefaultsGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetRoleNotificationDefaultsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the RoleNotificationDefaults model
     */
    readonly fields: RoleNotificationDefaultsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoleNotificationDefaults.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleNotificationDefaultsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the RoleNotificationDefaults model
   */
  interface RoleNotificationDefaultsFieldRefs {
    readonly id: FieldRef<'RoleNotificationDefaults', 'String'>;
    readonly roleId: FieldRef<'RoleNotificationDefaults', 'String'>;
    readonly module: FieldRef<'RoleNotificationDefaults', 'String'>;
    readonly eventType: FieldRef<'RoleNotificationDefaults', 'String'>;
    readonly channels: FieldRef<'RoleNotificationDefaults', 'NotificationChannel[]'>;
    readonly priority: FieldRef<'RoleNotificationDefaults', 'NotificationPriority'>;
    readonly digestEnabled: FieldRef<'RoleNotificationDefaults', 'Boolean'>;
    readonly createdAt: FieldRef<'RoleNotificationDefaults', 'DateTime'>;
    readonly updatedAt: FieldRef<'RoleNotificationDefaults', 'DateTime'>;
    readonly createdBy: FieldRef<'RoleNotificationDefaults', 'String'>;
  }

  // Custom InputTypes
  /**
   * RoleNotificationDefaults findUnique
   */
  export type RoleNotificationDefaultsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RoleNotificationDefaults
     */
    select?: RoleNotificationDefaultsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RoleNotificationDefaults
     */
    omit?: RoleNotificationDefaultsOmit<ExtArgs> | null;
    /**
     * Filter, which RoleNotificationDefaults to fetch.
     */
    where: RoleNotificationDefaultsWhereUniqueInput;
  };

  /**
   * RoleNotificationDefaults findUniqueOrThrow
   */
  export type RoleNotificationDefaultsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RoleNotificationDefaults
     */
    select?: RoleNotificationDefaultsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RoleNotificationDefaults
     */
    omit?: RoleNotificationDefaultsOmit<ExtArgs> | null;
    /**
     * Filter, which RoleNotificationDefaults to fetch.
     */
    where: RoleNotificationDefaultsWhereUniqueInput;
  };

  /**
   * RoleNotificationDefaults findFirst
   */
  export type RoleNotificationDefaultsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RoleNotificationDefaults
     */
    select?: RoleNotificationDefaultsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RoleNotificationDefaults
     */
    omit?: RoleNotificationDefaultsOmit<ExtArgs> | null;
    /**
     * Filter, which RoleNotificationDefaults to fetch.
     */
    where?: RoleNotificationDefaultsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RoleNotificationDefaults to fetch.
     */
    orderBy?:
      | RoleNotificationDefaultsOrderByWithRelationInput
      | RoleNotificationDefaultsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for RoleNotificationDefaults.
     */
    cursor?: RoleNotificationDefaultsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RoleNotificationDefaults from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RoleNotificationDefaults.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of RoleNotificationDefaults.
     */
    distinct?: RoleNotificationDefaultsScalarFieldEnum | RoleNotificationDefaultsScalarFieldEnum[];
  };

  /**
   * RoleNotificationDefaults findFirstOrThrow
   */
  export type RoleNotificationDefaultsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RoleNotificationDefaults
     */
    select?: RoleNotificationDefaultsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RoleNotificationDefaults
     */
    omit?: RoleNotificationDefaultsOmit<ExtArgs> | null;
    /**
     * Filter, which RoleNotificationDefaults to fetch.
     */
    where?: RoleNotificationDefaultsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RoleNotificationDefaults to fetch.
     */
    orderBy?:
      | RoleNotificationDefaultsOrderByWithRelationInput
      | RoleNotificationDefaultsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for RoleNotificationDefaults.
     */
    cursor?: RoleNotificationDefaultsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RoleNotificationDefaults from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RoleNotificationDefaults.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of RoleNotificationDefaults.
     */
    distinct?: RoleNotificationDefaultsScalarFieldEnum | RoleNotificationDefaultsScalarFieldEnum[];
  };

  /**
   * RoleNotificationDefaults findMany
   */
  export type RoleNotificationDefaultsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RoleNotificationDefaults
     */
    select?: RoleNotificationDefaultsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RoleNotificationDefaults
     */
    omit?: RoleNotificationDefaultsOmit<ExtArgs> | null;
    /**
     * Filter, which RoleNotificationDefaults to fetch.
     */
    where?: RoleNotificationDefaultsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RoleNotificationDefaults to fetch.
     */
    orderBy?:
      | RoleNotificationDefaultsOrderByWithRelationInput
      | RoleNotificationDefaultsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing RoleNotificationDefaults.
     */
    cursor?: RoleNotificationDefaultsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RoleNotificationDefaults from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RoleNotificationDefaults.
     */
    skip?: number;
    distinct?: RoleNotificationDefaultsScalarFieldEnum | RoleNotificationDefaultsScalarFieldEnum[];
  };

  /**
   * RoleNotificationDefaults create
   */
  export type RoleNotificationDefaultsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RoleNotificationDefaults
     */
    select?: RoleNotificationDefaultsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RoleNotificationDefaults
     */
    omit?: RoleNotificationDefaultsOmit<ExtArgs> | null;
    /**
     * The data needed to create a RoleNotificationDefaults.
     */
    data: XOR<RoleNotificationDefaultsCreateInput, RoleNotificationDefaultsUncheckedCreateInput>;
  };

  /**
   * RoleNotificationDefaults createMany
   */
  export type RoleNotificationDefaultsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many RoleNotificationDefaults.
     */
    data: RoleNotificationDefaultsCreateManyInput | RoleNotificationDefaultsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * RoleNotificationDefaults createManyAndReturn
   */
  export type RoleNotificationDefaultsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RoleNotificationDefaults
     */
    select?: RoleNotificationDefaultsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the RoleNotificationDefaults
     */
    omit?: RoleNotificationDefaultsOmit<ExtArgs> | null;
    /**
     * The data used to create many RoleNotificationDefaults.
     */
    data: RoleNotificationDefaultsCreateManyInput | RoleNotificationDefaultsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * RoleNotificationDefaults update
   */
  export type RoleNotificationDefaultsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RoleNotificationDefaults
     */
    select?: RoleNotificationDefaultsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RoleNotificationDefaults
     */
    omit?: RoleNotificationDefaultsOmit<ExtArgs> | null;
    /**
     * The data needed to update a RoleNotificationDefaults.
     */
    data: XOR<RoleNotificationDefaultsUpdateInput, RoleNotificationDefaultsUncheckedUpdateInput>;
    /**
     * Choose, which RoleNotificationDefaults to update.
     */
    where: RoleNotificationDefaultsWhereUniqueInput;
  };

  /**
   * RoleNotificationDefaults updateMany
   */
  export type RoleNotificationDefaultsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update RoleNotificationDefaults.
     */
    data: XOR<
      RoleNotificationDefaultsUpdateManyMutationInput,
      RoleNotificationDefaultsUncheckedUpdateManyInput
    >;
    /**
     * Filter which RoleNotificationDefaults to update
     */
    where?: RoleNotificationDefaultsWhereInput;
    /**
     * Limit how many RoleNotificationDefaults to update.
     */
    limit?: number;
  };

  /**
   * RoleNotificationDefaults updateManyAndReturn
   */
  export type RoleNotificationDefaultsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RoleNotificationDefaults
     */
    select?: RoleNotificationDefaultsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the RoleNotificationDefaults
     */
    omit?: RoleNotificationDefaultsOmit<ExtArgs> | null;
    /**
     * The data used to update RoleNotificationDefaults.
     */
    data: XOR<
      RoleNotificationDefaultsUpdateManyMutationInput,
      RoleNotificationDefaultsUncheckedUpdateManyInput
    >;
    /**
     * Filter which RoleNotificationDefaults to update
     */
    where?: RoleNotificationDefaultsWhereInput;
    /**
     * Limit how many RoleNotificationDefaults to update.
     */
    limit?: number;
  };

  /**
   * RoleNotificationDefaults upsert
   */
  export type RoleNotificationDefaultsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RoleNotificationDefaults
     */
    select?: RoleNotificationDefaultsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RoleNotificationDefaults
     */
    omit?: RoleNotificationDefaultsOmit<ExtArgs> | null;
    /**
     * The filter to search for the RoleNotificationDefaults to update in case it exists.
     */
    where: RoleNotificationDefaultsWhereUniqueInput;
    /**
     * In case the RoleNotificationDefaults found by the `where` argument doesn't exist, create a new RoleNotificationDefaults with this data.
     */
    create: XOR<RoleNotificationDefaultsCreateInput, RoleNotificationDefaultsUncheckedCreateInput>;
    /**
     * In case the RoleNotificationDefaults was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleNotificationDefaultsUpdateInput, RoleNotificationDefaultsUncheckedUpdateInput>;
  };

  /**
   * RoleNotificationDefaults delete
   */
  export type RoleNotificationDefaultsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RoleNotificationDefaults
     */
    select?: RoleNotificationDefaultsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RoleNotificationDefaults
     */
    omit?: RoleNotificationDefaultsOmit<ExtArgs> | null;
    /**
     * Filter which RoleNotificationDefaults to delete.
     */
    where: RoleNotificationDefaultsWhereUniqueInput;
  };

  /**
   * RoleNotificationDefaults deleteMany
   */
  export type RoleNotificationDefaultsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which RoleNotificationDefaults to delete
     */
    where?: RoleNotificationDefaultsWhereInput;
    /**
     * Limit how many RoleNotificationDefaults to delete.
     */
    limit?: number;
  };

  /**
   * RoleNotificationDefaults without action
   */
  export type RoleNotificationDefaultsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RoleNotificationDefaults
     */
    select?: RoleNotificationDefaultsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RoleNotificationDefaults
     */
    omit?: RoleNotificationDefaultsOmit<ExtArgs> | null;
  };

  /**
   * Model NotificationAnalytics
   */

  export type AggregateNotificationAnalytics = {
    _count: NotificationAnalyticsCountAggregateOutputType | null;
    _avg: NotificationAnalyticsAvgAggregateOutputType | null;
    _sum: NotificationAnalyticsSumAggregateOutputType | null;
    _min: NotificationAnalyticsMinAggregateOutputType | null;
    _max: NotificationAnalyticsMaxAggregateOutputType | null;
  };

  export type NotificationAnalyticsAvgAggregateOutputType = {
    hour: number | null;
    eventsCreated: number | null;
    notificationsSent: number | null;
    delivered: number | null;
    failed: number | null;
    opened: number | null;
    clicked: number | null;
    dismissed: number | null;
    avgResponseTime: number | null;
    maxResponseTime: number | null;
  };

  export type NotificationAnalyticsSumAggregateOutputType = {
    hour: number | null;
    eventsCreated: number | null;
    notificationsSent: number | null;
    delivered: number | null;
    failed: number | null;
    opened: number | null;
    clicked: number | null;
    dismissed: number | null;
    avgResponseTime: number | null;
    maxResponseTime: number | null;
  };

  export type NotificationAnalyticsMinAggregateOutputType = {
    id: string | null;
    date: Date | null;
    hour: number | null;
    module: string | null;
    eventType: string | null;
    channel: $Enums.NotificationChannel | null;
    priority: $Enums.NotificationPriority | null;
    userId: string | null;
    tenantId: string | null;
    eventsCreated: number | null;
    notificationsSent: number | null;
    delivered: number | null;
    failed: number | null;
    opened: number | null;
    clicked: number | null;
    dismissed: number | null;
    avgResponseTime: number | null;
    maxResponseTime: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type NotificationAnalyticsMaxAggregateOutputType = {
    id: string | null;
    date: Date | null;
    hour: number | null;
    module: string | null;
    eventType: string | null;
    channel: $Enums.NotificationChannel | null;
    priority: $Enums.NotificationPriority | null;
    userId: string | null;
    tenantId: string | null;
    eventsCreated: number | null;
    notificationsSent: number | null;
    delivered: number | null;
    failed: number | null;
    opened: number | null;
    clicked: number | null;
    dismissed: number | null;
    avgResponseTime: number | null;
    maxResponseTime: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type NotificationAnalyticsCountAggregateOutputType = {
    id: number;
    date: number;
    hour: number;
    module: number;
    eventType: number;
    channel: number;
    priority: number;
    userId: number;
    tenantId: number;
    eventsCreated: number;
    notificationsSent: number;
    delivered: number;
    failed: number;
    opened: number;
    clicked: number;
    dismissed: number;
    avgResponseTime: number;
    maxResponseTime: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type NotificationAnalyticsAvgAggregateInputType = {
    hour?: true;
    eventsCreated?: true;
    notificationsSent?: true;
    delivered?: true;
    failed?: true;
    opened?: true;
    clicked?: true;
    dismissed?: true;
    avgResponseTime?: true;
    maxResponseTime?: true;
  };

  export type NotificationAnalyticsSumAggregateInputType = {
    hour?: true;
    eventsCreated?: true;
    notificationsSent?: true;
    delivered?: true;
    failed?: true;
    opened?: true;
    clicked?: true;
    dismissed?: true;
    avgResponseTime?: true;
    maxResponseTime?: true;
  };

  export type NotificationAnalyticsMinAggregateInputType = {
    id?: true;
    date?: true;
    hour?: true;
    module?: true;
    eventType?: true;
    channel?: true;
    priority?: true;
    userId?: true;
    tenantId?: true;
    eventsCreated?: true;
    notificationsSent?: true;
    delivered?: true;
    failed?: true;
    opened?: true;
    clicked?: true;
    dismissed?: true;
    avgResponseTime?: true;
    maxResponseTime?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type NotificationAnalyticsMaxAggregateInputType = {
    id?: true;
    date?: true;
    hour?: true;
    module?: true;
    eventType?: true;
    channel?: true;
    priority?: true;
    userId?: true;
    tenantId?: true;
    eventsCreated?: true;
    notificationsSent?: true;
    delivered?: true;
    failed?: true;
    opened?: true;
    clicked?: true;
    dismissed?: true;
    avgResponseTime?: true;
    maxResponseTime?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type NotificationAnalyticsCountAggregateInputType = {
    id?: true;
    date?: true;
    hour?: true;
    module?: true;
    eventType?: true;
    channel?: true;
    priority?: true;
    userId?: true;
    tenantId?: true;
    eventsCreated?: true;
    notificationsSent?: true;
    delivered?: true;
    failed?: true;
    opened?: true;
    clicked?: true;
    dismissed?: true;
    avgResponseTime?: true;
    maxResponseTime?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type NotificationAnalyticsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which NotificationAnalytics to aggregate.
     */
    where?: NotificationAnalyticsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationAnalytics to fetch.
     */
    orderBy?:
      | NotificationAnalyticsOrderByWithRelationInput
      | NotificationAnalyticsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: NotificationAnalyticsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationAnalytics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationAnalytics.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned NotificationAnalytics
     **/
    _count?: true | NotificationAnalyticsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: NotificationAnalyticsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: NotificationAnalyticsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: NotificationAnalyticsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: NotificationAnalyticsMaxAggregateInputType;
  };

  export type GetNotificationAnalyticsAggregateType<T extends NotificationAnalyticsAggregateArgs> =
    {
      [P in keyof T & keyof AggregateNotificationAnalytics]: P extends '_count' | 'count'
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateNotificationAnalytics[P]>
        : GetScalarType<T[P], AggregateNotificationAnalytics[P]>;
    };

  export type NotificationAnalyticsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificationAnalyticsWhereInput;
    orderBy?:
      | NotificationAnalyticsOrderByWithAggregationInput
      | NotificationAnalyticsOrderByWithAggregationInput[];
    by: NotificationAnalyticsScalarFieldEnum[] | NotificationAnalyticsScalarFieldEnum;
    having?: NotificationAnalyticsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: NotificationAnalyticsCountAggregateInputType | true;
    _avg?: NotificationAnalyticsAvgAggregateInputType;
    _sum?: NotificationAnalyticsSumAggregateInputType;
    _min?: NotificationAnalyticsMinAggregateInputType;
    _max?: NotificationAnalyticsMaxAggregateInputType;
  };

  export type NotificationAnalyticsGroupByOutputType = {
    id: string;
    date: Date;
    hour: number | null;
    module: string | null;
    eventType: string | null;
    channel: $Enums.NotificationChannel | null;
    priority: $Enums.NotificationPriority | null;
    userId: string | null;
    tenantId: string | null;
    eventsCreated: number;
    notificationsSent: number;
    delivered: number;
    failed: number;
    opened: number;
    clicked: number;
    dismissed: number;
    avgResponseTime: number | null;
    maxResponseTime: number | null;
    createdAt: Date;
    updatedAt: Date;
    _count: NotificationAnalyticsCountAggregateOutputType | null;
    _avg: NotificationAnalyticsAvgAggregateOutputType | null;
    _sum: NotificationAnalyticsSumAggregateOutputType | null;
    _min: NotificationAnalyticsMinAggregateOutputType | null;
    _max: NotificationAnalyticsMaxAggregateOutputType | null;
  };

  type GetNotificationAnalyticsGroupByPayload<T extends NotificationAnalyticsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<NotificationAnalyticsGroupByOutputType, T['by']> & {
          [P in keyof T & keyof NotificationAnalyticsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationAnalyticsGroupByOutputType[P]>;
        }
      >
    >;

  export type NotificationAnalyticsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      date?: boolean;
      hour?: boolean;
      module?: boolean;
      eventType?: boolean;
      channel?: boolean;
      priority?: boolean;
      userId?: boolean;
      tenantId?: boolean;
      eventsCreated?: boolean;
      notificationsSent?: boolean;
      delivered?: boolean;
      failed?: boolean;
      opened?: boolean;
      clicked?: boolean;
      dismissed?: boolean;
      avgResponseTime?: boolean;
      maxResponseTime?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['notificationAnalytics']
  >;

  export type NotificationAnalyticsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      date?: boolean;
      hour?: boolean;
      module?: boolean;
      eventType?: boolean;
      channel?: boolean;
      priority?: boolean;
      userId?: boolean;
      tenantId?: boolean;
      eventsCreated?: boolean;
      notificationsSent?: boolean;
      delivered?: boolean;
      failed?: boolean;
      opened?: boolean;
      clicked?: boolean;
      dismissed?: boolean;
      avgResponseTime?: boolean;
      maxResponseTime?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['notificationAnalytics']
  >;

  export type NotificationAnalyticsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      date?: boolean;
      hour?: boolean;
      module?: boolean;
      eventType?: boolean;
      channel?: boolean;
      priority?: boolean;
      userId?: boolean;
      tenantId?: boolean;
      eventsCreated?: boolean;
      notificationsSent?: boolean;
      delivered?: boolean;
      failed?: boolean;
      opened?: boolean;
      clicked?: boolean;
      dismissed?: boolean;
      avgResponseTime?: boolean;
      maxResponseTime?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['notificationAnalytics']
  >;

  export type NotificationAnalyticsSelectScalar = {
    id?: boolean;
    date?: boolean;
    hour?: boolean;
    module?: boolean;
    eventType?: boolean;
    channel?: boolean;
    priority?: boolean;
    userId?: boolean;
    tenantId?: boolean;
    eventsCreated?: boolean;
    notificationsSent?: boolean;
    delivered?: boolean;
    failed?: boolean;
    opened?: boolean;
    clicked?: boolean;
    dismissed?: boolean;
    avgResponseTime?: boolean;
    maxResponseTime?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type NotificationAnalyticsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'date'
    | 'hour'
    | 'module'
    | 'eventType'
    | 'channel'
    | 'priority'
    | 'userId'
    | 'tenantId'
    | 'eventsCreated'
    | 'notificationsSent'
    | 'delivered'
    | 'failed'
    | 'opened'
    | 'clicked'
    | 'dismissed'
    | 'avgResponseTime'
    | 'maxResponseTime'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['notificationAnalytics']
  >;

  export type $NotificationAnalyticsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'NotificationAnalytics';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        date: Date;
        hour: number | null;
        module: string | null;
        eventType: string | null;
        channel: $Enums.NotificationChannel | null;
        priority: $Enums.NotificationPriority | null;
        userId: string | null;
        tenantId: string | null;
        eventsCreated: number;
        notificationsSent: number;
        delivered: number;
        failed: number;
        opened: number;
        clicked: number;
        dismissed: number;
        avgResponseTime: number | null;
        maxResponseTime: number | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['notificationAnalytics']
    >;
    composites: {};
  };

  type NotificationAnalyticsGetPayload<
    S extends boolean | null | undefined | NotificationAnalyticsDefaultArgs,
  > = $Result.GetResult<Prisma.$NotificationAnalyticsPayload, S>;

  type NotificationAnalyticsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<NotificationAnalyticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: NotificationAnalyticsCountAggregateInputType | true;
  };

  export interface NotificationAnalyticsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['NotificationAnalytics'];
      meta: { name: 'NotificationAnalytics' };
    };
    /**
     * Find zero or one NotificationAnalytics that matches the filter.
     * @param {NotificationAnalyticsFindUniqueArgs} args - Arguments to find a NotificationAnalytics
     * @example
     * // Get one NotificationAnalytics
     * const notificationAnalytics = await prisma.notificationAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationAnalyticsFindUniqueArgs>(
      args: SelectSubset<T, NotificationAnalyticsFindUniqueArgs<ExtArgs>>,
    ): Prisma__NotificationAnalyticsClient<
      $Result.GetResult<
        Prisma.$NotificationAnalyticsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one NotificationAnalytics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a NotificationAnalytics
     * @example
     * // Get one NotificationAnalytics
     * const notificationAnalytics = await prisma.notificationAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationAnalyticsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, NotificationAnalyticsFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__NotificationAnalyticsClient<
      $Result.GetResult<
        Prisma.$NotificationAnalyticsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first NotificationAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAnalyticsFindFirstArgs} args - Arguments to find a NotificationAnalytics
     * @example
     * // Get one NotificationAnalytics
     * const notificationAnalytics = await prisma.notificationAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationAnalyticsFindFirstArgs>(
      args?: SelectSubset<T, NotificationAnalyticsFindFirstArgs<ExtArgs>>,
    ): Prisma__NotificationAnalyticsClient<
      $Result.GetResult<
        Prisma.$NotificationAnalyticsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first NotificationAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAnalyticsFindFirstOrThrowArgs} args - Arguments to find a NotificationAnalytics
     * @example
     * // Get one NotificationAnalytics
     * const notificationAnalytics = await prisma.notificationAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationAnalyticsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NotificationAnalyticsFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__NotificationAnalyticsClient<
      $Result.GetResult<
        Prisma.$NotificationAnalyticsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more NotificationAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationAnalytics
     * const notificationAnalytics = await prisma.notificationAnalytics.findMany()
     *
     * // Get first 10 NotificationAnalytics
     * const notificationAnalytics = await prisma.notificationAnalytics.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const notificationAnalyticsWithIdOnly = await prisma.notificationAnalytics.findMany({ select: { id: true } })
     *
     */
    findMany<T extends NotificationAnalyticsFindManyArgs>(
      args?: SelectSubset<T, NotificationAnalyticsFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationAnalyticsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a NotificationAnalytics.
     * @param {NotificationAnalyticsCreateArgs} args - Arguments to create a NotificationAnalytics.
     * @example
     * // Create one NotificationAnalytics
     * const NotificationAnalytics = await prisma.notificationAnalytics.create({
     *   data: {
     *     // ... data to create a NotificationAnalytics
     *   }
     * })
     *
     */
    create<T extends NotificationAnalyticsCreateArgs>(
      args: SelectSubset<T, NotificationAnalyticsCreateArgs<ExtArgs>>,
    ): Prisma__NotificationAnalyticsClient<
      $Result.GetResult<
        Prisma.$NotificationAnalyticsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many NotificationAnalytics.
     * @param {NotificationAnalyticsCreateManyArgs} args - Arguments to create many NotificationAnalytics.
     * @example
     * // Create many NotificationAnalytics
     * const notificationAnalytics = await prisma.notificationAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends NotificationAnalyticsCreateManyArgs>(
      args?: SelectSubset<T, NotificationAnalyticsCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many NotificationAnalytics and returns the data saved in the database.
     * @param {NotificationAnalyticsCreateManyAndReturnArgs} args - Arguments to create many NotificationAnalytics.
     * @example
     * // Create many NotificationAnalytics
     * const notificationAnalytics = await prisma.notificationAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many NotificationAnalytics and only return the `id`
     * const notificationAnalyticsWithIdOnly = await prisma.notificationAnalytics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends NotificationAnalyticsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, NotificationAnalyticsCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationAnalyticsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a NotificationAnalytics.
     * @param {NotificationAnalyticsDeleteArgs} args - Arguments to delete one NotificationAnalytics.
     * @example
     * // Delete one NotificationAnalytics
     * const NotificationAnalytics = await prisma.notificationAnalytics.delete({
     *   where: {
     *     // ... filter to delete one NotificationAnalytics
     *   }
     * })
     *
     */
    delete<T extends NotificationAnalyticsDeleteArgs>(
      args: SelectSubset<T, NotificationAnalyticsDeleteArgs<ExtArgs>>,
    ): Prisma__NotificationAnalyticsClient<
      $Result.GetResult<
        Prisma.$NotificationAnalyticsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one NotificationAnalytics.
     * @param {NotificationAnalyticsUpdateArgs} args - Arguments to update one NotificationAnalytics.
     * @example
     * // Update one NotificationAnalytics
     * const notificationAnalytics = await prisma.notificationAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends NotificationAnalyticsUpdateArgs>(
      args: SelectSubset<T, NotificationAnalyticsUpdateArgs<ExtArgs>>,
    ): Prisma__NotificationAnalyticsClient<
      $Result.GetResult<
        Prisma.$NotificationAnalyticsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more NotificationAnalytics.
     * @param {NotificationAnalyticsDeleteManyArgs} args - Arguments to filter NotificationAnalytics to delete.
     * @example
     * // Delete a few NotificationAnalytics
     * const { count } = await prisma.notificationAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends NotificationAnalyticsDeleteManyArgs>(
      args?: SelectSubset<T, NotificationAnalyticsDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more NotificationAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationAnalytics
     * const notificationAnalytics = await prisma.notificationAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends NotificationAnalyticsUpdateManyArgs>(
      args: SelectSubset<T, NotificationAnalyticsUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more NotificationAnalytics and returns the data updated in the database.
     * @param {NotificationAnalyticsUpdateManyAndReturnArgs} args - Arguments to update many NotificationAnalytics.
     * @example
     * // Update many NotificationAnalytics
     * const notificationAnalytics = await prisma.notificationAnalytics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more NotificationAnalytics and only return the `id`
     * const notificationAnalyticsWithIdOnly = await prisma.notificationAnalytics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends NotificationAnalyticsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, NotificationAnalyticsUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationAnalyticsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one NotificationAnalytics.
     * @param {NotificationAnalyticsUpsertArgs} args - Arguments to update or create a NotificationAnalytics.
     * @example
     * // Update or create a NotificationAnalytics
     * const notificationAnalytics = await prisma.notificationAnalytics.upsert({
     *   create: {
     *     // ... data to create a NotificationAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends NotificationAnalyticsUpsertArgs>(
      args: SelectSubset<T, NotificationAnalyticsUpsertArgs<ExtArgs>>,
    ): Prisma__NotificationAnalyticsClient<
      $Result.GetResult<
        Prisma.$NotificationAnalyticsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of NotificationAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAnalyticsCountArgs} args - Arguments to filter NotificationAnalytics to count.
     * @example
     * // Count the number of NotificationAnalytics
     * const count = await prisma.notificationAnalytics.count({
     *   where: {
     *     // ... the filter for the NotificationAnalytics we want to count
     *   }
     * })
     **/
    count<T extends NotificationAnalyticsCountArgs>(
      args?: Subset<T, NotificationAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationAnalyticsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a NotificationAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends NotificationAnalyticsAggregateArgs>(
      args: Subset<T, NotificationAnalyticsAggregateArgs>,
    ): Prisma.PrismaPromise<GetNotificationAnalyticsAggregateType<T>>;

    /**
     * Group by NotificationAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends NotificationAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: NotificationAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, NotificationAnalyticsGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetNotificationAnalyticsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the NotificationAnalytics model
     */
    readonly fields: NotificationAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationAnalyticsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the NotificationAnalytics model
   */
  interface NotificationAnalyticsFieldRefs {
    readonly id: FieldRef<'NotificationAnalytics', 'String'>;
    readonly date: FieldRef<'NotificationAnalytics', 'DateTime'>;
    readonly hour: FieldRef<'NotificationAnalytics', 'Int'>;
    readonly module: FieldRef<'NotificationAnalytics', 'String'>;
    readonly eventType: FieldRef<'NotificationAnalytics', 'String'>;
    readonly channel: FieldRef<'NotificationAnalytics', 'NotificationChannel'>;
    readonly priority: FieldRef<'NotificationAnalytics', 'NotificationPriority'>;
    readonly userId: FieldRef<'NotificationAnalytics', 'String'>;
    readonly tenantId: FieldRef<'NotificationAnalytics', 'String'>;
    readonly eventsCreated: FieldRef<'NotificationAnalytics', 'Int'>;
    readonly notificationsSent: FieldRef<'NotificationAnalytics', 'Int'>;
    readonly delivered: FieldRef<'NotificationAnalytics', 'Int'>;
    readonly failed: FieldRef<'NotificationAnalytics', 'Int'>;
    readonly opened: FieldRef<'NotificationAnalytics', 'Int'>;
    readonly clicked: FieldRef<'NotificationAnalytics', 'Int'>;
    readonly dismissed: FieldRef<'NotificationAnalytics', 'Int'>;
    readonly avgResponseTime: FieldRef<'NotificationAnalytics', 'Float'>;
    readonly maxResponseTime: FieldRef<'NotificationAnalytics', 'Int'>;
    readonly createdAt: FieldRef<'NotificationAnalytics', 'DateTime'>;
    readonly updatedAt: FieldRef<'NotificationAnalytics', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * NotificationAnalytics findUnique
   */
  export type NotificationAnalyticsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationAnalytics
     */
    select?: NotificationAnalyticsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationAnalytics
     */
    omit?: NotificationAnalyticsOmit<ExtArgs> | null;
    /**
     * Filter, which NotificationAnalytics to fetch.
     */
    where: NotificationAnalyticsWhereUniqueInput;
  };

  /**
   * NotificationAnalytics findUniqueOrThrow
   */
  export type NotificationAnalyticsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationAnalytics
     */
    select?: NotificationAnalyticsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationAnalytics
     */
    omit?: NotificationAnalyticsOmit<ExtArgs> | null;
    /**
     * Filter, which NotificationAnalytics to fetch.
     */
    where: NotificationAnalyticsWhereUniqueInput;
  };

  /**
   * NotificationAnalytics findFirst
   */
  export type NotificationAnalyticsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationAnalytics
     */
    select?: NotificationAnalyticsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationAnalytics
     */
    omit?: NotificationAnalyticsOmit<ExtArgs> | null;
    /**
     * Filter, which NotificationAnalytics to fetch.
     */
    where?: NotificationAnalyticsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationAnalytics to fetch.
     */
    orderBy?:
      | NotificationAnalyticsOrderByWithRelationInput
      | NotificationAnalyticsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for NotificationAnalytics.
     */
    cursor?: NotificationAnalyticsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationAnalytics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationAnalytics.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of NotificationAnalytics.
     */
    distinct?: NotificationAnalyticsScalarFieldEnum | NotificationAnalyticsScalarFieldEnum[];
  };

  /**
   * NotificationAnalytics findFirstOrThrow
   */
  export type NotificationAnalyticsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationAnalytics
     */
    select?: NotificationAnalyticsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationAnalytics
     */
    omit?: NotificationAnalyticsOmit<ExtArgs> | null;
    /**
     * Filter, which NotificationAnalytics to fetch.
     */
    where?: NotificationAnalyticsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationAnalytics to fetch.
     */
    orderBy?:
      | NotificationAnalyticsOrderByWithRelationInput
      | NotificationAnalyticsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for NotificationAnalytics.
     */
    cursor?: NotificationAnalyticsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationAnalytics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationAnalytics.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of NotificationAnalytics.
     */
    distinct?: NotificationAnalyticsScalarFieldEnum | NotificationAnalyticsScalarFieldEnum[];
  };

  /**
   * NotificationAnalytics findMany
   */
  export type NotificationAnalyticsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationAnalytics
     */
    select?: NotificationAnalyticsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationAnalytics
     */
    omit?: NotificationAnalyticsOmit<ExtArgs> | null;
    /**
     * Filter, which NotificationAnalytics to fetch.
     */
    where?: NotificationAnalyticsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of NotificationAnalytics to fetch.
     */
    orderBy?:
      | NotificationAnalyticsOrderByWithRelationInput
      | NotificationAnalyticsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing NotificationAnalytics.
     */
    cursor?: NotificationAnalyticsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` NotificationAnalytics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` NotificationAnalytics.
     */
    skip?: number;
    distinct?: NotificationAnalyticsScalarFieldEnum | NotificationAnalyticsScalarFieldEnum[];
  };

  /**
   * NotificationAnalytics create
   */
  export type NotificationAnalyticsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationAnalytics
     */
    select?: NotificationAnalyticsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationAnalytics
     */
    omit?: NotificationAnalyticsOmit<ExtArgs> | null;
    /**
     * The data needed to create a NotificationAnalytics.
     */
    data: XOR<NotificationAnalyticsCreateInput, NotificationAnalyticsUncheckedCreateInput>;
  };

  /**
   * NotificationAnalytics createMany
   */
  export type NotificationAnalyticsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many NotificationAnalytics.
     */
    data: NotificationAnalyticsCreateManyInput | NotificationAnalyticsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * NotificationAnalytics createManyAndReturn
   */
  export type NotificationAnalyticsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationAnalytics
     */
    select?: NotificationAnalyticsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationAnalytics
     */
    omit?: NotificationAnalyticsOmit<ExtArgs> | null;
    /**
     * The data used to create many NotificationAnalytics.
     */
    data: NotificationAnalyticsCreateManyInput | NotificationAnalyticsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * NotificationAnalytics update
   */
  export type NotificationAnalyticsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationAnalytics
     */
    select?: NotificationAnalyticsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationAnalytics
     */
    omit?: NotificationAnalyticsOmit<ExtArgs> | null;
    /**
     * The data needed to update a NotificationAnalytics.
     */
    data: XOR<NotificationAnalyticsUpdateInput, NotificationAnalyticsUncheckedUpdateInput>;
    /**
     * Choose, which NotificationAnalytics to update.
     */
    where: NotificationAnalyticsWhereUniqueInput;
  };

  /**
   * NotificationAnalytics updateMany
   */
  export type NotificationAnalyticsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update NotificationAnalytics.
     */
    data: XOR<
      NotificationAnalyticsUpdateManyMutationInput,
      NotificationAnalyticsUncheckedUpdateManyInput
    >;
    /**
     * Filter which NotificationAnalytics to update
     */
    where?: NotificationAnalyticsWhereInput;
    /**
     * Limit how many NotificationAnalytics to update.
     */
    limit?: number;
  };

  /**
   * NotificationAnalytics updateManyAndReturn
   */
  export type NotificationAnalyticsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationAnalytics
     */
    select?: NotificationAnalyticsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationAnalytics
     */
    omit?: NotificationAnalyticsOmit<ExtArgs> | null;
    /**
     * The data used to update NotificationAnalytics.
     */
    data: XOR<
      NotificationAnalyticsUpdateManyMutationInput,
      NotificationAnalyticsUncheckedUpdateManyInput
    >;
    /**
     * Filter which NotificationAnalytics to update
     */
    where?: NotificationAnalyticsWhereInput;
    /**
     * Limit how many NotificationAnalytics to update.
     */
    limit?: number;
  };

  /**
   * NotificationAnalytics upsert
   */
  export type NotificationAnalyticsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationAnalytics
     */
    select?: NotificationAnalyticsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationAnalytics
     */
    omit?: NotificationAnalyticsOmit<ExtArgs> | null;
    /**
     * The filter to search for the NotificationAnalytics to update in case it exists.
     */
    where: NotificationAnalyticsWhereUniqueInput;
    /**
     * In case the NotificationAnalytics found by the `where` argument doesn't exist, create a new NotificationAnalytics with this data.
     */
    create: XOR<NotificationAnalyticsCreateInput, NotificationAnalyticsUncheckedCreateInput>;
    /**
     * In case the NotificationAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationAnalyticsUpdateInput, NotificationAnalyticsUncheckedUpdateInput>;
  };

  /**
   * NotificationAnalytics delete
   */
  export type NotificationAnalyticsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationAnalytics
     */
    select?: NotificationAnalyticsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationAnalytics
     */
    omit?: NotificationAnalyticsOmit<ExtArgs> | null;
    /**
     * Filter which NotificationAnalytics to delete.
     */
    where: NotificationAnalyticsWhereUniqueInput;
  };

  /**
   * NotificationAnalytics deleteMany
   */
  export type NotificationAnalyticsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which NotificationAnalytics to delete
     */
    where?: NotificationAnalyticsWhereInput;
    /**
     * Limit how many NotificationAnalytics to delete.
     */
    limit?: number;
  };

  /**
   * NotificationAnalytics without action
   */
  export type NotificationAnalyticsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NotificationAnalytics
     */
    select?: NotificationAnalyticsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the NotificationAnalytics
     */
    omit?: NotificationAnalyticsOmit<ExtArgs> | null;
  };

  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted';
    ReadCommitted: 'ReadCommitted';
    RepeatableRead: 'RepeatableRead';
    Serializable: 'Serializable';
  };

  export type TransactionIsolationLevel =
    (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

  export const NotificationEventScalarFieldEnum: {
    id: 'id';
    eventId: 'eventId';
    module: 'module';
    eventType: 'eventType';
    priority: 'priority';
    title: 'title';
    message: 'message';
    details: 'details';
    recipientRoles: 'recipientRoles';
    recipientUsers: 'recipientUsers';
    tenantId: 'tenantId';
    actions: 'actions';
    metadata: 'metadata';
    status: 'status';
    scheduledFor: 'scheduledFor';
    expiresAt: 'expiresAt';
    createdAt: 'createdAt';
    createdBy: 'createdBy';
    processedAt: 'processedAt';
  };

  export type NotificationEventScalarFieldEnum =
    (typeof NotificationEventScalarFieldEnum)[keyof typeof NotificationEventScalarFieldEnum];

  export const NotificationPreferenceScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    module: 'module';
    eventType: 'eventType';
    channels: 'channels';
    priority: 'priority';
    digestEnabled: 'digestEnabled';
    digestFrequency: 'digestFrequency';
    dndEnabled: 'dndEnabled';
    dndStartTime: 'dndStartTime';
    dndEndTime: 'dndEndTime';
    dndDays: 'dndDays';
    aiSummaryEnabled: 'aiSummaryEnabled';
    aiGroupingEnabled: 'aiGroupingEnabled';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type NotificationPreferenceScalarFieldEnum =
    (typeof NotificationPreferenceScalarFieldEnum)[keyof typeof NotificationPreferenceScalarFieldEnum];

  export const NotificationScalarFieldEnum: {
    id: 'id';
    eventId: 'eventId';
    userId: 'userId';
    channel: 'channel';
    title: 'title';
    message: 'message';
    details: 'details';
    actions: 'actions';
    status: 'status';
    priority: 'priority';
    scheduledFor: 'scheduledFor';
    deliveredAt: 'deliveredAt';
    readAt: 'readAt';
    clickedAt: 'clickedAt';
    dismissedAt: 'dismissedAt';
    retryCount: 'retryCount';
    maxRetries: 'maxRetries';
    nextRetry: 'nextRetry';
    aiSummary: 'aiSummary';
    groupId: 'groupId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type NotificationScalarFieldEnum =
    (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum];

  export const NotificationDeliveryScalarFieldEnum: {
    id: 'id';
    notificationId: 'notificationId';
    eventId: 'eventId';
    userId: 'userId';
    channel: 'channel';
    provider: 'provider';
    providerConfig: 'providerConfig';
    status: 'status';
    deliveredAt: 'deliveredAt';
    failedAt: 'failedAt';
    errorMessage: 'errorMessage';
    errorCode: 'errorCode';
    providerResponse: 'providerResponse';
    messageId: 'messageId';
    responseTime: 'responseTime';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type NotificationDeliveryScalarFieldEnum =
    (typeof NotificationDeliveryScalarFieldEnum)[keyof typeof NotificationDeliveryScalarFieldEnum];

  export const NotificationTemplateScalarFieldEnum: {
    id: 'id';
    module: 'module';
    eventType: 'eventType';
    channel: 'channel';
    name: 'name';
    description: 'description';
    titleTemplate: 'titleTemplate';
    messageTemplate: 'messageTemplate';
    detailsTemplate: 'detailsTemplate';
    isDefault: 'isDefault';
    isActive: 'isActive';
    version: 'version';
    locale: 'locale';
    variables: 'variables';
    actions: 'actions';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    createdBy: 'createdBy';
  };

  export type NotificationTemplateScalarFieldEnum =
    (typeof NotificationTemplateScalarFieldEnum)[keyof typeof NotificationTemplateScalarFieldEnum];

  export const NotificationProviderScalarFieldEnum: {
    id: 'id';
    name: 'name';
    type: 'type';
    config: 'config';
    credentials: 'credentials';
    isActive: 'isActive';
    isDefault: 'isDefault';
    priority: 'priority';
    rateLimitPerHour: 'rateLimitPerHour';
    rateLimitPerDay: 'rateLimitPerDay';
    lastHealthCheck: 'lastHealthCheck';
    healthStatus: 'healthStatus';
    errorCount: 'errorCount';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    createdBy: 'createdBy';
  };

  export type NotificationProviderScalarFieldEnum =
    (typeof NotificationProviderScalarFieldEnum)[keyof typeof NotificationProviderScalarFieldEnum];

  export const HelixUserNotificationProfileScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    globalEnabled: 'globalEnabled';
    defaultChannels: 'defaultChannels';
    timezone: 'timezone';
    digestEnabled: 'digestEnabled';
    digestFrequency: 'digestFrequency';
    digestTime: 'digestTime';
    dndEnabled: 'dndEnabled';
    dndStartTime: 'dndStartTime';
    dndEndTime: 'dndEndTime';
    dndDays: 'dndDays';
    goalertEnabled: 'goalertEnabled';
    goalertSchedules: 'goalertSchedules';
    goalertPolicies: 'goalertPolicies';
    pagerEnabled: 'pagerEnabled';
    synthEnabled: 'synthEnabled';
    aiDigestEnabled: 'aiDigestEnabled';
    aiGroupingLevel: 'aiGroupingLevel';
    muteRepetitive: 'muteRepetitive';
    sentinelEnabled: 'sentinelEnabled';
    securityEvents: 'securityEvents';
    complianceEvents: 'complianceEvents';
    deviceTokens: 'deviceTokens';
    pushEnabled: 'pushEnabled';
    phoneNumber: 'phoneNumber';
    slackUserId: 'slackUserId';
    teamsUserId: 'teamsUserId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type HelixUserNotificationProfileScalarFieldEnum =
    (typeof HelixUserNotificationProfileScalarFieldEnum)[keyof typeof HelixUserNotificationProfileScalarFieldEnum];

  export const NotificationQueueScalarFieldEnum: {
    id: 'id';
    eventId: 'eventId';
    deliveryId: 'deliveryId';
    priority: 'priority';
    scheduledFor: 'scheduledFor';
    attempts: 'attempts';
    maxAttempts: 'maxAttempts';
    lastAttemptAt: 'lastAttemptAt';
    nextAttemptAt: 'nextAttemptAt';
    status: 'status';
    error: 'error';
    metadata: 'metadata';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type NotificationQueueScalarFieldEnum =
    (typeof NotificationQueueScalarFieldEnum)[keyof typeof NotificationQueueScalarFieldEnum];

  export const NotificationRoleDefaultScalarFieldEnum: {
    id: 'id';
    roleName: 'roleName';
    module: 'module';
    eventType: 'eventType';
    channels: 'channels';
    enabled: 'enabled';
    priority: 'priority';
    metadata: 'metadata';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type NotificationRoleDefaultScalarFieldEnum =
    (typeof NotificationRoleDefaultScalarFieldEnum)[keyof typeof NotificationRoleDefaultScalarFieldEnum];

  export const NotificationAuditLogScalarFieldEnum: {
    id: 'id';
    eventId: 'eventId';
    action: 'action';
    userId: 'userId';
    metadata: 'metadata';
    ipAddress: 'ipAddress';
    userAgent: 'userAgent';
    timestamp: 'timestamp';
  };

  export type NotificationAuditLogScalarFieldEnum =
    (typeof NotificationAuditLogScalarFieldEnum)[keyof typeof NotificationAuditLogScalarFieldEnum];

  export const RoleNotificationDefaultsScalarFieldEnum: {
    id: 'id';
    roleId: 'roleId';
    module: 'module';
    eventType: 'eventType';
    channels: 'channels';
    priority: 'priority';
    digestEnabled: 'digestEnabled';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    createdBy: 'createdBy';
  };

  export type RoleNotificationDefaultsScalarFieldEnum =
    (typeof RoleNotificationDefaultsScalarFieldEnum)[keyof typeof RoleNotificationDefaultsScalarFieldEnum];

  export const NotificationAnalyticsScalarFieldEnum: {
    id: 'id';
    date: 'date';
    hour: 'hour';
    module: 'module';
    eventType: 'eventType';
    channel: 'channel';
    priority: 'priority';
    userId: 'userId';
    tenantId: 'tenantId';
    eventsCreated: 'eventsCreated';
    notificationsSent: 'notificationsSent';
    delivered: 'delivered';
    failed: 'failed';
    opened: 'opened';
    clicked: 'clicked';
    dismissed: 'dismissed';
    avgResponseTime: 'avgResponseTime';
    maxResponseTime: 'maxResponseTime';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type NotificationAnalyticsScalarFieldEnum =
    (typeof NotificationAnalyticsScalarFieldEnum)[keyof typeof NotificationAnalyticsScalarFieldEnum];

  export const SortOrder: {
    asc: 'asc';
    desc: 'desc';
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
  };

  export type NullableJsonNullValueInput =
    (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput];

  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull;
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput];

  export const QueryMode: {
    default: 'default';
    insensitive: 'insensitive';
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

  export const JsonNullValueFilter: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
    AnyNull: typeof AnyNull;
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter];

  export const NullsOrder: {
    first: 'first';
    last: 'last';
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>;

  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>;

  /**
   * Reference to a field of type 'NotificationPriority'
   */
  export type EnumNotificationPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'NotificationPriority'
  >;

  /**
   * Reference to a field of type 'NotificationPriority[]'
   */
  export type ListEnumNotificationPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'NotificationPriority[]'
  >;

  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>;

  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'QueryMode'
  >;

  /**
   * Reference to a field of type 'EventStatus'
   */
  export type EnumEventStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'EventStatus'
  >;

  /**
   * Reference to a field of type 'EventStatus[]'
   */
  export type ListEnumEventStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'EventStatus[]'
  >;

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>;

  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DateTime[]'
  >;

  /**
   * Reference to a field of type 'NotificationChannel[]'
   */
  export type ListEnumNotificationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'NotificationChannel[]'
  >;

  /**
   * Reference to a field of type 'NotificationChannel'
   */
  export type EnumNotificationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'NotificationChannel'
  >;

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>;

  /**
   * Reference to a field of type 'DigestFrequency'
   */
  export type EnumDigestFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DigestFrequency'
  >;

  /**
   * Reference to a field of type 'DigestFrequency[]'
   */
  export type ListEnumDigestFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DigestFrequency[]'
  >;

  /**
   * Reference to a field of type 'NotificationStatus'
   */
  export type EnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'NotificationStatus'
  >;

  /**
   * Reference to a field of type 'NotificationStatus[]'
   */
  export type ListEnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'NotificationStatus[]'
  >;

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>;

  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>;

  /**
   * Reference to a field of type 'DeliveryStatus'
   */
  export type EnumDeliveryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DeliveryStatus'
  >;

  /**
   * Reference to a field of type 'DeliveryStatus[]'
   */
  export type ListEnumDeliveryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DeliveryStatus[]'
  >;

  /**
   * Reference to a field of type 'ProviderHealth'
   */
  export type EnumProviderHealthFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'ProviderHealth'
  >;

  /**
   * Reference to a field of type 'ProviderHealth[]'
   */
  export type ListEnumProviderHealthFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'ProviderHealth[]'
  >;

  /**
   * Reference to a field of type 'AiGroupingLevel'
   */
  export type EnumAiGroupingLevelFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'AiGroupingLevel'
  >;

  /**
   * Reference to a field of type 'AiGroupingLevel[]'
   */
  export type ListEnumAiGroupingLevelFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'AiGroupingLevel[]'
  >;

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>;

  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>;

  /**
   * Deep Input Types
   */

  export type NotificationEventWhereInput = {
    AND?: NotificationEventWhereInput | NotificationEventWhereInput[];
    OR?: NotificationEventWhereInput[];
    NOT?: NotificationEventWhereInput | NotificationEventWhereInput[];
    id?: StringFilter<'NotificationEvent'> | string;
    eventId?: StringFilter<'NotificationEvent'> | string;
    module?: StringFilter<'NotificationEvent'> | string;
    eventType?: StringFilter<'NotificationEvent'> | string;
    priority?: EnumNotificationPriorityFilter<'NotificationEvent'> | $Enums.NotificationPriority;
    title?: StringFilter<'NotificationEvent'> | string;
    message?: StringFilter<'NotificationEvent'> | string;
    details?: StringNullableFilter<'NotificationEvent'> | string | null;
    recipientRoles?: StringNullableListFilter<'NotificationEvent'>;
    recipientUsers?: StringNullableListFilter<'NotificationEvent'>;
    tenantId?: StringNullableFilter<'NotificationEvent'> | string | null;
    actions?: JsonNullableFilter<'NotificationEvent'>;
    metadata?: JsonNullableFilter<'NotificationEvent'>;
    status?: EnumEventStatusFilter<'NotificationEvent'> | $Enums.EventStatus;
    scheduledFor?: DateTimeNullableFilter<'NotificationEvent'> | Date | string | null;
    expiresAt?: DateTimeNullableFilter<'NotificationEvent'> | Date | string | null;
    createdAt?: DateTimeFilter<'NotificationEvent'> | Date | string;
    createdBy?: StringNullableFilter<'NotificationEvent'> | string | null;
    processedAt?: DateTimeNullableFilter<'NotificationEvent'> | Date | string | null;
    notifications?: NotificationListRelationFilter;
    deliveries?: NotificationDeliveryListRelationFilter;
    queue?: NotificationQueueListRelationFilter;
    auditLogs?: NotificationAuditLogListRelationFilter;
  };

  export type NotificationEventOrderByWithRelationInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    module?: SortOrder;
    eventType?: SortOrder;
    priority?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    details?: SortOrderInput | SortOrder;
    recipientRoles?: SortOrder;
    recipientUsers?: SortOrder;
    tenantId?: SortOrderInput | SortOrder;
    actions?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    status?: SortOrder;
    scheduledFor?: SortOrderInput | SortOrder;
    expiresAt?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    createdBy?: SortOrderInput | SortOrder;
    processedAt?: SortOrderInput | SortOrder;
    notifications?: NotificationOrderByRelationAggregateInput;
    deliveries?: NotificationDeliveryOrderByRelationAggregateInput;
    queue?: NotificationQueueOrderByRelationAggregateInput;
    auditLogs?: NotificationAuditLogOrderByRelationAggregateInput;
  };

  export type NotificationEventWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      eventId?: string;
      AND?: NotificationEventWhereInput | NotificationEventWhereInput[];
      OR?: NotificationEventWhereInput[];
      NOT?: NotificationEventWhereInput | NotificationEventWhereInput[];
      module?: StringFilter<'NotificationEvent'> | string;
      eventType?: StringFilter<'NotificationEvent'> | string;
      priority?: EnumNotificationPriorityFilter<'NotificationEvent'> | $Enums.NotificationPriority;
      title?: StringFilter<'NotificationEvent'> | string;
      message?: StringFilter<'NotificationEvent'> | string;
      details?: StringNullableFilter<'NotificationEvent'> | string | null;
      recipientRoles?: StringNullableListFilter<'NotificationEvent'>;
      recipientUsers?: StringNullableListFilter<'NotificationEvent'>;
      tenantId?: StringNullableFilter<'NotificationEvent'> | string | null;
      actions?: JsonNullableFilter<'NotificationEvent'>;
      metadata?: JsonNullableFilter<'NotificationEvent'>;
      status?: EnumEventStatusFilter<'NotificationEvent'> | $Enums.EventStatus;
      scheduledFor?: DateTimeNullableFilter<'NotificationEvent'> | Date | string | null;
      expiresAt?: DateTimeNullableFilter<'NotificationEvent'> | Date | string | null;
      createdAt?: DateTimeFilter<'NotificationEvent'> | Date | string;
      createdBy?: StringNullableFilter<'NotificationEvent'> | string | null;
      processedAt?: DateTimeNullableFilter<'NotificationEvent'> | Date | string | null;
      notifications?: NotificationListRelationFilter;
      deliveries?: NotificationDeliveryListRelationFilter;
      queue?: NotificationQueueListRelationFilter;
      auditLogs?: NotificationAuditLogListRelationFilter;
    },
    'id' | 'eventId'
  >;

  export type NotificationEventOrderByWithAggregationInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    module?: SortOrder;
    eventType?: SortOrder;
    priority?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    details?: SortOrderInput | SortOrder;
    recipientRoles?: SortOrder;
    recipientUsers?: SortOrder;
    tenantId?: SortOrderInput | SortOrder;
    actions?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    status?: SortOrder;
    scheduledFor?: SortOrderInput | SortOrder;
    expiresAt?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    createdBy?: SortOrderInput | SortOrder;
    processedAt?: SortOrderInput | SortOrder;
    _count?: NotificationEventCountOrderByAggregateInput;
    _max?: NotificationEventMaxOrderByAggregateInput;
    _min?: NotificationEventMinOrderByAggregateInput;
  };

  export type NotificationEventScalarWhereWithAggregatesInput = {
    AND?:
      | NotificationEventScalarWhereWithAggregatesInput
      | NotificationEventScalarWhereWithAggregatesInput[];
    OR?: NotificationEventScalarWhereWithAggregatesInput[];
    NOT?:
      | NotificationEventScalarWhereWithAggregatesInput
      | NotificationEventScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'NotificationEvent'> | string;
    eventId?: StringWithAggregatesFilter<'NotificationEvent'> | string;
    module?: StringWithAggregatesFilter<'NotificationEvent'> | string;
    eventType?: StringWithAggregatesFilter<'NotificationEvent'> | string;
    priority?:
      | EnumNotificationPriorityWithAggregatesFilter<'NotificationEvent'>
      | $Enums.NotificationPriority;
    title?: StringWithAggregatesFilter<'NotificationEvent'> | string;
    message?: StringWithAggregatesFilter<'NotificationEvent'> | string;
    details?: StringNullableWithAggregatesFilter<'NotificationEvent'> | string | null;
    recipientRoles?: StringNullableListFilter<'NotificationEvent'>;
    recipientUsers?: StringNullableListFilter<'NotificationEvent'>;
    tenantId?: StringNullableWithAggregatesFilter<'NotificationEvent'> | string | null;
    actions?: JsonNullableWithAggregatesFilter<'NotificationEvent'>;
    metadata?: JsonNullableWithAggregatesFilter<'NotificationEvent'>;
    status?: EnumEventStatusWithAggregatesFilter<'NotificationEvent'> | $Enums.EventStatus;
    scheduledFor?: DateTimeNullableWithAggregatesFilter<'NotificationEvent'> | Date | string | null;
    expiresAt?: DateTimeNullableWithAggregatesFilter<'NotificationEvent'> | Date | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'NotificationEvent'> | Date | string;
    createdBy?: StringNullableWithAggregatesFilter<'NotificationEvent'> | string | null;
    processedAt?: DateTimeNullableWithAggregatesFilter<'NotificationEvent'> | Date | string | null;
  };

  export type NotificationPreferenceWhereInput = {
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[];
    OR?: NotificationPreferenceWhereInput[];
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[];
    id?: StringFilter<'NotificationPreference'> | string;
    userId?: StringFilter<'NotificationPreference'> | string;
    module?: StringFilter<'NotificationPreference'> | string;
    eventType?: StringFilter<'NotificationPreference'> | string;
    channels?: EnumNotificationChannelNullableListFilter<'NotificationPreference'>;
    priority?:
      | EnumNotificationPriorityFilter<'NotificationPreference'>
      | $Enums.NotificationPriority;
    digestEnabled?: BoolFilter<'NotificationPreference'> | boolean;
    digestFrequency?:
      | EnumDigestFrequencyNullableFilter<'NotificationPreference'>
      | $Enums.DigestFrequency
      | null;
    dndEnabled?: BoolFilter<'NotificationPreference'> | boolean;
    dndStartTime?: StringNullableFilter<'NotificationPreference'> | string | null;
    dndEndTime?: StringNullableFilter<'NotificationPreference'> | string | null;
    dndDays?: StringNullableListFilter<'NotificationPreference'>;
    aiSummaryEnabled?: BoolFilter<'NotificationPreference'> | boolean;
    aiGroupingEnabled?: BoolFilter<'NotificationPreference'> | boolean;
    createdAt?: DateTimeFilter<'NotificationPreference'> | Date | string;
    updatedAt?: DateTimeFilter<'NotificationPreference'> | Date | string;
    helixProfile?: XOR<
      HelixUserNotificationProfileNullableScalarRelationFilter,
      HelixUserNotificationProfileWhereInput
    > | null;
  };

  export type NotificationPreferenceOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    module?: SortOrder;
    eventType?: SortOrder;
    channels?: SortOrder;
    priority?: SortOrder;
    digestEnabled?: SortOrder;
    digestFrequency?: SortOrderInput | SortOrder;
    dndEnabled?: SortOrder;
    dndStartTime?: SortOrderInput | SortOrder;
    dndEndTime?: SortOrderInput | SortOrder;
    dndDays?: SortOrder;
    aiSummaryEnabled?: SortOrder;
    aiGroupingEnabled?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    helixProfile?: HelixUserNotificationProfileOrderByWithRelationInput;
  };

  export type NotificationPreferenceWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId_module_eventType?: NotificationPreferenceUserIdModuleEventTypeCompoundUniqueInput;
      AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[];
      OR?: NotificationPreferenceWhereInput[];
      NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[];
      userId?: StringFilter<'NotificationPreference'> | string;
      module?: StringFilter<'NotificationPreference'> | string;
      eventType?: StringFilter<'NotificationPreference'> | string;
      channels?: EnumNotificationChannelNullableListFilter<'NotificationPreference'>;
      priority?:
        | EnumNotificationPriorityFilter<'NotificationPreference'>
        | $Enums.NotificationPriority;
      digestEnabled?: BoolFilter<'NotificationPreference'> | boolean;
      digestFrequency?:
        | EnumDigestFrequencyNullableFilter<'NotificationPreference'>
        | $Enums.DigestFrequency
        | null;
      dndEnabled?: BoolFilter<'NotificationPreference'> | boolean;
      dndStartTime?: StringNullableFilter<'NotificationPreference'> | string | null;
      dndEndTime?: StringNullableFilter<'NotificationPreference'> | string | null;
      dndDays?: StringNullableListFilter<'NotificationPreference'>;
      aiSummaryEnabled?: BoolFilter<'NotificationPreference'> | boolean;
      aiGroupingEnabled?: BoolFilter<'NotificationPreference'> | boolean;
      createdAt?: DateTimeFilter<'NotificationPreference'> | Date | string;
      updatedAt?: DateTimeFilter<'NotificationPreference'> | Date | string;
      helixProfile?: XOR<
        HelixUserNotificationProfileNullableScalarRelationFilter,
        HelixUserNotificationProfileWhereInput
      > | null;
    },
    'id' | 'userId_module_eventType'
  >;

  export type NotificationPreferenceOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    module?: SortOrder;
    eventType?: SortOrder;
    channels?: SortOrder;
    priority?: SortOrder;
    digestEnabled?: SortOrder;
    digestFrequency?: SortOrderInput | SortOrder;
    dndEnabled?: SortOrder;
    dndStartTime?: SortOrderInput | SortOrder;
    dndEndTime?: SortOrderInput | SortOrder;
    dndDays?: SortOrder;
    aiSummaryEnabled?: SortOrder;
    aiGroupingEnabled?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: NotificationPreferenceCountOrderByAggregateInput;
    _max?: NotificationPreferenceMaxOrderByAggregateInput;
    _min?: NotificationPreferenceMinOrderByAggregateInput;
  };

  export type NotificationPreferenceScalarWhereWithAggregatesInput = {
    AND?:
      | NotificationPreferenceScalarWhereWithAggregatesInput
      | NotificationPreferenceScalarWhereWithAggregatesInput[];
    OR?: NotificationPreferenceScalarWhereWithAggregatesInput[];
    NOT?:
      | NotificationPreferenceScalarWhereWithAggregatesInput
      | NotificationPreferenceScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'NotificationPreference'> | string;
    userId?: StringWithAggregatesFilter<'NotificationPreference'> | string;
    module?: StringWithAggregatesFilter<'NotificationPreference'> | string;
    eventType?: StringWithAggregatesFilter<'NotificationPreference'> | string;
    channels?: EnumNotificationChannelNullableListFilter<'NotificationPreference'>;
    priority?:
      | EnumNotificationPriorityWithAggregatesFilter<'NotificationPreference'>
      | $Enums.NotificationPriority;
    digestEnabled?: BoolWithAggregatesFilter<'NotificationPreference'> | boolean;
    digestFrequency?:
      | EnumDigestFrequencyNullableWithAggregatesFilter<'NotificationPreference'>
      | $Enums.DigestFrequency
      | null;
    dndEnabled?: BoolWithAggregatesFilter<'NotificationPreference'> | boolean;
    dndStartTime?: StringNullableWithAggregatesFilter<'NotificationPreference'> | string | null;
    dndEndTime?: StringNullableWithAggregatesFilter<'NotificationPreference'> | string | null;
    dndDays?: StringNullableListFilter<'NotificationPreference'>;
    aiSummaryEnabled?: BoolWithAggregatesFilter<'NotificationPreference'> | boolean;
    aiGroupingEnabled?: BoolWithAggregatesFilter<'NotificationPreference'> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<'NotificationPreference'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'NotificationPreference'> | Date | string;
  };

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[];
    OR?: NotificationWhereInput[];
    NOT?: NotificationWhereInput | NotificationWhereInput[];
    id?: StringFilter<'Notification'> | string;
    eventId?: StringFilter<'Notification'> | string;
    userId?: StringFilter<'Notification'> | string;
    channel?: EnumNotificationChannelFilter<'Notification'> | $Enums.NotificationChannel;
    title?: StringFilter<'Notification'> | string;
    message?: StringFilter<'Notification'> | string;
    details?: StringNullableFilter<'Notification'> | string | null;
    actions?: JsonNullableFilter<'Notification'>;
    status?: EnumNotificationStatusFilter<'Notification'> | $Enums.NotificationStatus;
    priority?: EnumNotificationPriorityFilter<'Notification'> | $Enums.NotificationPriority;
    scheduledFor?: DateTimeNullableFilter<'Notification'> | Date | string | null;
    deliveredAt?: DateTimeNullableFilter<'Notification'> | Date | string | null;
    readAt?: DateTimeNullableFilter<'Notification'> | Date | string | null;
    clickedAt?: DateTimeNullableFilter<'Notification'> | Date | string | null;
    dismissedAt?: DateTimeNullableFilter<'Notification'> | Date | string | null;
    retryCount?: IntFilter<'Notification'> | number;
    maxRetries?: IntFilter<'Notification'> | number;
    nextRetry?: DateTimeNullableFilter<'Notification'> | Date | string | null;
    aiSummary?: StringNullableFilter<'Notification'> | string | null;
    groupId?: StringNullableFilter<'Notification'> | string | null;
    createdAt?: DateTimeFilter<'Notification'> | Date | string;
    updatedAt?: DateTimeFilter<'Notification'> | Date | string;
    event?: XOR<NotificationEventScalarRelationFilter, NotificationEventWhereInput>;
    deliveries?: NotificationDeliveryListRelationFilter;
    queue?: NotificationQueueListRelationFilter;
  };

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    userId?: SortOrder;
    channel?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    details?: SortOrderInput | SortOrder;
    actions?: SortOrderInput | SortOrder;
    status?: SortOrder;
    priority?: SortOrder;
    scheduledFor?: SortOrderInput | SortOrder;
    deliveredAt?: SortOrderInput | SortOrder;
    readAt?: SortOrderInput | SortOrder;
    clickedAt?: SortOrderInput | SortOrder;
    dismissedAt?: SortOrderInput | SortOrder;
    retryCount?: SortOrder;
    maxRetries?: SortOrder;
    nextRetry?: SortOrderInput | SortOrder;
    aiSummary?: SortOrderInput | SortOrder;
    groupId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    event?: NotificationEventOrderByWithRelationInput;
    deliveries?: NotificationDeliveryOrderByRelationAggregateInput;
    queue?: NotificationQueueOrderByRelationAggregateInput;
  };

  export type NotificationWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: NotificationWhereInput | NotificationWhereInput[];
      OR?: NotificationWhereInput[];
      NOT?: NotificationWhereInput | NotificationWhereInput[];
      eventId?: StringFilter<'Notification'> | string;
      userId?: StringFilter<'Notification'> | string;
      channel?: EnumNotificationChannelFilter<'Notification'> | $Enums.NotificationChannel;
      title?: StringFilter<'Notification'> | string;
      message?: StringFilter<'Notification'> | string;
      details?: StringNullableFilter<'Notification'> | string | null;
      actions?: JsonNullableFilter<'Notification'>;
      status?: EnumNotificationStatusFilter<'Notification'> | $Enums.NotificationStatus;
      priority?: EnumNotificationPriorityFilter<'Notification'> | $Enums.NotificationPriority;
      scheduledFor?: DateTimeNullableFilter<'Notification'> | Date | string | null;
      deliveredAt?: DateTimeNullableFilter<'Notification'> | Date | string | null;
      readAt?: DateTimeNullableFilter<'Notification'> | Date | string | null;
      clickedAt?: DateTimeNullableFilter<'Notification'> | Date | string | null;
      dismissedAt?: DateTimeNullableFilter<'Notification'> | Date | string | null;
      retryCount?: IntFilter<'Notification'> | number;
      maxRetries?: IntFilter<'Notification'> | number;
      nextRetry?: DateTimeNullableFilter<'Notification'> | Date | string | null;
      aiSummary?: StringNullableFilter<'Notification'> | string | null;
      groupId?: StringNullableFilter<'Notification'> | string | null;
      createdAt?: DateTimeFilter<'Notification'> | Date | string;
      updatedAt?: DateTimeFilter<'Notification'> | Date | string;
      event?: XOR<NotificationEventScalarRelationFilter, NotificationEventWhereInput>;
      deliveries?: NotificationDeliveryListRelationFilter;
      queue?: NotificationQueueListRelationFilter;
    },
    'id'
  >;

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    userId?: SortOrder;
    channel?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    details?: SortOrderInput | SortOrder;
    actions?: SortOrderInput | SortOrder;
    status?: SortOrder;
    priority?: SortOrder;
    scheduledFor?: SortOrderInput | SortOrder;
    deliveredAt?: SortOrderInput | SortOrder;
    readAt?: SortOrderInput | SortOrder;
    clickedAt?: SortOrderInput | SortOrder;
    dismissedAt?: SortOrderInput | SortOrder;
    retryCount?: SortOrder;
    maxRetries?: SortOrder;
    nextRetry?: SortOrderInput | SortOrder;
    aiSummary?: SortOrderInput | SortOrder;
    groupId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: NotificationCountOrderByAggregateInput;
    _avg?: NotificationAvgOrderByAggregateInput;
    _max?: NotificationMaxOrderByAggregateInput;
    _min?: NotificationMinOrderByAggregateInput;
    _sum?: NotificationSumOrderByAggregateInput;
  };

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[];
    OR?: NotificationScalarWhereWithAggregatesInput[];
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Notification'> | string;
    eventId?: StringWithAggregatesFilter<'Notification'> | string;
    userId?: StringWithAggregatesFilter<'Notification'> | string;
    channel?:
      | EnumNotificationChannelWithAggregatesFilter<'Notification'>
      | $Enums.NotificationChannel;
    title?: StringWithAggregatesFilter<'Notification'> | string;
    message?: StringWithAggregatesFilter<'Notification'> | string;
    details?: StringNullableWithAggregatesFilter<'Notification'> | string | null;
    actions?: JsonNullableWithAggregatesFilter<'Notification'>;
    status?: EnumNotificationStatusWithAggregatesFilter<'Notification'> | $Enums.NotificationStatus;
    priority?:
      | EnumNotificationPriorityWithAggregatesFilter<'Notification'>
      | $Enums.NotificationPriority;
    scheduledFor?: DateTimeNullableWithAggregatesFilter<'Notification'> | Date | string | null;
    deliveredAt?: DateTimeNullableWithAggregatesFilter<'Notification'> | Date | string | null;
    readAt?: DateTimeNullableWithAggregatesFilter<'Notification'> | Date | string | null;
    clickedAt?: DateTimeNullableWithAggregatesFilter<'Notification'> | Date | string | null;
    dismissedAt?: DateTimeNullableWithAggregatesFilter<'Notification'> | Date | string | null;
    retryCount?: IntWithAggregatesFilter<'Notification'> | number;
    maxRetries?: IntWithAggregatesFilter<'Notification'> | number;
    nextRetry?: DateTimeNullableWithAggregatesFilter<'Notification'> | Date | string | null;
    aiSummary?: StringNullableWithAggregatesFilter<'Notification'> | string | null;
    groupId?: StringNullableWithAggregatesFilter<'Notification'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'Notification'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Notification'> | Date | string;
  };

  export type NotificationDeliveryWhereInput = {
    AND?: NotificationDeliveryWhereInput | NotificationDeliveryWhereInput[];
    OR?: NotificationDeliveryWhereInput[];
    NOT?: NotificationDeliveryWhereInput | NotificationDeliveryWhereInput[];
    id?: StringFilter<'NotificationDelivery'> | string;
    notificationId?: StringFilter<'NotificationDelivery'> | string;
    eventId?: StringFilter<'NotificationDelivery'> | string;
    userId?: StringFilter<'NotificationDelivery'> | string;
    channel?: EnumNotificationChannelFilter<'NotificationDelivery'> | $Enums.NotificationChannel;
    provider?: StringNullableFilter<'NotificationDelivery'> | string | null;
    providerConfig?: JsonNullableFilter<'NotificationDelivery'>;
    status?: EnumDeliveryStatusFilter<'NotificationDelivery'> | $Enums.DeliveryStatus;
    deliveredAt?: DateTimeNullableFilter<'NotificationDelivery'> | Date | string | null;
    failedAt?: DateTimeNullableFilter<'NotificationDelivery'> | Date | string | null;
    errorMessage?: StringNullableFilter<'NotificationDelivery'> | string | null;
    errorCode?: StringNullableFilter<'NotificationDelivery'> | string | null;
    providerResponse?: JsonNullableFilter<'NotificationDelivery'>;
    messageId?: StringNullableFilter<'NotificationDelivery'> | string | null;
    responseTime?: IntNullableFilter<'NotificationDelivery'> | number | null;
    createdAt?: DateTimeFilter<'NotificationDelivery'> | Date | string;
    updatedAt?: DateTimeFilter<'NotificationDelivery'> | Date | string;
    notification?: XOR<NotificationScalarRelationFilter, NotificationWhereInput>;
    event?: XOR<NotificationEventScalarRelationFilter, NotificationEventWhereInput>;
  };

  export type NotificationDeliveryOrderByWithRelationInput = {
    id?: SortOrder;
    notificationId?: SortOrder;
    eventId?: SortOrder;
    userId?: SortOrder;
    channel?: SortOrder;
    provider?: SortOrderInput | SortOrder;
    providerConfig?: SortOrderInput | SortOrder;
    status?: SortOrder;
    deliveredAt?: SortOrderInput | SortOrder;
    failedAt?: SortOrderInput | SortOrder;
    errorMessage?: SortOrderInput | SortOrder;
    errorCode?: SortOrderInput | SortOrder;
    providerResponse?: SortOrderInput | SortOrder;
    messageId?: SortOrderInput | SortOrder;
    responseTime?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    notification?: NotificationOrderByWithRelationInput;
    event?: NotificationEventOrderByWithRelationInput;
  };

  export type NotificationDeliveryWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: NotificationDeliveryWhereInput | NotificationDeliveryWhereInput[];
      OR?: NotificationDeliveryWhereInput[];
      NOT?: NotificationDeliveryWhereInput | NotificationDeliveryWhereInput[];
      notificationId?: StringFilter<'NotificationDelivery'> | string;
      eventId?: StringFilter<'NotificationDelivery'> | string;
      userId?: StringFilter<'NotificationDelivery'> | string;
      channel?: EnumNotificationChannelFilter<'NotificationDelivery'> | $Enums.NotificationChannel;
      provider?: StringNullableFilter<'NotificationDelivery'> | string | null;
      providerConfig?: JsonNullableFilter<'NotificationDelivery'>;
      status?: EnumDeliveryStatusFilter<'NotificationDelivery'> | $Enums.DeliveryStatus;
      deliveredAt?: DateTimeNullableFilter<'NotificationDelivery'> | Date | string | null;
      failedAt?: DateTimeNullableFilter<'NotificationDelivery'> | Date | string | null;
      errorMessage?: StringNullableFilter<'NotificationDelivery'> | string | null;
      errorCode?: StringNullableFilter<'NotificationDelivery'> | string | null;
      providerResponse?: JsonNullableFilter<'NotificationDelivery'>;
      messageId?: StringNullableFilter<'NotificationDelivery'> | string | null;
      responseTime?: IntNullableFilter<'NotificationDelivery'> | number | null;
      createdAt?: DateTimeFilter<'NotificationDelivery'> | Date | string;
      updatedAt?: DateTimeFilter<'NotificationDelivery'> | Date | string;
      notification?: XOR<NotificationScalarRelationFilter, NotificationWhereInput>;
      event?: XOR<NotificationEventScalarRelationFilter, NotificationEventWhereInput>;
    },
    'id'
  >;

  export type NotificationDeliveryOrderByWithAggregationInput = {
    id?: SortOrder;
    notificationId?: SortOrder;
    eventId?: SortOrder;
    userId?: SortOrder;
    channel?: SortOrder;
    provider?: SortOrderInput | SortOrder;
    providerConfig?: SortOrderInput | SortOrder;
    status?: SortOrder;
    deliveredAt?: SortOrderInput | SortOrder;
    failedAt?: SortOrderInput | SortOrder;
    errorMessage?: SortOrderInput | SortOrder;
    errorCode?: SortOrderInput | SortOrder;
    providerResponse?: SortOrderInput | SortOrder;
    messageId?: SortOrderInput | SortOrder;
    responseTime?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: NotificationDeliveryCountOrderByAggregateInput;
    _avg?: NotificationDeliveryAvgOrderByAggregateInput;
    _max?: NotificationDeliveryMaxOrderByAggregateInput;
    _min?: NotificationDeliveryMinOrderByAggregateInput;
    _sum?: NotificationDeliverySumOrderByAggregateInput;
  };

  export type NotificationDeliveryScalarWhereWithAggregatesInput = {
    AND?:
      | NotificationDeliveryScalarWhereWithAggregatesInput
      | NotificationDeliveryScalarWhereWithAggregatesInput[];
    OR?: NotificationDeliveryScalarWhereWithAggregatesInput[];
    NOT?:
      | NotificationDeliveryScalarWhereWithAggregatesInput
      | NotificationDeliveryScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'NotificationDelivery'> | string;
    notificationId?: StringWithAggregatesFilter<'NotificationDelivery'> | string;
    eventId?: StringWithAggregatesFilter<'NotificationDelivery'> | string;
    userId?: StringWithAggregatesFilter<'NotificationDelivery'> | string;
    channel?:
      | EnumNotificationChannelWithAggregatesFilter<'NotificationDelivery'>
      | $Enums.NotificationChannel;
    provider?: StringNullableWithAggregatesFilter<'NotificationDelivery'> | string | null;
    providerConfig?: JsonNullableWithAggregatesFilter<'NotificationDelivery'>;
    status?: EnumDeliveryStatusWithAggregatesFilter<'NotificationDelivery'> | $Enums.DeliveryStatus;
    deliveredAt?:
      | DateTimeNullableWithAggregatesFilter<'NotificationDelivery'>
      | Date
      | string
      | null;
    failedAt?: DateTimeNullableWithAggregatesFilter<'NotificationDelivery'> | Date | string | null;
    errorMessage?: StringNullableWithAggregatesFilter<'NotificationDelivery'> | string | null;
    errorCode?: StringNullableWithAggregatesFilter<'NotificationDelivery'> | string | null;
    providerResponse?: JsonNullableWithAggregatesFilter<'NotificationDelivery'>;
    messageId?: StringNullableWithAggregatesFilter<'NotificationDelivery'> | string | null;
    responseTime?: IntNullableWithAggregatesFilter<'NotificationDelivery'> | number | null;
    createdAt?: DateTimeWithAggregatesFilter<'NotificationDelivery'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'NotificationDelivery'> | Date | string;
  };

  export type NotificationTemplateWhereInput = {
    AND?: NotificationTemplateWhereInput | NotificationTemplateWhereInput[];
    OR?: NotificationTemplateWhereInput[];
    NOT?: NotificationTemplateWhereInput | NotificationTemplateWhereInput[];
    id?: StringFilter<'NotificationTemplate'> | string;
    module?: StringFilter<'NotificationTemplate'> | string;
    eventType?: StringFilter<'NotificationTemplate'> | string;
    channel?: EnumNotificationChannelFilter<'NotificationTemplate'> | $Enums.NotificationChannel;
    name?: StringFilter<'NotificationTemplate'> | string;
    description?: StringNullableFilter<'NotificationTemplate'> | string | null;
    titleTemplate?: StringFilter<'NotificationTemplate'> | string;
    messageTemplate?: StringFilter<'NotificationTemplate'> | string;
    detailsTemplate?: StringNullableFilter<'NotificationTemplate'> | string | null;
    isDefault?: BoolFilter<'NotificationTemplate'> | boolean;
    isActive?: BoolFilter<'NotificationTemplate'> | boolean;
    version?: IntFilter<'NotificationTemplate'> | number;
    locale?: StringFilter<'NotificationTemplate'> | string;
    variables?: JsonNullableFilter<'NotificationTemplate'>;
    actions?: JsonNullableFilter<'NotificationTemplate'>;
    createdAt?: DateTimeFilter<'NotificationTemplate'> | Date | string;
    updatedAt?: DateTimeFilter<'NotificationTemplate'> | Date | string;
    createdBy?: StringNullableFilter<'NotificationTemplate'> | string | null;
  };

  export type NotificationTemplateOrderByWithRelationInput = {
    id?: SortOrder;
    module?: SortOrder;
    eventType?: SortOrder;
    channel?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    titleTemplate?: SortOrder;
    messageTemplate?: SortOrder;
    detailsTemplate?: SortOrderInput | SortOrder;
    isDefault?: SortOrder;
    isActive?: SortOrder;
    version?: SortOrder;
    locale?: SortOrder;
    variables?: SortOrderInput | SortOrder;
    actions?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrderInput | SortOrder;
  };

  export type NotificationTemplateWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      module_eventType_channel_locale?: NotificationTemplateModuleEventTypeChannelLocaleCompoundUniqueInput;
      AND?: NotificationTemplateWhereInput | NotificationTemplateWhereInput[];
      OR?: NotificationTemplateWhereInput[];
      NOT?: NotificationTemplateWhereInput | NotificationTemplateWhereInput[];
      module?: StringFilter<'NotificationTemplate'> | string;
      eventType?: StringFilter<'NotificationTemplate'> | string;
      channel?: EnumNotificationChannelFilter<'NotificationTemplate'> | $Enums.NotificationChannel;
      name?: StringFilter<'NotificationTemplate'> | string;
      description?: StringNullableFilter<'NotificationTemplate'> | string | null;
      titleTemplate?: StringFilter<'NotificationTemplate'> | string;
      messageTemplate?: StringFilter<'NotificationTemplate'> | string;
      detailsTemplate?: StringNullableFilter<'NotificationTemplate'> | string | null;
      isDefault?: BoolFilter<'NotificationTemplate'> | boolean;
      isActive?: BoolFilter<'NotificationTemplate'> | boolean;
      version?: IntFilter<'NotificationTemplate'> | number;
      locale?: StringFilter<'NotificationTemplate'> | string;
      variables?: JsonNullableFilter<'NotificationTemplate'>;
      actions?: JsonNullableFilter<'NotificationTemplate'>;
      createdAt?: DateTimeFilter<'NotificationTemplate'> | Date | string;
      updatedAt?: DateTimeFilter<'NotificationTemplate'> | Date | string;
      createdBy?: StringNullableFilter<'NotificationTemplate'> | string | null;
    },
    'id' | 'module_eventType_channel_locale'
  >;

  export type NotificationTemplateOrderByWithAggregationInput = {
    id?: SortOrder;
    module?: SortOrder;
    eventType?: SortOrder;
    channel?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    titleTemplate?: SortOrder;
    messageTemplate?: SortOrder;
    detailsTemplate?: SortOrderInput | SortOrder;
    isDefault?: SortOrder;
    isActive?: SortOrder;
    version?: SortOrder;
    locale?: SortOrder;
    variables?: SortOrderInput | SortOrder;
    actions?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrderInput | SortOrder;
    _count?: NotificationTemplateCountOrderByAggregateInput;
    _avg?: NotificationTemplateAvgOrderByAggregateInput;
    _max?: NotificationTemplateMaxOrderByAggregateInput;
    _min?: NotificationTemplateMinOrderByAggregateInput;
    _sum?: NotificationTemplateSumOrderByAggregateInput;
  };

  export type NotificationTemplateScalarWhereWithAggregatesInput = {
    AND?:
      | NotificationTemplateScalarWhereWithAggregatesInput
      | NotificationTemplateScalarWhereWithAggregatesInput[];
    OR?: NotificationTemplateScalarWhereWithAggregatesInput[];
    NOT?:
      | NotificationTemplateScalarWhereWithAggregatesInput
      | NotificationTemplateScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'NotificationTemplate'> | string;
    module?: StringWithAggregatesFilter<'NotificationTemplate'> | string;
    eventType?: StringWithAggregatesFilter<'NotificationTemplate'> | string;
    channel?:
      | EnumNotificationChannelWithAggregatesFilter<'NotificationTemplate'>
      | $Enums.NotificationChannel;
    name?: StringWithAggregatesFilter<'NotificationTemplate'> | string;
    description?: StringNullableWithAggregatesFilter<'NotificationTemplate'> | string | null;
    titleTemplate?: StringWithAggregatesFilter<'NotificationTemplate'> | string;
    messageTemplate?: StringWithAggregatesFilter<'NotificationTemplate'> | string;
    detailsTemplate?: StringNullableWithAggregatesFilter<'NotificationTemplate'> | string | null;
    isDefault?: BoolWithAggregatesFilter<'NotificationTemplate'> | boolean;
    isActive?: BoolWithAggregatesFilter<'NotificationTemplate'> | boolean;
    version?: IntWithAggregatesFilter<'NotificationTemplate'> | number;
    locale?: StringWithAggregatesFilter<'NotificationTemplate'> | string;
    variables?: JsonNullableWithAggregatesFilter<'NotificationTemplate'>;
    actions?: JsonNullableWithAggregatesFilter<'NotificationTemplate'>;
    createdAt?: DateTimeWithAggregatesFilter<'NotificationTemplate'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'NotificationTemplate'> | Date | string;
    createdBy?: StringNullableWithAggregatesFilter<'NotificationTemplate'> | string | null;
  };

  export type NotificationProviderWhereInput = {
    AND?: NotificationProviderWhereInput | NotificationProviderWhereInput[];
    OR?: NotificationProviderWhereInput[];
    NOT?: NotificationProviderWhereInput | NotificationProviderWhereInput[];
    id?: StringFilter<'NotificationProvider'> | string;
    name?: StringFilter<'NotificationProvider'> | string;
    type?: EnumNotificationChannelFilter<'NotificationProvider'> | $Enums.NotificationChannel;
    config?: JsonFilter<'NotificationProvider'>;
    credentials?: JsonNullableFilter<'NotificationProvider'>;
    isActive?: BoolFilter<'NotificationProvider'> | boolean;
    isDefault?: BoolFilter<'NotificationProvider'> | boolean;
    priority?: IntFilter<'NotificationProvider'> | number;
    rateLimitPerHour?: IntNullableFilter<'NotificationProvider'> | number | null;
    rateLimitPerDay?: IntNullableFilter<'NotificationProvider'> | number | null;
    lastHealthCheck?: DateTimeNullableFilter<'NotificationProvider'> | Date | string | null;
    healthStatus?: EnumProviderHealthFilter<'NotificationProvider'> | $Enums.ProviderHealth;
    errorCount?: IntFilter<'NotificationProvider'> | number;
    createdAt?: DateTimeFilter<'NotificationProvider'> | Date | string;
    updatedAt?: DateTimeFilter<'NotificationProvider'> | Date | string;
    createdBy?: StringNullableFilter<'NotificationProvider'> | string | null;
  };

  export type NotificationProviderOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    config?: SortOrder;
    credentials?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    isDefault?: SortOrder;
    priority?: SortOrder;
    rateLimitPerHour?: SortOrderInput | SortOrder;
    rateLimitPerDay?: SortOrderInput | SortOrder;
    lastHealthCheck?: SortOrderInput | SortOrder;
    healthStatus?: SortOrder;
    errorCount?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrderInput | SortOrder;
  };

  export type NotificationProviderWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: NotificationProviderWhereInput | NotificationProviderWhereInput[];
      OR?: NotificationProviderWhereInput[];
      NOT?: NotificationProviderWhereInput | NotificationProviderWhereInput[];
      name?: StringFilter<'NotificationProvider'> | string;
      type?: EnumNotificationChannelFilter<'NotificationProvider'> | $Enums.NotificationChannel;
      config?: JsonFilter<'NotificationProvider'>;
      credentials?: JsonNullableFilter<'NotificationProvider'>;
      isActive?: BoolFilter<'NotificationProvider'> | boolean;
      isDefault?: BoolFilter<'NotificationProvider'> | boolean;
      priority?: IntFilter<'NotificationProvider'> | number;
      rateLimitPerHour?: IntNullableFilter<'NotificationProvider'> | number | null;
      rateLimitPerDay?: IntNullableFilter<'NotificationProvider'> | number | null;
      lastHealthCheck?: DateTimeNullableFilter<'NotificationProvider'> | Date | string | null;
      healthStatus?: EnumProviderHealthFilter<'NotificationProvider'> | $Enums.ProviderHealth;
      errorCount?: IntFilter<'NotificationProvider'> | number;
      createdAt?: DateTimeFilter<'NotificationProvider'> | Date | string;
      updatedAt?: DateTimeFilter<'NotificationProvider'> | Date | string;
      createdBy?: StringNullableFilter<'NotificationProvider'> | string | null;
    },
    'id'
  >;

  export type NotificationProviderOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    config?: SortOrder;
    credentials?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    isDefault?: SortOrder;
    priority?: SortOrder;
    rateLimitPerHour?: SortOrderInput | SortOrder;
    rateLimitPerDay?: SortOrderInput | SortOrder;
    lastHealthCheck?: SortOrderInput | SortOrder;
    healthStatus?: SortOrder;
    errorCount?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrderInput | SortOrder;
    _count?: NotificationProviderCountOrderByAggregateInput;
    _avg?: NotificationProviderAvgOrderByAggregateInput;
    _max?: NotificationProviderMaxOrderByAggregateInput;
    _min?: NotificationProviderMinOrderByAggregateInput;
    _sum?: NotificationProviderSumOrderByAggregateInput;
  };

  export type NotificationProviderScalarWhereWithAggregatesInput = {
    AND?:
      | NotificationProviderScalarWhereWithAggregatesInput
      | NotificationProviderScalarWhereWithAggregatesInput[];
    OR?: NotificationProviderScalarWhereWithAggregatesInput[];
    NOT?:
      | NotificationProviderScalarWhereWithAggregatesInput
      | NotificationProviderScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'NotificationProvider'> | string;
    name?: StringWithAggregatesFilter<'NotificationProvider'> | string;
    type?:
      | EnumNotificationChannelWithAggregatesFilter<'NotificationProvider'>
      | $Enums.NotificationChannel;
    config?: JsonWithAggregatesFilter<'NotificationProvider'>;
    credentials?: JsonNullableWithAggregatesFilter<'NotificationProvider'>;
    isActive?: BoolWithAggregatesFilter<'NotificationProvider'> | boolean;
    isDefault?: BoolWithAggregatesFilter<'NotificationProvider'> | boolean;
    priority?: IntWithAggregatesFilter<'NotificationProvider'> | number;
    rateLimitPerHour?: IntNullableWithAggregatesFilter<'NotificationProvider'> | number | null;
    rateLimitPerDay?: IntNullableWithAggregatesFilter<'NotificationProvider'> | number | null;
    lastHealthCheck?:
      | DateTimeNullableWithAggregatesFilter<'NotificationProvider'>
      | Date
      | string
      | null;
    healthStatus?:
      | EnumProviderHealthWithAggregatesFilter<'NotificationProvider'>
      | $Enums.ProviderHealth;
    errorCount?: IntWithAggregatesFilter<'NotificationProvider'> | number;
    createdAt?: DateTimeWithAggregatesFilter<'NotificationProvider'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'NotificationProvider'> | Date | string;
    createdBy?: StringNullableWithAggregatesFilter<'NotificationProvider'> | string | null;
  };

  export type HelixUserNotificationProfileWhereInput = {
    AND?: HelixUserNotificationProfileWhereInput | HelixUserNotificationProfileWhereInput[];
    OR?: HelixUserNotificationProfileWhereInput[];
    NOT?: HelixUserNotificationProfileWhereInput | HelixUserNotificationProfileWhereInput[];
    id?: StringFilter<'HelixUserNotificationProfile'> | string;
    userId?: StringFilter<'HelixUserNotificationProfile'> | string;
    globalEnabled?: BoolFilter<'HelixUserNotificationProfile'> | boolean;
    defaultChannels?: EnumNotificationChannelNullableListFilter<'HelixUserNotificationProfile'>;
    timezone?: StringFilter<'HelixUserNotificationProfile'> | string;
    digestEnabled?: BoolFilter<'HelixUserNotificationProfile'> | boolean;
    digestFrequency?:
      | EnumDigestFrequencyFilter<'HelixUserNotificationProfile'>
      | $Enums.DigestFrequency;
    digestTime?: StringFilter<'HelixUserNotificationProfile'> | string;
    dndEnabled?: BoolFilter<'HelixUserNotificationProfile'> | boolean;
    dndStartTime?: StringNullableFilter<'HelixUserNotificationProfile'> | string | null;
    dndEndTime?: StringNullableFilter<'HelixUserNotificationProfile'> | string | null;
    dndDays?: StringNullableListFilter<'HelixUserNotificationProfile'>;
    goalertEnabled?: BoolFilter<'HelixUserNotificationProfile'> | boolean;
    goalertSchedules?: StringNullableListFilter<'HelixUserNotificationProfile'>;
    goalertPolicies?: StringNullableListFilter<'HelixUserNotificationProfile'>;
    pagerEnabled?: BoolFilter<'HelixUserNotificationProfile'> | boolean;
    synthEnabled?: BoolFilter<'HelixUserNotificationProfile'> | boolean;
    aiDigestEnabled?: BoolFilter<'HelixUserNotificationProfile'> | boolean;
    aiGroupingLevel?:
      | EnumAiGroupingLevelFilter<'HelixUserNotificationProfile'>
      | $Enums.AiGroupingLevel;
    muteRepetitive?: BoolFilter<'HelixUserNotificationProfile'> | boolean;
    sentinelEnabled?: BoolFilter<'HelixUserNotificationProfile'> | boolean;
    securityEvents?: StringNullableListFilter<'HelixUserNotificationProfile'>;
    complianceEvents?: BoolFilter<'HelixUserNotificationProfile'> | boolean;
    deviceTokens?: JsonNullableFilter<'HelixUserNotificationProfile'>;
    pushEnabled?: BoolFilter<'HelixUserNotificationProfile'> | boolean;
    phoneNumber?: StringNullableFilter<'HelixUserNotificationProfile'> | string | null;
    slackUserId?: StringNullableFilter<'HelixUserNotificationProfile'> | string | null;
    teamsUserId?: StringNullableFilter<'HelixUserNotificationProfile'> | string | null;
    createdAt?: DateTimeFilter<'HelixUserNotificationProfile'> | Date | string;
    updatedAt?: DateTimeFilter<'HelixUserNotificationProfile'> | Date | string;
    preferences?: NotificationPreferenceListRelationFilter;
  };

  export type HelixUserNotificationProfileOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    globalEnabled?: SortOrder;
    defaultChannels?: SortOrder;
    timezone?: SortOrder;
    digestEnabled?: SortOrder;
    digestFrequency?: SortOrder;
    digestTime?: SortOrder;
    dndEnabled?: SortOrder;
    dndStartTime?: SortOrderInput | SortOrder;
    dndEndTime?: SortOrderInput | SortOrder;
    dndDays?: SortOrder;
    goalertEnabled?: SortOrder;
    goalertSchedules?: SortOrder;
    goalertPolicies?: SortOrder;
    pagerEnabled?: SortOrder;
    synthEnabled?: SortOrder;
    aiDigestEnabled?: SortOrder;
    aiGroupingLevel?: SortOrder;
    muteRepetitive?: SortOrder;
    sentinelEnabled?: SortOrder;
    securityEvents?: SortOrder;
    complianceEvents?: SortOrder;
    deviceTokens?: SortOrderInput | SortOrder;
    pushEnabled?: SortOrder;
    phoneNumber?: SortOrderInput | SortOrder;
    slackUserId?: SortOrderInput | SortOrder;
    teamsUserId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    preferences?: NotificationPreferenceOrderByRelationAggregateInput;
  };

  export type HelixUserNotificationProfileWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId?: string;
      AND?: HelixUserNotificationProfileWhereInput | HelixUserNotificationProfileWhereInput[];
      OR?: HelixUserNotificationProfileWhereInput[];
      NOT?: HelixUserNotificationProfileWhereInput | HelixUserNotificationProfileWhereInput[];
      globalEnabled?: BoolFilter<'HelixUserNotificationProfile'> | boolean;
      defaultChannels?: EnumNotificationChannelNullableListFilter<'HelixUserNotificationProfile'>;
      timezone?: StringFilter<'HelixUserNotificationProfile'> | string;
      digestEnabled?: BoolFilter<'HelixUserNotificationProfile'> | boolean;
      digestFrequency?:
        | EnumDigestFrequencyFilter<'HelixUserNotificationProfile'>
        | $Enums.DigestFrequency;
      digestTime?: StringFilter<'HelixUserNotificationProfile'> | string;
      dndEnabled?: BoolFilter<'HelixUserNotificationProfile'> | boolean;
      dndStartTime?: StringNullableFilter<'HelixUserNotificationProfile'> | string | null;
      dndEndTime?: StringNullableFilter<'HelixUserNotificationProfile'> | string | null;
      dndDays?: StringNullableListFilter<'HelixUserNotificationProfile'>;
      goalertEnabled?: BoolFilter<'HelixUserNotificationProfile'> | boolean;
      goalertSchedules?: StringNullableListFilter<'HelixUserNotificationProfile'>;
      goalertPolicies?: StringNullableListFilter<'HelixUserNotificationProfile'>;
      pagerEnabled?: BoolFilter<'HelixUserNotificationProfile'> | boolean;
      synthEnabled?: BoolFilter<'HelixUserNotificationProfile'> | boolean;
      aiDigestEnabled?: BoolFilter<'HelixUserNotificationProfile'> | boolean;
      aiGroupingLevel?:
        | EnumAiGroupingLevelFilter<'HelixUserNotificationProfile'>
        | $Enums.AiGroupingLevel;
      muteRepetitive?: BoolFilter<'HelixUserNotificationProfile'> | boolean;
      sentinelEnabled?: BoolFilter<'HelixUserNotificationProfile'> | boolean;
      securityEvents?: StringNullableListFilter<'HelixUserNotificationProfile'>;
      complianceEvents?: BoolFilter<'HelixUserNotificationProfile'> | boolean;
      deviceTokens?: JsonNullableFilter<'HelixUserNotificationProfile'>;
      pushEnabled?: BoolFilter<'HelixUserNotificationProfile'> | boolean;
      phoneNumber?: StringNullableFilter<'HelixUserNotificationProfile'> | string | null;
      slackUserId?: StringNullableFilter<'HelixUserNotificationProfile'> | string | null;
      teamsUserId?: StringNullableFilter<'HelixUserNotificationProfile'> | string | null;
      createdAt?: DateTimeFilter<'HelixUserNotificationProfile'> | Date | string;
      updatedAt?: DateTimeFilter<'HelixUserNotificationProfile'> | Date | string;
      preferences?: NotificationPreferenceListRelationFilter;
    },
    'id' | 'userId'
  >;

  export type HelixUserNotificationProfileOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    globalEnabled?: SortOrder;
    defaultChannels?: SortOrder;
    timezone?: SortOrder;
    digestEnabled?: SortOrder;
    digestFrequency?: SortOrder;
    digestTime?: SortOrder;
    dndEnabled?: SortOrder;
    dndStartTime?: SortOrderInput | SortOrder;
    dndEndTime?: SortOrderInput | SortOrder;
    dndDays?: SortOrder;
    goalertEnabled?: SortOrder;
    goalertSchedules?: SortOrder;
    goalertPolicies?: SortOrder;
    pagerEnabled?: SortOrder;
    synthEnabled?: SortOrder;
    aiDigestEnabled?: SortOrder;
    aiGroupingLevel?: SortOrder;
    muteRepetitive?: SortOrder;
    sentinelEnabled?: SortOrder;
    securityEvents?: SortOrder;
    complianceEvents?: SortOrder;
    deviceTokens?: SortOrderInput | SortOrder;
    pushEnabled?: SortOrder;
    phoneNumber?: SortOrderInput | SortOrder;
    slackUserId?: SortOrderInput | SortOrder;
    teamsUserId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: HelixUserNotificationProfileCountOrderByAggregateInput;
    _max?: HelixUserNotificationProfileMaxOrderByAggregateInput;
    _min?: HelixUserNotificationProfileMinOrderByAggregateInput;
  };

  export type HelixUserNotificationProfileScalarWhereWithAggregatesInput = {
    AND?:
      | HelixUserNotificationProfileScalarWhereWithAggregatesInput
      | HelixUserNotificationProfileScalarWhereWithAggregatesInput[];
    OR?: HelixUserNotificationProfileScalarWhereWithAggregatesInput[];
    NOT?:
      | HelixUserNotificationProfileScalarWhereWithAggregatesInput
      | HelixUserNotificationProfileScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'HelixUserNotificationProfile'> | string;
    userId?: StringWithAggregatesFilter<'HelixUserNotificationProfile'> | string;
    globalEnabled?: BoolWithAggregatesFilter<'HelixUserNotificationProfile'> | boolean;
    defaultChannels?: EnumNotificationChannelNullableListFilter<'HelixUserNotificationProfile'>;
    timezone?: StringWithAggregatesFilter<'HelixUserNotificationProfile'> | string;
    digestEnabled?: BoolWithAggregatesFilter<'HelixUserNotificationProfile'> | boolean;
    digestFrequency?:
      | EnumDigestFrequencyWithAggregatesFilter<'HelixUserNotificationProfile'>
      | $Enums.DigestFrequency;
    digestTime?: StringWithAggregatesFilter<'HelixUserNotificationProfile'> | string;
    dndEnabled?: BoolWithAggregatesFilter<'HelixUserNotificationProfile'> | boolean;
    dndStartTime?:
      | StringNullableWithAggregatesFilter<'HelixUserNotificationProfile'>
      | string
      | null;
    dndEndTime?: StringNullableWithAggregatesFilter<'HelixUserNotificationProfile'> | string | null;
    dndDays?: StringNullableListFilter<'HelixUserNotificationProfile'>;
    goalertEnabled?: BoolWithAggregatesFilter<'HelixUserNotificationProfile'> | boolean;
    goalertSchedules?: StringNullableListFilter<'HelixUserNotificationProfile'>;
    goalertPolicies?: StringNullableListFilter<'HelixUserNotificationProfile'>;
    pagerEnabled?: BoolWithAggregatesFilter<'HelixUserNotificationProfile'> | boolean;
    synthEnabled?: BoolWithAggregatesFilter<'HelixUserNotificationProfile'> | boolean;
    aiDigestEnabled?: BoolWithAggregatesFilter<'HelixUserNotificationProfile'> | boolean;
    aiGroupingLevel?:
      | EnumAiGroupingLevelWithAggregatesFilter<'HelixUserNotificationProfile'>
      | $Enums.AiGroupingLevel;
    muteRepetitive?: BoolWithAggregatesFilter<'HelixUserNotificationProfile'> | boolean;
    sentinelEnabled?: BoolWithAggregatesFilter<'HelixUserNotificationProfile'> | boolean;
    securityEvents?: StringNullableListFilter<'HelixUserNotificationProfile'>;
    complianceEvents?: BoolWithAggregatesFilter<'HelixUserNotificationProfile'> | boolean;
    deviceTokens?: JsonNullableWithAggregatesFilter<'HelixUserNotificationProfile'>;
    pushEnabled?: BoolWithAggregatesFilter<'HelixUserNotificationProfile'> | boolean;
    phoneNumber?:
      | StringNullableWithAggregatesFilter<'HelixUserNotificationProfile'>
      | string
      | null;
    slackUserId?:
      | StringNullableWithAggregatesFilter<'HelixUserNotificationProfile'>
      | string
      | null;
    teamsUserId?:
      | StringNullableWithAggregatesFilter<'HelixUserNotificationProfile'>
      | string
      | null;
    createdAt?: DateTimeWithAggregatesFilter<'HelixUserNotificationProfile'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'HelixUserNotificationProfile'> | Date | string;
  };

  export type NotificationQueueWhereInput = {
    AND?: NotificationQueueWhereInput | NotificationQueueWhereInput[];
    OR?: NotificationQueueWhereInput[];
    NOT?: NotificationQueueWhereInput | NotificationQueueWhereInput[];
    id?: StringFilter<'NotificationQueue'> | string;
    eventId?: StringFilter<'NotificationQueue'> | string;
    deliveryId?: StringFilter<'NotificationQueue'> | string;
    priority?: EnumNotificationPriorityFilter<'NotificationQueue'> | $Enums.NotificationPriority;
    scheduledFor?: DateTimeFilter<'NotificationQueue'> | Date | string;
    attempts?: IntFilter<'NotificationQueue'> | number;
    maxAttempts?: IntFilter<'NotificationQueue'> | number;
    lastAttemptAt?: DateTimeNullableFilter<'NotificationQueue'> | Date | string | null;
    nextAttemptAt?: DateTimeNullableFilter<'NotificationQueue'> | Date | string | null;
    status?: StringFilter<'NotificationQueue'> | string;
    error?: StringNullableFilter<'NotificationQueue'> | string | null;
    metadata?: JsonNullableFilter<'NotificationQueue'>;
    createdAt?: DateTimeFilter<'NotificationQueue'> | Date | string;
    updatedAt?: DateTimeFilter<'NotificationQueue'> | Date | string;
    event?: XOR<NotificationEventScalarRelationFilter, NotificationEventWhereInput>;
    delivery?: XOR<NotificationScalarRelationFilter, NotificationWhereInput>;
  };

  export type NotificationQueueOrderByWithRelationInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    deliveryId?: SortOrder;
    priority?: SortOrder;
    scheduledFor?: SortOrder;
    attempts?: SortOrder;
    maxAttempts?: SortOrder;
    lastAttemptAt?: SortOrderInput | SortOrder;
    nextAttemptAt?: SortOrderInput | SortOrder;
    status?: SortOrder;
    error?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    event?: NotificationEventOrderByWithRelationInput;
    delivery?: NotificationOrderByWithRelationInput;
  };

  export type NotificationQueueWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: NotificationQueueWhereInput | NotificationQueueWhereInput[];
      OR?: NotificationQueueWhereInput[];
      NOT?: NotificationQueueWhereInput | NotificationQueueWhereInput[];
      eventId?: StringFilter<'NotificationQueue'> | string;
      deliveryId?: StringFilter<'NotificationQueue'> | string;
      priority?: EnumNotificationPriorityFilter<'NotificationQueue'> | $Enums.NotificationPriority;
      scheduledFor?: DateTimeFilter<'NotificationQueue'> | Date | string;
      attempts?: IntFilter<'NotificationQueue'> | number;
      maxAttempts?: IntFilter<'NotificationQueue'> | number;
      lastAttemptAt?: DateTimeNullableFilter<'NotificationQueue'> | Date | string | null;
      nextAttemptAt?: DateTimeNullableFilter<'NotificationQueue'> | Date | string | null;
      status?: StringFilter<'NotificationQueue'> | string;
      error?: StringNullableFilter<'NotificationQueue'> | string | null;
      metadata?: JsonNullableFilter<'NotificationQueue'>;
      createdAt?: DateTimeFilter<'NotificationQueue'> | Date | string;
      updatedAt?: DateTimeFilter<'NotificationQueue'> | Date | string;
      event?: XOR<NotificationEventScalarRelationFilter, NotificationEventWhereInput>;
      delivery?: XOR<NotificationScalarRelationFilter, NotificationWhereInput>;
    },
    'id'
  >;

  export type NotificationQueueOrderByWithAggregationInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    deliveryId?: SortOrder;
    priority?: SortOrder;
    scheduledFor?: SortOrder;
    attempts?: SortOrder;
    maxAttempts?: SortOrder;
    lastAttemptAt?: SortOrderInput | SortOrder;
    nextAttemptAt?: SortOrderInput | SortOrder;
    status?: SortOrder;
    error?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: NotificationQueueCountOrderByAggregateInput;
    _avg?: NotificationQueueAvgOrderByAggregateInput;
    _max?: NotificationQueueMaxOrderByAggregateInput;
    _min?: NotificationQueueMinOrderByAggregateInput;
    _sum?: NotificationQueueSumOrderByAggregateInput;
  };

  export type NotificationQueueScalarWhereWithAggregatesInput = {
    AND?:
      | NotificationQueueScalarWhereWithAggregatesInput
      | NotificationQueueScalarWhereWithAggregatesInput[];
    OR?: NotificationQueueScalarWhereWithAggregatesInput[];
    NOT?:
      | NotificationQueueScalarWhereWithAggregatesInput
      | NotificationQueueScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'NotificationQueue'> | string;
    eventId?: StringWithAggregatesFilter<'NotificationQueue'> | string;
    deliveryId?: StringWithAggregatesFilter<'NotificationQueue'> | string;
    priority?:
      | EnumNotificationPriorityWithAggregatesFilter<'NotificationQueue'>
      | $Enums.NotificationPriority;
    scheduledFor?: DateTimeWithAggregatesFilter<'NotificationQueue'> | Date | string;
    attempts?: IntWithAggregatesFilter<'NotificationQueue'> | number;
    maxAttempts?: IntWithAggregatesFilter<'NotificationQueue'> | number;
    lastAttemptAt?:
      | DateTimeNullableWithAggregatesFilter<'NotificationQueue'>
      | Date
      | string
      | null;
    nextAttemptAt?:
      | DateTimeNullableWithAggregatesFilter<'NotificationQueue'>
      | Date
      | string
      | null;
    status?: StringWithAggregatesFilter<'NotificationQueue'> | string;
    error?: StringNullableWithAggregatesFilter<'NotificationQueue'> | string | null;
    metadata?: JsonNullableWithAggregatesFilter<'NotificationQueue'>;
    createdAt?: DateTimeWithAggregatesFilter<'NotificationQueue'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'NotificationQueue'> | Date | string;
  };

  export type NotificationRoleDefaultWhereInput = {
    AND?: NotificationRoleDefaultWhereInput | NotificationRoleDefaultWhereInput[];
    OR?: NotificationRoleDefaultWhereInput[];
    NOT?: NotificationRoleDefaultWhereInput | NotificationRoleDefaultWhereInput[];
    id?: StringFilter<'NotificationRoleDefault'> | string;
    roleName?: StringFilter<'NotificationRoleDefault'> | string;
    module?: StringFilter<'NotificationRoleDefault'> | string;
    eventType?: StringFilter<'NotificationRoleDefault'> | string;
    channels?: EnumNotificationChannelNullableListFilter<'NotificationRoleDefault'>;
    enabled?: BoolFilter<'NotificationRoleDefault'> | boolean;
    priority?:
      | EnumNotificationPriorityNullableFilter<'NotificationRoleDefault'>
      | $Enums.NotificationPriority
      | null;
    metadata?: JsonNullableFilter<'NotificationRoleDefault'>;
    createdAt?: DateTimeFilter<'NotificationRoleDefault'> | Date | string;
    updatedAt?: DateTimeFilter<'NotificationRoleDefault'> | Date | string;
  };

  export type NotificationRoleDefaultOrderByWithRelationInput = {
    id?: SortOrder;
    roleName?: SortOrder;
    module?: SortOrder;
    eventType?: SortOrder;
    channels?: SortOrder;
    enabled?: SortOrder;
    priority?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type NotificationRoleDefaultWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      roleName_module_eventType?: NotificationRoleDefaultRoleNameModuleEventTypeCompoundUniqueInput;
      AND?: NotificationRoleDefaultWhereInput | NotificationRoleDefaultWhereInput[];
      OR?: NotificationRoleDefaultWhereInput[];
      NOT?: NotificationRoleDefaultWhereInput | NotificationRoleDefaultWhereInput[];
      roleName?: StringFilter<'NotificationRoleDefault'> | string;
      module?: StringFilter<'NotificationRoleDefault'> | string;
      eventType?: StringFilter<'NotificationRoleDefault'> | string;
      channels?: EnumNotificationChannelNullableListFilter<'NotificationRoleDefault'>;
      enabled?: BoolFilter<'NotificationRoleDefault'> | boolean;
      priority?:
        | EnumNotificationPriorityNullableFilter<'NotificationRoleDefault'>
        | $Enums.NotificationPriority
        | null;
      metadata?: JsonNullableFilter<'NotificationRoleDefault'>;
      createdAt?: DateTimeFilter<'NotificationRoleDefault'> | Date | string;
      updatedAt?: DateTimeFilter<'NotificationRoleDefault'> | Date | string;
    },
    'id' | 'roleName_module_eventType'
  >;

  export type NotificationRoleDefaultOrderByWithAggregationInput = {
    id?: SortOrder;
    roleName?: SortOrder;
    module?: SortOrder;
    eventType?: SortOrder;
    channels?: SortOrder;
    enabled?: SortOrder;
    priority?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: NotificationRoleDefaultCountOrderByAggregateInput;
    _max?: NotificationRoleDefaultMaxOrderByAggregateInput;
    _min?: NotificationRoleDefaultMinOrderByAggregateInput;
  };

  export type NotificationRoleDefaultScalarWhereWithAggregatesInput = {
    AND?:
      | NotificationRoleDefaultScalarWhereWithAggregatesInput
      | NotificationRoleDefaultScalarWhereWithAggregatesInput[];
    OR?: NotificationRoleDefaultScalarWhereWithAggregatesInput[];
    NOT?:
      | NotificationRoleDefaultScalarWhereWithAggregatesInput
      | NotificationRoleDefaultScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'NotificationRoleDefault'> | string;
    roleName?: StringWithAggregatesFilter<'NotificationRoleDefault'> | string;
    module?: StringWithAggregatesFilter<'NotificationRoleDefault'> | string;
    eventType?: StringWithAggregatesFilter<'NotificationRoleDefault'> | string;
    channels?: EnumNotificationChannelNullableListFilter<'NotificationRoleDefault'>;
    enabled?: BoolWithAggregatesFilter<'NotificationRoleDefault'> | boolean;
    priority?:
      | EnumNotificationPriorityNullableWithAggregatesFilter<'NotificationRoleDefault'>
      | $Enums.NotificationPriority
      | null;
    metadata?: JsonNullableWithAggregatesFilter<'NotificationRoleDefault'>;
    createdAt?: DateTimeWithAggregatesFilter<'NotificationRoleDefault'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'NotificationRoleDefault'> | Date | string;
  };

  export type NotificationAuditLogWhereInput = {
    AND?: NotificationAuditLogWhereInput | NotificationAuditLogWhereInput[];
    OR?: NotificationAuditLogWhereInput[];
    NOT?: NotificationAuditLogWhereInput | NotificationAuditLogWhereInput[];
    id?: StringFilter<'NotificationAuditLog'> | string;
    eventId?: StringFilter<'NotificationAuditLog'> | string;
    action?: StringFilter<'NotificationAuditLog'> | string;
    userId?: StringNullableFilter<'NotificationAuditLog'> | string | null;
    metadata?: JsonNullableFilter<'NotificationAuditLog'>;
    ipAddress?: StringNullableFilter<'NotificationAuditLog'> | string | null;
    userAgent?: StringNullableFilter<'NotificationAuditLog'> | string | null;
    timestamp?: DateTimeFilter<'NotificationAuditLog'> | Date | string;
    event?: XOR<NotificationEventScalarRelationFilter, NotificationEventWhereInput>;
  };

  export type NotificationAuditLogOrderByWithRelationInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    action?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    ipAddress?: SortOrderInput | SortOrder;
    userAgent?: SortOrderInput | SortOrder;
    timestamp?: SortOrder;
    event?: NotificationEventOrderByWithRelationInput;
  };

  export type NotificationAuditLogWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: NotificationAuditLogWhereInput | NotificationAuditLogWhereInput[];
      OR?: NotificationAuditLogWhereInput[];
      NOT?: NotificationAuditLogWhereInput | NotificationAuditLogWhereInput[];
      eventId?: StringFilter<'NotificationAuditLog'> | string;
      action?: StringFilter<'NotificationAuditLog'> | string;
      userId?: StringNullableFilter<'NotificationAuditLog'> | string | null;
      metadata?: JsonNullableFilter<'NotificationAuditLog'>;
      ipAddress?: StringNullableFilter<'NotificationAuditLog'> | string | null;
      userAgent?: StringNullableFilter<'NotificationAuditLog'> | string | null;
      timestamp?: DateTimeFilter<'NotificationAuditLog'> | Date | string;
      event?: XOR<NotificationEventScalarRelationFilter, NotificationEventWhereInput>;
    },
    'id'
  >;

  export type NotificationAuditLogOrderByWithAggregationInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    action?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    ipAddress?: SortOrderInput | SortOrder;
    userAgent?: SortOrderInput | SortOrder;
    timestamp?: SortOrder;
    _count?: NotificationAuditLogCountOrderByAggregateInput;
    _max?: NotificationAuditLogMaxOrderByAggregateInput;
    _min?: NotificationAuditLogMinOrderByAggregateInput;
  };

  export type NotificationAuditLogScalarWhereWithAggregatesInput = {
    AND?:
      | NotificationAuditLogScalarWhereWithAggregatesInput
      | NotificationAuditLogScalarWhereWithAggregatesInput[];
    OR?: NotificationAuditLogScalarWhereWithAggregatesInput[];
    NOT?:
      | NotificationAuditLogScalarWhereWithAggregatesInput
      | NotificationAuditLogScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'NotificationAuditLog'> | string;
    eventId?: StringWithAggregatesFilter<'NotificationAuditLog'> | string;
    action?: StringWithAggregatesFilter<'NotificationAuditLog'> | string;
    userId?: StringNullableWithAggregatesFilter<'NotificationAuditLog'> | string | null;
    metadata?: JsonNullableWithAggregatesFilter<'NotificationAuditLog'>;
    ipAddress?: StringNullableWithAggregatesFilter<'NotificationAuditLog'> | string | null;
    userAgent?: StringNullableWithAggregatesFilter<'NotificationAuditLog'> | string | null;
    timestamp?: DateTimeWithAggregatesFilter<'NotificationAuditLog'> | Date | string;
  };

  export type RoleNotificationDefaultsWhereInput = {
    AND?: RoleNotificationDefaultsWhereInput | RoleNotificationDefaultsWhereInput[];
    OR?: RoleNotificationDefaultsWhereInput[];
    NOT?: RoleNotificationDefaultsWhereInput | RoleNotificationDefaultsWhereInput[];
    id?: StringFilter<'RoleNotificationDefaults'> | string;
    roleId?: StringFilter<'RoleNotificationDefaults'> | string;
    module?: StringFilter<'RoleNotificationDefaults'> | string;
    eventType?: StringFilter<'RoleNotificationDefaults'> | string;
    channels?: EnumNotificationChannelNullableListFilter<'RoleNotificationDefaults'>;
    priority?:
      | EnumNotificationPriorityFilter<'RoleNotificationDefaults'>
      | $Enums.NotificationPriority;
    digestEnabled?: BoolFilter<'RoleNotificationDefaults'> | boolean;
    createdAt?: DateTimeFilter<'RoleNotificationDefaults'> | Date | string;
    updatedAt?: DateTimeFilter<'RoleNotificationDefaults'> | Date | string;
    createdBy?: StringNullableFilter<'RoleNotificationDefaults'> | string | null;
  };

  export type RoleNotificationDefaultsOrderByWithRelationInput = {
    id?: SortOrder;
    roleId?: SortOrder;
    module?: SortOrder;
    eventType?: SortOrder;
    channels?: SortOrder;
    priority?: SortOrder;
    digestEnabled?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrderInput | SortOrder;
  };

  export type RoleNotificationDefaultsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      roleId_module_eventType?: RoleNotificationDefaultsRoleIdModuleEventTypeCompoundUniqueInput;
      AND?: RoleNotificationDefaultsWhereInput | RoleNotificationDefaultsWhereInput[];
      OR?: RoleNotificationDefaultsWhereInput[];
      NOT?: RoleNotificationDefaultsWhereInput | RoleNotificationDefaultsWhereInput[];
      roleId?: StringFilter<'RoleNotificationDefaults'> | string;
      module?: StringFilter<'RoleNotificationDefaults'> | string;
      eventType?: StringFilter<'RoleNotificationDefaults'> | string;
      channels?: EnumNotificationChannelNullableListFilter<'RoleNotificationDefaults'>;
      priority?:
        | EnumNotificationPriorityFilter<'RoleNotificationDefaults'>
        | $Enums.NotificationPriority;
      digestEnabled?: BoolFilter<'RoleNotificationDefaults'> | boolean;
      createdAt?: DateTimeFilter<'RoleNotificationDefaults'> | Date | string;
      updatedAt?: DateTimeFilter<'RoleNotificationDefaults'> | Date | string;
      createdBy?: StringNullableFilter<'RoleNotificationDefaults'> | string | null;
    },
    'id' | 'roleId_module_eventType'
  >;

  export type RoleNotificationDefaultsOrderByWithAggregationInput = {
    id?: SortOrder;
    roleId?: SortOrder;
    module?: SortOrder;
    eventType?: SortOrder;
    channels?: SortOrder;
    priority?: SortOrder;
    digestEnabled?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrderInput | SortOrder;
    _count?: RoleNotificationDefaultsCountOrderByAggregateInput;
    _max?: RoleNotificationDefaultsMaxOrderByAggregateInput;
    _min?: RoleNotificationDefaultsMinOrderByAggregateInput;
  };

  export type RoleNotificationDefaultsScalarWhereWithAggregatesInput = {
    AND?:
      | RoleNotificationDefaultsScalarWhereWithAggregatesInput
      | RoleNotificationDefaultsScalarWhereWithAggregatesInput[];
    OR?: RoleNotificationDefaultsScalarWhereWithAggregatesInput[];
    NOT?:
      | RoleNotificationDefaultsScalarWhereWithAggregatesInput
      | RoleNotificationDefaultsScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'RoleNotificationDefaults'> | string;
    roleId?: StringWithAggregatesFilter<'RoleNotificationDefaults'> | string;
    module?: StringWithAggregatesFilter<'RoleNotificationDefaults'> | string;
    eventType?: StringWithAggregatesFilter<'RoleNotificationDefaults'> | string;
    channels?: EnumNotificationChannelNullableListFilter<'RoleNotificationDefaults'>;
    priority?:
      | EnumNotificationPriorityWithAggregatesFilter<'RoleNotificationDefaults'>
      | $Enums.NotificationPriority;
    digestEnabled?: BoolWithAggregatesFilter<'RoleNotificationDefaults'> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<'RoleNotificationDefaults'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'RoleNotificationDefaults'> | Date | string;
    createdBy?: StringNullableWithAggregatesFilter<'RoleNotificationDefaults'> | string | null;
  };

  export type NotificationAnalyticsWhereInput = {
    AND?: NotificationAnalyticsWhereInput | NotificationAnalyticsWhereInput[];
    OR?: NotificationAnalyticsWhereInput[];
    NOT?: NotificationAnalyticsWhereInput | NotificationAnalyticsWhereInput[];
    id?: StringFilter<'NotificationAnalytics'> | string;
    date?: DateTimeFilter<'NotificationAnalytics'> | Date | string;
    hour?: IntNullableFilter<'NotificationAnalytics'> | number | null;
    module?: StringNullableFilter<'NotificationAnalytics'> | string | null;
    eventType?: StringNullableFilter<'NotificationAnalytics'> | string | null;
    channel?:
      | EnumNotificationChannelNullableFilter<'NotificationAnalytics'>
      | $Enums.NotificationChannel
      | null;
    priority?:
      | EnumNotificationPriorityNullableFilter<'NotificationAnalytics'>
      | $Enums.NotificationPriority
      | null;
    userId?: StringNullableFilter<'NotificationAnalytics'> | string | null;
    tenantId?: StringNullableFilter<'NotificationAnalytics'> | string | null;
    eventsCreated?: IntFilter<'NotificationAnalytics'> | number;
    notificationsSent?: IntFilter<'NotificationAnalytics'> | number;
    delivered?: IntFilter<'NotificationAnalytics'> | number;
    failed?: IntFilter<'NotificationAnalytics'> | number;
    opened?: IntFilter<'NotificationAnalytics'> | number;
    clicked?: IntFilter<'NotificationAnalytics'> | number;
    dismissed?: IntFilter<'NotificationAnalytics'> | number;
    avgResponseTime?: FloatNullableFilter<'NotificationAnalytics'> | number | null;
    maxResponseTime?: IntNullableFilter<'NotificationAnalytics'> | number | null;
    createdAt?: DateTimeFilter<'NotificationAnalytics'> | Date | string;
    updatedAt?: DateTimeFilter<'NotificationAnalytics'> | Date | string;
  };

  export type NotificationAnalyticsOrderByWithRelationInput = {
    id?: SortOrder;
    date?: SortOrder;
    hour?: SortOrderInput | SortOrder;
    module?: SortOrderInput | SortOrder;
    eventType?: SortOrderInput | SortOrder;
    channel?: SortOrderInput | SortOrder;
    priority?: SortOrderInput | SortOrder;
    userId?: SortOrderInput | SortOrder;
    tenantId?: SortOrderInput | SortOrder;
    eventsCreated?: SortOrder;
    notificationsSent?: SortOrder;
    delivered?: SortOrder;
    failed?: SortOrder;
    opened?: SortOrder;
    clicked?: SortOrder;
    dismissed?: SortOrder;
    avgResponseTime?: SortOrderInput | SortOrder;
    maxResponseTime?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type NotificationAnalyticsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      date_hour_module_eventType_channel_userId?: NotificationAnalyticsDateHourModuleEventTypeChannelUserIdCompoundUniqueInput;
      AND?: NotificationAnalyticsWhereInput | NotificationAnalyticsWhereInput[];
      OR?: NotificationAnalyticsWhereInput[];
      NOT?: NotificationAnalyticsWhereInput | NotificationAnalyticsWhereInput[];
      date?: DateTimeFilter<'NotificationAnalytics'> | Date | string;
      hour?: IntNullableFilter<'NotificationAnalytics'> | number | null;
      module?: StringNullableFilter<'NotificationAnalytics'> | string | null;
      eventType?: StringNullableFilter<'NotificationAnalytics'> | string | null;
      channel?:
        | EnumNotificationChannelNullableFilter<'NotificationAnalytics'>
        | $Enums.NotificationChannel
        | null;
      priority?:
        | EnumNotificationPriorityNullableFilter<'NotificationAnalytics'>
        | $Enums.NotificationPriority
        | null;
      userId?: StringNullableFilter<'NotificationAnalytics'> | string | null;
      tenantId?: StringNullableFilter<'NotificationAnalytics'> | string | null;
      eventsCreated?: IntFilter<'NotificationAnalytics'> | number;
      notificationsSent?: IntFilter<'NotificationAnalytics'> | number;
      delivered?: IntFilter<'NotificationAnalytics'> | number;
      failed?: IntFilter<'NotificationAnalytics'> | number;
      opened?: IntFilter<'NotificationAnalytics'> | number;
      clicked?: IntFilter<'NotificationAnalytics'> | number;
      dismissed?: IntFilter<'NotificationAnalytics'> | number;
      avgResponseTime?: FloatNullableFilter<'NotificationAnalytics'> | number | null;
      maxResponseTime?: IntNullableFilter<'NotificationAnalytics'> | number | null;
      createdAt?: DateTimeFilter<'NotificationAnalytics'> | Date | string;
      updatedAt?: DateTimeFilter<'NotificationAnalytics'> | Date | string;
    },
    'id' | 'date_hour_module_eventType_channel_userId'
  >;

  export type NotificationAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder;
    date?: SortOrder;
    hour?: SortOrderInput | SortOrder;
    module?: SortOrderInput | SortOrder;
    eventType?: SortOrderInput | SortOrder;
    channel?: SortOrderInput | SortOrder;
    priority?: SortOrderInput | SortOrder;
    userId?: SortOrderInput | SortOrder;
    tenantId?: SortOrderInput | SortOrder;
    eventsCreated?: SortOrder;
    notificationsSent?: SortOrder;
    delivered?: SortOrder;
    failed?: SortOrder;
    opened?: SortOrder;
    clicked?: SortOrder;
    dismissed?: SortOrder;
    avgResponseTime?: SortOrderInput | SortOrder;
    maxResponseTime?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: NotificationAnalyticsCountOrderByAggregateInput;
    _avg?: NotificationAnalyticsAvgOrderByAggregateInput;
    _max?: NotificationAnalyticsMaxOrderByAggregateInput;
    _min?: NotificationAnalyticsMinOrderByAggregateInput;
    _sum?: NotificationAnalyticsSumOrderByAggregateInput;
  };

  export type NotificationAnalyticsScalarWhereWithAggregatesInput = {
    AND?:
      | NotificationAnalyticsScalarWhereWithAggregatesInput
      | NotificationAnalyticsScalarWhereWithAggregatesInput[];
    OR?: NotificationAnalyticsScalarWhereWithAggregatesInput[];
    NOT?:
      | NotificationAnalyticsScalarWhereWithAggregatesInput
      | NotificationAnalyticsScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'NotificationAnalytics'> | string;
    date?: DateTimeWithAggregatesFilter<'NotificationAnalytics'> | Date | string;
    hour?: IntNullableWithAggregatesFilter<'NotificationAnalytics'> | number | null;
    module?: StringNullableWithAggregatesFilter<'NotificationAnalytics'> | string | null;
    eventType?: StringNullableWithAggregatesFilter<'NotificationAnalytics'> | string | null;
    channel?:
      | EnumNotificationChannelNullableWithAggregatesFilter<'NotificationAnalytics'>
      | $Enums.NotificationChannel
      | null;
    priority?:
      | EnumNotificationPriorityNullableWithAggregatesFilter<'NotificationAnalytics'>
      | $Enums.NotificationPriority
      | null;
    userId?: StringNullableWithAggregatesFilter<'NotificationAnalytics'> | string | null;
    tenantId?: StringNullableWithAggregatesFilter<'NotificationAnalytics'> | string | null;
    eventsCreated?: IntWithAggregatesFilter<'NotificationAnalytics'> | number;
    notificationsSent?: IntWithAggregatesFilter<'NotificationAnalytics'> | number;
    delivered?: IntWithAggregatesFilter<'NotificationAnalytics'> | number;
    failed?: IntWithAggregatesFilter<'NotificationAnalytics'> | number;
    opened?: IntWithAggregatesFilter<'NotificationAnalytics'> | number;
    clicked?: IntWithAggregatesFilter<'NotificationAnalytics'> | number;
    dismissed?: IntWithAggregatesFilter<'NotificationAnalytics'> | number;
    avgResponseTime?: FloatNullableWithAggregatesFilter<'NotificationAnalytics'> | number | null;
    maxResponseTime?: IntNullableWithAggregatesFilter<'NotificationAnalytics'> | number | null;
    createdAt?: DateTimeWithAggregatesFilter<'NotificationAnalytics'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'NotificationAnalytics'> | Date | string;
  };

  export type NotificationEventCreateInput = {
    id?: string;
    eventId: string;
    module: string;
    eventType: string;
    priority?: $Enums.NotificationPriority;
    title: string;
    message: string;
    details?: string | null;
    recipientRoles?: NotificationEventCreaterecipientRolesInput | string[];
    recipientUsers?: NotificationEventCreaterecipientUsersInput | string[];
    tenantId?: string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    status?: $Enums.EventStatus;
    scheduledFor?: Date | string | null;
    expiresAt?: Date | string | null;
    createdAt?: Date | string;
    createdBy?: string | null;
    processedAt?: Date | string | null;
    notifications?: NotificationCreateNestedManyWithoutEventInput;
    deliveries?: NotificationDeliveryCreateNestedManyWithoutEventInput;
    queue?: NotificationQueueCreateNestedManyWithoutEventInput;
    auditLogs?: NotificationAuditLogCreateNestedManyWithoutEventInput;
  };

  export type NotificationEventUncheckedCreateInput = {
    id?: string;
    eventId: string;
    module: string;
    eventType: string;
    priority?: $Enums.NotificationPriority;
    title: string;
    message: string;
    details?: string | null;
    recipientRoles?: NotificationEventCreaterecipientRolesInput | string[];
    recipientUsers?: NotificationEventCreaterecipientUsersInput | string[];
    tenantId?: string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    status?: $Enums.EventStatus;
    scheduledFor?: Date | string | null;
    expiresAt?: Date | string | null;
    createdAt?: Date | string;
    createdBy?: string | null;
    processedAt?: Date | string | null;
    notifications?: NotificationUncheckedCreateNestedManyWithoutEventInput;
    deliveries?: NotificationDeliveryUncheckedCreateNestedManyWithoutEventInput;
    queue?: NotificationQueueUncheckedCreateNestedManyWithoutEventInput;
    auditLogs?: NotificationAuditLogUncheckedCreateNestedManyWithoutEventInput;
  };

  export type NotificationEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    module?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    details?: NullableStringFieldUpdateOperationsInput | string | null;
    recipientRoles?: NotificationEventUpdaterecipientRolesInput | string[];
    recipientUsers?: NotificationEventUpdaterecipientUsersInput | string[];
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    notifications?: NotificationUpdateManyWithoutEventNestedInput;
    deliveries?: NotificationDeliveryUpdateManyWithoutEventNestedInput;
    queue?: NotificationQueueUpdateManyWithoutEventNestedInput;
    auditLogs?: NotificationAuditLogUpdateManyWithoutEventNestedInput;
  };

  export type NotificationEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    module?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    details?: NullableStringFieldUpdateOperationsInput | string | null;
    recipientRoles?: NotificationEventUpdaterecipientRolesInput | string[];
    recipientUsers?: NotificationEventUpdaterecipientUsersInput | string[];
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    notifications?: NotificationUncheckedUpdateManyWithoutEventNestedInput;
    deliveries?: NotificationDeliveryUncheckedUpdateManyWithoutEventNestedInput;
    queue?: NotificationQueueUncheckedUpdateManyWithoutEventNestedInput;
    auditLogs?: NotificationAuditLogUncheckedUpdateManyWithoutEventNestedInput;
  };

  export type NotificationEventCreateManyInput = {
    id?: string;
    eventId: string;
    module: string;
    eventType: string;
    priority?: $Enums.NotificationPriority;
    title: string;
    message: string;
    details?: string | null;
    recipientRoles?: NotificationEventCreaterecipientRolesInput | string[];
    recipientUsers?: NotificationEventCreaterecipientUsersInput | string[];
    tenantId?: string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    status?: $Enums.EventStatus;
    scheduledFor?: Date | string | null;
    expiresAt?: Date | string | null;
    createdAt?: Date | string;
    createdBy?: string | null;
    processedAt?: Date | string | null;
  };

  export type NotificationEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    module?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    details?: NullableStringFieldUpdateOperationsInput | string | null;
    recipientRoles?: NotificationEventUpdaterecipientRolesInput | string[];
    recipientUsers?: NotificationEventUpdaterecipientUsersInput | string[];
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type NotificationEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    module?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    details?: NullableStringFieldUpdateOperationsInput | string | null;
    recipientRoles?: NotificationEventUpdaterecipientRolesInput | string[];
    recipientUsers?: NotificationEventUpdaterecipientUsersInput | string[];
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type NotificationPreferenceCreateInput = {
    id?: string;
    module: string;
    eventType: string;
    channels?: NotificationPreferenceCreatechannelsInput | $Enums.NotificationChannel[];
    priority?: $Enums.NotificationPriority;
    digestEnabled?: boolean;
    digestFrequency?: $Enums.DigestFrequency | null;
    dndEnabled?: boolean;
    dndStartTime?: string | null;
    dndEndTime?: string | null;
    dndDays?: NotificationPreferenceCreatedndDaysInput | string[];
    aiSummaryEnabled?: boolean;
    aiGroupingEnabled?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    helixProfile?: HelixUserNotificationProfileCreateNestedOneWithoutPreferencesInput;
  };

  export type NotificationPreferenceUncheckedCreateInput = {
    id?: string;
    userId: string;
    module: string;
    eventType: string;
    channels?: NotificationPreferenceCreatechannelsInput | $Enums.NotificationChannel[];
    priority?: $Enums.NotificationPriority;
    digestEnabled?: boolean;
    digestFrequency?: $Enums.DigestFrequency | null;
    dndEnabled?: boolean;
    dndStartTime?: string | null;
    dndEndTime?: string | null;
    dndDays?: NotificationPreferenceCreatedndDaysInput | string[];
    aiSummaryEnabled?: boolean;
    aiGroupingEnabled?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type NotificationPreferenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    module?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    channels?: NotificationPreferenceUpdatechannelsInput | $Enums.NotificationChannel[];
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    digestEnabled?: BoolFieldUpdateOperationsInput | boolean;
    digestFrequency?:
      | NullableEnumDigestFrequencyFieldUpdateOperationsInput
      | $Enums.DigestFrequency
      | null;
    dndEnabled?: BoolFieldUpdateOperationsInput | boolean;
    dndStartTime?: NullableStringFieldUpdateOperationsInput | string | null;
    dndEndTime?: NullableStringFieldUpdateOperationsInput | string | null;
    dndDays?: NotificationPreferenceUpdatedndDaysInput | string[];
    aiSummaryEnabled?: BoolFieldUpdateOperationsInput | boolean;
    aiGroupingEnabled?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    helixProfile?: HelixUserNotificationProfileUpdateOneWithoutPreferencesNestedInput;
  };

  export type NotificationPreferenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    module?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    channels?: NotificationPreferenceUpdatechannelsInput | $Enums.NotificationChannel[];
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    digestEnabled?: BoolFieldUpdateOperationsInput | boolean;
    digestFrequency?:
      | NullableEnumDigestFrequencyFieldUpdateOperationsInput
      | $Enums.DigestFrequency
      | null;
    dndEnabled?: BoolFieldUpdateOperationsInput | boolean;
    dndStartTime?: NullableStringFieldUpdateOperationsInput | string | null;
    dndEndTime?: NullableStringFieldUpdateOperationsInput | string | null;
    dndDays?: NotificationPreferenceUpdatedndDaysInput | string[];
    aiSummaryEnabled?: BoolFieldUpdateOperationsInput | boolean;
    aiGroupingEnabled?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationPreferenceCreateManyInput = {
    id?: string;
    userId: string;
    module: string;
    eventType: string;
    channels?: NotificationPreferenceCreatechannelsInput | $Enums.NotificationChannel[];
    priority?: $Enums.NotificationPriority;
    digestEnabled?: boolean;
    digestFrequency?: $Enums.DigestFrequency | null;
    dndEnabled?: boolean;
    dndStartTime?: string | null;
    dndEndTime?: string | null;
    dndDays?: NotificationPreferenceCreatedndDaysInput | string[];
    aiSummaryEnabled?: boolean;
    aiGroupingEnabled?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type NotificationPreferenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    module?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    channels?: NotificationPreferenceUpdatechannelsInput | $Enums.NotificationChannel[];
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    digestEnabled?: BoolFieldUpdateOperationsInput | boolean;
    digestFrequency?:
      | NullableEnumDigestFrequencyFieldUpdateOperationsInput
      | $Enums.DigestFrequency
      | null;
    dndEnabled?: BoolFieldUpdateOperationsInput | boolean;
    dndStartTime?: NullableStringFieldUpdateOperationsInput | string | null;
    dndEndTime?: NullableStringFieldUpdateOperationsInput | string | null;
    dndDays?: NotificationPreferenceUpdatedndDaysInput | string[];
    aiSummaryEnabled?: BoolFieldUpdateOperationsInput | boolean;
    aiGroupingEnabled?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationPreferenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    module?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    channels?: NotificationPreferenceUpdatechannelsInput | $Enums.NotificationChannel[];
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    digestEnabled?: BoolFieldUpdateOperationsInput | boolean;
    digestFrequency?:
      | NullableEnumDigestFrequencyFieldUpdateOperationsInput
      | $Enums.DigestFrequency
      | null;
    dndEnabled?: BoolFieldUpdateOperationsInput | boolean;
    dndStartTime?: NullableStringFieldUpdateOperationsInput | string | null;
    dndEndTime?: NullableStringFieldUpdateOperationsInput | string | null;
    dndDays?: NotificationPreferenceUpdatedndDaysInput | string[];
    aiSummaryEnabled?: BoolFieldUpdateOperationsInput | boolean;
    aiGroupingEnabled?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationCreateInput = {
    id?: string;
    userId: string;
    channel: $Enums.NotificationChannel;
    title: string;
    message: string;
    details?: string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    status?: $Enums.NotificationStatus;
    priority?: $Enums.NotificationPriority;
    scheduledFor?: Date | string | null;
    deliveredAt?: Date | string | null;
    readAt?: Date | string | null;
    clickedAt?: Date | string | null;
    dismissedAt?: Date | string | null;
    retryCount?: number;
    maxRetries?: number;
    nextRetry?: Date | string | null;
    aiSummary?: string | null;
    groupId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    event: NotificationEventCreateNestedOneWithoutNotificationsInput;
    deliveries?: NotificationDeliveryCreateNestedManyWithoutNotificationInput;
    queue?: NotificationQueueCreateNestedManyWithoutDeliveryInput;
  };

  export type NotificationUncheckedCreateInput = {
    id?: string;
    eventId: string;
    userId: string;
    channel: $Enums.NotificationChannel;
    title: string;
    message: string;
    details?: string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    status?: $Enums.NotificationStatus;
    priority?: $Enums.NotificationPriority;
    scheduledFor?: Date | string | null;
    deliveredAt?: Date | string | null;
    readAt?: Date | string | null;
    clickedAt?: Date | string | null;
    dismissedAt?: Date | string | null;
    retryCount?: number;
    maxRetries?: number;
    nextRetry?: Date | string | null;
    aiSummary?: string | null;
    groupId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deliveries?: NotificationDeliveryUncheckedCreateNestedManyWithoutNotificationInput;
    queue?: NotificationQueueUncheckedCreateNestedManyWithoutDeliveryInput;
  };

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    details?: NullableStringFieldUpdateOperationsInput | string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    retryCount?: IntFieldUpdateOperationsInput | number;
    maxRetries?: IntFieldUpdateOperationsInput | number;
    nextRetry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null;
    groupId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    event?: NotificationEventUpdateOneRequiredWithoutNotificationsNestedInput;
    deliveries?: NotificationDeliveryUpdateManyWithoutNotificationNestedInput;
    queue?: NotificationQueueUpdateManyWithoutDeliveryNestedInput;
  };

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    details?: NullableStringFieldUpdateOperationsInput | string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    retryCount?: IntFieldUpdateOperationsInput | number;
    maxRetries?: IntFieldUpdateOperationsInput | number;
    nextRetry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null;
    groupId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deliveries?: NotificationDeliveryUncheckedUpdateManyWithoutNotificationNestedInput;
    queue?: NotificationQueueUncheckedUpdateManyWithoutDeliveryNestedInput;
  };

  export type NotificationCreateManyInput = {
    id?: string;
    eventId: string;
    userId: string;
    channel: $Enums.NotificationChannel;
    title: string;
    message: string;
    details?: string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    status?: $Enums.NotificationStatus;
    priority?: $Enums.NotificationPriority;
    scheduledFor?: Date | string | null;
    deliveredAt?: Date | string | null;
    readAt?: Date | string | null;
    clickedAt?: Date | string | null;
    dismissedAt?: Date | string | null;
    retryCount?: number;
    maxRetries?: number;
    nextRetry?: Date | string | null;
    aiSummary?: string | null;
    groupId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    details?: NullableStringFieldUpdateOperationsInput | string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    retryCount?: IntFieldUpdateOperationsInput | number;
    maxRetries?: IntFieldUpdateOperationsInput | number;
    nextRetry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null;
    groupId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    details?: NullableStringFieldUpdateOperationsInput | string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    retryCount?: IntFieldUpdateOperationsInput | number;
    maxRetries?: IntFieldUpdateOperationsInput | number;
    nextRetry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null;
    groupId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationDeliveryCreateInput = {
    id?: string;
    userId: string;
    channel: $Enums.NotificationChannel;
    provider?: string | null;
    providerConfig?: NullableJsonNullValueInput | InputJsonValue;
    status?: $Enums.DeliveryStatus;
    deliveredAt?: Date | string | null;
    failedAt?: Date | string | null;
    errorMessage?: string | null;
    errorCode?: string | null;
    providerResponse?: NullableJsonNullValueInput | InputJsonValue;
    messageId?: string | null;
    responseTime?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    notification: NotificationCreateNestedOneWithoutDeliveriesInput;
    event: NotificationEventCreateNestedOneWithoutDeliveriesInput;
  };

  export type NotificationDeliveryUncheckedCreateInput = {
    id?: string;
    notificationId: string;
    eventId: string;
    userId: string;
    channel: $Enums.NotificationChannel;
    provider?: string | null;
    providerConfig?: NullableJsonNullValueInput | InputJsonValue;
    status?: $Enums.DeliveryStatus;
    deliveredAt?: Date | string | null;
    failedAt?: Date | string | null;
    errorMessage?: string | null;
    errorCode?: string | null;
    providerResponse?: NullableJsonNullValueInput | InputJsonValue;
    messageId?: string | null;
    responseTime?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type NotificationDeliveryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel;
    provider?: NullableStringFieldUpdateOperationsInput | string | null;
    providerConfig?: NullableJsonNullValueInput | InputJsonValue;
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus;
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null;
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null;
    providerResponse?: NullableJsonNullValueInput | InputJsonValue;
    messageId?: NullableStringFieldUpdateOperationsInput | string | null;
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    notification?: NotificationUpdateOneRequiredWithoutDeliveriesNestedInput;
    event?: NotificationEventUpdateOneRequiredWithoutDeliveriesNestedInput;
  };

  export type NotificationDeliveryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    notificationId?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel;
    provider?: NullableStringFieldUpdateOperationsInput | string | null;
    providerConfig?: NullableJsonNullValueInput | InputJsonValue;
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus;
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null;
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null;
    providerResponse?: NullableJsonNullValueInput | InputJsonValue;
    messageId?: NullableStringFieldUpdateOperationsInput | string | null;
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationDeliveryCreateManyInput = {
    id?: string;
    notificationId: string;
    eventId: string;
    userId: string;
    channel: $Enums.NotificationChannel;
    provider?: string | null;
    providerConfig?: NullableJsonNullValueInput | InputJsonValue;
    status?: $Enums.DeliveryStatus;
    deliveredAt?: Date | string | null;
    failedAt?: Date | string | null;
    errorMessage?: string | null;
    errorCode?: string | null;
    providerResponse?: NullableJsonNullValueInput | InputJsonValue;
    messageId?: string | null;
    responseTime?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type NotificationDeliveryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel;
    provider?: NullableStringFieldUpdateOperationsInput | string | null;
    providerConfig?: NullableJsonNullValueInput | InputJsonValue;
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus;
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null;
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null;
    providerResponse?: NullableJsonNullValueInput | InputJsonValue;
    messageId?: NullableStringFieldUpdateOperationsInput | string | null;
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationDeliveryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    notificationId?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel;
    provider?: NullableStringFieldUpdateOperationsInput | string | null;
    providerConfig?: NullableJsonNullValueInput | InputJsonValue;
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus;
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null;
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null;
    providerResponse?: NullableJsonNullValueInput | InputJsonValue;
    messageId?: NullableStringFieldUpdateOperationsInput | string | null;
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationTemplateCreateInput = {
    id?: string;
    module: string;
    eventType: string;
    channel: $Enums.NotificationChannel;
    name: string;
    description?: string | null;
    titleTemplate: string;
    messageTemplate: string;
    detailsTemplate?: string | null;
    isDefault?: boolean;
    isActive?: boolean;
    version?: number;
    locale?: string;
    variables?: NullableJsonNullValueInput | InputJsonValue;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
  };

  export type NotificationTemplateUncheckedCreateInput = {
    id?: string;
    module: string;
    eventType: string;
    channel: $Enums.NotificationChannel;
    name: string;
    description?: string | null;
    titleTemplate: string;
    messageTemplate: string;
    detailsTemplate?: string | null;
    isDefault?: boolean;
    isActive?: boolean;
    version?: number;
    locale?: string;
    variables?: NullableJsonNullValueInput | InputJsonValue;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
  };

  export type NotificationTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    module?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    titleTemplate?: StringFieldUpdateOperationsInput | string;
    messageTemplate?: StringFieldUpdateOperationsInput | string;
    detailsTemplate?: NullableStringFieldUpdateOperationsInput | string | null;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    version?: IntFieldUpdateOperationsInput | number;
    locale?: StringFieldUpdateOperationsInput | string;
    variables?: NullableJsonNullValueInput | InputJsonValue;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type NotificationTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    module?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    titleTemplate?: StringFieldUpdateOperationsInput | string;
    messageTemplate?: StringFieldUpdateOperationsInput | string;
    detailsTemplate?: NullableStringFieldUpdateOperationsInput | string | null;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    version?: IntFieldUpdateOperationsInput | number;
    locale?: StringFieldUpdateOperationsInput | string;
    variables?: NullableJsonNullValueInput | InputJsonValue;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type NotificationTemplateCreateManyInput = {
    id?: string;
    module: string;
    eventType: string;
    channel: $Enums.NotificationChannel;
    name: string;
    description?: string | null;
    titleTemplate: string;
    messageTemplate: string;
    detailsTemplate?: string | null;
    isDefault?: boolean;
    isActive?: boolean;
    version?: number;
    locale?: string;
    variables?: NullableJsonNullValueInput | InputJsonValue;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
  };

  export type NotificationTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    module?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    titleTemplate?: StringFieldUpdateOperationsInput | string;
    messageTemplate?: StringFieldUpdateOperationsInput | string;
    detailsTemplate?: NullableStringFieldUpdateOperationsInput | string | null;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    version?: IntFieldUpdateOperationsInput | number;
    locale?: StringFieldUpdateOperationsInput | string;
    variables?: NullableJsonNullValueInput | InputJsonValue;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type NotificationTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    module?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    titleTemplate?: StringFieldUpdateOperationsInput | string;
    messageTemplate?: StringFieldUpdateOperationsInput | string;
    detailsTemplate?: NullableStringFieldUpdateOperationsInput | string | null;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    version?: IntFieldUpdateOperationsInput | number;
    locale?: StringFieldUpdateOperationsInput | string;
    variables?: NullableJsonNullValueInput | InputJsonValue;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type NotificationProviderCreateInput = {
    id?: string;
    name: string;
    type: $Enums.NotificationChannel;
    config: JsonNullValueInput | InputJsonValue;
    credentials?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    isDefault?: boolean;
    priority?: number;
    rateLimitPerHour?: number | null;
    rateLimitPerDay?: number | null;
    lastHealthCheck?: Date | string | null;
    healthStatus?: $Enums.ProviderHealth;
    errorCount?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
  };

  export type NotificationProviderUncheckedCreateInput = {
    id?: string;
    name: string;
    type: $Enums.NotificationChannel;
    config: JsonNullValueInput | InputJsonValue;
    credentials?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    isDefault?: boolean;
    priority?: number;
    rateLimitPerHour?: number | null;
    rateLimitPerDay?: number | null;
    lastHealthCheck?: Date | string | null;
    healthStatus?: $Enums.ProviderHealth;
    errorCount?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
  };

  export type NotificationProviderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel;
    config?: JsonNullValueInput | InputJsonValue;
    credentials?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    priority?: IntFieldUpdateOperationsInput | number;
    rateLimitPerHour?: NullableIntFieldUpdateOperationsInput | number | null;
    rateLimitPerDay?: NullableIntFieldUpdateOperationsInput | number | null;
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    healthStatus?: EnumProviderHealthFieldUpdateOperationsInput | $Enums.ProviderHealth;
    errorCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type NotificationProviderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel;
    config?: JsonNullValueInput | InputJsonValue;
    credentials?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    priority?: IntFieldUpdateOperationsInput | number;
    rateLimitPerHour?: NullableIntFieldUpdateOperationsInput | number | null;
    rateLimitPerDay?: NullableIntFieldUpdateOperationsInput | number | null;
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    healthStatus?: EnumProviderHealthFieldUpdateOperationsInput | $Enums.ProviderHealth;
    errorCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type NotificationProviderCreateManyInput = {
    id?: string;
    name: string;
    type: $Enums.NotificationChannel;
    config: JsonNullValueInput | InputJsonValue;
    credentials?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: boolean;
    isDefault?: boolean;
    priority?: number;
    rateLimitPerHour?: number | null;
    rateLimitPerDay?: number | null;
    lastHealthCheck?: Date | string | null;
    healthStatus?: $Enums.ProviderHealth;
    errorCount?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
  };

  export type NotificationProviderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel;
    config?: JsonNullValueInput | InputJsonValue;
    credentials?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    priority?: IntFieldUpdateOperationsInput | number;
    rateLimitPerHour?: NullableIntFieldUpdateOperationsInput | number | null;
    rateLimitPerDay?: NullableIntFieldUpdateOperationsInput | number | null;
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    healthStatus?: EnumProviderHealthFieldUpdateOperationsInput | $Enums.ProviderHealth;
    errorCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type NotificationProviderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel;
    config?: JsonNullValueInput | InputJsonValue;
    credentials?: NullableJsonNullValueInput | InputJsonValue;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    priority?: IntFieldUpdateOperationsInput | number;
    rateLimitPerHour?: NullableIntFieldUpdateOperationsInput | number | null;
    rateLimitPerDay?: NullableIntFieldUpdateOperationsInput | number | null;
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    healthStatus?: EnumProviderHealthFieldUpdateOperationsInput | $Enums.ProviderHealth;
    errorCount?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type HelixUserNotificationProfileCreateInput = {
    id?: string;
    userId: string;
    globalEnabled?: boolean;
    defaultChannels?:
      | HelixUserNotificationProfileCreatedefaultChannelsInput
      | $Enums.NotificationChannel[];
    timezone?: string;
    digestEnabled?: boolean;
    digestFrequency?: $Enums.DigestFrequency;
    digestTime?: string;
    dndEnabled?: boolean;
    dndStartTime?: string | null;
    dndEndTime?: string | null;
    dndDays?: HelixUserNotificationProfileCreatedndDaysInput | string[];
    goalertEnabled?: boolean;
    goalertSchedules?: HelixUserNotificationProfileCreategoalertSchedulesInput | string[];
    goalertPolicies?: HelixUserNotificationProfileCreategoalertPoliciesInput | string[];
    pagerEnabled?: boolean;
    synthEnabled?: boolean;
    aiDigestEnabled?: boolean;
    aiGroupingLevel?: $Enums.AiGroupingLevel;
    muteRepetitive?: boolean;
    sentinelEnabled?: boolean;
    securityEvents?: HelixUserNotificationProfileCreatesecurityEventsInput | string[];
    complianceEvents?: boolean;
    deviceTokens?: NullableJsonNullValueInput | InputJsonValue;
    pushEnabled?: boolean;
    phoneNumber?: string | null;
    slackUserId?: string | null;
    teamsUserId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    preferences?: NotificationPreferenceCreateNestedManyWithoutHelixProfileInput;
  };

  export type HelixUserNotificationProfileUncheckedCreateInput = {
    id?: string;
    userId: string;
    globalEnabled?: boolean;
    defaultChannels?:
      | HelixUserNotificationProfileCreatedefaultChannelsInput
      | $Enums.NotificationChannel[];
    timezone?: string;
    digestEnabled?: boolean;
    digestFrequency?: $Enums.DigestFrequency;
    digestTime?: string;
    dndEnabled?: boolean;
    dndStartTime?: string | null;
    dndEndTime?: string | null;
    dndDays?: HelixUserNotificationProfileCreatedndDaysInput | string[];
    goalertEnabled?: boolean;
    goalertSchedules?: HelixUserNotificationProfileCreategoalertSchedulesInput | string[];
    goalertPolicies?: HelixUserNotificationProfileCreategoalertPoliciesInput | string[];
    pagerEnabled?: boolean;
    synthEnabled?: boolean;
    aiDigestEnabled?: boolean;
    aiGroupingLevel?: $Enums.AiGroupingLevel;
    muteRepetitive?: boolean;
    sentinelEnabled?: boolean;
    securityEvents?: HelixUserNotificationProfileCreatesecurityEventsInput | string[];
    complianceEvents?: boolean;
    deviceTokens?: NullableJsonNullValueInput | InputJsonValue;
    pushEnabled?: boolean;
    phoneNumber?: string | null;
    slackUserId?: string | null;
    teamsUserId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    preferences?: NotificationPreferenceUncheckedCreateNestedManyWithoutHelixProfileInput;
  };

  export type HelixUserNotificationProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    globalEnabled?: BoolFieldUpdateOperationsInput | boolean;
    defaultChannels?:
      | HelixUserNotificationProfileUpdatedefaultChannelsInput
      | $Enums.NotificationChannel[];
    timezone?: StringFieldUpdateOperationsInput | string;
    digestEnabled?: BoolFieldUpdateOperationsInput | boolean;
    digestFrequency?: EnumDigestFrequencyFieldUpdateOperationsInput | $Enums.DigestFrequency;
    digestTime?: StringFieldUpdateOperationsInput | string;
    dndEnabled?: BoolFieldUpdateOperationsInput | boolean;
    dndStartTime?: NullableStringFieldUpdateOperationsInput | string | null;
    dndEndTime?: NullableStringFieldUpdateOperationsInput | string | null;
    dndDays?: HelixUserNotificationProfileUpdatedndDaysInput | string[];
    goalertEnabled?: BoolFieldUpdateOperationsInput | boolean;
    goalertSchedules?: HelixUserNotificationProfileUpdategoalertSchedulesInput | string[];
    goalertPolicies?: HelixUserNotificationProfileUpdategoalertPoliciesInput | string[];
    pagerEnabled?: BoolFieldUpdateOperationsInput | boolean;
    synthEnabled?: BoolFieldUpdateOperationsInput | boolean;
    aiDigestEnabled?: BoolFieldUpdateOperationsInput | boolean;
    aiGroupingLevel?: EnumAiGroupingLevelFieldUpdateOperationsInput | $Enums.AiGroupingLevel;
    muteRepetitive?: BoolFieldUpdateOperationsInput | boolean;
    sentinelEnabled?: BoolFieldUpdateOperationsInput | boolean;
    securityEvents?: HelixUserNotificationProfileUpdatesecurityEventsInput | string[];
    complianceEvents?: BoolFieldUpdateOperationsInput | boolean;
    deviceTokens?: NullableJsonNullValueInput | InputJsonValue;
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    slackUserId?: NullableStringFieldUpdateOperationsInput | string | null;
    teamsUserId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    preferences?: NotificationPreferenceUpdateManyWithoutHelixProfileNestedInput;
  };

  export type HelixUserNotificationProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    globalEnabled?: BoolFieldUpdateOperationsInput | boolean;
    defaultChannels?:
      | HelixUserNotificationProfileUpdatedefaultChannelsInput
      | $Enums.NotificationChannel[];
    timezone?: StringFieldUpdateOperationsInput | string;
    digestEnabled?: BoolFieldUpdateOperationsInput | boolean;
    digestFrequency?: EnumDigestFrequencyFieldUpdateOperationsInput | $Enums.DigestFrequency;
    digestTime?: StringFieldUpdateOperationsInput | string;
    dndEnabled?: BoolFieldUpdateOperationsInput | boolean;
    dndStartTime?: NullableStringFieldUpdateOperationsInput | string | null;
    dndEndTime?: NullableStringFieldUpdateOperationsInput | string | null;
    dndDays?: HelixUserNotificationProfileUpdatedndDaysInput | string[];
    goalertEnabled?: BoolFieldUpdateOperationsInput | boolean;
    goalertSchedules?: HelixUserNotificationProfileUpdategoalertSchedulesInput | string[];
    goalertPolicies?: HelixUserNotificationProfileUpdategoalertPoliciesInput | string[];
    pagerEnabled?: BoolFieldUpdateOperationsInput | boolean;
    synthEnabled?: BoolFieldUpdateOperationsInput | boolean;
    aiDigestEnabled?: BoolFieldUpdateOperationsInput | boolean;
    aiGroupingLevel?: EnumAiGroupingLevelFieldUpdateOperationsInput | $Enums.AiGroupingLevel;
    muteRepetitive?: BoolFieldUpdateOperationsInput | boolean;
    sentinelEnabled?: BoolFieldUpdateOperationsInput | boolean;
    securityEvents?: HelixUserNotificationProfileUpdatesecurityEventsInput | string[];
    complianceEvents?: BoolFieldUpdateOperationsInput | boolean;
    deviceTokens?: NullableJsonNullValueInput | InputJsonValue;
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    slackUserId?: NullableStringFieldUpdateOperationsInput | string | null;
    teamsUserId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    preferences?: NotificationPreferenceUncheckedUpdateManyWithoutHelixProfileNestedInput;
  };

  export type HelixUserNotificationProfileCreateManyInput = {
    id?: string;
    userId: string;
    globalEnabled?: boolean;
    defaultChannels?:
      | HelixUserNotificationProfileCreatedefaultChannelsInput
      | $Enums.NotificationChannel[];
    timezone?: string;
    digestEnabled?: boolean;
    digestFrequency?: $Enums.DigestFrequency;
    digestTime?: string;
    dndEnabled?: boolean;
    dndStartTime?: string | null;
    dndEndTime?: string | null;
    dndDays?: HelixUserNotificationProfileCreatedndDaysInput | string[];
    goalertEnabled?: boolean;
    goalertSchedules?: HelixUserNotificationProfileCreategoalertSchedulesInput | string[];
    goalertPolicies?: HelixUserNotificationProfileCreategoalertPoliciesInput | string[];
    pagerEnabled?: boolean;
    synthEnabled?: boolean;
    aiDigestEnabled?: boolean;
    aiGroupingLevel?: $Enums.AiGroupingLevel;
    muteRepetitive?: boolean;
    sentinelEnabled?: boolean;
    securityEvents?: HelixUserNotificationProfileCreatesecurityEventsInput | string[];
    complianceEvents?: boolean;
    deviceTokens?: NullableJsonNullValueInput | InputJsonValue;
    pushEnabled?: boolean;
    phoneNumber?: string | null;
    slackUserId?: string | null;
    teamsUserId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type HelixUserNotificationProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    globalEnabled?: BoolFieldUpdateOperationsInput | boolean;
    defaultChannels?:
      | HelixUserNotificationProfileUpdatedefaultChannelsInput
      | $Enums.NotificationChannel[];
    timezone?: StringFieldUpdateOperationsInput | string;
    digestEnabled?: BoolFieldUpdateOperationsInput | boolean;
    digestFrequency?: EnumDigestFrequencyFieldUpdateOperationsInput | $Enums.DigestFrequency;
    digestTime?: StringFieldUpdateOperationsInput | string;
    dndEnabled?: BoolFieldUpdateOperationsInput | boolean;
    dndStartTime?: NullableStringFieldUpdateOperationsInput | string | null;
    dndEndTime?: NullableStringFieldUpdateOperationsInput | string | null;
    dndDays?: HelixUserNotificationProfileUpdatedndDaysInput | string[];
    goalertEnabled?: BoolFieldUpdateOperationsInput | boolean;
    goalertSchedules?: HelixUserNotificationProfileUpdategoalertSchedulesInput | string[];
    goalertPolicies?: HelixUserNotificationProfileUpdategoalertPoliciesInput | string[];
    pagerEnabled?: BoolFieldUpdateOperationsInput | boolean;
    synthEnabled?: BoolFieldUpdateOperationsInput | boolean;
    aiDigestEnabled?: BoolFieldUpdateOperationsInput | boolean;
    aiGroupingLevel?: EnumAiGroupingLevelFieldUpdateOperationsInput | $Enums.AiGroupingLevel;
    muteRepetitive?: BoolFieldUpdateOperationsInput | boolean;
    sentinelEnabled?: BoolFieldUpdateOperationsInput | boolean;
    securityEvents?: HelixUserNotificationProfileUpdatesecurityEventsInput | string[];
    complianceEvents?: BoolFieldUpdateOperationsInput | boolean;
    deviceTokens?: NullableJsonNullValueInput | InputJsonValue;
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    slackUserId?: NullableStringFieldUpdateOperationsInput | string | null;
    teamsUserId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type HelixUserNotificationProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    globalEnabled?: BoolFieldUpdateOperationsInput | boolean;
    defaultChannels?:
      | HelixUserNotificationProfileUpdatedefaultChannelsInput
      | $Enums.NotificationChannel[];
    timezone?: StringFieldUpdateOperationsInput | string;
    digestEnabled?: BoolFieldUpdateOperationsInput | boolean;
    digestFrequency?: EnumDigestFrequencyFieldUpdateOperationsInput | $Enums.DigestFrequency;
    digestTime?: StringFieldUpdateOperationsInput | string;
    dndEnabled?: BoolFieldUpdateOperationsInput | boolean;
    dndStartTime?: NullableStringFieldUpdateOperationsInput | string | null;
    dndEndTime?: NullableStringFieldUpdateOperationsInput | string | null;
    dndDays?: HelixUserNotificationProfileUpdatedndDaysInput | string[];
    goalertEnabled?: BoolFieldUpdateOperationsInput | boolean;
    goalertSchedules?: HelixUserNotificationProfileUpdategoalertSchedulesInput | string[];
    goalertPolicies?: HelixUserNotificationProfileUpdategoalertPoliciesInput | string[];
    pagerEnabled?: BoolFieldUpdateOperationsInput | boolean;
    synthEnabled?: BoolFieldUpdateOperationsInput | boolean;
    aiDigestEnabled?: BoolFieldUpdateOperationsInput | boolean;
    aiGroupingLevel?: EnumAiGroupingLevelFieldUpdateOperationsInput | $Enums.AiGroupingLevel;
    muteRepetitive?: BoolFieldUpdateOperationsInput | boolean;
    sentinelEnabled?: BoolFieldUpdateOperationsInput | boolean;
    securityEvents?: HelixUserNotificationProfileUpdatesecurityEventsInput | string[];
    complianceEvents?: BoolFieldUpdateOperationsInput | boolean;
    deviceTokens?: NullableJsonNullValueInput | InputJsonValue;
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    slackUserId?: NullableStringFieldUpdateOperationsInput | string | null;
    teamsUserId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationQueueCreateInput = {
    id?: string;
    priority?: $Enums.NotificationPriority;
    scheduledFor?: Date | string;
    attempts?: number;
    maxAttempts?: number;
    lastAttemptAt?: Date | string | null;
    nextAttemptAt?: Date | string | null;
    status?: string;
    error?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    event: NotificationEventCreateNestedOneWithoutQueueInput;
    delivery: NotificationCreateNestedOneWithoutQueueInput;
  };

  export type NotificationQueueUncheckedCreateInput = {
    id?: string;
    eventId: string;
    deliveryId: string;
    priority?: $Enums.NotificationPriority;
    scheduledFor?: Date | string;
    attempts?: number;
    maxAttempts?: number;
    lastAttemptAt?: Date | string | null;
    nextAttemptAt?: Date | string | null;
    status?: string;
    error?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type NotificationQueueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string;
    attempts?: IntFieldUpdateOperationsInput | number;
    maxAttempts?: IntFieldUpdateOperationsInput | number;
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nextAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    status?: StringFieldUpdateOperationsInput | string;
    error?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    event?: NotificationEventUpdateOneRequiredWithoutQueueNestedInput;
    delivery?: NotificationUpdateOneRequiredWithoutQueueNestedInput;
  };

  export type NotificationQueueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    deliveryId?: StringFieldUpdateOperationsInput | string;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string;
    attempts?: IntFieldUpdateOperationsInput | number;
    maxAttempts?: IntFieldUpdateOperationsInput | number;
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nextAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    status?: StringFieldUpdateOperationsInput | string;
    error?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationQueueCreateManyInput = {
    id?: string;
    eventId: string;
    deliveryId: string;
    priority?: $Enums.NotificationPriority;
    scheduledFor?: Date | string;
    attempts?: number;
    maxAttempts?: number;
    lastAttemptAt?: Date | string | null;
    nextAttemptAt?: Date | string | null;
    status?: string;
    error?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type NotificationQueueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string;
    attempts?: IntFieldUpdateOperationsInput | number;
    maxAttempts?: IntFieldUpdateOperationsInput | number;
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nextAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    status?: StringFieldUpdateOperationsInput | string;
    error?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationQueueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    deliveryId?: StringFieldUpdateOperationsInput | string;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string;
    attempts?: IntFieldUpdateOperationsInput | number;
    maxAttempts?: IntFieldUpdateOperationsInput | number;
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nextAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    status?: StringFieldUpdateOperationsInput | string;
    error?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationRoleDefaultCreateInput = {
    id?: string;
    roleName: string;
    module: string;
    eventType: string;
    channels?: NotificationRoleDefaultCreatechannelsInput | $Enums.NotificationChannel[];
    enabled?: boolean;
    priority?: $Enums.NotificationPriority | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type NotificationRoleDefaultUncheckedCreateInput = {
    id?: string;
    roleName: string;
    module: string;
    eventType: string;
    channels?: NotificationRoleDefaultCreatechannelsInput | $Enums.NotificationChannel[];
    enabled?: boolean;
    priority?: $Enums.NotificationPriority | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type NotificationRoleDefaultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    roleName?: StringFieldUpdateOperationsInput | string;
    module?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    channels?: NotificationRoleDefaultUpdatechannelsInput | $Enums.NotificationChannel[];
    enabled?: BoolFieldUpdateOperationsInput | boolean;
    priority?:
      | NullableEnumNotificationPriorityFieldUpdateOperationsInput
      | $Enums.NotificationPriority
      | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationRoleDefaultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    roleName?: StringFieldUpdateOperationsInput | string;
    module?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    channels?: NotificationRoleDefaultUpdatechannelsInput | $Enums.NotificationChannel[];
    enabled?: BoolFieldUpdateOperationsInput | boolean;
    priority?:
      | NullableEnumNotificationPriorityFieldUpdateOperationsInput
      | $Enums.NotificationPriority
      | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationRoleDefaultCreateManyInput = {
    id?: string;
    roleName: string;
    module: string;
    eventType: string;
    channels?: NotificationRoleDefaultCreatechannelsInput | $Enums.NotificationChannel[];
    enabled?: boolean;
    priority?: $Enums.NotificationPriority | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type NotificationRoleDefaultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    roleName?: StringFieldUpdateOperationsInput | string;
    module?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    channels?: NotificationRoleDefaultUpdatechannelsInput | $Enums.NotificationChannel[];
    enabled?: BoolFieldUpdateOperationsInput | boolean;
    priority?:
      | NullableEnumNotificationPriorityFieldUpdateOperationsInput
      | $Enums.NotificationPriority
      | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationRoleDefaultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    roleName?: StringFieldUpdateOperationsInput | string;
    module?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    channels?: NotificationRoleDefaultUpdatechannelsInput | $Enums.NotificationChannel[];
    enabled?: BoolFieldUpdateOperationsInput | boolean;
    priority?:
      | NullableEnumNotificationPriorityFieldUpdateOperationsInput
      | $Enums.NotificationPriority
      | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationAuditLogCreateInput = {
    id?: string;
    action: string;
    userId?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    timestamp?: Date | string;
    event: NotificationEventCreateNestedOneWithoutAuditLogsInput;
  };

  export type NotificationAuditLogUncheckedCreateInput = {
    id?: string;
    eventId: string;
    action: string;
    userId?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    timestamp?: Date | string;
  };

  export type NotificationAuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    event?: NotificationEventUpdateOneRequiredWithoutAuditLogsNestedInput;
  };

  export type NotificationAuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationAuditLogCreateManyInput = {
    id?: string;
    eventId: string;
    action: string;
    userId?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    timestamp?: Date | string;
  };

  export type NotificationAuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationAuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RoleNotificationDefaultsCreateInput = {
    id?: string;
    roleId: string;
    module: string;
    eventType: string;
    channels?: RoleNotificationDefaultsCreatechannelsInput | $Enums.NotificationChannel[];
    priority?: $Enums.NotificationPriority;
    digestEnabled?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
  };

  export type RoleNotificationDefaultsUncheckedCreateInput = {
    id?: string;
    roleId: string;
    module: string;
    eventType: string;
    channels?: RoleNotificationDefaultsCreatechannelsInput | $Enums.NotificationChannel[];
    priority?: $Enums.NotificationPriority;
    digestEnabled?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
  };

  export type RoleNotificationDefaultsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    roleId?: StringFieldUpdateOperationsInput | string;
    module?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    channels?: RoleNotificationDefaultsUpdatechannelsInput | $Enums.NotificationChannel[];
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    digestEnabled?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type RoleNotificationDefaultsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    roleId?: StringFieldUpdateOperationsInput | string;
    module?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    channels?: RoleNotificationDefaultsUpdatechannelsInput | $Enums.NotificationChannel[];
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    digestEnabled?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type RoleNotificationDefaultsCreateManyInput = {
    id?: string;
    roleId: string;
    module: string;
    eventType: string;
    channels?: RoleNotificationDefaultsCreatechannelsInput | $Enums.NotificationChannel[];
    priority?: $Enums.NotificationPriority;
    digestEnabled?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy?: string | null;
  };

  export type RoleNotificationDefaultsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    roleId?: StringFieldUpdateOperationsInput | string;
    module?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    channels?: RoleNotificationDefaultsUpdatechannelsInput | $Enums.NotificationChannel[];
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    digestEnabled?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type RoleNotificationDefaultsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    roleId?: StringFieldUpdateOperationsInput | string;
    module?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    channels?: RoleNotificationDefaultsUpdatechannelsInput | $Enums.NotificationChannel[];
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    digestEnabled?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type NotificationAnalyticsCreateInput = {
    id?: string;
    date: Date | string;
    hour?: number | null;
    module?: string | null;
    eventType?: string | null;
    channel?: $Enums.NotificationChannel | null;
    priority?: $Enums.NotificationPriority | null;
    userId?: string | null;
    tenantId?: string | null;
    eventsCreated?: number;
    notificationsSent?: number;
    delivered?: number;
    failed?: number;
    opened?: number;
    clicked?: number;
    dismissed?: number;
    avgResponseTime?: number | null;
    maxResponseTime?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type NotificationAnalyticsUncheckedCreateInput = {
    id?: string;
    date: Date | string;
    hour?: number | null;
    module?: string | null;
    eventType?: string | null;
    channel?: $Enums.NotificationChannel | null;
    priority?: $Enums.NotificationPriority | null;
    userId?: string | null;
    tenantId?: string | null;
    eventsCreated?: number;
    notificationsSent?: number;
    delivered?: number;
    failed?: number;
    opened?: number;
    clicked?: number;
    dismissed?: number;
    avgResponseTime?: number | null;
    maxResponseTime?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type NotificationAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    hour?: NullableIntFieldUpdateOperationsInput | number | null;
    module?: NullableStringFieldUpdateOperationsInput | string | null;
    eventType?: NullableStringFieldUpdateOperationsInput | string | null;
    channel?:
      | NullableEnumNotificationChannelFieldUpdateOperationsInput
      | $Enums.NotificationChannel
      | null;
    priority?:
      | NullableEnumNotificationPriorityFieldUpdateOperationsInput
      | $Enums.NotificationPriority
      | null;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null;
    eventsCreated?: IntFieldUpdateOperationsInput | number;
    notificationsSent?: IntFieldUpdateOperationsInput | number;
    delivered?: IntFieldUpdateOperationsInput | number;
    failed?: IntFieldUpdateOperationsInput | number;
    opened?: IntFieldUpdateOperationsInput | number;
    clicked?: IntFieldUpdateOperationsInput | number;
    dismissed?: IntFieldUpdateOperationsInput | number;
    avgResponseTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    maxResponseTime?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    hour?: NullableIntFieldUpdateOperationsInput | number | null;
    module?: NullableStringFieldUpdateOperationsInput | string | null;
    eventType?: NullableStringFieldUpdateOperationsInput | string | null;
    channel?:
      | NullableEnumNotificationChannelFieldUpdateOperationsInput
      | $Enums.NotificationChannel
      | null;
    priority?:
      | NullableEnumNotificationPriorityFieldUpdateOperationsInput
      | $Enums.NotificationPriority
      | null;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null;
    eventsCreated?: IntFieldUpdateOperationsInput | number;
    notificationsSent?: IntFieldUpdateOperationsInput | number;
    delivered?: IntFieldUpdateOperationsInput | number;
    failed?: IntFieldUpdateOperationsInput | number;
    opened?: IntFieldUpdateOperationsInput | number;
    clicked?: IntFieldUpdateOperationsInput | number;
    dismissed?: IntFieldUpdateOperationsInput | number;
    avgResponseTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    maxResponseTime?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationAnalyticsCreateManyInput = {
    id?: string;
    date: Date | string;
    hour?: number | null;
    module?: string | null;
    eventType?: string | null;
    channel?: $Enums.NotificationChannel | null;
    priority?: $Enums.NotificationPriority | null;
    userId?: string | null;
    tenantId?: string | null;
    eventsCreated?: number;
    notificationsSent?: number;
    delivered?: number;
    failed?: number;
    opened?: number;
    clicked?: number;
    dismissed?: number;
    avgResponseTime?: number | null;
    maxResponseTime?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type NotificationAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    hour?: NullableIntFieldUpdateOperationsInput | number | null;
    module?: NullableStringFieldUpdateOperationsInput | string | null;
    eventType?: NullableStringFieldUpdateOperationsInput | string | null;
    channel?:
      | NullableEnumNotificationChannelFieldUpdateOperationsInput
      | $Enums.NotificationChannel
      | null;
    priority?:
      | NullableEnumNotificationPriorityFieldUpdateOperationsInput
      | $Enums.NotificationPriority
      | null;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null;
    eventsCreated?: IntFieldUpdateOperationsInput | number;
    notificationsSent?: IntFieldUpdateOperationsInput | number;
    delivered?: IntFieldUpdateOperationsInput | number;
    failed?: IntFieldUpdateOperationsInput | number;
    opened?: IntFieldUpdateOperationsInput | number;
    clicked?: IntFieldUpdateOperationsInput | number;
    dismissed?: IntFieldUpdateOperationsInput | number;
    avgResponseTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    maxResponseTime?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    hour?: NullableIntFieldUpdateOperationsInput | number | null;
    module?: NullableStringFieldUpdateOperationsInput | string | null;
    eventType?: NullableStringFieldUpdateOperationsInput | string | null;
    channel?:
      | NullableEnumNotificationChannelFieldUpdateOperationsInput
      | $Enums.NotificationChannel
      | null;
    priority?:
      | NullableEnumNotificationPriorityFieldUpdateOperationsInput
      | $Enums.NotificationPriority
      | null;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null;
    eventsCreated?: IntFieldUpdateOperationsInput | number;
    notificationsSent?: IntFieldUpdateOperationsInput | number;
    delivered?: IntFieldUpdateOperationsInput | number;
    failed?: IntFieldUpdateOperationsInput | number;
    opened?: IntFieldUpdateOperationsInput | number;
    clicked?: IntFieldUpdateOperationsInput | number;
    dismissed?: IntFieldUpdateOperationsInput | number;
    avgResponseTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    maxResponseTime?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type EnumNotificationPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>;
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>;
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>;
    not?: NestedEnumNotificationPriorityFilter<$PrismaModel> | $Enums.NotificationPriority;
  };

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    has?: string | StringFieldRefInput<$PrismaModel> | null;
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>;
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>;
    isEmpty?: boolean;
  };
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>;

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
  };

  export type EnumEventStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EventStatus | EnumEventStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumEventStatusFilter<$PrismaModel> | $Enums.EventStatus;
  };

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput;
    some?: NotificationWhereInput;
    none?: NotificationWhereInput;
  };

  export type NotificationDeliveryListRelationFilter = {
    every?: NotificationDeliveryWhereInput;
    some?: NotificationDeliveryWhereInput;
    none?: NotificationDeliveryWhereInput;
  };

  export type NotificationQueueListRelationFilter = {
    every?: NotificationQueueWhereInput;
    some?: NotificationQueueWhereInput;
    none?: NotificationQueueWhereInput;
  };

  export type NotificationAuditLogListRelationFilter = {
    every?: NotificationAuditLogWhereInput;
    some?: NotificationAuditLogWhereInput;
    none?: NotificationAuditLogWhereInput;
  };

  export type SortOrderInput = {
    sort: SortOrder;
    nulls?: NullsOrder;
  };

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type NotificationDeliveryOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type NotificationQueueOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type NotificationAuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type NotificationEventCountOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    module?: SortOrder;
    eventType?: SortOrder;
    priority?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    details?: SortOrder;
    recipientRoles?: SortOrder;
    recipientUsers?: SortOrder;
    tenantId?: SortOrder;
    actions?: SortOrder;
    metadata?: SortOrder;
    status?: SortOrder;
    scheduledFor?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
    createdBy?: SortOrder;
    processedAt?: SortOrder;
  };

  export type NotificationEventMaxOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    module?: SortOrder;
    eventType?: SortOrder;
    priority?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    details?: SortOrder;
    tenantId?: SortOrder;
    status?: SortOrder;
    scheduledFor?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
    createdBy?: SortOrder;
    processedAt?: SortOrder;
  };

  export type NotificationEventMinOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    module?: SortOrder;
    eventType?: SortOrder;
    priority?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    details?: SortOrder;
    tenantId?: SortOrder;
    status?: SortOrder;
    scheduledFor?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
    createdBy?: SortOrder;
    processedAt?: SortOrder;
  };

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type EnumNotificationPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>;
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>;
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel>
      | $Enums.NotificationPriority;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumNotificationPriorityFilter<$PrismaModel>;
    _max?: NestedEnumNotificationPriorityFilter<$PrismaModel>;
  };

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>;

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedJsonNullableFilter<$PrismaModel>;
    _max?: NestedJsonNullableFilter<$PrismaModel>;
  };

  export type EnumEventStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventStatus | EnumEventStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumEventStatusWithAggregatesFilter<$PrismaModel> | $Enums.EventStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumEventStatusFilter<$PrismaModel>;
    _max?: NestedEnumEventStatusFilter<$PrismaModel>;
  };

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type EnumNotificationChannelNullableListFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.NotificationChannel[]
      | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
      | null;
    has?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel> | null;
    hasEvery?:
      | $Enums.NotificationChannel[]
      | ListEnumNotificationChannelFieldRefInput<$PrismaModel>;
    hasSome?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>;
    isEmpty?: boolean;
  };

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type EnumDigestFrequencyNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DigestFrequency | EnumDigestFrequencyFieldRefInput<$PrismaModel> | null;
    in?: $Enums.DigestFrequency[] | ListEnumDigestFrequencyFieldRefInput<$PrismaModel> | null;
    notIn?: $Enums.DigestFrequency[] | ListEnumDigestFrequencyFieldRefInput<$PrismaModel> | null;
    not?: NestedEnumDigestFrequencyNullableFilter<$PrismaModel> | $Enums.DigestFrequency | null;
  };

  export type HelixUserNotificationProfileNullableScalarRelationFilter = {
    is?: HelixUserNotificationProfileWhereInput | null;
    isNot?: HelixUserNotificationProfileWhereInput | null;
  };

  export type NotificationPreferenceUserIdModuleEventTypeCompoundUniqueInput = {
    userId: string;
    module: string;
    eventType: string;
  };

  export type NotificationPreferenceCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    module?: SortOrder;
    eventType?: SortOrder;
    channels?: SortOrder;
    priority?: SortOrder;
    digestEnabled?: SortOrder;
    digestFrequency?: SortOrder;
    dndEnabled?: SortOrder;
    dndStartTime?: SortOrder;
    dndEndTime?: SortOrder;
    dndDays?: SortOrder;
    aiSummaryEnabled?: SortOrder;
    aiGroupingEnabled?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type NotificationPreferenceMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    module?: SortOrder;
    eventType?: SortOrder;
    priority?: SortOrder;
    digestEnabled?: SortOrder;
    digestFrequency?: SortOrder;
    dndEnabled?: SortOrder;
    dndStartTime?: SortOrder;
    dndEndTime?: SortOrder;
    aiSummaryEnabled?: SortOrder;
    aiGroupingEnabled?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type NotificationPreferenceMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    module?: SortOrder;
    eventType?: SortOrder;
    priority?: SortOrder;
    digestEnabled?: SortOrder;
    digestFrequency?: SortOrder;
    dndEnabled?: SortOrder;
    dndStartTime?: SortOrder;
    dndEndTime?: SortOrder;
    aiSummaryEnabled?: SortOrder;
    aiGroupingEnabled?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type EnumDigestFrequencyNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DigestFrequency | EnumDigestFrequencyFieldRefInput<$PrismaModel> | null;
    in?: $Enums.DigestFrequency[] | ListEnumDigestFrequencyFieldRefInput<$PrismaModel> | null;
    notIn?: $Enums.DigestFrequency[] | ListEnumDigestFrequencyFieldRefInput<$PrismaModel> | null;
    not?:
      | NestedEnumDigestFrequencyNullableWithAggregatesFilter<$PrismaModel>
      | $Enums.DigestFrequency
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedEnumDigestFrequencyNullableFilter<$PrismaModel>;
    _max?: NestedEnumDigestFrequencyNullableFilter<$PrismaModel>;
  };

  export type EnumNotificationChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel>;
    in?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>;
    notIn?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>;
    not?: NestedEnumNotificationChannelFilter<$PrismaModel> | $Enums.NotificationChannel;
  };

  export type EnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus;
  };

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NotificationEventScalarRelationFilter = {
    is?: NotificationEventWhereInput;
    isNot?: NotificationEventWhereInput;
  };

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    userId?: SortOrder;
    channel?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    details?: SortOrder;
    actions?: SortOrder;
    status?: SortOrder;
    priority?: SortOrder;
    scheduledFor?: SortOrder;
    deliveredAt?: SortOrder;
    readAt?: SortOrder;
    clickedAt?: SortOrder;
    dismissedAt?: SortOrder;
    retryCount?: SortOrder;
    maxRetries?: SortOrder;
    nextRetry?: SortOrder;
    aiSummary?: SortOrder;
    groupId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type NotificationAvgOrderByAggregateInput = {
    retryCount?: SortOrder;
    maxRetries?: SortOrder;
  };

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    userId?: SortOrder;
    channel?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    details?: SortOrder;
    status?: SortOrder;
    priority?: SortOrder;
    scheduledFor?: SortOrder;
    deliveredAt?: SortOrder;
    readAt?: SortOrder;
    clickedAt?: SortOrder;
    dismissedAt?: SortOrder;
    retryCount?: SortOrder;
    maxRetries?: SortOrder;
    nextRetry?: SortOrder;
    aiSummary?: SortOrder;
    groupId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    userId?: SortOrder;
    channel?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    details?: SortOrder;
    status?: SortOrder;
    priority?: SortOrder;
    scheduledFor?: SortOrder;
    deliveredAt?: SortOrder;
    readAt?: SortOrder;
    clickedAt?: SortOrder;
    dismissedAt?: SortOrder;
    retryCount?: SortOrder;
    maxRetries?: SortOrder;
    nextRetry?: SortOrder;
    aiSummary?: SortOrder;
    groupId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type NotificationSumOrderByAggregateInput = {
    retryCount?: SortOrder;
    maxRetries?: SortOrder;
  };

  export type EnumNotificationChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel>;
    in?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>;
    notIn?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumNotificationChannelWithAggregatesFilter<$PrismaModel>
      | $Enums.NotificationChannel;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumNotificationChannelFilter<$PrismaModel>;
    _max?: NestedEnumNotificationChannelFilter<$PrismaModel>;
  };

  export type EnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.NotificationStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>;
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>;
  };

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type EnumDeliveryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryStatus | EnumDeliveryStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumDeliveryStatusFilter<$PrismaModel> | $Enums.DeliveryStatus;
  };

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type NotificationScalarRelationFilter = {
    is?: NotificationWhereInput;
    isNot?: NotificationWhereInput;
  };

  export type NotificationDeliveryCountOrderByAggregateInput = {
    id?: SortOrder;
    notificationId?: SortOrder;
    eventId?: SortOrder;
    userId?: SortOrder;
    channel?: SortOrder;
    provider?: SortOrder;
    providerConfig?: SortOrder;
    status?: SortOrder;
    deliveredAt?: SortOrder;
    failedAt?: SortOrder;
    errorMessage?: SortOrder;
    errorCode?: SortOrder;
    providerResponse?: SortOrder;
    messageId?: SortOrder;
    responseTime?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type NotificationDeliveryAvgOrderByAggregateInput = {
    responseTime?: SortOrder;
  };

  export type NotificationDeliveryMaxOrderByAggregateInput = {
    id?: SortOrder;
    notificationId?: SortOrder;
    eventId?: SortOrder;
    userId?: SortOrder;
    channel?: SortOrder;
    provider?: SortOrder;
    status?: SortOrder;
    deliveredAt?: SortOrder;
    failedAt?: SortOrder;
    errorMessage?: SortOrder;
    errorCode?: SortOrder;
    messageId?: SortOrder;
    responseTime?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type NotificationDeliveryMinOrderByAggregateInput = {
    id?: SortOrder;
    notificationId?: SortOrder;
    eventId?: SortOrder;
    userId?: SortOrder;
    channel?: SortOrder;
    provider?: SortOrder;
    status?: SortOrder;
    deliveredAt?: SortOrder;
    failedAt?: SortOrder;
    errorMessage?: SortOrder;
    errorCode?: SortOrder;
    messageId?: SortOrder;
    responseTime?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type NotificationDeliverySumOrderByAggregateInput = {
    responseTime?: SortOrder;
  };

  export type EnumDeliveryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryStatus | EnumDeliveryStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumDeliveryStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumDeliveryStatusFilter<$PrismaModel>;
    _max?: NestedEnumDeliveryStatusFilter<$PrismaModel>;
  };

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type NotificationTemplateModuleEventTypeChannelLocaleCompoundUniqueInput = {
    module: string;
    eventType: string;
    channel: $Enums.NotificationChannel;
    locale: string;
  };

  export type NotificationTemplateCountOrderByAggregateInput = {
    id?: SortOrder;
    module?: SortOrder;
    eventType?: SortOrder;
    channel?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    titleTemplate?: SortOrder;
    messageTemplate?: SortOrder;
    detailsTemplate?: SortOrder;
    isDefault?: SortOrder;
    isActive?: SortOrder;
    version?: SortOrder;
    locale?: SortOrder;
    variables?: SortOrder;
    actions?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrder;
  };

  export type NotificationTemplateAvgOrderByAggregateInput = {
    version?: SortOrder;
  };

  export type NotificationTemplateMaxOrderByAggregateInput = {
    id?: SortOrder;
    module?: SortOrder;
    eventType?: SortOrder;
    channel?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    titleTemplate?: SortOrder;
    messageTemplate?: SortOrder;
    detailsTemplate?: SortOrder;
    isDefault?: SortOrder;
    isActive?: SortOrder;
    version?: SortOrder;
    locale?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrder;
  };

  export type NotificationTemplateMinOrderByAggregateInput = {
    id?: SortOrder;
    module?: SortOrder;
    eventType?: SortOrder;
    channel?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    titleTemplate?: SortOrder;
    messageTemplate?: SortOrder;
    detailsTemplate?: SortOrder;
    isDefault?: SortOrder;
    isActive?: SortOrder;
    version?: SortOrder;
    locale?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrder;
  };

  export type NotificationTemplateSumOrderByAggregateInput = {
    version?: SortOrder;
  };
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>;

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
  };

  export type EnumProviderHealthFilter<$PrismaModel = never> = {
    equals?: $Enums.ProviderHealth | EnumProviderHealthFieldRefInput<$PrismaModel>;
    in?: $Enums.ProviderHealth[] | ListEnumProviderHealthFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ProviderHealth[] | ListEnumProviderHealthFieldRefInput<$PrismaModel>;
    not?: NestedEnumProviderHealthFilter<$PrismaModel> | $Enums.ProviderHealth;
  };

  export type NotificationProviderCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    config?: SortOrder;
    credentials?: SortOrder;
    isActive?: SortOrder;
    isDefault?: SortOrder;
    priority?: SortOrder;
    rateLimitPerHour?: SortOrder;
    rateLimitPerDay?: SortOrder;
    lastHealthCheck?: SortOrder;
    healthStatus?: SortOrder;
    errorCount?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrder;
  };

  export type NotificationProviderAvgOrderByAggregateInput = {
    priority?: SortOrder;
    rateLimitPerHour?: SortOrder;
    rateLimitPerDay?: SortOrder;
    errorCount?: SortOrder;
  };

  export type NotificationProviderMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    isActive?: SortOrder;
    isDefault?: SortOrder;
    priority?: SortOrder;
    rateLimitPerHour?: SortOrder;
    rateLimitPerDay?: SortOrder;
    lastHealthCheck?: SortOrder;
    healthStatus?: SortOrder;
    errorCount?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrder;
  };

  export type NotificationProviderMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    isActive?: SortOrder;
    isDefault?: SortOrder;
    priority?: SortOrder;
    rateLimitPerHour?: SortOrder;
    rateLimitPerDay?: SortOrder;
    lastHealthCheck?: SortOrder;
    healthStatus?: SortOrder;
    errorCount?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrder;
  };

  export type NotificationProviderSumOrderByAggregateInput = {
    priority?: SortOrder;
    rateLimitPerHour?: SortOrder;
    rateLimitPerDay?: SortOrder;
    errorCount?: SortOrder;
  };
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>;

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedJsonFilter<$PrismaModel>;
    _max?: NestedJsonFilter<$PrismaModel>;
  };

  export type EnumProviderHealthWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProviderHealth | EnumProviderHealthFieldRefInput<$PrismaModel>;
    in?: $Enums.ProviderHealth[] | ListEnumProviderHealthFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ProviderHealth[] | ListEnumProviderHealthFieldRefInput<$PrismaModel>;
    not?: NestedEnumProviderHealthWithAggregatesFilter<$PrismaModel> | $Enums.ProviderHealth;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumProviderHealthFilter<$PrismaModel>;
    _max?: NestedEnumProviderHealthFilter<$PrismaModel>;
  };

  export type EnumDigestFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.DigestFrequency | EnumDigestFrequencyFieldRefInput<$PrismaModel>;
    in?: $Enums.DigestFrequency[] | ListEnumDigestFrequencyFieldRefInput<$PrismaModel>;
    notIn?: $Enums.DigestFrequency[] | ListEnumDigestFrequencyFieldRefInput<$PrismaModel>;
    not?: NestedEnumDigestFrequencyFilter<$PrismaModel> | $Enums.DigestFrequency;
  };

  export type EnumAiGroupingLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.AiGroupingLevel | EnumAiGroupingLevelFieldRefInput<$PrismaModel>;
    in?: $Enums.AiGroupingLevel[] | ListEnumAiGroupingLevelFieldRefInput<$PrismaModel>;
    notIn?: $Enums.AiGroupingLevel[] | ListEnumAiGroupingLevelFieldRefInput<$PrismaModel>;
    not?: NestedEnumAiGroupingLevelFilter<$PrismaModel> | $Enums.AiGroupingLevel;
  };

  export type NotificationPreferenceListRelationFilter = {
    every?: NotificationPreferenceWhereInput;
    some?: NotificationPreferenceWhereInput;
    none?: NotificationPreferenceWhereInput;
  };

  export type NotificationPreferenceOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type HelixUserNotificationProfileCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    globalEnabled?: SortOrder;
    defaultChannels?: SortOrder;
    timezone?: SortOrder;
    digestEnabled?: SortOrder;
    digestFrequency?: SortOrder;
    digestTime?: SortOrder;
    dndEnabled?: SortOrder;
    dndStartTime?: SortOrder;
    dndEndTime?: SortOrder;
    dndDays?: SortOrder;
    goalertEnabled?: SortOrder;
    goalertSchedules?: SortOrder;
    goalertPolicies?: SortOrder;
    pagerEnabled?: SortOrder;
    synthEnabled?: SortOrder;
    aiDigestEnabled?: SortOrder;
    aiGroupingLevel?: SortOrder;
    muteRepetitive?: SortOrder;
    sentinelEnabled?: SortOrder;
    securityEvents?: SortOrder;
    complianceEvents?: SortOrder;
    deviceTokens?: SortOrder;
    pushEnabled?: SortOrder;
    phoneNumber?: SortOrder;
    slackUserId?: SortOrder;
    teamsUserId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type HelixUserNotificationProfileMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    globalEnabled?: SortOrder;
    timezone?: SortOrder;
    digestEnabled?: SortOrder;
    digestFrequency?: SortOrder;
    digestTime?: SortOrder;
    dndEnabled?: SortOrder;
    dndStartTime?: SortOrder;
    dndEndTime?: SortOrder;
    goalertEnabled?: SortOrder;
    pagerEnabled?: SortOrder;
    synthEnabled?: SortOrder;
    aiDigestEnabled?: SortOrder;
    aiGroupingLevel?: SortOrder;
    muteRepetitive?: SortOrder;
    sentinelEnabled?: SortOrder;
    complianceEvents?: SortOrder;
    pushEnabled?: SortOrder;
    phoneNumber?: SortOrder;
    slackUserId?: SortOrder;
    teamsUserId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type HelixUserNotificationProfileMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    globalEnabled?: SortOrder;
    timezone?: SortOrder;
    digestEnabled?: SortOrder;
    digestFrequency?: SortOrder;
    digestTime?: SortOrder;
    dndEnabled?: SortOrder;
    dndStartTime?: SortOrder;
    dndEndTime?: SortOrder;
    goalertEnabled?: SortOrder;
    pagerEnabled?: SortOrder;
    synthEnabled?: SortOrder;
    aiDigestEnabled?: SortOrder;
    aiGroupingLevel?: SortOrder;
    muteRepetitive?: SortOrder;
    sentinelEnabled?: SortOrder;
    complianceEvents?: SortOrder;
    pushEnabled?: SortOrder;
    phoneNumber?: SortOrder;
    slackUserId?: SortOrder;
    teamsUserId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type EnumDigestFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DigestFrequency | EnumDigestFrequencyFieldRefInput<$PrismaModel>;
    in?: $Enums.DigestFrequency[] | ListEnumDigestFrequencyFieldRefInput<$PrismaModel>;
    notIn?: $Enums.DigestFrequency[] | ListEnumDigestFrequencyFieldRefInput<$PrismaModel>;
    not?: NestedEnumDigestFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.DigestFrequency;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumDigestFrequencyFilter<$PrismaModel>;
    _max?: NestedEnumDigestFrequencyFilter<$PrismaModel>;
  };

  export type EnumAiGroupingLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AiGroupingLevel | EnumAiGroupingLevelFieldRefInput<$PrismaModel>;
    in?: $Enums.AiGroupingLevel[] | ListEnumAiGroupingLevelFieldRefInput<$PrismaModel>;
    notIn?: $Enums.AiGroupingLevel[] | ListEnumAiGroupingLevelFieldRefInput<$PrismaModel>;
    not?: NestedEnumAiGroupingLevelWithAggregatesFilter<$PrismaModel> | $Enums.AiGroupingLevel;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumAiGroupingLevelFilter<$PrismaModel>;
    _max?: NestedEnumAiGroupingLevelFilter<$PrismaModel>;
  };

  export type NotificationQueueCountOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    deliveryId?: SortOrder;
    priority?: SortOrder;
    scheduledFor?: SortOrder;
    attempts?: SortOrder;
    maxAttempts?: SortOrder;
    lastAttemptAt?: SortOrder;
    nextAttemptAt?: SortOrder;
    status?: SortOrder;
    error?: SortOrder;
    metadata?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type NotificationQueueAvgOrderByAggregateInput = {
    attempts?: SortOrder;
    maxAttempts?: SortOrder;
  };

  export type NotificationQueueMaxOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    deliveryId?: SortOrder;
    priority?: SortOrder;
    scheduledFor?: SortOrder;
    attempts?: SortOrder;
    maxAttempts?: SortOrder;
    lastAttemptAt?: SortOrder;
    nextAttemptAt?: SortOrder;
    status?: SortOrder;
    error?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type NotificationQueueMinOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    deliveryId?: SortOrder;
    priority?: SortOrder;
    scheduledFor?: SortOrder;
    attempts?: SortOrder;
    maxAttempts?: SortOrder;
    lastAttemptAt?: SortOrder;
    nextAttemptAt?: SortOrder;
    status?: SortOrder;
    error?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type NotificationQueueSumOrderByAggregateInput = {
    attempts?: SortOrder;
    maxAttempts?: SortOrder;
  };

  export type EnumNotificationPriorityNullableFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.NotificationPriority
      | EnumNotificationPriorityFieldRefInput<$PrismaModel>
      | null;
    in?:
      | $Enums.NotificationPriority[]
      | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.NotificationPriority[]
      | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumNotificationPriorityNullableFilter<$PrismaModel>
      | $Enums.NotificationPriority
      | null;
  };

  export type NotificationRoleDefaultRoleNameModuleEventTypeCompoundUniqueInput = {
    roleName: string;
    module: string;
    eventType: string;
  };

  export type NotificationRoleDefaultCountOrderByAggregateInput = {
    id?: SortOrder;
    roleName?: SortOrder;
    module?: SortOrder;
    eventType?: SortOrder;
    channels?: SortOrder;
    enabled?: SortOrder;
    priority?: SortOrder;
    metadata?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type NotificationRoleDefaultMaxOrderByAggregateInput = {
    id?: SortOrder;
    roleName?: SortOrder;
    module?: SortOrder;
    eventType?: SortOrder;
    enabled?: SortOrder;
    priority?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type NotificationRoleDefaultMinOrderByAggregateInput = {
    id?: SortOrder;
    roleName?: SortOrder;
    module?: SortOrder;
    eventType?: SortOrder;
    enabled?: SortOrder;
    priority?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type EnumNotificationPriorityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.NotificationPriority
      | EnumNotificationPriorityFieldRefInput<$PrismaModel>
      | null;
    in?:
      | $Enums.NotificationPriority[]
      | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.NotificationPriority[]
      | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumNotificationPriorityNullableWithAggregatesFilter<$PrismaModel>
      | $Enums.NotificationPriority
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedEnumNotificationPriorityNullableFilter<$PrismaModel>;
    _max?: NestedEnumNotificationPriorityNullableFilter<$PrismaModel>;
  };

  export type NotificationAuditLogCountOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    action?: SortOrder;
    userId?: SortOrder;
    metadata?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    timestamp?: SortOrder;
  };

  export type NotificationAuditLogMaxOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    action?: SortOrder;
    userId?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    timestamp?: SortOrder;
  };

  export type NotificationAuditLogMinOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    action?: SortOrder;
    userId?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    timestamp?: SortOrder;
  };

  export type RoleNotificationDefaultsRoleIdModuleEventTypeCompoundUniqueInput = {
    roleId: string;
    module: string;
    eventType: string;
  };

  export type RoleNotificationDefaultsCountOrderByAggregateInput = {
    id?: SortOrder;
    roleId?: SortOrder;
    module?: SortOrder;
    eventType?: SortOrder;
    channels?: SortOrder;
    priority?: SortOrder;
    digestEnabled?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrder;
  };

  export type RoleNotificationDefaultsMaxOrderByAggregateInput = {
    id?: SortOrder;
    roleId?: SortOrder;
    module?: SortOrder;
    eventType?: SortOrder;
    priority?: SortOrder;
    digestEnabled?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrder;
  };

  export type RoleNotificationDefaultsMinOrderByAggregateInput = {
    id?: SortOrder;
    roleId?: SortOrder;
    module?: SortOrder;
    eventType?: SortOrder;
    priority?: SortOrder;
    digestEnabled?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdBy?: SortOrder;
  };

  export type EnumNotificationChannelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel> | null;
    in?:
      | $Enums.NotificationChannel[]
      | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.NotificationChannel[]
      | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumNotificationChannelNullableFilter<$PrismaModel>
      | $Enums.NotificationChannel
      | null;
  };

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type NotificationAnalyticsDateHourModuleEventTypeChannelUserIdCompoundUniqueInput = {
    date: Date | string;
    hour: number;
    module: string;
    eventType: string;
    channel: $Enums.NotificationChannel;
    userId: string;
  };

  export type NotificationAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder;
    date?: SortOrder;
    hour?: SortOrder;
    module?: SortOrder;
    eventType?: SortOrder;
    channel?: SortOrder;
    priority?: SortOrder;
    userId?: SortOrder;
    tenantId?: SortOrder;
    eventsCreated?: SortOrder;
    notificationsSent?: SortOrder;
    delivered?: SortOrder;
    failed?: SortOrder;
    opened?: SortOrder;
    clicked?: SortOrder;
    dismissed?: SortOrder;
    avgResponseTime?: SortOrder;
    maxResponseTime?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type NotificationAnalyticsAvgOrderByAggregateInput = {
    hour?: SortOrder;
    eventsCreated?: SortOrder;
    notificationsSent?: SortOrder;
    delivered?: SortOrder;
    failed?: SortOrder;
    opened?: SortOrder;
    clicked?: SortOrder;
    dismissed?: SortOrder;
    avgResponseTime?: SortOrder;
    maxResponseTime?: SortOrder;
  };

  export type NotificationAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder;
    date?: SortOrder;
    hour?: SortOrder;
    module?: SortOrder;
    eventType?: SortOrder;
    channel?: SortOrder;
    priority?: SortOrder;
    userId?: SortOrder;
    tenantId?: SortOrder;
    eventsCreated?: SortOrder;
    notificationsSent?: SortOrder;
    delivered?: SortOrder;
    failed?: SortOrder;
    opened?: SortOrder;
    clicked?: SortOrder;
    dismissed?: SortOrder;
    avgResponseTime?: SortOrder;
    maxResponseTime?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type NotificationAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder;
    date?: SortOrder;
    hour?: SortOrder;
    module?: SortOrder;
    eventType?: SortOrder;
    channel?: SortOrder;
    priority?: SortOrder;
    userId?: SortOrder;
    tenantId?: SortOrder;
    eventsCreated?: SortOrder;
    notificationsSent?: SortOrder;
    delivered?: SortOrder;
    failed?: SortOrder;
    opened?: SortOrder;
    clicked?: SortOrder;
    dismissed?: SortOrder;
    avgResponseTime?: SortOrder;
    maxResponseTime?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type NotificationAnalyticsSumOrderByAggregateInput = {
    hour?: SortOrder;
    eventsCreated?: SortOrder;
    notificationsSent?: SortOrder;
    delivered?: SortOrder;
    failed?: SortOrder;
    opened?: SortOrder;
    clicked?: SortOrder;
    dismissed?: SortOrder;
    avgResponseTime?: SortOrder;
    maxResponseTime?: SortOrder;
  };

  export type EnumNotificationChannelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel> | null;
    in?:
      | $Enums.NotificationChannel[]
      | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.NotificationChannel[]
      | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumNotificationChannelNullableWithAggregatesFilter<$PrismaModel>
      | $Enums.NotificationChannel
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedEnumNotificationChannelNullableFilter<$PrismaModel>;
    _max?: NestedEnumNotificationChannelNullableFilter<$PrismaModel>;
  };

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedFloatNullableFilter<$PrismaModel>;
    _min?: NestedFloatNullableFilter<$PrismaModel>;
    _max?: NestedFloatNullableFilter<$PrismaModel>;
  };

  export type NotificationEventCreaterecipientRolesInput = {
    set: string[];
  };

  export type NotificationEventCreaterecipientUsersInput = {
    set: string[];
  };

  export type NotificationCreateNestedManyWithoutEventInput = {
    create?:
      | XOR<NotificationCreateWithoutEventInput, NotificationUncheckedCreateWithoutEventInput>
      | NotificationCreateWithoutEventInput[]
      | NotificationUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutEventInput
      | NotificationCreateOrConnectWithoutEventInput[];
    createMany?: NotificationCreateManyEventInputEnvelope;
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
  };

  export type NotificationDeliveryCreateNestedManyWithoutEventInput = {
    create?:
      | XOR<
          NotificationDeliveryCreateWithoutEventInput,
          NotificationDeliveryUncheckedCreateWithoutEventInput
        >
      | NotificationDeliveryCreateWithoutEventInput[]
      | NotificationDeliveryUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | NotificationDeliveryCreateOrConnectWithoutEventInput
      | NotificationDeliveryCreateOrConnectWithoutEventInput[];
    createMany?: NotificationDeliveryCreateManyEventInputEnvelope;
    connect?: NotificationDeliveryWhereUniqueInput | NotificationDeliveryWhereUniqueInput[];
  };

  export type NotificationQueueCreateNestedManyWithoutEventInput = {
    create?:
      | XOR<
          NotificationQueueCreateWithoutEventInput,
          NotificationQueueUncheckedCreateWithoutEventInput
        >
      | NotificationQueueCreateWithoutEventInput[]
      | NotificationQueueUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | NotificationQueueCreateOrConnectWithoutEventInput
      | NotificationQueueCreateOrConnectWithoutEventInput[];
    createMany?: NotificationQueueCreateManyEventInputEnvelope;
    connect?: NotificationQueueWhereUniqueInput | NotificationQueueWhereUniqueInput[];
  };

  export type NotificationAuditLogCreateNestedManyWithoutEventInput = {
    create?:
      | XOR<
          NotificationAuditLogCreateWithoutEventInput,
          NotificationAuditLogUncheckedCreateWithoutEventInput
        >
      | NotificationAuditLogCreateWithoutEventInput[]
      | NotificationAuditLogUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | NotificationAuditLogCreateOrConnectWithoutEventInput
      | NotificationAuditLogCreateOrConnectWithoutEventInput[];
    createMany?: NotificationAuditLogCreateManyEventInputEnvelope;
    connect?: NotificationAuditLogWhereUniqueInput | NotificationAuditLogWhereUniqueInput[];
  };

  export type NotificationUncheckedCreateNestedManyWithoutEventInput = {
    create?:
      | XOR<NotificationCreateWithoutEventInput, NotificationUncheckedCreateWithoutEventInput>
      | NotificationCreateWithoutEventInput[]
      | NotificationUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutEventInput
      | NotificationCreateOrConnectWithoutEventInput[];
    createMany?: NotificationCreateManyEventInputEnvelope;
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
  };

  export type NotificationDeliveryUncheckedCreateNestedManyWithoutEventInput = {
    create?:
      | XOR<
          NotificationDeliveryCreateWithoutEventInput,
          NotificationDeliveryUncheckedCreateWithoutEventInput
        >
      | NotificationDeliveryCreateWithoutEventInput[]
      | NotificationDeliveryUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | NotificationDeliveryCreateOrConnectWithoutEventInput
      | NotificationDeliveryCreateOrConnectWithoutEventInput[];
    createMany?: NotificationDeliveryCreateManyEventInputEnvelope;
    connect?: NotificationDeliveryWhereUniqueInput | NotificationDeliveryWhereUniqueInput[];
  };

  export type NotificationQueueUncheckedCreateNestedManyWithoutEventInput = {
    create?:
      | XOR<
          NotificationQueueCreateWithoutEventInput,
          NotificationQueueUncheckedCreateWithoutEventInput
        >
      | NotificationQueueCreateWithoutEventInput[]
      | NotificationQueueUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | NotificationQueueCreateOrConnectWithoutEventInput
      | NotificationQueueCreateOrConnectWithoutEventInput[];
    createMany?: NotificationQueueCreateManyEventInputEnvelope;
    connect?: NotificationQueueWhereUniqueInput | NotificationQueueWhereUniqueInput[];
  };

  export type NotificationAuditLogUncheckedCreateNestedManyWithoutEventInput = {
    create?:
      | XOR<
          NotificationAuditLogCreateWithoutEventInput,
          NotificationAuditLogUncheckedCreateWithoutEventInput
        >
      | NotificationAuditLogCreateWithoutEventInput[]
      | NotificationAuditLogUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | NotificationAuditLogCreateOrConnectWithoutEventInput
      | NotificationAuditLogCreateOrConnectWithoutEventInput[];
    createMany?: NotificationAuditLogCreateManyEventInputEnvelope;
    connect?: NotificationAuditLogWhereUniqueInput | NotificationAuditLogWhereUniqueInput[];
  };

  export type StringFieldUpdateOperationsInput = {
    set?: string;
  };

  export type EnumNotificationPriorityFieldUpdateOperationsInput = {
    set?: $Enums.NotificationPriority;
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
  };

  export type NotificationEventUpdaterecipientRolesInput = {
    set?: string[];
    push?: string | string[];
  };

  export type NotificationEventUpdaterecipientUsersInput = {
    set?: string[];
    push?: string | string[];
  };

  export type EnumEventStatusFieldUpdateOperationsInput = {
    set?: $Enums.EventStatus;
  };

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
  };

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
  };

  export type NotificationUpdateManyWithoutEventNestedInput = {
    create?:
      | XOR<NotificationCreateWithoutEventInput, NotificationUncheckedCreateWithoutEventInput>
      | NotificationCreateWithoutEventInput[]
      | NotificationUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutEventInput
      | NotificationCreateOrConnectWithoutEventInput[];
    upsert?:
      | NotificationUpsertWithWhereUniqueWithoutEventInput
      | NotificationUpsertWithWhereUniqueWithoutEventInput[];
    createMany?: NotificationCreateManyEventInputEnvelope;
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    update?:
      | NotificationUpdateWithWhereUniqueWithoutEventInput
      | NotificationUpdateWithWhereUniqueWithoutEventInput[];
    updateMany?:
      | NotificationUpdateManyWithWhereWithoutEventInput
      | NotificationUpdateManyWithWhereWithoutEventInput[];
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
  };

  export type NotificationDeliveryUpdateManyWithoutEventNestedInput = {
    create?:
      | XOR<
          NotificationDeliveryCreateWithoutEventInput,
          NotificationDeliveryUncheckedCreateWithoutEventInput
        >
      | NotificationDeliveryCreateWithoutEventInput[]
      | NotificationDeliveryUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | NotificationDeliveryCreateOrConnectWithoutEventInput
      | NotificationDeliveryCreateOrConnectWithoutEventInput[];
    upsert?:
      | NotificationDeliveryUpsertWithWhereUniqueWithoutEventInput
      | NotificationDeliveryUpsertWithWhereUniqueWithoutEventInput[];
    createMany?: NotificationDeliveryCreateManyEventInputEnvelope;
    set?: NotificationDeliveryWhereUniqueInput | NotificationDeliveryWhereUniqueInput[];
    disconnect?: NotificationDeliveryWhereUniqueInput | NotificationDeliveryWhereUniqueInput[];
    delete?: NotificationDeliveryWhereUniqueInput | NotificationDeliveryWhereUniqueInput[];
    connect?: NotificationDeliveryWhereUniqueInput | NotificationDeliveryWhereUniqueInput[];
    update?:
      | NotificationDeliveryUpdateWithWhereUniqueWithoutEventInput
      | NotificationDeliveryUpdateWithWhereUniqueWithoutEventInput[];
    updateMany?:
      | NotificationDeliveryUpdateManyWithWhereWithoutEventInput
      | NotificationDeliveryUpdateManyWithWhereWithoutEventInput[];
    deleteMany?: NotificationDeliveryScalarWhereInput | NotificationDeliveryScalarWhereInput[];
  };

  export type NotificationQueueUpdateManyWithoutEventNestedInput = {
    create?:
      | XOR<
          NotificationQueueCreateWithoutEventInput,
          NotificationQueueUncheckedCreateWithoutEventInput
        >
      | NotificationQueueCreateWithoutEventInput[]
      | NotificationQueueUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | NotificationQueueCreateOrConnectWithoutEventInput
      | NotificationQueueCreateOrConnectWithoutEventInput[];
    upsert?:
      | NotificationQueueUpsertWithWhereUniqueWithoutEventInput
      | NotificationQueueUpsertWithWhereUniqueWithoutEventInput[];
    createMany?: NotificationQueueCreateManyEventInputEnvelope;
    set?: NotificationQueueWhereUniqueInput | NotificationQueueWhereUniqueInput[];
    disconnect?: NotificationQueueWhereUniqueInput | NotificationQueueWhereUniqueInput[];
    delete?: NotificationQueueWhereUniqueInput | NotificationQueueWhereUniqueInput[];
    connect?: NotificationQueueWhereUniqueInput | NotificationQueueWhereUniqueInput[];
    update?:
      | NotificationQueueUpdateWithWhereUniqueWithoutEventInput
      | NotificationQueueUpdateWithWhereUniqueWithoutEventInput[];
    updateMany?:
      | NotificationQueueUpdateManyWithWhereWithoutEventInput
      | NotificationQueueUpdateManyWithWhereWithoutEventInput[];
    deleteMany?: NotificationQueueScalarWhereInput | NotificationQueueScalarWhereInput[];
  };

  export type NotificationAuditLogUpdateManyWithoutEventNestedInput = {
    create?:
      | XOR<
          NotificationAuditLogCreateWithoutEventInput,
          NotificationAuditLogUncheckedCreateWithoutEventInput
        >
      | NotificationAuditLogCreateWithoutEventInput[]
      | NotificationAuditLogUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | NotificationAuditLogCreateOrConnectWithoutEventInput
      | NotificationAuditLogCreateOrConnectWithoutEventInput[];
    upsert?:
      | NotificationAuditLogUpsertWithWhereUniqueWithoutEventInput
      | NotificationAuditLogUpsertWithWhereUniqueWithoutEventInput[];
    createMany?: NotificationAuditLogCreateManyEventInputEnvelope;
    set?: NotificationAuditLogWhereUniqueInput | NotificationAuditLogWhereUniqueInput[];
    disconnect?: NotificationAuditLogWhereUniqueInput | NotificationAuditLogWhereUniqueInput[];
    delete?: NotificationAuditLogWhereUniqueInput | NotificationAuditLogWhereUniqueInput[];
    connect?: NotificationAuditLogWhereUniqueInput | NotificationAuditLogWhereUniqueInput[];
    update?:
      | NotificationAuditLogUpdateWithWhereUniqueWithoutEventInput
      | NotificationAuditLogUpdateWithWhereUniqueWithoutEventInput[];
    updateMany?:
      | NotificationAuditLogUpdateManyWithWhereWithoutEventInput
      | NotificationAuditLogUpdateManyWithWhereWithoutEventInput[];
    deleteMany?: NotificationAuditLogScalarWhereInput | NotificationAuditLogScalarWhereInput[];
  };

  export type NotificationUncheckedUpdateManyWithoutEventNestedInput = {
    create?:
      | XOR<NotificationCreateWithoutEventInput, NotificationUncheckedCreateWithoutEventInput>
      | NotificationCreateWithoutEventInput[]
      | NotificationUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutEventInput
      | NotificationCreateOrConnectWithoutEventInput[];
    upsert?:
      | NotificationUpsertWithWhereUniqueWithoutEventInput
      | NotificationUpsertWithWhereUniqueWithoutEventInput[];
    createMany?: NotificationCreateManyEventInputEnvelope;
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    update?:
      | NotificationUpdateWithWhereUniqueWithoutEventInput
      | NotificationUpdateWithWhereUniqueWithoutEventInput[];
    updateMany?:
      | NotificationUpdateManyWithWhereWithoutEventInput
      | NotificationUpdateManyWithWhereWithoutEventInput[];
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
  };

  export type NotificationDeliveryUncheckedUpdateManyWithoutEventNestedInput = {
    create?:
      | XOR<
          NotificationDeliveryCreateWithoutEventInput,
          NotificationDeliveryUncheckedCreateWithoutEventInput
        >
      | NotificationDeliveryCreateWithoutEventInput[]
      | NotificationDeliveryUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | NotificationDeliveryCreateOrConnectWithoutEventInput
      | NotificationDeliveryCreateOrConnectWithoutEventInput[];
    upsert?:
      | NotificationDeliveryUpsertWithWhereUniqueWithoutEventInput
      | NotificationDeliveryUpsertWithWhereUniqueWithoutEventInput[];
    createMany?: NotificationDeliveryCreateManyEventInputEnvelope;
    set?: NotificationDeliveryWhereUniqueInput | NotificationDeliveryWhereUniqueInput[];
    disconnect?: NotificationDeliveryWhereUniqueInput | NotificationDeliveryWhereUniqueInput[];
    delete?: NotificationDeliveryWhereUniqueInput | NotificationDeliveryWhereUniqueInput[];
    connect?: NotificationDeliveryWhereUniqueInput | NotificationDeliveryWhereUniqueInput[];
    update?:
      | NotificationDeliveryUpdateWithWhereUniqueWithoutEventInput
      | NotificationDeliveryUpdateWithWhereUniqueWithoutEventInput[];
    updateMany?:
      | NotificationDeliveryUpdateManyWithWhereWithoutEventInput
      | NotificationDeliveryUpdateManyWithWhereWithoutEventInput[];
    deleteMany?: NotificationDeliveryScalarWhereInput | NotificationDeliveryScalarWhereInput[];
  };

  export type NotificationQueueUncheckedUpdateManyWithoutEventNestedInput = {
    create?:
      | XOR<
          NotificationQueueCreateWithoutEventInput,
          NotificationQueueUncheckedCreateWithoutEventInput
        >
      | NotificationQueueCreateWithoutEventInput[]
      | NotificationQueueUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | NotificationQueueCreateOrConnectWithoutEventInput
      | NotificationQueueCreateOrConnectWithoutEventInput[];
    upsert?:
      | NotificationQueueUpsertWithWhereUniqueWithoutEventInput
      | NotificationQueueUpsertWithWhereUniqueWithoutEventInput[];
    createMany?: NotificationQueueCreateManyEventInputEnvelope;
    set?: NotificationQueueWhereUniqueInput | NotificationQueueWhereUniqueInput[];
    disconnect?: NotificationQueueWhereUniqueInput | NotificationQueueWhereUniqueInput[];
    delete?: NotificationQueueWhereUniqueInput | NotificationQueueWhereUniqueInput[];
    connect?: NotificationQueueWhereUniqueInput | NotificationQueueWhereUniqueInput[];
    update?:
      | NotificationQueueUpdateWithWhereUniqueWithoutEventInput
      | NotificationQueueUpdateWithWhereUniqueWithoutEventInput[];
    updateMany?:
      | NotificationQueueUpdateManyWithWhereWithoutEventInput
      | NotificationQueueUpdateManyWithWhereWithoutEventInput[];
    deleteMany?: NotificationQueueScalarWhereInput | NotificationQueueScalarWhereInput[];
  };

  export type NotificationAuditLogUncheckedUpdateManyWithoutEventNestedInput = {
    create?:
      | XOR<
          NotificationAuditLogCreateWithoutEventInput,
          NotificationAuditLogUncheckedCreateWithoutEventInput
        >
      | NotificationAuditLogCreateWithoutEventInput[]
      | NotificationAuditLogUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | NotificationAuditLogCreateOrConnectWithoutEventInput
      | NotificationAuditLogCreateOrConnectWithoutEventInput[];
    upsert?:
      | NotificationAuditLogUpsertWithWhereUniqueWithoutEventInput
      | NotificationAuditLogUpsertWithWhereUniqueWithoutEventInput[];
    createMany?: NotificationAuditLogCreateManyEventInputEnvelope;
    set?: NotificationAuditLogWhereUniqueInput | NotificationAuditLogWhereUniqueInput[];
    disconnect?: NotificationAuditLogWhereUniqueInput | NotificationAuditLogWhereUniqueInput[];
    delete?: NotificationAuditLogWhereUniqueInput | NotificationAuditLogWhereUniqueInput[];
    connect?: NotificationAuditLogWhereUniqueInput | NotificationAuditLogWhereUniqueInput[];
    update?:
      | NotificationAuditLogUpdateWithWhereUniqueWithoutEventInput
      | NotificationAuditLogUpdateWithWhereUniqueWithoutEventInput[];
    updateMany?:
      | NotificationAuditLogUpdateManyWithWhereWithoutEventInput
      | NotificationAuditLogUpdateManyWithWhereWithoutEventInput[];
    deleteMany?: NotificationAuditLogScalarWhereInput | NotificationAuditLogScalarWhereInput[];
  };

  export type NotificationPreferenceCreatechannelsInput = {
    set: $Enums.NotificationChannel[];
  };

  export type NotificationPreferenceCreatedndDaysInput = {
    set: string[];
  };

  export type HelixUserNotificationProfileCreateNestedOneWithoutPreferencesInput = {
    create?: XOR<
      HelixUserNotificationProfileCreateWithoutPreferencesInput,
      HelixUserNotificationProfileUncheckedCreateWithoutPreferencesInput
    >;
    connectOrCreate?: HelixUserNotificationProfileCreateOrConnectWithoutPreferencesInput;
    connect?: HelixUserNotificationProfileWhereUniqueInput;
  };

  export type NotificationPreferenceUpdatechannelsInput = {
    set?: $Enums.NotificationChannel[];
    push?: $Enums.NotificationChannel | $Enums.NotificationChannel[];
  };

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean;
  };

  export type NullableEnumDigestFrequencyFieldUpdateOperationsInput = {
    set?: $Enums.DigestFrequency | null;
  };

  export type NotificationPreferenceUpdatedndDaysInput = {
    set?: string[];
    push?: string | string[];
  };

  export type HelixUserNotificationProfileUpdateOneWithoutPreferencesNestedInput = {
    create?: XOR<
      HelixUserNotificationProfileCreateWithoutPreferencesInput,
      HelixUserNotificationProfileUncheckedCreateWithoutPreferencesInput
    >;
    connectOrCreate?: HelixUserNotificationProfileCreateOrConnectWithoutPreferencesInput;
    upsert?: HelixUserNotificationProfileUpsertWithoutPreferencesInput;
    disconnect?: HelixUserNotificationProfileWhereInput | boolean;
    delete?: HelixUserNotificationProfileWhereInput | boolean;
    connect?: HelixUserNotificationProfileWhereUniqueInput;
    update?: XOR<
      XOR<
        HelixUserNotificationProfileUpdateToOneWithWhereWithoutPreferencesInput,
        HelixUserNotificationProfileUpdateWithoutPreferencesInput
      >,
      HelixUserNotificationProfileUncheckedUpdateWithoutPreferencesInput
    >;
  };

  export type NotificationEventCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<
      NotificationEventCreateWithoutNotificationsInput,
      NotificationEventUncheckedCreateWithoutNotificationsInput
    >;
    connectOrCreate?: NotificationEventCreateOrConnectWithoutNotificationsInput;
    connect?: NotificationEventWhereUniqueInput;
  };

  export type NotificationDeliveryCreateNestedManyWithoutNotificationInput = {
    create?:
      | XOR<
          NotificationDeliveryCreateWithoutNotificationInput,
          NotificationDeliveryUncheckedCreateWithoutNotificationInput
        >
      | NotificationDeliveryCreateWithoutNotificationInput[]
      | NotificationDeliveryUncheckedCreateWithoutNotificationInput[];
    connectOrCreate?:
      | NotificationDeliveryCreateOrConnectWithoutNotificationInput
      | NotificationDeliveryCreateOrConnectWithoutNotificationInput[];
    createMany?: NotificationDeliveryCreateManyNotificationInputEnvelope;
    connect?: NotificationDeliveryWhereUniqueInput | NotificationDeliveryWhereUniqueInput[];
  };

  export type NotificationQueueCreateNestedManyWithoutDeliveryInput = {
    create?:
      | XOR<
          NotificationQueueCreateWithoutDeliveryInput,
          NotificationQueueUncheckedCreateWithoutDeliveryInput
        >
      | NotificationQueueCreateWithoutDeliveryInput[]
      | NotificationQueueUncheckedCreateWithoutDeliveryInput[];
    connectOrCreate?:
      | NotificationQueueCreateOrConnectWithoutDeliveryInput
      | NotificationQueueCreateOrConnectWithoutDeliveryInput[];
    createMany?: NotificationQueueCreateManyDeliveryInputEnvelope;
    connect?: NotificationQueueWhereUniqueInput | NotificationQueueWhereUniqueInput[];
  };

  export type NotificationDeliveryUncheckedCreateNestedManyWithoutNotificationInput = {
    create?:
      | XOR<
          NotificationDeliveryCreateWithoutNotificationInput,
          NotificationDeliveryUncheckedCreateWithoutNotificationInput
        >
      | NotificationDeliveryCreateWithoutNotificationInput[]
      | NotificationDeliveryUncheckedCreateWithoutNotificationInput[];
    connectOrCreate?:
      | NotificationDeliveryCreateOrConnectWithoutNotificationInput
      | NotificationDeliveryCreateOrConnectWithoutNotificationInput[];
    createMany?: NotificationDeliveryCreateManyNotificationInputEnvelope;
    connect?: NotificationDeliveryWhereUniqueInput | NotificationDeliveryWhereUniqueInput[];
  };

  export type NotificationQueueUncheckedCreateNestedManyWithoutDeliveryInput = {
    create?:
      | XOR<
          NotificationQueueCreateWithoutDeliveryInput,
          NotificationQueueUncheckedCreateWithoutDeliveryInput
        >
      | NotificationQueueCreateWithoutDeliveryInput[]
      | NotificationQueueUncheckedCreateWithoutDeliveryInput[];
    connectOrCreate?:
      | NotificationQueueCreateOrConnectWithoutDeliveryInput
      | NotificationQueueCreateOrConnectWithoutDeliveryInput[];
    createMany?: NotificationQueueCreateManyDeliveryInputEnvelope;
    connect?: NotificationQueueWhereUniqueInput | NotificationQueueWhereUniqueInput[];
  };

  export type EnumNotificationChannelFieldUpdateOperationsInput = {
    set?: $Enums.NotificationChannel;
  };

  export type EnumNotificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.NotificationStatus;
  };

  export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type NotificationEventUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<
      NotificationEventCreateWithoutNotificationsInput,
      NotificationEventUncheckedCreateWithoutNotificationsInput
    >;
    connectOrCreate?: NotificationEventCreateOrConnectWithoutNotificationsInput;
    upsert?: NotificationEventUpsertWithoutNotificationsInput;
    connect?: NotificationEventWhereUniqueInput;
    update?: XOR<
      XOR<
        NotificationEventUpdateToOneWithWhereWithoutNotificationsInput,
        NotificationEventUpdateWithoutNotificationsInput
      >,
      NotificationEventUncheckedUpdateWithoutNotificationsInput
    >;
  };

  export type NotificationDeliveryUpdateManyWithoutNotificationNestedInput = {
    create?:
      | XOR<
          NotificationDeliveryCreateWithoutNotificationInput,
          NotificationDeliveryUncheckedCreateWithoutNotificationInput
        >
      | NotificationDeliveryCreateWithoutNotificationInput[]
      | NotificationDeliveryUncheckedCreateWithoutNotificationInput[];
    connectOrCreate?:
      | NotificationDeliveryCreateOrConnectWithoutNotificationInput
      | NotificationDeliveryCreateOrConnectWithoutNotificationInput[];
    upsert?:
      | NotificationDeliveryUpsertWithWhereUniqueWithoutNotificationInput
      | NotificationDeliveryUpsertWithWhereUniqueWithoutNotificationInput[];
    createMany?: NotificationDeliveryCreateManyNotificationInputEnvelope;
    set?: NotificationDeliveryWhereUniqueInput | NotificationDeliveryWhereUniqueInput[];
    disconnect?: NotificationDeliveryWhereUniqueInput | NotificationDeliveryWhereUniqueInput[];
    delete?: NotificationDeliveryWhereUniqueInput | NotificationDeliveryWhereUniqueInput[];
    connect?: NotificationDeliveryWhereUniqueInput | NotificationDeliveryWhereUniqueInput[];
    update?:
      | NotificationDeliveryUpdateWithWhereUniqueWithoutNotificationInput
      | NotificationDeliveryUpdateWithWhereUniqueWithoutNotificationInput[];
    updateMany?:
      | NotificationDeliveryUpdateManyWithWhereWithoutNotificationInput
      | NotificationDeliveryUpdateManyWithWhereWithoutNotificationInput[];
    deleteMany?: NotificationDeliveryScalarWhereInput | NotificationDeliveryScalarWhereInput[];
  };

  export type NotificationQueueUpdateManyWithoutDeliveryNestedInput = {
    create?:
      | XOR<
          NotificationQueueCreateWithoutDeliveryInput,
          NotificationQueueUncheckedCreateWithoutDeliveryInput
        >
      | NotificationQueueCreateWithoutDeliveryInput[]
      | NotificationQueueUncheckedCreateWithoutDeliveryInput[];
    connectOrCreate?:
      | NotificationQueueCreateOrConnectWithoutDeliveryInput
      | NotificationQueueCreateOrConnectWithoutDeliveryInput[];
    upsert?:
      | NotificationQueueUpsertWithWhereUniqueWithoutDeliveryInput
      | NotificationQueueUpsertWithWhereUniqueWithoutDeliveryInput[];
    createMany?: NotificationQueueCreateManyDeliveryInputEnvelope;
    set?: NotificationQueueWhereUniqueInput | NotificationQueueWhereUniqueInput[];
    disconnect?: NotificationQueueWhereUniqueInput | NotificationQueueWhereUniqueInput[];
    delete?: NotificationQueueWhereUniqueInput | NotificationQueueWhereUniqueInput[];
    connect?: NotificationQueueWhereUniqueInput | NotificationQueueWhereUniqueInput[];
    update?:
      | NotificationQueueUpdateWithWhereUniqueWithoutDeliveryInput
      | NotificationQueueUpdateWithWhereUniqueWithoutDeliveryInput[];
    updateMany?:
      | NotificationQueueUpdateManyWithWhereWithoutDeliveryInput
      | NotificationQueueUpdateManyWithWhereWithoutDeliveryInput[];
    deleteMany?: NotificationQueueScalarWhereInput | NotificationQueueScalarWhereInput[];
  };

  export type NotificationDeliveryUncheckedUpdateManyWithoutNotificationNestedInput = {
    create?:
      | XOR<
          NotificationDeliveryCreateWithoutNotificationInput,
          NotificationDeliveryUncheckedCreateWithoutNotificationInput
        >
      | NotificationDeliveryCreateWithoutNotificationInput[]
      | NotificationDeliveryUncheckedCreateWithoutNotificationInput[];
    connectOrCreate?:
      | NotificationDeliveryCreateOrConnectWithoutNotificationInput
      | NotificationDeliveryCreateOrConnectWithoutNotificationInput[];
    upsert?:
      | NotificationDeliveryUpsertWithWhereUniqueWithoutNotificationInput
      | NotificationDeliveryUpsertWithWhereUniqueWithoutNotificationInput[];
    createMany?: NotificationDeliveryCreateManyNotificationInputEnvelope;
    set?: NotificationDeliveryWhereUniqueInput | NotificationDeliveryWhereUniqueInput[];
    disconnect?: NotificationDeliveryWhereUniqueInput | NotificationDeliveryWhereUniqueInput[];
    delete?: NotificationDeliveryWhereUniqueInput | NotificationDeliveryWhereUniqueInput[];
    connect?: NotificationDeliveryWhereUniqueInput | NotificationDeliveryWhereUniqueInput[];
    update?:
      | NotificationDeliveryUpdateWithWhereUniqueWithoutNotificationInput
      | NotificationDeliveryUpdateWithWhereUniqueWithoutNotificationInput[];
    updateMany?:
      | NotificationDeliveryUpdateManyWithWhereWithoutNotificationInput
      | NotificationDeliveryUpdateManyWithWhereWithoutNotificationInput[];
    deleteMany?: NotificationDeliveryScalarWhereInput | NotificationDeliveryScalarWhereInput[];
  };

  export type NotificationQueueUncheckedUpdateManyWithoutDeliveryNestedInput = {
    create?:
      | XOR<
          NotificationQueueCreateWithoutDeliveryInput,
          NotificationQueueUncheckedCreateWithoutDeliveryInput
        >
      | NotificationQueueCreateWithoutDeliveryInput[]
      | NotificationQueueUncheckedCreateWithoutDeliveryInput[];
    connectOrCreate?:
      | NotificationQueueCreateOrConnectWithoutDeliveryInput
      | NotificationQueueCreateOrConnectWithoutDeliveryInput[];
    upsert?:
      | NotificationQueueUpsertWithWhereUniqueWithoutDeliveryInput
      | NotificationQueueUpsertWithWhereUniqueWithoutDeliveryInput[];
    createMany?: NotificationQueueCreateManyDeliveryInputEnvelope;
    set?: NotificationQueueWhereUniqueInput | NotificationQueueWhereUniqueInput[];
    disconnect?: NotificationQueueWhereUniqueInput | NotificationQueueWhereUniqueInput[];
    delete?: NotificationQueueWhereUniqueInput | NotificationQueueWhereUniqueInput[];
    connect?: NotificationQueueWhereUniqueInput | NotificationQueueWhereUniqueInput[];
    update?:
      | NotificationQueueUpdateWithWhereUniqueWithoutDeliveryInput
      | NotificationQueueUpdateWithWhereUniqueWithoutDeliveryInput[];
    updateMany?:
      | NotificationQueueUpdateManyWithWhereWithoutDeliveryInput
      | NotificationQueueUpdateManyWithWhereWithoutDeliveryInput[];
    deleteMany?: NotificationQueueScalarWhereInput | NotificationQueueScalarWhereInput[];
  };

  export type NotificationCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<
      NotificationCreateWithoutDeliveriesInput,
      NotificationUncheckedCreateWithoutDeliveriesInput
    >;
    connectOrCreate?: NotificationCreateOrConnectWithoutDeliveriesInput;
    connect?: NotificationWhereUniqueInput;
  };

  export type NotificationEventCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<
      NotificationEventCreateWithoutDeliveriesInput,
      NotificationEventUncheckedCreateWithoutDeliveriesInput
    >;
    connectOrCreate?: NotificationEventCreateOrConnectWithoutDeliveriesInput;
    connect?: NotificationEventWhereUniqueInput;
  };

  export type EnumDeliveryStatusFieldUpdateOperationsInput = {
    set?: $Enums.DeliveryStatus;
  };

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type NotificationUpdateOneRequiredWithoutDeliveriesNestedInput = {
    create?: XOR<
      NotificationCreateWithoutDeliveriesInput,
      NotificationUncheckedCreateWithoutDeliveriesInput
    >;
    connectOrCreate?: NotificationCreateOrConnectWithoutDeliveriesInput;
    upsert?: NotificationUpsertWithoutDeliveriesInput;
    connect?: NotificationWhereUniqueInput;
    update?: XOR<
      XOR<
        NotificationUpdateToOneWithWhereWithoutDeliveriesInput,
        NotificationUpdateWithoutDeliveriesInput
      >,
      NotificationUncheckedUpdateWithoutDeliveriesInput
    >;
  };

  export type NotificationEventUpdateOneRequiredWithoutDeliveriesNestedInput = {
    create?: XOR<
      NotificationEventCreateWithoutDeliveriesInput,
      NotificationEventUncheckedCreateWithoutDeliveriesInput
    >;
    connectOrCreate?: NotificationEventCreateOrConnectWithoutDeliveriesInput;
    upsert?: NotificationEventUpsertWithoutDeliveriesInput;
    connect?: NotificationEventWhereUniqueInput;
    update?: XOR<
      XOR<
        NotificationEventUpdateToOneWithWhereWithoutDeliveriesInput,
        NotificationEventUpdateWithoutDeliveriesInput
      >,
      NotificationEventUncheckedUpdateWithoutDeliveriesInput
    >;
  };

  export type EnumProviderHealthFieldUpdateOperationsInput = {
    set?: $Enums.ProviderHealth;
  };

  export type HelixUserNotificationProfileCreatedefaultChannelsInput = {
    set: $Enums.NotificationChannel[];
  };

  export type HelixUserNotificationProfileCreatedndDaysInput = {
    set: string[];
  };

  export type HelixUserNotificationProfileCreategoalertSchedulesInput = {
    set: string[];
  };

  export type HelixUserNotificationProfileCreategoalertPoliciesInput = {
    set: string[];
  };

  export type HelixUserNotificationProfileCreatesecurityEventsInput = {
    set: string[];
  };

  export type NotificationPreferenceCreateNestedManyWithoutHelixProfileInput = {
    create?:
      | XOR<
          NotificationPreferenceCreateWithoutHelixProfileInput,
          NotificationPreferenceUncheckedCreateWithoutHelixProfileInput
        >
      | NotificationPreferenceCreateWithoutHelixProfileInput[]
      | NotificationPreferenceUncheckedCreateWithoutHelixProfileInput[];
    connectOrCreate?:
      | NotificationPreferenceCreateOrConnectWithoutHelixProfileInput
      | NotificationPreferenceCreateOrConnectWithoutHelixProfileInput[];
    createMany?: NotificationPreferenceCreateManyHelixProfileInputEnvelope;
    connect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[];
  };

  export type NotificationPreferenceUncheckedCreateNestedManyWithoutHelixProfileInput = {
    create?:
      | XOR<
          NotificationPreferenceCreateWithoutHelixProfileInput,
          NotificationPreferenceUncheckedCreateWithoutHelixProfileInput
        >
      | NotificationPreferenceCreateWithoutHelixProfileInput[]
      | NotificationPreferenceUncheckedCreateWithoutHelixProfileInput[];
    connectOrCreate?:
      | NotificationPreferenceCreateOrConnectWithoutHelixProfileInput
      | NotificationPreferenceCreateOrConnectWithoutHelixProfileInput[];
    createMany?: NotificationPreferenceCreateManyHelixProfileInputEnvelope;
    connect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[];
  };

  export type HelixUserNotificationProfileUpdatedefaultChannelsInput = {
    set?: $Enums.NotificationChannel[];
    push?: $Enums.NotificationChannel | $Enums.NotificationChannel[];
  };

  export type EnumDigestFrequencyFieldUpdateOperationsInput = {
    set?: $Enums.DigestFrequency;
  };

  export type HelixUserNotificationProfileUpdatedndDaysInput = {
    set?: string[];
    push?: string | string[];
  };

  export type HelixUserNotificationProfileUpdategoalertSchedulesInput = {
    set?: string[];
    push?: string | string[];
  };

  export type HelixUserNotificationProfileUpdategoalertPoliciesInput = {
    set?: string[];
    push?: string | string[];
  };

  export type EnumAiGroupingLevelFieldUpdateOperationsInput = {
    set?: $Enums.AiGroupingLevel;
  };

  export type HelixUserNotificationProfileUpdatesecurityEventsInput = {
    set?: string[];
    push?: string | string[];
  };

  export type NotificationPreferenceUpdateManyWithoutHelixProfileNestedInput = {
    create?:
      | XOR<
          NotificationPreferenceCreateWithoutHelixProfileInput,
          NotificationPreferenceUncheckedCreateWithoutHelixProfileInput
        >
      | NotificationPreferenceCreateWithoutHelixProfileInput[]
      | NotificationPreferenceUncheckedCreateWithoutHelixProfileInput[];
    connectOrCreate?:
      | NotificationPreferenceCreateOrConnectWithoutHelixProfileInput
      | NotificationPreferenceCreateOrConnectWithoutHelixProfileInput[];
    upsert?:
      | NotificationPreferenceUpsertWithWhereUniqueWithoutHelixProfileInput
      | NotificationPreferenceUpsertWithWhereUniqueWithoutHelixProfileInput[];
    createMany?: NotificationPreferenceCreateManyHelixProfileInputEnvelope;
    set?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[];
    disconnect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[];
    delete?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[];
    connect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[];
    update?:
      | NotificationPreferenceUpdateWithWhereUniqueWithoutHelixProfileInput
      | NotificationPreferenceUpdateWithWhereUniqueWithoutHelixProfileInput[];
    updateMany?:
      | NotificationPreferenceUpdateManyWithWhereWithoutHelixProfileInput
      | NotificationPreferenceUpdateManyWithWhereWithoutHelixProfileInput[];
    deleteMany?: NotificationPreferenceScalarWhereInput | NotificationPreferenceScalarWhereInput[];
  };

  export type NotificationPreferenceUncheckedUpdateManyWithoutHelixProfileNestedInput = {
    create?:
      | XOR<
          NotificationPreferenceCreateWithoutHelixProfileInput,
          NotificationPreferenceUncheckedCreateWithoutHelixProfileInput
        >
      | NotificationPreferenceCreateWithoutHelixProfileInput[]
      | NotificationPreferenceUncheckedCreateWithoutHelixProfileInput[];
    connectOrCreate?:
      | NotificationPreferenceCreateOrConnectWithoutHelixProfileInput
      | NotificationPreferenceCreateOrConnectWithoutHelixProfileInput[];
    upsert?:
      | NotificationPreferenceUpsertWithWhereUniqueWithoutHelixProfileInput
      | NotificationPreferenceUpsertWithWhereUniqueWithoutHelixProfileInput[];
    createMany?: NotificationPreferenceCreateManyHelixProfileInputEnvelope;
    set?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[];
    disconnect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[];
    delete?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[];
    connect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[];
    update?:
      | NotificationPreferenceUpdateWithWhereUniqueWithoutHelixProfileInput
      | NotificationPreferenceUpdateWithWhereUniqueWithoutHelixProfileInput[];
    updateMany?:
      | NotificationPreferenceUpdateManyWithWhereWithoutHelixProfileInput
      | NotificationPreferenceUpdateManyWithWhereWithoutHelixProfileInput[];
    deleteMany?: NotificationPreferenceScalarWhereInput | NotificationPreferenceScalarWhereInput[];
  };

  export type NotificationEventCreateNestedOneWithoutQueueInput = {
    create?: XOR<
      NotificationEventCreateWithoutQueueInput,
      NotificationEventUncheckedCreateWithoutQueueInput
    >;
    connectOrCreate?: NotificationEventCreateOrConnectWithoutQueueInput;
    connect?: NotificationEventWhereUniqueInput;
  };

  export type NotificationCreateNestedOneWithoutQueueInput = {
    create?: XOR<NotificationCreateWithoutQueueInput, NotificationUncheckedCreateWithoutQueueInput>;
    connectOrCreate?: NotificationCreateOrConnectWithoutQueueInput;
    connect?: NotificationWhereUniqueInput;
  };

  export type NotificationEventUpdateOneRequiredWithoutQueueNestedInput = {
    create?: XOR<
      NotificationEventCreateWithoutQueueInput,
      NotificationEventUncheckedCreateWithoutQueueInput
    >;
    connectOrCreate?: NotificationEventCreateOrConnectWithoutQueueInput;
    upsert?: NotificationEventUpsertWithoutQueueInput;
    connect?: NotificationEventWhereUniqueInput;
    update?: XOR<
      XOR<
        NotificationEventUpdateToOneWithWhereWithoutQueueInput,
        NotificationEventUpdateWithoutQueueInput
      >,
      NotificationEventUncheckedUpdateWithoutQueueInput
    >;
  };

  export type NotificationUpdateOneRequiredWithoutQueueNestedInput = {
    create?: XOR<NotificationCreateWithoutQueueInput, NotificationUncheckedCreateWithoutQueueInput>;
    connectOrCreate?: NotificationCreateOrConnectWithoutQueueInput;
    upsert?: NotificationUpsertWithoutQueueInput;
    connect?: NotificationWhereUniqueInput;
    update?: XOR<
      XOR<NotificationUpdateToOneWithWhereWithoutQueueInput, NotificationUpdateWithoutQueueInput>,
      NotificationUncheckedUpdateWithoutQueueInput
    >;
  };

  export type NotificationRoleDefaultCreatechannelsInput = {
    set: $Enums.NotificationChannel[];
  };

  export type NotificationRoleDefaultUpdatechannelsInput = {
    set?: $Enums.NotificationChannel[];
    push?: $Enums.NotificationChannel | $Enums.NotificationChannel[];
  };

  export type NullableEnumNotificationPriorityFieldUpdateOperationsInput = {
    set?: $Enums.NotificationPriority | null;
  };

  export type NotificationEventCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<
      NotificationEventCreateWithoutAuditLogsInput,
      NotificationEventUncheckedCreateWithoutAuditLogsInput
    >;
    connectOrCreate?: NotificationEventCreateOrConnectWithoutAuditLogsInput;
    connect?: NotificationEventWhereUniqueInput;
  };

  export type NotificationEventUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<
      NotificationEventCreateWithoutAuditLogsInput,
      NotificationEventUncheckedCreateWithoutAuditLogsInput
    >;
    connectOrCreate?: NotificationEventCreateOrConnectWithoutAuditLogsInput;
    upsert?: NotificationEventUpsertWithoutAuditLogsInput;
    connect?: NotificationEventWhereUniqueInput;
    update?: XOR<
      XOR<
        NotificationEventUpdateToOneWithWhereWithoutAuditLogsInput,
        NotificationEventUpdateWithoutAuditLogsInput
      >,
      NotificationEventUncheckedUpdateWithoutAuditLogsInput
    >;
  };

  export type RoleNotificationDefaultsCreatechannelsInput = {
    set: $Enums.NotificationChannel[];
  };

  export type RoleNotificationDefaultsUpdatechannelsInput = {
    set?: $Enums.NotificationChannel[];
    push?: $Enums.NotificationChannel | $Enums.NotificationChannel[];
  };

  export type NullableEnumNotificationChannelFieldUpdateOperationsInput = {
    set?: $Enums.NotificationChannel | null;
  };

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type NestedEnumNotificationPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>;
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>;
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>;
    not?: NestedEnumNotificationPriorityFilter<$PrismaModel> | $Enums.NotificationPriority;
  };

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type NestedEnumEventStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EventStatus | EnumEventStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumEventStatusFilter<$PrismaModel> | $Enums.EventStatus;
  };

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>;
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>;
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel>
      | $Enums.NotificationPriority;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumNotificationPriorityFilter<$PrismaModel>;
    _max?: NestedEnumNotificationPriorityFilter<$PrismaModel>;
  };

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonNullableFilterBase<$PrismaModel>>,
          Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>;

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
  };

  export type NestedEnumEventStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventStatus | EnumEventStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumEventStatusWithAggregatesFilter<$PrismaModel> | $Enums.EventStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumEventStatusFilter<$PrismaModel>;
    _max?: NestedEnumEventStatusFilter<$PrismaModel>;
  };

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type NestedEnumDigestFrequencyNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DigestFrequency | EnumDigestFrequencyFieldRefInput<$PrismaModel> | null;
    in?: $Enums.DigestFrequency[] | ListEnumDigestFrequencyFieldRefInput<$PrismaModel> | null;
    notIn?: $Enums.DigestFrequency[] | ListEnumDigestFrequencyFieldRefInput<$PrismaModel> | null;
    not?: NestedEnumDigestFrequencyNullableFilter<$PrismaModel> | $Enums.DigestFrequency | null;
  };

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type NestedEnumDigestFrequencyNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DigestFrequency | EnumDigestFrequencyFieldRefInput<$PrismaModel> | null;
    in?: $Enums.DigestFrequency[] | ListEnumDigestFrequencyFieldRefInput<$PrismaModel> | null;
    notIn?: $Enums.DigestFrequency[] | ListEnumDigestFrequencyFieldRefInput<$PrismaModel> | null;
    not?:
      | NestedEnumDigestFrequencyNullableWithAggregatesFilter<$PrismaModel>
      | $Enums.DigestFrequency
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedEnumDigestFrequencyNullableFilter<$PrismaModel>;
    _max?: NestedEnumDigestFrequencyNullableFilter<$PrismaModel>;
  };

  export type NestedEnumNotificationChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel>;
    in?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>;
    notIn?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>;
    not?: NestedEnumNotificationChannelFilter<$PrismaModel> | $Enums.NotificationChannel;
  };

  export type NestedEnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus;
  };

  export type NestedEnumNotificationChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel>;
    in?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>;
    notIn?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumNotificationChannelWithAggregatesFilter<$PrismaModel>
      | $Enums.NotificationChannel;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumNotificationChannelFilter<$PrismaModel>;
    _max?: NestedEnumNotificationChannelFilter<$PrismaModel>;
  };

  export type NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.NotificationStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>;
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>;
  };

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type NestedEnumDeliveryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryStatus | EnumDeliveryStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumDeliveryStatusFilter<$PrismaModel> | $Enums.DeliveryStatus;
  };

  export type NestedEnumDeliveryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryStatus | EnumDeliveryStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumDeliveryStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumDeliveryStatusFilter<$PrismaModel>;
    _max?: NestedEnumDeliveryStatusFilter<$PrismaModel>;
  };

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedEnumProviderHealthFilter<$PrismaModel = never> = {
    equals?: $Enums.ProviderHealth | EnumProviderHealthFieldRefInput<$PrismaModel>;
    in?: $Enums.ProviderHealth[] | ListEnumProviderHealthFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ProviderHealth[] | ListEnumProviderHealthFieldRefInput<$PrismaModel>;
    not?: NestedEnumProviderHealthFilter<$PrismaModel> | $Enums.ProviderHealth;
  };
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>;

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
  };

  export type NestedEnumProviderHealthWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProviderHealth | EnumProviderHealthFieldRefInput<$PrismaModel>;
    in?: $Enums.ProviderHealth[] | ListEnumProviderHealthFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ProviderHealth[] | ListEnumProviderHealthFieldRefInput<$PrismaModel>;
    not?: NestedEnumProviderHealthWithAggregatesFilter<$PrismaModel> | $Enums.ProviderHealth;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumProviderHealthFilter<$PrismaModel>;
    _max?: NestedEnumProviderHealthFilter<$PrismaModel>;
  };

  export type NestedEnumDigestFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.DigestFrequency | EnumDigestFrequencyFieldRefInput<$PrismaModel>;
    in?: $Enums.DigestFrequency[] | ListEnumDigestFrequencyFieldRefInput<$PrismaModel>;
    notIn?: $Enums.DigestFrequency[] | ListEnumDigestFrequencyFieldRefInput<$PrismaModel>;
    not?: NestedEnumDigestFrequencyFilter<$PrismaModel> | $Enums.DigestFrequency;
  };

  export type NestedEnumAiGroupingLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.AiGroupingLevel | EnumAiGroupingLevelFieldRefInput<$PrismaModel>;
    in?: $Enums.AiGroupingLevel[] | ListEnumAiGroupingLevelFieldRefInput<$PrismaModel>;
    notIn?: $Enums.AiGroupingLevel[] | ListEnumAiGroupingLevelFieldRefInput<$PrismaModel>;
    not?: NestedEnumAiGroupingLevelFilter<$PrismaModel> | $Enums.AiGroupingLevel;
  };

  export type NestedEnumDigestFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DigestFrequency | EnumDigestFrequencyFieldRefInput<$PrismaModel>;
    in?: $Enums.DigestFrequency[] | ListEnumDigestFrequencyFieldRefInput<$PrismaModel>;
    notIn?: $Enums.DigestFrequency[] | ListEnumDigestFrequencyFieldRefInput<$PrismaModel>;
    not?: NestedEnumDigestFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.DigestFrequency;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumDigestFrequencyFilter<$PrismaModel>;
    _max?: NestedEnumDigestFrequencyFilter<$PrismaModel>;
  };

  export type NestedEnumAiGroupingLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AiGroupingLevel | EnumAiGroupingLevelFieldRefInput<$PrismaModel>;
    in?: $Enums.AiGroupingLevel[] | ListEnumAiGroupingLevelFieldRefInput<$PrismaModel>;
    notIn?: $Enums.AiGroupingLevel[] | ListEnumAiGroupingLevelFieldRefInput<$PrismaModel>;
    not?: NestedEnumAiGroupingLevelWithAggregatesFilter<$PrismaModel> | $Enums.AiGroupingLevel;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumAiGroupingLevelFilter<$PrismaModel>;
    _max?: NestedEnumAiGroupingLevelFilter<$PrismaModel>;
  };

  export type NestedEnumNotificationPriorityNullableFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.NotificationPriority
      | EnumNotificationPriorityFieldRefInput<$PrismaModel>
      | null;
    in?:
      | $Enums.NotificationPriority[]
      | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.NotificationPriority[]
      | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumNotificationPriorityNullableFilter<$PrismaModel>
      | $Enums.NotificationPriority
      | null;
  };

  export type NestedEnumNotificationPriorityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.NotificationPriority
      | EnumNotificationPriorityFieldRefInput<$PrismaModel>
      | null;
    in?:
      | $Enums.NotificationPriority[]
      | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.NotificationPriority[]
      | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumNotificationPriorityNullableWithAggregatesFilter<$PrismaModel>
      | $Enums.NotificationPriority
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedEnumNotificationPriorityNullableFilter<$PrismaModel>;
    _max?: NestedEnumNotificationPriorityNullableFilter<$PrismaModel>;
  };

  export type NestedEnumNotificationChannelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel> | null;
    in?:
      | $Enums.NotificationChannel[]
      | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.NotificationChannel[]
      | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumNotificationChannelNullableFilter<$PrismaModel>
      | $Enums.NotificationChannel
      | null;
  };

  export type NestedEnumNotificationChannelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel> | null;
    in?:
      | $Enums.NotificationChannel[]
      | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.NotificationChannel[]
      | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumNotificationChannelNullableWithAggregatesFilter<$PrismaModel>
      | $Enums.NotificationChannel
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedEnumNotificationChannelNullableFilter<$PrismaModel>;
    _max?: NestedEnumNotificationChannelNullableFilter<$PrismaModel>;
  };

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedFloatNullableFilter<$PrismaModel>;
    _min?: NestedFloatNullableFilter<$PrismaModel>;
    _max?: NestedFloatNullableFilter<$PrismaModel>;
  };

  export type NotificationCreateWithoutEventInput = {
    id?: string;
    userId: string;
    channel: $Enums.NotificationChannel;
    title: string;
    message: string;
    details?: string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    status?: $Enums.NotificationStatus;
    priority?: $Enums.NotificationPriority;
    scheduledFor?: Date | string | null;
    deliveredAt?: Date | string | null;
    readAt?: Date | string | null;
    clickedAt?: Date | string | null;
    dismissedAt?: Date | string | null;
    retryCount?: number;
    maxRetries?: number;
    nextRetry?: Date | string | null;
    aiSummary?: string | null;
    groupId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deliveries?: NotificationDeliveryCreateNestedManyWithoutNotificationInput;
    queue?: NotificationQueueCreateNestedManyWithoutDeliveryInput;
  };

  export type NotificationUncheckedCreateWithoutEventInput = {
    id?: string;
    userId: string;
    channel: $Enums.NotificationChannel;
    title: string;
    message: string;
    details?: string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    status?: $Enums.NotificationStatus;
    priority?: $Enums.NotificationPriority;
    scheduledFor?: Date | string | null;
    deliveredAt?: Date | string | null;
    readAt?: Date | string | null;
    clickedAt?: Date | string | null;
    dismissedAt?: Date | string | null;
    retryCount?: number;
    maxRetries?: number;
    nextRetry?: Date | string | null;
    aiSummary?: string | null;
    groupId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deliveries?: NotificationDeliveryUncheckedCreateNestedManyWithoutNotificationInput;
    queue?: NotificationQueueUncheckedCreateNestedManyWithoutDeliveryInput;
  };

  export type NotificationCreateOrConnectWithoutEventInput = {
    where: NotificationWhereUniqueInput;
    create: XOR<NotificationCreateWithoutEventInput, NotificationUncheckedCreateWithoutEventInput>;
  };

  export type NotificationCreateManyEventInputEnvelope = {
    data: NotificationCreateManyEventInput | NotificationCreateManyEventInput[];
    skipDuplicates?: boolean;
  };

  export type NotificationDeliveryCreateWithoutEventInput = {
    id?: string;
    userId: string;
    channel: $Enums.NotificationChannel;
    provider?: string | null;
    providerConfig?: NullableJsonNullValueInput | InputJsonValue;
    status?: $Enums.DeliveryStatus;
    deliveredAt?: Date | string | null;
    failedAt?: Date | string | null;
    errorMessage?: string | null;
    errorCode?: string | null;
    providerResponse?: NullableJsonNullValueInput | InputJsonValue;
    messageId?: string | null;
    responseTime?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    notification: NotificationCreateNestedOneWithoutDeliveriesInput;
  };

  export type NotificationDeliveryUncheckedCreateWithoutEventInput = {
    id?: string;
    notificationId: string;
    userId: string;
    channel: $Enums.NotificationChannel;
    provider?: string | null;
    providerConfig?: NullableJsonNullValueInput | InputJsonValue;
    status?: $Enums.DeliveryStatus;
    deliveredAt?: Date | string | null;
    failedAt?: Date | string | null;
    errorMessage?: string | null;
    errorCode?: string | null;
    providerResponse?: NullableJsonNullValueInput | InputJsonValue;
    messageId?: string | null;
    responseTime?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type NotificationDeliveryCreateOrConnectWithoutEventInput = {
    where: NotificationDeliveryWhereUniqueInput;
    create: XOR<
      NotificationDeliveryCreateWithoutEventInput,
      NotificationDeliveryUncheckedCreateWithoutEventInput
    >;
  };

  export type NotificationDeliveryCreateManyEventInputEnvelope = {
    data: NotificationDeliveryCreateManyEventInput | NotificationDeliveryCreateManyEventInput[];
    skipDuplicates?: boolean;
  };

  export type NotificationQueueCreateWithoutEventInput = {
    id?: string;
    priority?: $Enums.NotificationPriority;
    scheduledFor?: Date | string;
    attempts?: number;
    maxAttempts?: number;
    lastAttemptAt?: Date | string | null;
    nextAttemptAt?: Date | string | null;
    status?: string;
    error?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    delivery: NotificationCreateNestedOneWithoutQueueInput;
  };

  export type NotificationQueueUncheckedCreateWithoutEventInput = {
    id?: string;
    deliveryId: string;
    priority?: $Enums.NotificationPriority;
    scheduledFor?: Date | string;
    attempts?: number;
    maxAttempts?: number;
    lastAttemptAt?: Date | string | null;
    nextAttemptAt?: Date | string | null;
    status?: string;
    error?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type NotificationQueueCreateOrConnectWithoutEventInput = {
    where: NotificationQueueWhereUniqueInput;
    create: XOR<
      NotificationQueueCreateWithoutEventInput,
      NotificationQueueUncheckedCreateWithoutEventInput
    >;
  };

  export type NotificationQueueCreateManyEventInputEnvelope = {
    data: NotificationQueueCreateManyEventInput | NotificationQueueCreateManyEventInput[];
    skipDuplicates?: boolean;
  };

  export type NotificationAuditLogCreateWithoutEventInput = {
    id?: string;
    action: string;
    userId?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    timestamp?: Date | string;
  };

  export type NotificationAuditLogUncheckedCreateWithoutEventInput = {
    id?: string;
    action: string;
    userId?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    timestamp?: Date | string;
  };

  export type NotificationAuditLogCreateOrConnectWithoutEventInput = {
    where: NotificationAuditLogWhereUniqueInput;
    create: XOR<
      NotificationAuditLogCreateWithoutEventInput,
      NotificationAuditLogUncheckedCreateWithoutEventInput
    >;
  };

  export type NotificationAuditLogCreateManyEventInputEnvelope = {
    data: NotificationAuditLogCreateManyEventInput | NotificationAuditLogCreateManyEventInput[];
    skipDuplicates?: boolean;
  };

  export type NotificationUpsertWithWhereUniqueWithoutEventInput = {
    where: NotificationWhereUniqueInput;
    update: XOR<NotificationUpdateWithoutEventInput, NotificationUncheckedUpdateWithoutEventInput>;
    create: XOR<NotificationCreateWithoutEventInput, NotificationUncheckedCreateWithoutEventInput>;
  };

  export type NotificationUpdateWithWhereUniqueWithoutEventInput = {
    where: NotificationWhereUniqueInput;
    data: XOR<NotificationUpdateWithoutEventInput, NotificationUncheckedUpdateWithoutEventInput>;
  };

  export type NotificationUpdateManyWithWhereWithoutEventInput = {
    where: NotificationScalarWhereInput;
    data: XOR<
      NotificationUpdateManyMutationInput,
      NotificationUncheckedUpdateManyWithoutEventInput
    >;
  };

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
    OR?: NotificationScalarWhereInput[];
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
    id?: StringFilter<'Notification'> | string;
    eventId?: StringFilter<'Notification'> | string;
    userId?: StringFilter<'Notification'> | string;
    channel?: EnumNotificationChannelFilter<'Notification'> | $Enums.NotificationChannel;
    title?: StringFilter<'Notification'> | string;
    message?: StringFilter<'Notification'> | string;
    details?: StringNullableFilter<'Notification'> | string | null;
    actions?: JsonNullableFilter<'Notification'>;
    status?: EnumNotificationStatusFilter<'Notification'> | $Enums.NotificationStatus;
    priority?: EnumNotificationPriorityFilter<'Notification'> | $Enums.NotificationPriority;
    scheduledFor?: DateTimeNullableFilter<'Notification'> | Date | string | null;
    deliveredAt?: DateTimeNullableFilter<'Notification'> | Date | string | null;
    readAt?: DateTimeNullableFilter<'Notification'> | Date | string | null;
    clickedAt?: DateTimeNullableFilter<'Notification'> | Date | string | null;
    dismissedAt?: DateTimeNullableFilter<'Notification'> | Date | string | null;
    retryCount?: IntFilter<'Notification'> | number;
    maxRetries?: IntFilter<'Notification'> | number;
    nextRetry?: DateTimeNullableFilter<'Notification'> | Date | string | null;
    aiSummary?: StringNullableFilter<'Notification'> | string | null;
    groupId?: StringNullableFilter<'Notification'> | string | null;
    createdAt?: DateTimeFilter<'Notification'> | Date | string;
    updatedAt?: DateTimeFilter<'Notification'> | Date | string;
  };

  export type NotificationDeliveryUpsertWithWhereUniqueWithoutEventInput = {
    where: NotificationDeliveryWhereUniqueInput;
    update: XOR<
      NotificationDeliveryUpdateWithoutEventInput,
      NotificationDeliveryUncheckedUpdateWithoutEventInput
    >;
    create: XOR<
      NotificationDeliveryCreateWithoutEventInput,
      NotificationDeliveryUncheckedCreateWithoutEventInput
    >;
  };

  export type NotificationDeliveryUpdateWithWhereUniqueWithoutEventInput = {
    where: NotificationDeliveryWhereUniqueInput;
    data: XOR<
      NotificationDeliveryUpdateWithoutEventInput,
      NotificationDeliveryUncheckedUpdateWithoutEventInput
    >;
  };

  export type NotificationDeliveryUpdateManyWithWhereWithoutEventInput = {
    where: NotificationDeliveryScalarWhereInput;
    data: XOR<
      NotificationDeliveryUpdateManyMutationInput,
      NotificationDeliveryUncheckedUpdateManyWithoutEventInput
    >;
  };

  export type NotificationDeliveryScalarWhereInput = {
    AND?: NotificationDeliveryScalarWhereInput | NotificationDeliveryScalarWhereInput[];
    OR?: NotificationDeliveryScalarWhereInput[];
    NOT?: NotificationDeliveryScalarWhereInput | NotificationDeliveryScalarWhereInput[];
    id?: StringFilter<'NotificationDelivery'> | string;
    notificationId?: StringFilter<'NotificationDelivery'> | string;
    eventId?: StringFilter<'NotificationDelivery'> | string;
    userId?: StringFilter<'NotificationDelivery'> | string;
    channel?: EnumNotificationChannelFilter<'NotificationDelivery'> | $Enums.NotificationChannel;
    provider?: StringNullableFilter<'NotificationDelivery'> | string | null;
    providerConfig?: JsonNullableFilter<'NotificationDelivery'>;
    status?: EnumDeliveryStatusFilter<'NotificationDelivery'> | $Enums.DeliveryStatus;
    deliveredAt?: DateTimeNullableFilter<'NotificationDelivery'> | Date | string | null;
    failedAt?: DateTimeNullableFilter<'NotificationDelivery'> | Date | string | null;
    errorMessage?: StringNullableFilter<'NotificationDelivery'> | string | null;
    errorCode?: StringNullableFilter<'NotificationDelivery'> | string | null;
    providerResponse?: JsonNullableFilter<'NotificationDelivery'>;
    messageId?: StringNullableFilter<'NotificationDelivery'> | string | null;
    responseTime?: IntNullableFilter<'NotificationDelivery'> | number | null;
    createdAt?: DateTimeFilter<'NotificationDelivery'> | Date | string;
    updatedAt?: DateTimeFilter<'NotificationDelivery'> | Date | string;
  };

  export type NotificationQueueUpsertWithWhereUniqueWithoutEventInput = {
    where: NotificationQueueWhereUniqueInput;
    update: XOR<
      NotificationQueueUpdateWithoutEventInput,
      NotificationQueueUncheckedUpdateWithoutEventInput
    >;
    create: XOR<
      NotificationQueueCreateWithoutEventInput,
      NotificationQueueUncheckedCreateWithoutEventInput
    >;
  };

  export type NotificationQueueUpdateWithWhereUniqueWithoutEventInput = {
    where: NotificationQueueWhereUniqueInput;
    data: XOR<
      NotificationQueueUpdateWithoutEventInput,
      NotificationQueueUncheckedUpdateWithoutEventInput
    >;
  };

  export type NotificationQueueUpdateManyWithWhereWithoutEventInput = {
    where: NotificationQueueScalarWhereInput;
    data: XOR<
      NotificationQueueUpdateManyMutationInput,
      NotificationQueueUncheckedUpdateManyWithoutEventInput
    >;
  };

  export type NotificationQueueScalarWhereInput = {
    AND?: NotificationQueueScalarWhereInput | NotificationQueueScalarWhereInput[];
    OR?: NotificationQueueScalarWhereInput[];
    NOT?: NotificationQueueScalarWhereInput | NotificationQueueScalarWhereInput[];
    id?: StringFilter<'NotificationQueue'> | string;
    eventId?: StringFilter<'NotificationQueue'> | string;
    deliveryId?: StringFilter<'NotificationQueue'> | string;
    priority?: EnumNotificationPriorityFilter<'NotificationQueue'> | $Enums.NotificationPriority;
    scheduledFor?: DateTimeFilter<'NotificationQueue'> | Date | string;
    attempts?: IntFilter<'NotificationQueue'> | number;
    maxAttempts?: IntFilter<'NotificationQueue'> | number;
    lastAttemptAt?: DateTimeNullableFilter<'NotificationQueue'> | Date | string | null;
    nextAttemptAt?: DateTimeNullableFilter<'NotificationQueue'> | Date | string | null;
    status?: StringFilter<'NotificationQueue'> | string;
    error?: StringNullableFilter<'NotificationQueue'> | string | null;
    metadata?: JsonNullableFilter<'NotificationQueue'>;
    createdAt?: DateTimeFilter<'NotificationQueue'> | Date | string;
    updatedAt?: DateTimeFilter<'NotificationQueue'> | Date | string;
  };

  export type NotificationAuditLogUpsertWithWhereUniqueWithoutEventInput = {
    where: NotificationAuditLogWhereUniqueInput;
    update: XOR<
      NotificationAuditLogUpdateWithoutEventInput,
      NotificationAuditLogUncheckedUpdateWithoutEventInput
    >;
    create: XOR<
      NotificationAuditLogCreateWithoutEventInput,
      NotificationAuditLogUncheckedCreateWithoutEventInput
    >;
  };

  export type NotificationAuditLogUpdateWithWhereUniqueWithoutEventInput = {
    where: NotificationAuditLogWhereUniqueInput;
    data: XOR<
      NotificationAuditLogUpdateWithoutEventInput,
      NotificationAuditLogUncheckedUpdateWithoutEventInput
    >;
  };

  export type NotificationAuditLogUpdateManyWithWhereWithoutEventInput = {
    where: NotificationAuditLogScalarWhereInput;
    data: XOR<
      NotificationAuditLogUpdateManyMutationInput,
      NotificationAuditLogUncheckedUpdateManyWithoutEventInput
    >;
  };

  export type NotificationAuditLogScalarWhereInput = {
    AND?: NotificationAuditLogScalarWhereInput | NotificationAuditLogScalarWhereInput[];
    OR?: NotificationAuditLogScalarWhereInput[];
    NOT?: NotificationAuditLogScalarWhereInput | NotificationAuditLogScalarWhereInput[];
    id?: StringFilter<'NotificationAuditLog'> | string;
    eventId?: StringFilter<'NotificationAuditLog'> | string;
    action?: StringFilter<'NotificationAuditLog'> | string;
    userId?: StringNullableFilter<'NotificationAuditLog'> | string | null;
    metadata?: JsonNullableFilter<'NotificationAuditLog'>;
    ipAddress?: StringNullableFilter<'NotificationAuditLog'> | string | null;
    userAgent?: StringNullableFilter<'NotificationAuditLog'> | string | null;
    timestamp?: DateTimeFilter<'NotificationAuditLog'> | Date | string;
  };

  export type HelixUserNotificationProfileCreateWithoutPreferencesInput = {
    id?: string;
    userId: string;
    globalEnabled?: boolean;
    defaultChannels?:
      | HelixUserNotificationProfileCreatedefaultChannelsInput
      | $Enums.NotificationChannel[];
    timezone?: string;
    digestEnabled?: boolean;
    digestFrequency?: $Enums.DigestFrequency;
    digestTime?: string;
    dndEnabled?: boolean;
    dndStartTime?: string | null;
    dndEndTime?: string | null;
    dndDays?: HelixUserNotificationProfileCreatedndDaysInput | string[];
    goalertEnabled?: boolean;
    goalertSchedules?: HelixUserNotificationProfileCreategoalertSchedulesInput | string[];
    goalertPolicies?: HelixUserNotificationProfileCreategoalertPoliciesInput | string[];
    pagerEnabled?: boolean;
    synthEnabled?: boolean;
    aiDigestEnabled?: boolean;
    aiGroupingLevel?: $Enums.AiGroupingLevel;
    muteRepetitive?: boolean;
    sentinelEnabled?: boolean;
    securityEvents?: HelixUserNotificationProfileCreatesecurityEventsInput | string[];
    complianceEvents?: boolean;
    deviceTokens?: NullableJsonNullValueInput | InputJsonValue;
    pushEnabled?: boolean;
    phoneNumber?: string | null;
    slackUserId?: string | null;
    teamsUserId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type HelixUserNotificationProfileUncheckedCreateWithoutPreferencesInput = {
    id?: string;
    userId: string;
    globalEnabled?: boolean;
    defaultChannels?:
      | HelixUserNotificationProfileCreatedefaultChannelsInput
      | $Enums.NotificationChannel[];
    timezone?: string;
    digestEnabled?: boolean;
    digestFrequency?: $Enums.DigestFrequency;
    digestTime?: string;
    dndEnabled?: boolean;
    dndStartTime?: string | null;
    dndEndTime?: string | null;
    dndDays?: HelixUserNotificationProfileCreatedndDaysInput | string[];
    goalertEnabled?: boolean;
    goalertSchedules?: HelixUserNotificationProfileCreategoalertSchedulesInput | string[];
    goalertPolicies?: HelixUserNotificationProfileCreategoalertPoliciesInput | string[];
    pagerEnabled?: boolean;
    synthEnabled?: boolean;
    aiDigestEnabled?: boolean;
    aiGroupingLevel?: $Enums.AiGroupingLevel;
    muteRepetitive?: boolean;
    sentinelEnabled?: boolean;
    securityEvents?: HelixUserNotificationProfileCreatesecurityEventsInput | string[];
    complianceEvents?: boolean;
    deviceTokens?: NullableJsonNullValueInput | InputJsonValue;
    pushEnabled?: boolean;
    phoneNumber?: string | null;
    slackUserId?: string | null;
    teamsUserId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type HelixUserNotificationProfileCreateOrConnectWithoutPreferencesInput = {
    where: HelixUserNotificationProfileWhereUniqueInput;
    create: XOR<
      HelixUserNotificationProfileCreateWithoutPreferencesInput,
      HelixUserNotificationProfileUncheckedCreateWithoutPreferencesInput
    >;
  };

  export type HelixUserNotificationProfileUpsertWithoutPreferencesInput = {
    update: XOR<
      HelixUserNotificationProfileUpdateWithoutPreferencesInput,
      HelixUserNotificationProfileUncheckedUpdateWithoutPreferencesInput
    >;
    create: XOR<
      HelixUserNotificationProfileCreateWithoutPreferencesInput,
      HelixUserNotificationProfileUncheckedCreateWithoutPreferencesInput
    >;
    where?: HelixUserNotificationProfileWhereInput;
  };

  export type HelixUserNotificationProfileUpdateToOneWithWhereWithoutPreferencesInput = {
    where?: HelixUserNotificationProfileWhereInput;
    data: XOR<
      HelixUserNotificationProfileUpdateWithoutPreferencesInput,
      HelixUserNotificationProfileUncheckedUpdateWithoutPreferencesInput
    >;
  };

  export type HelixUserNotificationProfileUpdateWithoutPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    globalEnabled?: BoolFieldUpdateOperationsInput | boolean;
    defaultChannels?:
      | HelixUserNotificationProfileUpdatedefaultChannelsInput
      | $Enums.NotificationChannel[];
    timezone?: StringFieldUpdateOperationsInput | string;
    digestEnabled?: BoolFieldUpdateOperationsInput | boolean;
    digestFrequency?: EnumDigestFrequencyFieldUpdateOperationsInput | $Enums.DigestFrequency;
    digestTime?: StringFieldUpdateOperationsInput | string;
    dndEnabled?: BoolFieldUpdateOperationsInput | boolean;
    dndStartTime?: NullableStringFieldUpdateOperationsInput | string | null;
    dndEndTime?: NullableStringFieldUpdateOperationsInput | string | null;
    dndDays?: HelixUserNotificationProfileUpdatedndDaysInput | string[];
    goalertEnabled?: BoolFieldUpdateOperationsInput | boolean;
    goalertSchedules?: HelixUserNotificationProfileUpdategoalertSchedulesInput | string[];
    goalertPolicies?: HelixUserNotificationProfileUpdategoalertPoliciesInput | string[];
    pagerEnabled?: BoolFieldUpdateOperationsInput | boolean;
    synthEnabled?: BoolFieldUpdateOperationsInput | boolean;
    aiDigestEnabled?: BoolFieldUpdateOperationsInput | boolean;
    aiGroupingLevel?: EnumAiGroupingLevelFieldUpdateOperationsInput | $Enums.AiGroupingLevel;
    muteRepetitive?: BoolFieldUpdateOperationsInput | boolean;
    sentinelEnabled?: BoolFieldUpdateOperationsInput | boolean;
    securityEvents?: HelixUserNotificationProfileUpdatesecurityEventsInput | string[];
    complianceEvents?: BoolFieldUpdateOperationsInput | boolean;
    deviceTokens?: NullableJsonNullValueInput | InputJsonValue;
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    slackUserId?: NullableStringFieldUpdateOperationsInput | string | null;
    teamsUserId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type HelixUserNotificationProfileUncheckedUpdateWithoutPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    globalEnabled?: BoolFieldUpdateOperationsInput | boolean;
    defaultChannels?:
      | HelixUserNotificationProfileUpdatedefaultChannelsInput
      | $Enums.NotificationChannel[];
    timezone?: StringFieldUpdateOperationsInput | string;
    digestEnabled?: BoolFieldUpdateOperationsInput | boolean;
    digestFrequency?: EnumDigestFrequencyFieldUpdateOperationsInput | $Enums.DigestFrequency;
    digestTime?: StringFieldUpdateOperationsInput | string;
    dndEnabled?: BoolFieldUpdateOperationsInput | boolean;
    dndStartTime?: NullableStringFieldUpdateOperationsInput | string | null;
    dndEndTime?: NullableStringFieldUpdateOperationsInput | string | null;
    dndDays?: HelixUserNotificationProfileUpdatedndDaysInput | string[];
    goalertEnabled?: BoolFieldUpdateOperationsInput | boolean;
    goalertSchedules?: HelixUserNotificationProfileUpdategoalertSchedulesInput | string[];
    goalertPolicies?: HelixUserNotificationProfileUpdategoalertPoliciesInput | string[];
    pagerEnabled?: BoolFieldUpdateOperationsInput | boolean;
    synthEnabled?: BoolFieldUpdateOperationsInput | boolean;
    aiDigestEnabled?: BoolFieldUpdateOperationsInput | boolean;
    aiGroupingLevel?: EnumAiGroupingLevelFieldUpdateOperationsInput | $Enums.AiGroupingLevel;
    muteRepetitive?: BoolFieldUpdateOperationsInput | boolean;
    sentinelEnabled?: BoolFieldUpdateOperationsInput | boolean;
    securityEvents?: HelixUserNotificationProfileUpdatesecurityEventsInput | string[];
    complianceEvents?: BoolFieldUpdateOperationsInput | boolean;
    deviceTokens?: NullableJsonNullValueInput | InputJsonValue;
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    slackUserId?: NullableStringFieldUpdateOperationsInput | string | null;
    teamsUserId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationEventCreateWithoutNotificationsInput = {
    id?: string;
    eventId: string;
    module: string;
    eventType: string;
    priority?: $Enums.NotificationPriority;
    title: string;
    message: string;
    details?: string | null;
    recipientRoles?: NotificationEventCreaterecipientRolesInput | string[];
    recipientUsers?: NotificationEventCreaterecipientUsersInput | string[];
    tenantId?: string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    status?: $Enums.EventStatus;
    scheduledFor?: Date | string | null;
    expiresAt?: Date | string | null;
    createdAt?: Date | string;
    createdBy?: string | null;
    processedAt?: Date | string | null;
    deliveries?: NotificationDeliveryCreateNestedManyWithoutEventInput;
    queue?: NotificationQueueCreateNestedManyWithoutEventInput;
    auditLogs?: NotificationAuditLogCreateNestedManyWithoutEventInput;
  };

  export type NotificationEventUncheckedCreateWithoutNotificationsInput = {
    id?: string;
    eventId: string;
    module: string;
    eventType: string;
    priority?: $Enums.NotificationPriority;
    title: string;
    message: string;
    details?: string | null;
    recipientRoles?: NotificationEventCreaterecipientRolesInput | string[];
    recipientUsers?: NotificationEventCreaterecipientUsersInput | string[];
    tenantId?: string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    status?: $Enums.EventStatus;
    scheduledFor?: Date | string | null;
    expiresAt?: Date | string | null;
    createdAt?: Date | string;
    createdBy?: string | null;
    processedAt?: Date | string | null;
    deliveries?: NotificationDeliveryUncheckedCreateNestedManyWithoutEventInput;
    queue?: NotificationQueueUncheckedCreateNestedManyWithoutEventInput;
    auditLogs?: NotificationAuditLogUncheckedCreateNestedManyWithoutEventInput;
  };

  export type NotificationEventCreateOrConnectWithoutNotificationsInput = {
    where: NotificationEventWhereUniqueInput;
    create: XOR<
      NotificationEventCreateWithoutNotificationsInput,
      NotificationEventUncheckedCreateWithoutNotificationsInput
    >;
  };

  export type NotificationDeliveryCreateWithoutNotificationInput = {
    id?: string;
    userId: string;
    channel: $Enums.NotificationChannel;
    provider?: string | null;
    providerConfig?: NullableJsonNullValueInput | InputJsonValue;
    status?: $Enums.DeliveryStatus;
    deliveredAt?: Date | string | null;
    failedAt?: Date | string | null;
    errorMessage?: string | null;
    errorCode?: string | null;
    providerResponse?: NullableJsonNullValueInput | InputJsonValue;
    messageId?: string | null;
    responseTime?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    event: NotificationEventCreateNestedOneWithoutDeliveriesInput;
  };

  export type NotificationDeliveryUncheckedCreateWithoutNotificationInput = {
    id?: string;
    eventId: string;
    userId: string;
    channel: $Enums.NotificationChannel;
    provider?: string | null;
    providerConfig?: NullableJsonNullValueInput | InputJsonValue;
    status?: $Enums.DeliveryStatus;
    deliveredAt?: Date | string | null;
    failedAt?: Date | string | null;
    errorMessage?: string | null;
    errorCode?: string | null;
    providerResponse?: NullableJsonNullValueInput | InputJsonValue;
    messageId?: string | null;
    responseTime?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type NotificationDeliveryCreateOrConnectWithoutNotificationInput = {
    where: NotificationDeliveryWhereUniqueInput;
    create: XOR<
      NotificationDeliveryCreateWithoutNotificationInput,
      NotificationDeliveryUncheckedCreateWithoutNotificationInput
    >;
  };

  export type NotificationDeliveryCreateManyNotificationInputEnvelope = {
    data:
      | NotificationDeliveryCreateManyNotificationInput
      | NotificationDeliveryCreateManyNotificationInput[];
    skipDuplicates?: boolean;
  };

  export type NotificationQueueCreateWithoutDeliveryInput = {
    id?: string;
    priority?: $Enums.NotificationPriority;
    scheduledFor?: Date | string;
    attempts?: number;
    maxAttempts?: number;
    lastAttemptAt?: Date | string | null;
    nextAttemptAt?: Date | string | null;
    status?: string;
    error?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    event: NotificationEventCreateNestedOneWithoutQueueInput;
  };

  export type NotificationQueueUncheckedCreateWithoutDeliveryInput = {
    id?: string;
    eventId: string;
    priority?: $Enums.NotificationPriority;
    scheduledFor?: Date | string;
    attempts?: number;
    maxAttempts?: number;
    lastAttemptAt?: Date | string | null;
    nextAttemptAt?: Date | string | null;
    status?: string;
    error?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type NotificationQueueCreateOrConnectWithoutDeliveryInput = {
    where: NotificationQueueWhereUniqueInput;
    create: XOR<
      NotificationQueueCreateWithoutDeliveryInput,
      NotificationQueueUncheckedCreateWithoutDeliveryInput
    >;
  };

  export type NotificationQueueCreateManyDeliveryInputEnvelope = {
    data: NotificationQueueCreateManyDeliveryInput | NotificationQueueCreateManyDeliveryInput[];
    skipDuplicates?: boolean;
  };

  export type NotificationEventUpsertWithoutNotificationsInput = {
    update: XOR<
      NotificationEventUpdateWithoutNotificationsInput,
      NotificationEventUncheckedUpdateWithoutNotificationsInput
    >;
    create: XOR<
      NotificationEventCreateWithoutNotificationsInput,
      NotificationEventUncheckedCreateWithoutNotificationsInput
    >;
    where?: NotificationEventWhereInput;
  };

  export type NotificationEventUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: NotificationEventWhereInput;
    data: XOR<
      NotificationEventUpdateWithoutNotificationsInput,
      NotificationEventUncheckedUpdateWithoutNotificationsInput
    >;
  };

  export type NotificationEventUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    module?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    details?: NullableStringFieldUpdateOperationsInput | string | null;
    recipientRoles?: NotificationEventUpdaterecipientRolesInput | string[];
    recipientUsers?: NotificationEventUpdaterecipientUsersInput | string[];
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveries?: NotificationDeliveryUpdateManyWithoutEventNestedInput;
    queue?: NotificationQueueUpdateManyWithoutEventNestedInput;
    auditLogs?: NotificationAuditLogUpdateManyWithoutEventNestedInput;
  };

  export type NotificationEventUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    module?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    details?: NullableStringFieldUpdateOperationsInput | string | null;
    recipientRoles?: NotificationEventUpdaterecipientRolesInput | string[];
    recipientUsers?: NotificationEventUpdaterecipientUsersInput | string[];
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveries?: NotificationDeliveryUncheckedUpdateManyWithoutEventNestedInput;
    queue?: NotificationQueueUncheckedUpdateManyWithoutEventNestedInput;
    auditLogs?: NotificationAuditLogUncheckedUpdateManyWithoutEventNestedInput;
  };

  export type NotificationDeliveryUpsertWithWhereUniqueWithoutNotificationInput = {
    where: NotificationDeliveryWhereUniqueInput;
    update: XOR<
      NotificationDeliveryUpdateWithoutNotificationInput,
      NotificationDeliveryUncheckedUpdateWithoutNotificationInput
    >;
    create: XOR<
      NotificationDeliveryCreateWithoutNotificationInput,
      NotificationDeliveryUncheckedCreateWithoutNotificationInput
    >;
  };

  export type NotificationDeliveryUpdateWithWhereUniqueWithoutNotificationInput = {
    where: NotificationDeliveryWhereUniqueInput;
    data: XOR<
      NotificationDeliveryUpdateWithoutNotificationInput,
      NotificationDeliveryUncheckedUpdateWithoutNotificationInput
    >;
  };

  export type NotificationDeliveryUpdateManyWithWhereWithoutNotificationInput = {
    where: NotificationDeliveryScalarWhereInput;
    data: XOR<
      NotificationDeliveryUpdateManyMutationInput,
      NotificationDeliveryUncheckedUpdateManyWithoutNotificationInput
    >;
  };

  export type NotificationQueueUpsertWithWhereUniqueWithoutDeliveryInput = {
    where: NotificationQueueWhereUniqueInput;
    update: XOR<
      NotificationQueueUpdateWithoutDeliveryInput,
      NotificationQueueUncheckedUpdateWithoutDeliveryInput
    >;
    create: XOR<
      NotificationQueueCreateWithoutDeliveryInput,
      NotificationQueueUncheckedCreateWithoutDeliveryInput
    >;
  };

  export type NotificationQueueUpdateWithWhereUniqueWithoutDeliveryInput = {
    where: NotificationQueueWhereUniqueInput;
    data: XOR<
      NotificationQueueUpdateWithoutDeliveryInput,
      NotificationQueueUncheckedUpdateWithoutDeliveryInput
    >;
  };

  export type NotificationQueueUpdateManyWithWhereWithoutDeliveryInput = {
    where: NotificationQueueScalarWhereInput;
    data: XOR<
      NotificationQueueUpdateManyMutationInput,
      NotificationQueueUncheckedUpdateManyWithoutDeliveryInput
    >;
  };

  export type NotificationCreateWithoutDeliveriesInput = {
    id?: string;
    userId: string;
    channel: $Enums.NotificationChannel;
    title: string;
    message: string;
    details?: string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    status?: $Enums.NotificationStatus;
    priority?: $Enums.NotificationPriority;
    scheduledFor?: Date | string | null;
    deliveredAt?: Date | string | null;
    readAt?: Date | string | null;
    clickedAt?: Date | string | null;
    dismissedAt?: Date | string | null;
    retryCount?: number;
    maxRetries?: number;
    nextRetry?: Date | string | null;
    aiSummary?: string | null;
    groupId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    event: NotificationEventCreateNestedOneWithoutNotificationsInput;
    queue?: NotificationQueueCreateNestedManyWithoutDeliveryInput;
  };

  export type NotificationUncheckedCreateWithoutDeliveriesInput = {
    id?: string;
    eventId: string;
    userId: string;
    channel: $Enums.NotificationChannel;
    title: string;
    message: string;
    details?: string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    status?: $Enums.NotificationStatus;
    priority?: $Enums.NotificationPriority;
    scheduledFor?: Date | string | null;
    deliveredAt?: Date | string | null;
    readAt?: Date | string | null;
    clickedAt?: Date | string | null;
    dismissedAt?: Date | string | null;
    retryCount?: number;
    maxRetries?: number;
    nextRetry?: Date | string | null;
    aiSummary?: string | null;
    groupId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    queue?: NotificationQueueUncheckedCreateNestedManyWithoutDeliveryInput;
  };

  export type NotificationCreateOrConnectWithoutDeliveriesInput = {
    where: NotificationWhereUniqueInput;
    create: XOR<
      NotificationCreateWithoutDeliveriesInput,
      NotificationUncheckedCreateWithoutDeliveriesInput
    >;
  };

  export type NotificationEventCreateWithoutDeliveriesInput = {
    id?: string;
    eventId: string;
    module: string;
    eventType: string;
    priority?: $Enums.NotificationPriority;
    title: string;
    message: string;
    details?: string | null;
    recipientRoles?: NotificationEventCreaterecipientRolesInput | string[];
    recipientUsers?: NotificationEventCreaterecipientUsersInput | string[];
    tenantId?: string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    status?: $Enums.EventStatus;
    scheduledFor?: Date | string | null;
    expiresAt?: Date | string | null;
    createdAt?: Date | string;
    createdBy?: string | null;
    processedAt?: Date | string | null;
    notifications?: NotificationCreateNestedManyWithoutEventInput;
    queue?: NotificationQueueCreateNestedManyWithoutEventInput;
    auditLogs?: NotificationAuditLogCreateNestedManyWithoutEventInput;
  };

  export type NotificationEventUncheckedCreateWithoutDeliveriesInput = {
    id?: string;
    eventId: string;
    module: string;
    eventType: string;
    priority?: $Enums.NotificationPriority;
    title: string;
    message: string;
    details?: string | null;
    recipientRoles?: NotificationEventCreaterecipientRolesInput | string[];
    recipientUsers?: NotificationEventCreaterecipientUsersInput | string[];
    tenantId?: string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    status?: $Enums.EventStatus;
    scheduledFor?: Date | string | null;
    expiresAt?: Date | string | null;
    createdAt?: Date | string;
    createdBy?: string | null;
    processedAt?: Date | string | null;
    notifications?: NotificationUncheckedCreateNestedManyWithoutEventInput;
    queue?: NotificationQueueUncheckedCreateNestedManyWithoutEventInput;
    auditLogs?: NotificationAuditLogUncheckedCreateNestedManyWithoutEventInput;
  };

  export type NotificationEventCreateOrConnectWithoutDeliveriesInput = {
    where: NotificationEventWhereUniqueInput;
    create: XOR<
      NotificationEventCreateWithoutDeliveriesInput,
      NotificationEventUncheckedCreateWithoutDeliveriesInput
    >;
  };

  export type NotificationUpsertWithoutDeliveriesInput = {
    update: XOR<
      NotificationUpdateWithoutDeliveriesInput,
      NotificationUncheckedUpdateWithoutDeliveriesInput
    >;
    create: XOR<
      NotificationCreateWithoutDeliveriesInput,
      NotificationUncheckedCreateWithoutDeliveriesInput
    >;
    where?: NotificationWhereInput;
  };

  export type NotificationUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: NotificationWhereInput;
    data: XOR<
      NotificationUpdateWithoutDeliveriesInput,
      NotificationUncheckedUpdateWithoutDeliveriesInput
    >;
  };

  export type NotificationUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    details?: NullableStringFieldUpdateOperationsInput | string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    retryCount?: IntFieldUpdateOperationsInput | number;
    maxRetries?: IntFieldUpdateOperationsInput | number;
    nextRetry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null;
    groupId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    event?: NotificationEventUpdateOneRequiredWithoutNotificationsNestedInput;
    queue?: NotificationQueueUpdateManyWithoutDeliveryNestedInput;
  };

  export type NotificationUncheckedUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    details?: NullableStringFieldUpdateOperationsInput | string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    retryCount?: IntFieldUpdateOperationsInput | number;
    maxRetries?: IntFieldUpdateOperationsInput | number;
    nextRetry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null;
    groupId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    queue?: NotificationQueueUncheckedUpdateManyWithoutDeliveryNestedInput;
  };

  export type NotificationEventUpsertWithoutDeliveriesInput = {
    update: XOR<
      NotificationEventUpdateWithoutDeliveriesInput,
      NotificationEventUncheckedUpdateWithoutDeliveriesInput
    >;
    create: XOR<
      NotificationEventCreateWithoutDeliveriesInput,
      NotificationEventUncheckedCreateWithoutDeliveriesInput
    >;
    where?: NotificationEventWhereInput;
  };

  export type NotificationEventUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: NotificationEventWhereInput;
    data: XOR<
      NotificationEventUpdateWithoutDeliveriesInput,
      NotificationEventUncheckedUpdateWithoutDeliveriesInput
    >;
  };

  export type NotificationEventUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    module?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    details?: NullableStringFieldUpdateOperationsInput | string | null;
    recipientRoles?: NotificationEventUpdaterecipientRolesInput | string[];
    recipientUsers?: NotificationEventUpdaterecipientUsersInput | string[];
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    notifications?: NotificationUpdateManyWithoutEventNestedInput;
    queue?: NotificationQueueUpdateManyWithoutEventNestedInput;
    auditLogs?: NotificationAuditLogUpdateManyWithoutEventNestedInput;
  };

  export type NotificationEventUncheckedUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    module?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    details?: NullableStringFieldUpdateOperationsInput | string | null;
    recipientRoles?: NotificationEventUpdaterecipientRolesInput | string[];
    recipientUsers?: NotificationEventUpdaterecipientUsersInput | string[];
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    notifications?: NotificationUncheckedUpdateManyWithoutEventNestedInput;
    queue?: NotificationQueueUncheckedUpdateManyWithoutEventNestedInput;
    auditLogs?: NotificationAuditLogUncheckedUpdateManyWithoutEventNestedInput;
  };

  export type NotificationPreferenceCreateWithoutHelixProfileInput = {
    id?: string;
    module: string;
    eventType: string;
    channels?: NotificationPreferenceCreatechannelsInput | $Enums.NotificationChannel[];
    priority?: $Enums.NotificationPriority;
    digestEnabled?: boolean;
    digestFrequency?: $Enums.DigestFrequency | null;
    dndEnabled?: boolean;
    dndStartTime?: string | null;
    dndEndTime?: string | null;
    dndDays?: NotificationPreferenceCreatedndDaysInput | string[];
    aiSummaryEnabled?: boolean;
    aiGroupingEnabled?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type NotificationPreferenceUncheckedCreateWithoutHelixProfileInput = {
    id?: string;
    module: string;
    eventType: string;
    channels?: NotificationPreferenceCreatechannelsInput | $Enums.NotificationChannel[];
    priority?: $Enums.NotificationPriority;
    digestEnabled?: boolean;
    digestFrequency?: $Enums.DigestFrequency | null;
    dndEnabled?: boolean;
    dndStartTime?: string | null;
    dndEndTime?: string | null;
    dndDays?: NotificationPreferenceCreatedndDaysInput | string[];
    aiSummaryEnabled?: boolean;
    aiGroupingEnabled?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type NotificationPreferenceCreateOrConnectWithoutHelixProfileInput = {
    where: NotificationPreferenceWhereUniqueInput;
    create: XOR<
      NotificationPreferenceCreateWithoutHelixProfileInput,
      NotificationPreferenceUncheckedCreateWithoutHelixProfileInput
    >;
  };

  export type NotificationPreferenceCreateManyHelixProfileInputEnvelope = {
    data:
      | NotificationPreferenceCreateManyHelixProfileInput
      | NotificationPreferenceCreateManyHelixProfileInput[];
    skipDuplicates?: boolean;
  };

  export type NotificationPreferenceUpsertWithWhereUniqueWithoutHelixProfileInput = {
    where: NotificationPreferenceWhereUniqueInput;
    update: XOR<
      NotificationPreferenceUpdateWithoutHelixProfileInput,
      NotificationPreferenceUncheckedUpdateWithoutHelixProfileInput
    >;
    create: XOR<
      NotificationPreferenceCreateWithoutHelixProfileInput,
      NotificationPreferenceUncheckedCreateWithoutHelixProfileInput
    >;
  };

  export type NotificationPreferenceUpdateWithWhereUniqueWithoutHelixProfileInput = {
    where: NotificationPreferenceWhereUniqueInput;
    data: XOR<
      NotificationPreferenceUpdateWithoutHelixProfileInput,
      NotificationPreferenceUncheckedUpdateWithoutHelixProfileInput
    >;
  };

  export type NotificationPreferenceUpdateManyWithWhereWithoutHelixProfileInput = {
    where: NotificationPreferenceScalarWhereInput;
    data: XOR<
      NotificationPreferenceUpdateManyMutationInput,
      NotificationPreferenceUncheckedUpdateManyWithoutHelixProfileInput
    >;
  };

  export type NotificationPreferenceScalarWhereInput = {
    AND?: NotificationPreferenceScalarWhereInput | NotificationPreferenceScalarWhereInput[];
    OR?: NotificationPreferenceScalarWhereInput[];
    NOT?: NotificationPreferenceScalarWhereInput | NotificationPreferenceScalarWhereInput[];
    id?: StringFilter<'NotificationPreference'> | string;
    userId?: StringFilter<'NotificationPreference'> | string;
    module?: StringFilter<'NotificationPreference'> | string;
    eventType?: StringFilter<'NotificationPreference'> | string;
    channels?: EnumNotificationChannelNullableListFilter<'NotificationPreference'>;
    priority?:
      | EnumNotificationPriorityFilter<'NotificationPreference'>
      | $Enums.NotificationPriority;
    digestEnabled?: BoolFilter<'NotificationPreference'> | boolean;
    digestFrequency?:
      | EnumDigestFrequencyNullableFilter<'NotificationPreference'>
      | $Enums.DigestFrequency
      | null;
    dndEnabled?: BoolFilter<'NotificationPreference'> | boolean;
    dndStartTime?: StringNullableFilter<'NotificationPreference'> | string | null;
    dndEndTime?: StringNullableFilter<'NotificationPreference'> | string | null;
    dndDays?: StringNullableListFilter<'NotificationPreference'>;
    aiSummaryEnabled?: BoolFilter<'NotificationPreference'> | boolean;
    aiGroupingEnabled?: BoolFilter<'NotificationPreference'> | boolean;
    createdAt?: DateTimeFilter<'NotificationPreference'> | Date | string;
    updatedAt?: DateTimeFilter<'NotificationPreference'> | Date | string;
  };

  export type NotificationEventCreateWithoutQueueInput = {
    id?: string;
    eventId: string;
    module: string;
    eventType: string;
    priority?: $Enums.NotificationPriority;
    title: string;
    message: string;
    details?: string | null;
    recipientRoles?: NotificationEventCreaterecipientRolesInput | string[];
    recipientUsers?: NotificationEventCreaterecipientUsersInput | string[];
    tenantId?: string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    status?: $Enums.EventStatus;
    scheduledFor?: Date | string | null;
    expiresAt?: Date | string | null;
    createdAt?: Date | string;
    createdBy?: string | null;
    processedAt?: Date | string | null;
    notifications?: NotificationCreateNestedManyWithoutEventInput;
    deliveries?: NotificationDeliveryCreateNestedManyWithoutEventInput;
    auditLogs?: NotificationAuditLogCreateNestedManyWithoutEventInput;
  };

  export type NotificationEventUncheckedCreateWithoutQueueInput = {
    id?: string;
    eventId: string;
    module: string;
    eventType: string;
    priority?: $Enums.NotificationPriority;
    title: string;
    message: string;
    details?: string | null;
    recipientRoles?: NotificationEventCreaterecipientRolesInput | string[];
    recipientUsers?: NotificationEventCreaterecipientUsersInput | string[];
    tenantId?: string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    status?: $Enums.EventStatus;
    scheduledFor?: Date | string | null;
    expiresAt?: Date | string | null;
    createdAt?: Date | string;
    createdBy?: string | null;
    processedAt?: Date | string | null;
    notifications?: NotificationUncheckedCreateNestedManyWithoutEventInput;
    deliveries?: NotificationDeliveryUncheckedCreateNestedManyWithoutEventInput;
    auditLogs?: NotificationAuditLogUncheckedCreateNestedManyWithoutEventInput;
  };

  export type NotificationEventCreateOrConnectWithoutQueueInput = {
    where: NotificationEventWhereUniqueInput;
    create: XOR<
      NotificationEventCreateWithoutQueueInput,
      NotificationEventUncheckedCreateWithoutQueueInput
    >;
  };

  export type NotificationCreateWithoutQueueInput = {
    id?: string;
    userId: string;
    channel: $Enums.NotificationChannel;
    title: string;
    message: string;
    details?: string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    status?: $Enums.NotificationStatus;
    priority?: $Enums.NotificationPriority;
    scheduledFor?: Date | string | null;
    deliveredAt?: Date | string | null;
    readAt?: Date | string | null;
    clickedAt?: Date | string | null;
    dismissedAt?: Date | string | null;
    retryCount?: number;
    maxRetries?: number;
    nextRetry?: Date | string | null;
    aiSummary?: string | null;
    groupId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    event: NotificationEventCreateNestedOneWithoutNotificationsInput;
    deliveries?: NotificationDeliveryCreateNestedManyWithoutNotificationInput;
  };

  export type NotificationUncheckedCreateWithoutQueueInput = {
    id?: string;
    eventId: string;
    userId: string;
    channel: $Enums.NotificationChannel;
    title: string;
    message: string;
    details?: string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    status?: $Enums.NotificationStatus;
    priority?: $Enums.NotificationPriority;
    scheduledFor?: Date | string | null;
    deliveredAt?: Date | string | null;
    readAt?: Date | string | null;
    clickedAt?: Date | string | null;
    dismissedAt?: Date | string | null;
    retryCount?: number;
    maxRetries?: number;
    nextRetry?: Date | string | null;
    aiSummary?: string | null;
    groupId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deliveries?: NotificationDeliveryUncheckedCreateNestedManyWithoutNotificationInput;
  };

  export type NotificationCreateOrConnectWithoutQueueInput = {
    where: NotificationWhereUniqueInput;
    create: XOR<NotificationCreateWithoutQueueInput, NotificationUncheckedCreateWithoutQueueInput>;
  };

  export type NotificationEventUpsertWithoutQueueInput = {
    update: XOR<
      NotificationEventUpdateWithoutQueueInput,
      NotificationEventUncheckedUpdateWithoutQueueInput
    >;
    create: XOR<
      NotificationEventCreateWithoutQueueInput,
      NotificationEventUncheckedCreateWithoutQueueInput
    >;
    where?: NotificationEventWhereInput;
  };

  export type NotificationEventUpdateToOneWithWhereWithoutQueueInput = {
    where?: NotificationEventWhereInput;
    data: XOR<
      NotificationEventUpdateWithoutQueueInput,
      NotificationEventUncheckedUpdateWithoutQueueInput
    >;
  };

  export type NotificationEventUpdateWithoutQueueInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    module?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    details?: NullableStringFieldUpdateOperationsInput | string | null;
    recipientRoles?: NotificationEventUpdaterecipientRolesInput | string[];
    recipientUsers?: NotificationEventUpdaterecipientUsersInput | string[];
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    notifications?: NotificationUpdateManyWithoutEventNestedInput;
    deliveries?: NotificationDeliveryUpdateManyWithoutEventNestedInput;
    auditLogs?: NotificationAuditLogUpdateManyWithoutEventNestedInput;
  };

  export type NotificationEventUncheckedUpdateWithoutQueueInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    module?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    details?: NullableStringFieldUpdateOperationsInput | string | null;
    recipientRoles?: NotificationEventUpdaterecipientRolesInput | string[];
    recipientUsers?: NotificationEventUpdaterecipientUsersInput | string[];
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    notifications?: NotificationUncheckedUpdateManyWithoutEventNestedInput;
    deliveries?: NotificationDeliveryUncheckedUpdateManyWithoutEventNestedInput;
    auditLogs?: NotificationAuditLogUncheckedUpdateManyWithoutEventNestedInput;
  };

  export type NotificationUpsertWithoutQueueInput = {
    update: XOR<NotificationUpdateWithoutQueueInput, NotificationUncheckedUpdateWithoutQueueInput>;
    create: XOR<NotificationCreateWithoutQueueInput, NotificationUncheckedCreateWithoutQueueInput>;
    where?: NotificationWhereInput;
  };

  export type NotificationUpdateToOneWithWhereWithoutQueueInput = {
    where?: NotificationWhereInput;
    data: XOR<NotificationUpdateWithoutQueueInput, NotificationUncheckedUpdateWithoutQueueInput>;
  };

  export type NotificationUpdateWithoutQueueInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    details?: NullableStringFieldUpdateOperationsInput | string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    retryCount?: IntFieldUpdateOperationsInput | number;
    maxRetries?: IntFieldUpdateOperationsInput | number;
    nextRetry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null;
    groupId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    event?: NotificationEventUpdateOneRequiredWithoutNotificationsNestedInput;
    deliveries?: NotificationDeliveryUpdateManyWithoutNotificationNestedInput;
  };

  export type NotificationUncheckedUpdateWithoutQueueInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    details?: NullableStringFieldUpdateOperationsInput | string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    retryCount?: IntFieldUpdateOperationsInput | number;
    maxRetries?: IntFieldUpdateOperationsInput | number;
    nextRetry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null;
    groupId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deliveries?: NotificationDeliveryUncheckedUpdateManyWithoutNotificationNestedInput;
  };

  export type NotificationEventCreateWithoutAuditLogsInput = {
    id?: string;
    eventId: string;
    module: string;
    eventType: string;
    priority?: $Enums.NotificationPriority;
    title: string;
    message: string;
    details?: string | null;
    recipientRoles?: NotificationEventCreaterecipientRolesInput | string[];
    recipientUsers?: NotificationEventCreaterecipientUsersInput | string[];
    tenantId?: string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    status?: $Enums.EventStatus;
    scheduledFor?: Date | string | null;
    expiresAt?: Date | string | null;
    createdAt?: Date | string;
    createdBy?: string | null;
    processedAt?: Date | string | null;
    notifications?: NotificationCreateNestedManyWithoutEventInput;
    deliveries?: NotificationDeliveryCreateNestedManyWithoutEventInput;
    queue?: NotificationQueueCreateNestedManyWithoutEventInput;
  };

  export type NotificationEventUncheckedCreateWithoutAuditLogsInput = {
    id?: string;
    eventId: string;
    module: string;
    eventType: string;
    priority?: $Enums.NotificationPriority;
    title: string;
    message: string;
    details?: string | null;
    recipientRoles?: NotificationEventCreaterecipientRolesInput | string[];
    recipientUsers?: NotificationEventCreaterecipientUsersInput | string[];
    tenantId?: string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    status?: $Enums.EventStatus;
    scheduledFor?: Date | string | null;
    expiresAt?: Date | string | null;
    createdAt?: Date | string;
    createdBy?: string | null;
    processedAt?: Date | string | null;
    notifications?: NotificationUncheckedCreateNestedManyWithoutEventInput;
    deliveries?: NotificationDeliveryUncheckedCreateNestedManyWithoutEventInput;
    queue?: NotificationQueueUncheckedCreateNestedManyWithoutEventInput;
  };

  export type NotificationEventCreateOrConnectWithoutAuditLogsInput = {
    where: NotificationEventWhereUniqueInput;
    create: XOR<
      NotificationEventCreateWithoutAuditLogsInput,
      NotificationEventUncheckedCreateWithoutAuditLogsInput
    >;
  };

  export type NotificationEventUpsertWithoutAuditLogsInput = {
    update: XOR<
      NotificationEventUpdateWithoutAuditLogsInput,
      NotificationEventUncheckedUpdateWithoutAuditLogsInput
    >;
    create: XOR<
      NotificationEventCreateWithoutAuditLogsInput,
      NotificationEventUncheckedCreateWithoutAuditLogsInput
    >;
    where?: NotificationEventWhereInput;
  };

  export type NotificationEventUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: NotificationEventWhereInput;
    data: XOR<
      NotificationEventUpdateWithoutAuditLogsInput,
      NotificationEventUncheckedUpdateWithoutAuditLogsInput
    >;
  };

  export type NotificationEventUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    module?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    details?: NullableStringFieldUpdateOperationsInput | string | null;
    recipientRoles?: NotificationEventUpdaterecipientRolesInput | string[];
    recipientUsers?: NotificationEventUpdaterecipientUsersInput | string[];
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    notifications?: NotificationUpdateManyWithoutEventNestedInput;
    deliveries?: NotificationDeliveryUpdateManyWithoutEventNestedInput;
    queue?: NotificationQueueUpdateManyWithoutEventNestedInput;
  };

  export type NotificationEventUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    module?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    details?: NullableStringFieldUpdateOperationsInput | string | null;
    recipientRoles?: NotificationEventUpdaterecipientRolesInput | string[];
    recipientUsers?: NotificationEventUpdaterecipientUsersInput | string[];
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null;
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    notifications?: NotificationUncheckedUpdateManyWithoutEventNestedInput;
    deliveries?: NotificationDeliveryUncheckedUpdateManyWithoutEventNestedInput;
    queue?: NotificationQueueUncheckedUpdateManyWithoutEventNestedInput;
  };

  export type NotificationCreateManyEventInput = {
    id?: string;
    userId: string;
    channel: $Enums.NotificationChannel;
    title: string;
    message: string;
    details?: string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    status?: $Enums.NotificationStatus;
    priority?: $Enums.NotificationPriority;
    scheduledFor?: Date | string | null;
    deliveredAt?: Date | string | null;
    readAt?: Date | string | null;
    clickedAt?: Date | string | null;
    dismissedAt?: Date | string | null;
    retryCount?: number;
    maxRetries?: number;
    nextRetry?: Date | string | null;
    aiSummary?: string | null;
    groupId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type NotificationDeliveryCreateManyEventInput = {
    id?: string;
    notificationId: string;
    userId: string;
    channel: $Enums.NotificationChannel;
    provider?: string | null;
    providerConfig?: NullableJsonNullValueInput | InputJsonValue;
    status?: $Enums.DeliveryStatus;
    deliveredAt?: Date | string | null;
    failedAt?: Date | string | null;
    errorMessage?: string | null;
    errorCode?: string | null;
    providerResponse?: NullableJsonNullValueInput | InputJsonValue;
    messageId?: string | null;
    responseTime?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type NotificationQueueCreateManyEventInput = {
    id?: string;
    deliveryId: string;
    priority?: $Enums.NotificationPriority;
    scheduledFor?: Date | string;
    attempts?: number;
    maxAttempts?: number;
    lastAttemptAt?: Date | string | null;
    nextAttemptAt?: Date | string | null;
    status?: string;
    error?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type NotificationAuditLogCreateManyEventInput = {
    id?: string;
    action: string;
    userId?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    timestamp?: Date | string;
  };

  export type NotificationUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    details?: NullableStringFieldUpdateOperationsInput | string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    retryCount?: IntFieldUpdateOperationsInput | number;
    maxRetries?: IntFieldUpdateOperationsInput | number;
    nextRetry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null;
    groupId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deliveries?: NotificationDeliveryUpdateManyWithoutNotificationNestedInput;
    queue?: NotificationQueueUpdateManyWithoutDeliveryNestedInput;
  };

  export type NotificationUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    details?: NullableStringFieldUpdateOperationsInput | string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    retryCount?: IntFieldUpdateOperationsInput | number;
    maxRetries?: IntFieldUpdateOperationsInput | number;
    nextRetry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null;
    groupId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deliveries?: NotificationDeliveryUncheckedUpdateManyWithoutNotificationNestedInput;
    queue?: NotificationQueueUncheckedUpdateManyWithoutDeliveryNestedInput;
  };

  export type NotificationUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    details?: NullableStringFieldUpdateOperationsInput | string | null;
    actions?: NullableJsonNullValueInput | InputJsonValue;
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    retryCount?: IntFieldUpdateOperationsInput | number;
    maxRetries?: IntFieldUpdateOperationsInput | number;
    nextRetry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null;
    groupId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationDeliveryUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel;
    provider?: NullableStringFieldUpdateOperationsInput | string | null;
    providerConfig?: NullableJsonNullValueInput | InputJsonValue;
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus;
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null;
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null;
    providerResponse?: NullableJsonNullValueInput | InputJsonValue;
    messageId?: NullableStringFieldUpdateOperationsInput | string | null;
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    notification?: NotificationUpdateOneRequiredWithoutDeliveriesNestedInput;
  };

  export type NotificationDeliveryUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    notificationId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel;
    provider?: NullableStringFieldUpdateOperationsInput | string | null;
    providerConfig?: NullableJsonNullValueInput | InputJsonValue;
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus;
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null;
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null;
    providerResponse?: NullableJsonNullValueInput | InputJsonValue;
    messageId?: NullableStringFieldUpdateOperationsInput | string | null;
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationDeliveryUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    notificationId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel;
    provider?: NullableStringFieldUpdateOperationsInput | string | null;
    providerConfig?: NullableJsonNullValueInput | InputJsonValue;
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus;
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null;
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null;
    providerResponse?: NullableJsonNullValueInput | InputJsonValue;
    messageId?: NullableStringFieldUpdateOperationsInput | string | null;
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationQueueUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string;
    attempts?: IntFieldUpdateOperationsInput | number;
    maxAttempts?: IntFieldUpdateOperationsInput | number;
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nextAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    status?: StringFieldUpdateOperationsInput | string;
    error?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    delivery?: NotificationUpdateOneRequiredWithoutQueueNestedInput;
  };

  export type NotificationQueueUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    deliveryId?: StringFieldUpdateOperationsInput | string;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string;
    attempts?: IntFieldUpdateOperationsInput | number;
    maxAttempts?: IntFieldUpdateOperationsInput | number;
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nextAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    status?: StringFieldUpdateOperationsInput | string;
    error?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationQueueUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    deliveryId?: StringFieldUpdateOperationsInput | string;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string;
    attempts?: IntFieldUpdateOperationsInput | number;
    maxAttempts?: IntFieldUpdateOperationsInput | number;
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nextAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    status?: StringFieldUpdateOperationsInput | string;
    error?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationAuditLogUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationAuditLogUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationAuditLogUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationDeliveryCreateManyNotificationInput = {
    id?: string;
    eventId: string;
    userId: string;
    channel: $Enums.NotificationChannel;
    provider?: string | null;
    providerConfig?: NullableJsonNullValueInput | InputJsonValue;
    status?: $Enums.DeliveryStatus;
    deliveredAt?: Date | string | null;
    failedAt?: Date | string | null;
    errorMessage?: string | null;
    errorCode?: string | null;
    providerResponse?: NullableJsonNullValueInput | InputJsonValue;
    messageId?: string | null;
    responseTime?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type NotificationQueueCreateManyDeliveryInput = {
    id?: string;
    eventId: string;
    priority?: $Enums.NotificationPriority;
    scheduledFor?: Date | string;
    attempts?: number;
    maxAttempts?: number;
    lastAttemptAt?: Date | string | null;
    nextAttemptAt?: Date | string | null;
    status?: string;
    error?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type NotificationDeliveryUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel;
    provider?: NullableStringFieldUpdateOperationsInput | string | null;
    providerConfig?: NullableJsonNullValueInput | InputJsonValue;
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus;
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null;
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null;
    providerResponse?: NullableJsonNullValueInput | InputJsonValue;
    messageId?: NullableStringFieldUpdateOperationsInput | string | null;
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    event?: NotificationEventUpdateOneRequiredWithoutDeliveriesNestedInput;
  };

  export type NotificationDeliveryUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel;
    provider?: NullableStringFieldUpdateOperationsInput | string | null;
    providerConfig?: NullableJsonNullValueInput | InputJsonValue;
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus;
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null;
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null;
    providerResponse?: NullableJsonNullValueInput | InputJsonValue;
    messageId?: NullableStringFieldUpdateOperationsInput | string | null;
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationDeliveryUncheckedUpdateManyWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel;
    provider?: NullableStringFieldUpdateOperationsInput | string | null;
    providerConfig?: NullableJsonNullValueInput | InputJsonValue;
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus;
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null;
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null;
    providerResponse?: NullableJsonNullValueInput | InputJsonValue;
    messageId?: NullableStringFieldUpdateOperationsInput | string | null;
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationQueueUpdateWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string;
    attempts?: IntFieldUpdateOperationsInput | number;
    maxAttempts?: IntFieldUpdateOperationsInput | number;
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nextAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    status?: StringFieldUpdateOperationsInput | string;
    error?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    event?: NotificationEventUpdateOneRequiredWithoutQueueNestedInput;
  };

  export type NotificationQueueUncheckedUpdateWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string;
    attempts?: IntFieldUpdateOperationsInput | number;
    maxAttempts?: IntFieldUpdateOperationsInput | number;
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nextAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    status?: StringFieldUpdateOperationsInput | string;
    error?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationQueueUncheckedUpdateManyWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string;
    attempts?: IntFieldUpdateOperationsInput | number;
    maxAttempts?: IntFieldUpdateOperationsInput | number;
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nextAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    status?: StringFieldUpdateOperationsInput | string;
    error?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationPreferenceCreateManyHelixProfileInput = {
    id?: string;
    module: string;
    eventType: string;
    channels?: NotificationPreferenceCreatechannelsInput | $Enums.NotificationChannel[];
    priority?: $Enums.NotificationPriority;
    digestEnabled?: boolean;
    digestFrequency?: $Enums.DigestFrequency | null;
    dndEnabled?: boolean;
    dndStartTime?: string | null;
    dndEndTime?: string | null;
    dndDays?: NotificationPreferenceCreatedndDaysInput | string[];
    aiSummaryEnabled?: boolean;
    aiGroupingEnabled?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type NotificationPreferenceUpdateWithoutHelixProfileInput = {
    id?: StringFieldUpdateOperationsInput | string;
    module?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    channels?: NotificationPreferenceUpdatechannelsInput | $Enums.NotificationChannel[];
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    digestEnabled?: BoolFieldUpdateOperationsInput | boolean;
    digestFrequency?:
      | NullableEnumDigestFrequencyFieldUpdateOperationsInput
      | $Enums.DigestFrequency
      | null;
    dndEnabled?: BoolFieldUpdateOperationsInput | boolean;
    dndStartTime?: NullableStringFieldUpdateOperationsInput | string | null;
    dndEndTime?: NullableStringFieldUpdateOperationsInput | string | null;
    dndDays?: NotificationPreferenceUpdatedndDaysInput | string[];
    aiSummaryEnabled?: BoolFieldUpdateOperationsInput | boolean;
    aiGroupingEnabled?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationPreferenceUncheckedUpdateWithoutHelixProfileInput = {
    id?: StringFieldUpdateOperationsInput | string;
    module?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    channels?: NotificationPreferenceUpdatechannelsInput | $Enums.NotificationChannel[];
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    digestEnabled?: BoolFieldUpdateOperationsInput | boolean;
    digestFrequency?:
      | NullableEnumDigestFrequencyFieldUpdateOperationsInput
      | $Enums.DigestFrequency
      | null;
    dndEnabled?: BoolFieldUpdateOperationsInput | boolean;
    dndStartTime?: NullableStringFieldUpdateOperationsInput | string | null;
    dndEndTime?: NullableStringFieldUpdateOperationsInput | string | null;
    dndDays?: NotificationPreferenceUpdatedndDaysInput | string[];
    aiSummaryEnabled?: BoolFieldUpdateOperationsInput | boolean;
    aiGroupingEnabled?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationPreferenceUncheckedUpdateManyWithoutHelixProfileInput = {
    id?: StringFieldUpdateOperationsInput | string;
    module?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    channels?: NotificationPreferenceUpdatechannelsInput | $Enums.NotificationChannel[];
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority;
    digestEnabled?: BoolFieldUpdateOperationsInput | boolean;
    digestFrequency?:
      | NullableEnumDigestFrequencyFieldUpdateOperationsInput
      | $Enums.DigestFrequency
      | null;
    dndEnabled?: BoolFieldUpdateOperationsInput | boolean;
    dndStartTime?: NullableStringFieldUpdateOperationsInput | string | null;
    dndEndTime?: NullableStringFieldUpdateOperationsInput | string | null;
    dndDays?: NotificationPreferenceUpdatedndDaysInput | string[];
    aiSummaryEnabled?: BoolFieldUpdateOperationsInput | boolean;
    aiGroupingEnabled?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF;
}
