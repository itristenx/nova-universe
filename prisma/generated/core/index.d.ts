
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model UserRole
 * 
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>
/**
 * Model RolePermission
 * 
 */
export type RolePermission = $Result.DefaultSelection<Prisma.$RolePermissionPayload>
/**
 * Model Passkey
 * 
 */
export type Passkey = $Result.DefaultSelection<Prisma.$PasskeyPayload>
/**
 * Model Log
 * 
 */
export type Log = $Result.DefaultSelection<Prisma.$LogPayload>
/**
 * Model Config
 * 
 */
export type Config = $Result.DefaultSelection<Prisma.$ConfigPayload>
/**
 * Model ConfigHistory
 * 
 */
export type ConfigHistory = $Result.DefaultSelection<Prisma.$ConfigHistoryPayload>
/**
 * Model ConfigTemplate
 * 
 */
export type ConfigTemplate = $Result.DefaultSelection<Prisma.$ConfigTemplatePayload>
/**
 * Model Kiosk
 * 
 */
export type Kiosk = $Result.DefaultSelection<Prisma.$KioskPayload>
/**
 * Model Feedback
 * 
 */
export type Feedback = $Result.DefaultSelection<Prisma.$FeedbackPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model DirectoryIntegration
 * 
 */
export type DirectoryIntegration = $Result.DefaultSelection<Prisma.$DirectoryIntegrationPayload>
/**
 * Model Asset
 * 
 */
export type Asset = $Result.DefaultSelection<Prisma.$AssetPayload>
/**
 * Model KioskActivation
 * 
 */
export type KioskActivation = $Result.DefaultSelection<Prisma.$KioskActivationPayload>
/**
 * Model SsoConfiguration
 * 
 */
export type SsoConfiguration = $Result.DefaultSelection<Prisma.$SsoConfigurationPayload>
/**
 * Model AdminPin
 * 
 */
export type AdminPin = $Result.DefaultSelection<Prisma.$AdminPinPayload>
/**
 * Model KbArticle
 * 
 */
export type KbArticle = $Result.DefaultSelection<Prisma.$KbArticlePayload>
/**
 * Model KbArticleVersion
 * 
 */
export type KbArticleVersion = $Result.DefaultSelection<Prisma.$KbArticleVersionPayload>
/**
 * Model KbArticleComment
 * 
 */
export type KbArticleComment = $Result.DefaultSelection<Prisma.$KbArticleCommentPayload>
/**
 * Model SupportTicket
 * 
 */
export type SupportTicket = $Result.DefaultSelection<Prisma.$SupportTicketPayload>
/**
 * Model InventoryAsset
 * 
 */
export type InventoryAsset = $Result.DefaultSelection<Prisma.$InventoryAssetPayload>
/**
 * Model AssetStatusLog
 * 
 */
export type AssetStatusLog = $Result.DefaultSelection<Prisma.$AssetStatusLogPayload>
/**
 * Model AssetAssignment
 * 
 */
export type AssetAssignment = $Result.DefaultSelection<Prisma.$AssetAssignmentPayload>
/**
 * Model AssetTicketHistory
 * 
 */
export type AssetTicketHistory = $Result.DefaultSelection<Prisma.$AssetTicketHistoryPayload>
/**
 * Model AssetWarrantyAlert
 * 
 */
export type AssetWarrantyAlert = $Result.DefaultSelection<Prisma.$AssetWarrantyAlertPayload>
/**
 * Model AssetImportBatch
 * 
 */
export type AssetImportBatch = $Result.DefaultSelection<Prisma.$AssetImportBatchPayload>
/**
 * Model AssetValidationLog
 * 
 */
export type AssetValidationLog = $Result.DefaultSelection<Prisma.$AssetValidationLogPayload>
/**
 * Model KioskAssetRegistry
 * 
 */
export type KioskAssetRegistry = $Result.DefaultSelection<Prisma.$KioskAssetRegistryPayload>
/**
 * Model HelixSyncFailure
 * 
 */
export type HelixSyncFailure = $Result.DefaultSelection<Prisma.$HelixSyncFailurePayload>
/**
 * Model KioskOrganizationAssignment
 * 
 */
export type KioskOrganizationAssignment = $Result.DefaultSelection<Prisma.$KioskOrganizationAssignmentPayload>
/**
 * Model KioskMetadataLog
 * 
 */
export type KioskMetadataLog = $Result.DefaultSelection<Prisma.$KioskMetadataLogPayload>
/**
 * Model XpEvent
 * 
 */
export type XpEvent = $Result.DefaultSelection<Prisma.$XpEventPayload>
/**
 * Model Leaderboard
 * 
 */
export type Leaderboard = $Result.DefaultSelection<Prisma.$LeaderboardPayload>
/**
 * Model ScimMapping
 * 
 */
export type ScimMapping = $Result.DefaultSelection<Prisma.$ScimMappingPayload>
/**
 * Model ScimLog
 * 
 */
export type ScimLog = $Result.DefaultSelection<Prisma.$ScimLogPayload>
/**
 * Model MailroomPackage
 * 
 */
export type MailroomPackage = $Result.DefaultSelection<Prisma.$MailroomPackagePayload>
/**
 * Model DeliveryEvent
 * 
 */
export type DeliveryEvent = $Result.DefaultSelection<Prisma.$DeliveryEventPayload>
/**
 * Model ProxyAuthorization
 * 
 */
export type ProxyAuthorization = $Result.DefaultSelection<Prisma.$ProxyAuthorizationPayload>
/**
 * Model RequestCatalogItem
 * 
 */
export type RequestCatalogItem = $Result.DefaultSelection<Prisma.$RequestCatalogItemPayload>
/**
 * Model RITM
 * 
 */
export type RITM = $Result.DefaultSelection<Prisma.$RITMPayload>
/**
 * Model VipProxy
 * 
 */
export type VipProxy = $Result.DefaultSelection<Prisma.$VipProxyPayload>
/**
 * Model VipSlaHistory
 * 
 */
export type VipSlaHistory = $Result.DefaultSelection<Prisma.$VipSlaHistoryPayload>
/**
 * Model AgentAvailability
 * 
 */
export type AgentAvailability = $Result.DefaultSelection<Prisma.$AgentAvailabilityPayload>
/**
 * Model QueueMetrics
 * 
 */
export type QueueMetrics = $Result.DefaultSelection<Prisma.$QueueMetricsPayload>
/**
 * Model QueueAlert
 * 
 */
export type QueueAlert = $Result.DefaultSelection<Prisma.$QueueAlertPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rolePermission`: Exposes CRUD operations for the **RolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermission.findMany()
    * ```
    */
  get rolePermission(): Prisma.RolePermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passkey`: Exposes CRUD operations for the **Passkey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Passkeys
    * const passkeys = await prisma.passkey.findMany()
    * ```
    */
  get passkey(): Prisma.PasskeyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.log`: Exposes CRUD operations for the **Log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs
    * const logs = await prisma.log.findMany()
    * ```
    */
  get log(): Prisma.LogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.config`: Exposes CRUD operations for the **Config** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Configs
    * const configs = await prisma.config.findMany()
    * ```
    */
  get config(): Prisma.ConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.configHistory`: Exposes CRUD operations for the **ConfigHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConfigHistories
    * const configHistories = await prisma.configHistory.findMany()
    * ```
    */
  get configHistory(): Prisma.ConfigHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.configTemplate`: Exposes CRUD operations for the **ConfigTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConfigTemplates
    * const configTemplates = await prisma.configTemplate.findMany()
    * ```
    */
  get configTemplate(): Prisma.ConfigTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kiosk`: Exposes CRUD operations for the **Kiosk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kiosks
    * const kiosks = await prisma.kiosk.findMany()
    * ```
    */
  get kiosk(): Prisma.KioskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feedback`: Exposes CRUD operations for the **Feedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feedbacks
    * const feedbacks = await prisma.feedback.findMany()
    * ```
    */
  get feedback(): Prisma.FeedbackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.directoryIntegration`: Exposes CRUD operations for the **DirectoryIntegration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DirectoryIntegrations
    * const directoryIntegrations = await prisma.directoryIntegration.findMany()
    * ```
    */
  get directoryIntegration(): Prisma.DirectoryIntegrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.asset`: Exposes CRUD operations for the **Asset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assets
    * const assets = await prisma.asset.findMany()
    * ```
    */
  get asset(): Prisma.AssetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kioskActivation`: Exposes CRUD operations for the **KioskActivation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KioskActivations
    * const kioskActivations = await prisma.kioskActivation.findMany()
    * ```
    */
  get kioskActivation(): Prisma.KioskActivationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ssoConfiguration`: Exposes CRUD operations for the **SsoConfiguration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SsoConfigurations
    * const ssoConfigurations = await prisma.ssoConfiguration.findMany()
    * ```
    */
  get ssoConfiguration(): Prisma.SsoConfigurationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminPin`: Exposes CRUD operations for the **AdminPin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminPins
    * const adminPins = await prisma.adminPin.findMany()
    * ```
    */
  get adminPin(): Prisma.AdminPinDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kbArticle`: Exposes CRUD operations for the **KbArticle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KbArticles
    * const kbArticles = await prisma.kbArticle.findMany()
    * ```
    */
  get kbArticle(): Prisma.KbArticleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kbArticleVersion`: Exposes CRUD operations for the **KbArticleVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KbArticleVersions
    * const kbArticleVersions = await prisma.kbArticleVersion.findMany()
    * ```
    */
  get kbArticleVersion(): Prisma.KbArticleVersionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kbArticleComment`: Exposes CRUD operations for the **KbArticleComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KbArticleComments
    * const kbArticleComments = await prisma.kbArticleComment.findMany()
    * ```
    */
  get kbArticleComment(): Prisma.KbArticleCommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supportTicket`: Exposes CRUD operations for the **SupportTicket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupportTickets
    * const supportTickets = await prisma.supportTicket.findMany()
    * ```
    */
  get supportTicket(): Prisma.SupportTicketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryAsset`: Exposes CRUD operations for the **InventoryAsset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryAssets
    * const inventoryAssets = await prisma.inventoryAsset.findMany()
    * ```
    */
  get inventoryAsset(): Prisma.InventoryAssetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assetStatusLog`: Exposes CRUD operations for the **AssetStatusLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssetStatusLogs
    * const assetStatusLogs = await prisma.assetStatusLog.findMany()
    * ```
    */
  get assetStatusLog(): Prisma.AssetStatusLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assetAssignment`: Exposes CRUD operations for the **AssetAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssetAssignments
    * const assetAssignments = await prisma.assetAssignment.findMany()
    * ```
    */
  get assetAssignment(): Prisma.AssetAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assetTicketHistory`: Exposes CRUD operations for the **AssetTicketHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssetTicketHistories
    * const assetTicketHistories = await prisma.assetTicketHistory.findMany()
    * ```
    */
  get assetTicketHistory(): Prisma.AssetTicketHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assetWarrantyAlert`: Exposes CRUD operations for the **AssetWarrantyAlert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssetWarrantyAlerts
    * const assetWarrantyAlerts = await prisma.assetWarrantyAlert.findMany()
    * ```
    */
  get assetWarrantyAlert(): Prisma.AssetWarrantyAlertDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assetImportBatch`: Exposes CRUD operations for the **AssetImportBatch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssetImportBatches
    * const assetImportBatches = await prisma.assetImportBatch.findMany()
    * ```
    */
  get assetImportBatch(): Prisma.AssetImportBatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assetValidationLog`: Exposes CRUD operations for the **AssetValidationLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssetValidationLogs
    * const assetValidationLogs = await prisma.assetValidationLog.findMany()
    * ```
    */
  get assetValidationLog(): Prisma.AssetValidationLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kioskAssetRegistry`: Exposes CRUD operations for the **KioskAssetRegistry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KioskAssetRegistries
    * const kioskAssetRegistries = await prisma.kioskAssetRegistry.findMany()
    * ```
    */
  get kioskAssetRegistry(): Prisma.KioskAssetRegistryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.helixSyncFailure`: Exposes CRUD operations for the **HelixSyncFailure** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HelixSyncFailures
    * const helixSyncFailures = await prisma.helixSyncFailure.findMany()
    * ```
    */
  get helixSyncFailure(): Prisma.HelixSyncFailureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kioskOrganizationAssignment`: Exposes CRUD operations for the **KioskOrganizationAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KioskOrganizationAssignments
    * const kioskOrganizationAssignments = await prisma.kioskOrganizationAssignment.findMany()
    * ```
    */
  get kioskOrganizationAssignment(): Prisma.KioskOrganizationAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kioskMetadataLog`: Exposes CRUD operations for the **KioskMetadataLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KioskMetadataLogs
    * const kioskMetadataLogs = await prisma.kioskMetadataLog.findMany()
    * ```
    */
  get kioskMetadataLog(): Prisma.KioskMetadataLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.xpEvent`: Exposes CRUD operations for the **XpEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more XpEvents
    * const xpEvents = await prisma.xpEvent.findMany()
    * ```
    */
  get xpEvent(): Prisma.XpEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leaderboard`: Exposes CRUD operations for the **Leaderboard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leaderboards
    * const leaderboards = await prisma.leaderboard.findMany()
    * ```
    */
  get leaderboard(): Prisma.LeaderboardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scimMapping`: Exposes CRUD operations for the **ScimMapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScimMappings
    * const scimMappings = await prisma.scimMapping.findMany()
    * ```
    */
  get scimMapping(): Prisma.ScimMappingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scimLog`: Exposes CRUD operations for the **ScimLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScimLogs
    * const scimLogs = await prisma.scimLog.findMany()
    * ```
    */
  get scimLog(): Prisma.ScimLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mailroomPackage`: Exposes CRUD operations for the **MailroomPackage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MailroomPackages
    * const mailroomPackages = await prisma.mailroomPackage.findMany()
    * ```
    */
  get mailroomPackage(): Prisma.MailroomPackageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deliveryEvent`: Exposes CRUD operations for the **DeliveryEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryEvents
    * const deliveryEvents = await prisma.deliveryEvent.findMany()
    * ```
    */
  get deliveryEvent(): Prisma.DeliveryEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.proxyAuthorization`: Exposes CRUD operations for the **ProxyAuthorization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProxyAuthorizations
    * const proxyAuthorizations = await prisma.proxyAuthorization.findMany()
    * ```
    */
  get proxyAuthorization(): Prisma.ProxyAuthorizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.requestCatalogItem`: Exposes CRUD operations for the **RequestCatalogItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestCatalogItems
    * const requestCatalogItems = await prisma.requestCatalogItem.findMany()
    * ```
    */
  get requestCatalogItem(): Prisma.RequestCatalogItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rITM`: Exposes CRUD operations for the **RITM** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RITMS
    * const rITMS = await prisma.rITM.findMany()
    * ```
    */
  get rITM(): Prisma.RITMDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vipProxy`: Exposes CRUD operations for the **VipProxy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VipProxies
    * const vipProxies = await prisma.vipProxy.findMany()
    * ```
    */
  get vipProxy(): Prisma.VipProxyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vipSlaHistory`: Exposes CRUD operations for the **VipSlaHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VipSlaHistories
    * const vipSlaHistories = await prisma.vipSlaHistory.findMany()
    * ```
    */
  get vipSlaHistory(): Prisma.VipSlaHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agentAvailability`: Exposes CRUD operations for the **AgentAvailability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgentAvailabilities
    * const agentAvailabilities = await prisma.agentAvailability.findMany()
    * ```
    */
  get agentAvailability(): Prisma.AgentAvailabilityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.queueMetrics`: Exposes CRUD operations for the **QueueMetrics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QueueMetrics
    * const queueMetrics = await prisma.queueMetrics.findMany()
    * ```
    */
  get queueMetrics(): Prisma.QueueMetricsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.queueAlert`: Exposes CRUD operations for the **QueueAlert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QueueAlerts
    * const queueAlerts = await prisma.queueAlert.findMany()
    * ```
    */
  get queueAlert(): Prisma.QueueAlertDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.14.0
   * Query Engine version: 717184b7b35ea05dfa71a3236b7af656013e1e49
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Role: 'Role',
    Permission: 'Permission',
    UserRole: 'UserRole',
    RolePermission: 'RolePermission',
    Passkey: 'Passkey',
    Log: 'Log',
    Config: 'Config',
    ConfigHistory: 'ConfigHistory',
    ConfigTemplate: 'ConfigTemplate',
    Kiosk: 'Kiosk',
    Feedback: 'Feedback',
    Notification: 'Notification',
    DirectoryIntegration: 'DirectoryIntegration',
    Asset: 'Asset',
    KioskActivation: 'KioskActivation',
    SsoConfiguration: 'SsoConfiguration',
    AdminPin: 'AdminPin',
    KbArticle: 'KbArticle',
    KbArticleVersion: 'KbArticleVersion',
    KbArticleComment: 'KbArticleComment',
    SupportTicket: 'SupportTicket',
    InventoryAsset: 'InventoryAsset',
    AssetStatusLog: 'AssetStatusLog',
    AssetAssignment: 'AssetAssignment',
    AssetTicketHistory: 'AssetTicketHistory',
    AssetWarrantyAlert: 'AssetWarrantyAlert',
    AssetImportBatch: 'AssetImportBatch',
    AssetValidationLog: 'AssetValidationLog',
    KioskAssetRegistry: 'KioskAssetRegistry',
    HelixSyncFailure: 'HelixSyncFailure',
    KioskOrganizationAssignment: 'KioskOrganizationAssignment',
    KioskMetadataLog: 'KioskMetadataLog',
    XpEvent: 'XpEvent',
    Leaderboard: 'Leaderboard',
    ScimMapping: 'ScimMapping',
    ScimLog: 'ScimLog',
    MailroomPackage: 'MailroomPackage',
    DeliveryEvent: 'DeliveryEvent',
    ProxyAuthorization: 'ProxyAuthorization',
    RequestCatalogItem: 'RequestCatalogItem',
    RITM: 'RITM',
    VipProxy: 'VipProxy',
    VipSlaHistory: 'VipSlaHistory',
    AgentAvailability: 'AgentAvailability',
    QueueMetrics: 'QueueMetrics',
    QueueAlert: 'QueueAlert'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    core_db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "role" | "permission" | "userRole" | "rolePermission" | "passkey" | "log" | "config" | "configHistory" | "configTemplate" | "kiosk" | "feedback" | "notification" | "directoryIntegration" | "asset" | "kioskActivation" | "ssoConfiguration" | "adminPin" | "kbArticle" | "kbArticleVersion" | "kbArticleComment" | "supportTicket" | "inventoryAsset" | "assetStatusLog" | "assetAssignment" | "assetTicketHistory" | "assetWarrantyAlert" | "assetImportBatch" | "assetValidationLog" | "kioskAssetRegistry" | "helixSyncFailure" | "kioskOrganizationAssignment" | "kioskMetadataLog" | "xpEvent" | "leaderboard" | "scimMapping" | "scimLog" | "mailroomPackage" | "deliveryEvent" | "proxyAuthorization" | "requestCatalogItem" | "rITM" | "vipProxy" | "vipSlaHistory" | "agentAvailability" | "queueMetrics" | "queueAlert"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
      RolePermission: {
        payload: Prisma.$RolePermissionPayload<ExtArgs>
        fields: Prisma.RolePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findFirst: {
            args: Prisma.RolePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findMany: {
            args: Prisma.RolePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          create: {
            args: Prisma.RolePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          createMany: {
            args: Prisma.RolePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolePermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          delete: {
            args: Prisma.RolePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          update: {
            args: Prisma.RolePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          deleteMany: {
            args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RolePermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          upsert: {
            args: Prisma.RolePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          aggregate: {
            args: Prisma.RolePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePermission>
          }
          groupBy: {
            args: Prisma.RolePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionCountAggregateOutputType> | number
          }
        }
      }
      Passkey: {
        payload: Prisma.$PasskeyPayload<ExtArgs>
        fields: Prisma.PasskeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasskeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasskeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasskeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasskeyPayload>
          }
          findFirst: {
            args: Prisma.PasskeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasskeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasskeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasskeyPayload>
          }
          findMany: {
            args: Prisma.PasskeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasskeyPayload>[]
          }
          create: {
            args: Prisma.PasskeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasskeyPayload>
          }
          createMany: {
            args: Prisma.PasskeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasskeyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasskeyPayload>[]
          }
          delete: {
            args: Prisma.PasskeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasskeyPayload>
          }
          update: {
            args: Prisma.PasskeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasskeyPayload>
          }
          deleteMany: {
            args: Prisma.PasskeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasskeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasskeyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasskeyPayload>[]
          }
          upsert: {
            args: Prisma.PasskeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasskeyPayload>
          }
          aggregate: {
            args: Prisma.PasskeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasskey>
          }
          groupBy: {
            args: Prisma.PasskeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasskeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasskeyCountArgs<ExtArgs>
            result: $Utils.Optional<PasskeyCountAggregateOutputType> | number
          }
        }
      }
      Log: {
        payload: Prisma.$LogPayload<ExtArgs>
        fields: Prisma.LogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findFirst: {
            args: Prisma.LogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findMany: {
            args: Prisma.LogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          create: {
            args: Prisma.LogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          createMany: {
            args: Prisma.LogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          delete: {
            args: Prisma.LogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          update: {
            args: Prisma.LogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          deleteMany: {
            args: Prisma.LogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          upsert: {
            args: Prisma.LogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          aggregate: {
            args: Prisma.LogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLog>
          }
          groupBy: {
            args: Prisma.LogGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogCountArgs<ExtArgs>
            result: $Utils.Optional<LogCountAggregateOutputType> | number
          }
        }
      }
      Config: {
        payload: Prisma.$ConfigPayload<ExtArgs>
        fields: Prisma.ConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigPayload>
          }
          findFirst: {
            args: Prisma.ConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigPayload>
          }
          findMany: {
            args: Prisma.ConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigPayload>[]
          }
          create: {
            args: Prisma.ConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigPayload>
          }
          createMany: {
            args: Prisma.ConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigPayload>[]
          }
          delete: {
            args: Prisma.ConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigPayload>
          }
          update: {
            args: Prisma.ConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigPayload>
          }
          deleteMany: {
            args: Prisma.ConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigPayload>[]
          }
          upsert: {
            args: Prisma.ConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigPayload>
          }
          aggregate: {
            args: Prisma.ConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfig>
          }
          groupBy: {
            args: Prisma.ConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConfigCountArgs<ExtArgs>
            result: $Utils.Optional<ConfigCountAggregateOutputType> | number
          }
        }
      }
      ConfigHistory: {
        payload: Prisma.$ConfigHistoryPayload<ExtArgs>
        fields: Prisma.ConfigHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConfigHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConfigHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigHistoryPayload>
          }
          findFirst: {
            args: Prisma.ConfigHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConfigHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigHistoryPayload>
          }
          findMany: {
            args: Prisma.ConfigHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigHistoryPayload>[]
          }
          create: {
            args: Prisma.ConfigHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigHistoryPayload>
          }
          createMany: {
            args: Prisma.ConfigHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConfigHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigHistoryPayload>[]
          }
          delete: {
            args: Prisma.ConfigHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigHistoryPayload>
          }
          update: {
            args: Prisma.ConfigHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigHistoryPayload>
          }
          deleteMany: {
            args: Prisma.ConfigHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConfigHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConfigHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigHistoryPayload>[]
          }
          upsert: {
            args: Prisma.ConfigHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigHistoryPayload>
          }
          aggregate: {
            args: Prisma.ConfigHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfigHistory>
          }
          groupBy: {
            args: Prisma.ConfigHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConfigHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConfigHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<ConfigHistoryCountAggregateOutputType> | number
          }
        }
      }
      ConfigTemplate: {
        payload: Prisma.$ConfigTemplatePayload<ExtArgs>
        fields: Prisma.ConfigTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConfigTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConfigTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigTemplatePayload>
          }
          findFirst: {
            args: Prisma.ConfigTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConfigTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigTemplatePayload>
          }
          findMany: {
            args: Prisma.ConfigTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigTemplatePayload>[]
          }
          create: {
            args: Prisma.ConfigTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigTemplatePayload>
          }
          createMany: {
            args: Prisma.ConfigTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConfigTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigTemplatePayload>[]
          }
          delete: {
            args: Prisma.ConfigTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigTemplatePayload>
          }
          update: {
            args: Prisma.ConfigTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigTemplatePayload>
          }
          deleteMany: {
            args: Prisma.ConfigTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConfigTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConfigTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigTemplatePayload>[]
          }
          upsert: {
            args: Prisma.ConfigTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigTemplatePayload>
          }
          aggregate: {
            args: Prisma.ConfigTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfigTemplate>
          }
          groupBy: {
            args: Prisma.ConfigTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConfigTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConfigTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<ConfigTemplateCountAggregateOutputType> | number
          }
        }
      }
      Kiosk: {
        payload: Prisma.$KioskPayload<ExtArgs>
        fields: Prisma.KioskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KioskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KioskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskPayload>
          }
          findFirst: {
            args: Prisma.KioskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KioskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskPayload>
          }
          findMany: {
            args: Prisma.KioskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskPayload>[]
          }
          create: {
            args: Prisma.KioskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskPayload>
          }
          createMany: {
            args: Prisma.KioskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KioskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskPayload>[]
          }
          delete: {
            args: Prisma.KioskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskPayload>
          }
          update: {
            args: Prisma.KioskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskPayload>
          }
          deleteMany: {
            args: Prisma.KioskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KioskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KioskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskPayload>[]
          }
          upsert: {
            args: Prisma.KioskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskPayload>
          }
          aggregate: {
            args: Prisma.KioskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKiosk>
          }
          groupBy: {
            args: Prisma.KioskGroupByArgs<ExtArgs>
            result: $Utils.Optional<KioskGroupByOutputType>[]
          }
          count: {
            args: Prisma.KioskCountArgs<ExtArgs>
            result: $Utils.Optional<KioskCountAggregateOutputType> | number
          }
        }
      }
      Feedback: {
        payload: Prisma.$FeedbackPayload<ExtArgs>
        fields: Prisma.FeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findFirst: {
            args: Prisma.FeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findMany: {
            args: Prisma.FeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          create: {
            args: Prisma.FeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          createMany: {
            args: Prisma.FeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          delete: {
            args: Prisma.FeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          update: {
            args: Prisma.FeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          deleteMany: {
            args: Prisma.FeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeedbackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          upsert: {
            args: Prisma.FeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          aggregate: {
            args: Prisma.FeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedback>
          }
          groupBy: {
            args: Prisma.FeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<FeedbackCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      DirectoryIntegration: {
        payload: Prisma.$DirectoryIntegrationPayload<ExtArgs>
        fields: Prisma.DirectoryIntegrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DirectoryIntegrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectoryIntegrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DirectoryIntegrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectoryIntegrationPayload>
          }
          findFirst: {
            args: Prisma.DirectoryIntegrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectoryIntegrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DirectoryIntegrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectoryIntegrationPayload>
          }
          findMany: {
            args: Prisma.DirectoryIntegrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectoryIntegrationPayload>[]
          }
          create: {
            args: Prisma.DirectoryIntegrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectoryIntegrationPayload>
          }
          createMany: {
            args: Prisma.DirectoryIntegrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DirectoryIntegrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectoryIntegrationPayload>[]
          }
          delete: {
            args: Prisma.DirectoryIntegrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectoryIntegrationPayload>
          }
          update: {
            args: Prisma.DirectoryIntegrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectoryIntegrationPayload>
          }
          deleteMany: {
            args: Prisma.DirectoryIntegrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DirectoryIntegrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DirectoryIntegrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectoryIntegrationPayload>[]
          }
          upsert: {
            args: Prisma.DirectoryIntegrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectoryIntegrationPayload>
          }
          aggregate: {
            args: Prisma.DirectoryIntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDirectoryIntegration>
          }
          groupBy: {
            args: Prisma.DirectoryIntegrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DirectoryIntegrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DirectoryIntegrationCountArgs<ExtArgs>
            result: $Utils.Optional<DirectoryIntegrationCountAggregateOutputType> | number
          }
        }
      }
      Asset: {
        payload: Prisma.$AssetPayload<ExtArgs>
        fields: Prisma.AssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findFirst: {
            args: Prisma.AssetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findMany: {
            args: Prisma.AssetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          create: {
            args: Prisma.AssetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          createMany: {
            args: Prisma.AssetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          delete: {
            args: Prisma.AssetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          update: {
            args: Prisma.AssetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          deleteMany: {
            args: Prisma.AssetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          upsert: {
            args: Prisma.AssetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          aggregate: {
            args: Prisma.AssetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAsset>
          }
          groupBy: {
            args: Prisma.AssetGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssetGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetCountArgs<ExtArgs>
            result: $Utils.Optional<AssetCountAggregateOutputType> | number
          }
        }
      }
      KioskActivation: {
        payload: Prisma.$KioskActivationPayload<ExtArgs>
        fields: Prisma.KioskActivationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KioskActivationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskActivationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KioskActivationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskActivationPayload>
          }
          findFirst: {
            args: Prisma.KioskActivationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskActivationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KioskActivationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskActivationPayload>
          }
          findMany: {
            args: Prisma.KioskActivationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskActivationPayload>[]
          }
          create: {
            args: Prisma.KioskActivationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskActivationPayload>
          }
          createMany: {
            args: Prisma.KioskActivationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KioskActivationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskActivationPayload>[]
          }
          delete: {
            args: Prisma.KioskActivationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskActivationPayload>
          }
          update: {
            args: Prisma.KioskActivationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskActivationPayload>
          }
          deleteMany: {
            args: Prisma.KioskActivationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KioskActivationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KioskActivationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskActivationPayload>[]
          }
          upsert: {
            args: Prisma.KioskActivationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskActivationPayload>
          }
          aggregate: {
            args: Prisma.KioskActivationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKioskActivation>
          }
          groupBy: {
            args: Prisma.KioskActivationGroupByArgs<ExtArgs>
            result: $Utils.Optional<KioskActivationGroupByOutputType>[]
          }
          count: {
            args: Prisma.KioskActivationCountArgs<ExtArgs>
            result: $Utils.Optional<KioskActivationCountAggregateOutputType> | number
          }
        }
      }
      SsoConfiguration: {
        payload: Prisma.$SsoConfigurationPayload<ExtArgs>
        fields: Prisma.SsoConfigurationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SsoConfigurationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SsoConfigurationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SsoConfigurationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SsoConfigurationPayload>
          }
          findFirst: {
            args: Prisma.SsoConfigurationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SsoConfigurationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SsoConfigurationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SsoConfigurationPayload>
          }
          findMany: {
            args: Prisma.SsoConfigurationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SsoConfigurationPayload>[]
          }
          create: {
            args: Prisma.SsoConfigurationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SsoConfigurationPayload>
          }
          createMany: {
            args: Prisma.SsoConfigurationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SsoConfigurationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SsoConfigurationPayload>[]
          }
          delete: {
            args: Prisma.SsoConfigurationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SsoConfigurationPayload>
          }
          update: {
            args: Prisma.SsoConfigurationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SsoConfigurationPayload>
          }
          deleteMany: {
            args: Prisma.SsoConfigurationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SsoConfigurationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SsoConfigurationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SsoConfigurationPayload>[]
          }
          upsert: {
            args: Prisma.SsoConfigurationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SsoConfigurationPayload>
          }
          aggregate: {
            args: Prisma.SsoConfigurationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSsoConfiguration>
          }
          groupBy: {
            args: Prisma.SsoConfigurationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SsoConfigurationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SsoConfigurationCountArgs<ExtArgs>
            result: $Utils.Optional<SsoConfigurationCountAggregateOutputType> | number
          }
        }
      }
      AdminPin: {
        payload: Prisma.$AdminPinPayload<ExtArgs>
        fields: Prisma.AdminPinFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminPinFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPinPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminPinFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPinPayload>
          }
          findFirst: {
            args: Prisma.AdminPinFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPinPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminPinFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPinPayload>
          }
          findMany: {
            args: Prisma.AdminPinFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPinPayload>[]
          }
          create: {
            args: Prisma.AdminPinCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPinPayload>
          }
          createMany: {
            args: Prisma.AdminPinCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminPinCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPinPayload>[]
          }
          delete: {
            args: Prisma.AdminPinDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPinPayload>
          }
          update: {
            args: Prisma.AdminPinUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPinPayload>
          }
          deleteMany: {
            args: Prisma.AdminPinDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminPinUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminPinUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPinPayload>[]
          }
          upsert: {
            args: Prisma.AdminPinUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPinPayload>
          }
          aggregate: {
            args: Prisma.AdminPinAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminPin>
          }
          groupBy: {
            args: Prisma.AdminPinGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminPinGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminPinCountArgs<ExtArgs>
            result: $Utils.Optional<AdminPinCountAggregateOutputType> | number
          }
        }
      }
      KbArticle: {
        payload: Prisma.$KbArticlePayload<ExtArgs>
        fields: Prisma.KbArticleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KbArticleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KbArticlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KbArticleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KbArticlePayload>
          }
          findFirst: {
            args: Prisma.KbArticleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KbArticlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KbArticleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KbArticlePayload>
          }
          findMany: {
            args: Prisma.KbArticleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KbArticlePayload>[]
          }
          create: {
            args: Prisma.KbArticleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KbArticlePayload>
          }
          createMany: {
            args: Prisma.KbArticleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KbArticleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KbArticlePayload>[]
          }
          delete: {
            args: Prisma.KbArticleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KbArticlePayload>
          }
          update: {
            args: Prisma.KbArticleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KbArticlePayload>
          }
          deleteMany: {
            args: Prisma.KbArticleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KbArticleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KbArticleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KbArticlePayload>[]
          }
          upsert: {
            args: Prisma.KbArticleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KbArticlePayload>
          }
          aggregate: {
            args: Prisma.KbArticleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKbArticle>
          }
          groupBy: {
            args: Prisma.KbArticleGroupByArgs<ExtArgs>
            result: $Utils.Optional<KbArticleGroupByOutputType>[]
          }
          count: {
            args: Prisma.KbArticleCountArgs<ExtArgs>
            result: $Utils.Optional<KbArticleCountAggregateOutputType> | number
          }
        }
      }
      KbArticleVersion: {
        payload: Prisma.$KbArticleVersionPayload<ExtArgs>
        fields: Prisma.KbArticleVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KbArticleVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KbArticleVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KbArticleVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KbArticleVersionPayload>
          }
          findFirst: {
            args: Prisma.KbArticleVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KbArticleVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KbArticleVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KbArticleVersionPayload>
          }
          findMany: {
            args: Prisma.KbArticleVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KbArticleVersionPayload>[]
          }
          create: {
            args: Prisma.KbArticleVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KbArticleVersionPayload>
          }
          createMany: {
            args: Prisma.KbArticleVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KbArticleVersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KbArticleVersionPayload>[]
          }
          delete: {
            args: Prisma.KbArticleVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KbArticleVersionPayload>
          }
          update: {
            args: Prisma.KbArticleVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KbArticleVersionPayload>
          }
          deleteMany: {
            args: Prisma.KbArticleVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KbArticleVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KbArticleVersionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KbArticleVersionPayload>[]
          }
          upsert: {
            args: Prisma.KbArticleVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KbArticleVersionPayload>
          }
          aggregate: {
            args: Prisma.KbArticleVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKbArticleVersion>
          }
          groupBy: {
            args: Prisma.KbArticleVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<KbArticleVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.KbArticleVersionCountArgs<ExtArgs>
            result: $Utils.Optional<KbArticleVersionCountAggregateOutputType> | number
          }
        }
      }
      KbArticleComment: {
        payload: Prisma.$KbArticleCommentPayload<ExtArgs>
        fields: Prisma.KbArticleCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KbArticleCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KbArticleCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KbArticleCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KbArticleCommentPayload>
          }
          findFirst: {
            args: Prisma.KbArticleCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KbArticleCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KbArticleCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KbArticleCommentPayload>
          }
          findMany: {
            args: Prisma.KbArticleCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KbArticleCommentPayload>[]
          }
          create: {
            args: Prisma.KbArticleCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KbArticleCommentPayload>
          }
          createMany: {
            args: Prisma.KbArticleCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KbArticleCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KbArticleCommentPayload>[]
          }
          delete: {
            args: Prisma.KbArticleCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KbArticleCommentPayload>
          }
          update: {
            args: Prisma.KbArticleCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KbArticleCommentPayload>
          }
          deleteMany: {
            args: Prisma.KbArticleCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KbArticleCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KbArticleCommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KbArticleCommentPayload>[]
          }
          upsert: {
            args: Prisma.KbArticleCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KbArticleCommentPayload>
          }
          aggregate: {
            args: Prisma.KbArticleCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKbArticleComment>
          }
          groupBy: {
            args: Prisma.KbArticleCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<KbArticleCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.KbArticleCommentCountArgs<ExtArgs>
            result: $Utils.Optional<KbArticleCommentCountAggregateOutputType> | number
          }
        }
      }
      SupportTicket: {
        payload: Prisma.$SupportTicketPayload<ExtArgs>
        fields: Prisma.SupportTicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupportTicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupportTicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          findFirst: {
            args: Prisma.SupportTicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupportTicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          findMany: {
            args: Prisma.SupportTicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          create: {
            args: Prisma.SupportTicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          createMany: {
            args: Prisma.SupportTicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupportTicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          delete: {
            args: Prisma.SupportTicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          update: {
            args: Prisma.SupportTicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          deleteMany: {
            args: Prisma.SupportTicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupportTicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupportTicketUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          upsert: {
            args: Prisma.SupportTicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          aggregate: {
            args: Prisma.SupportTicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupportTicket>
          }
          groupBy: {
            args: Prisma.SupportTicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupportTicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupportTicketCountArgs<ExtArgs>
            result: $Utils.Optional<SupportTicketCountAggregateOutputType> | number
          }
        }
      }
      InventoryAsset: {
        payload: Prisma.$InventoryAssetPayload<ExtArgs>
        fields: Prisma.InventoryAssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryAssetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryAssetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAssetPayload>
          }
          findFirst: {
            args: Prisma.InventoryAssetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryAssetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAssetPayload>
          }
          findMany: {
            args: Prisma.InventoryAssetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAssetPayload>[]
          }
          create: {
            args: Prisma.InventoryAssetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAssetPayload>
          }
          createMany: {
            args: Prisma.InventoryAssetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryAssetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAssetPayload>[]
          }
          delete: {
            args: Prisma.InventoryAssetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAssetPayload>
          }
          update: {
            args: Prisma.InventoryAssetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAssetPayload>
          }
          deleteMany: {
            args: Prisma.InventoryAssetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryAssetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryAssetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAssetPayload>[]
          }
          upsert: {
            args: Prisma.InventoryAssetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAssetPayload>
          }
          aggregate: {
            args: Prisma.InventoryAssetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryAsset>
          }
          groupBy: {
            args: Prisma.InventoryAssetGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryAssetGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryAssetCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryAssetCountAggregateOutputType> | number
          }
        }
      }
      AssetStatusLog: {
        payload: Prisma.$AssetStatusLogPayload<ExtArgs>
        fields: Prisma.AssetStatusLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetStatusLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetStatusLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetStatusLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetStatusLogPayload>
          }
          findFirst: {
            args: Prisma.AssetStatusLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetStatusLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetStatusLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetStatusLogPayload>
          }
          findMany: {
            args: Prisma.AssetStatusLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetStatusLogPayload>[]
          }
          create: {
            args: Prisma.AssetStatusLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetStatusLogPayload>
          }
          createMany: {
            args: Prisma.AssetStatusLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssetStatusLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetStatusLogPayload>[]
          }
          delete: {
            args: Prisma.AssetStatusLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetStatusLogPayload>
          }
          update: {
            args: Prisma.AssetStatusLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetStatusLogPayload>
          }
          deleteMany: {
            args: Prisma.AssetStatusLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssetStatusLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssetStatusLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetStatusLogPayload>[]
          }
          upsert: {
            args: Prisma.AssetStatusLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetStatusLogPayload>
          }
          aggregate: {
            args: Prisma.AssetStatusLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssetStatusLog>
          }
          groupBy: {
            args: Prisma.AssetStatusLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssetStatusLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetStatusLogCountArgs<ExtArgs>
            result: $Utils.Optional<AssetStatusLogCountAggregateOutputType> | number
          }
        }
      }
      AssetAssignment: {
        payload: Prisma.$AssetAssignmentPayload<ExtArgs>
        fields: Prisma.AssetAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetAssignmentPayload>
          }
          findFirst: {
            args: Prisma.AssetAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetAssignmentPayload>
          }
          findMany: {
            args: Prisma.AssetAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetAssignmentPayload>[]
          }
          create: {
            args: Prisma.AssetAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetAssignmentPayload>
          }
          createMany: {
            args: Prisma.AssetAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssetAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetAssignmentPayload>[]
          }
          delete: {
            args: Prisma.AssetAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetAssignmentPayload>
          }
          update: {
            args: Prisma.AssetAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.AssetAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssetAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssetAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.AssetAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetAssignmentPayload>
          }
          aggregate: {
            args: Prisma.AssetAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssetAssignment>
          }
          groupBy: {
            args: Prisma.AssetAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssetAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<AssetAssignmentCountAggregateOutputType> | number
          }
        }
      }
      AssetTicketHistory: {
        payload: Prisma.$AssetTicketHistoryPayload<ExtArgs>
        fields: Prisma.AssetTicketHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetTicketHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetTicketHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetTicketHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetTicketHistoryPayload>
          }
          findFirst: {
            args: Prisma.AssetTicketHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetTicketHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetTicketHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetTicketHistoryPayload>
          }
          findMany: {
            args: Prisma.AssetTicketHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetTicketHistoryPayload>[]
          }
          create: {
            args: Prisma.AssetTicketHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetTicketHistoryPayload>
          }
          createMany: {
            args: Prisma.AssetTicketHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssetTicketHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetTicketHistoryPayload>[]
          }
          delete: {
            args: Prisma.AssetTicketHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetTicketHistoryPayload>
          }
          update: {
            args: Prisma.AssetTicketHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetTicketHistoryPayload>
          }
          deleteMany: {
            args: Prisma.AssetTicketHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssetTicketHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssetTicketHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetTicketHistoryPayload>[]
          }
          upsert: {
            args: Prisma.AssetTicketHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetTicketHistoryPayload>
          }
          aggregate: {
            args: Prisma.AssetTicketHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssetTicketHistory>
          }
          groupBy: {
            args: Prisma.AssetTicketHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssetTicketHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetTicketHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<AssetTicketHistoryCountAggregateOutputType> | number
          }
        }
      }
      AssetWarrantyAlert: {
        payload: Prisma.$AssetWarrantyAlertPayload<ExtArgs>
        fields: Prisma.AssetWarrantyAlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetWarrantyAlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetWarrantyAlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetWarrantyAlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetWarrantyAlertPayload>
          }
          findFirst: {
            args: Prisma.AssetWarrantyAlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetWarrantyAlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetWarrantyAlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetWarrantyAlertPayload>
          }
          findMany: {
            args: Prisma.AssetWarrantyAlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetWarrantyAlertPayload>[]
          }
          create: {
            args: Prisma.AssetWarrantyAlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetWarrantyAlertPayload>
          }
          createMany: {
            args: Prisma.AssetWarrantyAlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssetWarrantyAlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetWarrantyAlertPayload>[]
          }
          delete: {
            args: Prisma.AssetWarrantyAlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetWarrantyAlertPayload>
          }
          update: {
            args: Prisma.AssetWarrantyAlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetWarrantyAlertPayload>
          }
          deleteMany: {
            args: Prisma.AssetWarrantyAlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssetWarrantyAlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssetWarrantyAlertUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetWarrantyAlertPayload>[]
          }
          upsert: {
            args: Prisma.AssetWarrantyAlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetWarrantyAlertPayload>
          }
          aggregate: {
            args: Prisma.AssetWarrantyAlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssetWarrantyAlert>
          }
          groupBy: {
            args: Prisma.AssetWarrantyAlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssetWarrantyAlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetWarrantyAlertCountArgs<ExtArgs>
            result: $Utils.Optional<AssetWarrantyAlertCountAggregateOutputType> | number
          }
        }
      }
      AssetImportBatch: {
        payload: Prisma.$AssetImportBatchPayload<ExtArgs>
        fields: Prisma.AssetImportBatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetImportBatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetImportBatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetImportBatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetImportBatchPayload>
          }
          findFirst: {
            args: Prisma.AssetImportBatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetImportBatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetImportBatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetImportBatchPayload>
          }
          findMany: {
            args: Prisma.AssetImportBatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetImportBatchPayload>[]
          }
          create: {
            args: Prisma.AssetImportBatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetImportBatchPayload>
          }
          createMany: {
            args: Prisma.AssetImportBatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssetImportBatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetImportBatchPayload>[]
          }
          delete: {
            args: Prisma.AssetImportBatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetImportBatchPayload>
          }
          update: {
            args: Prisma.AssetImportBatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetImportBatchPayload>
          }
          deleteMany: {
            args: Prisma.AssetImportBatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssetImportBatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssetImportBatchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetImportBatchPayload>[]
          }
          upsert: {
            args: Prisma.AssetImportBatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetImportBatchPayload>
          }
          aggregate: {
            args: Prisma.AssetImportBatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssetImportBatch>
          }
          groupBy: {
            args: Prisma.AssetImportBatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssetImportBatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetImportBatchCountArgs<ExtArgs>
            result: $Utils.Optional<AssetImportBatchCountAggregateOutputType> | number
          }
        }
      }
      AssetValidationLog: {
        payload: Prisma.$AssetValidationLogPayload<ExtArgs>
        fields: Prisma.AssetValidationLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetValidationLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetValidationLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetValidationLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetValidationLogPayload>
          }
          findFirst: {
            args: Prisma.AssetValidationLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetValidationLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetValidationLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetValidationLogPayload>
          }
          findMany: {
            args: Prisma.AssetValidationLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetValidationLogPayload>[]
          }
          create: {
            args: Prisma.AssetValidationLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetValidationLogPayload>
          }
          createMany: {
            args: Prisma.AssetValidationLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssetValidationLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetValidationLogPayload>[]
          }
          delete: {
            args: Prisma.AssetValidationLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetValidationLogPayload>
          }
          update: {
            args: Prisma.AssetValidationLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetValidationLogPayload>
          }
          deleteMany: {
            args: Prisma.AssetValidationLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssetValidationLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssetValidationLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetValidationLogPayload>[]
          }
          upsert: {
            args: Prisma.AssetValidationLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetValidationLogPayload>
          }
          aggregate: {
            args: Prisma.AssetValidationLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssetValidationLog>
          }
          groupBy: {
            args: Prisma.AssetValidationLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssetValidationLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetValidationLogCountArgs<ExtArgs>
            result: $Utils.Optional<AssetValidationLogCountAggregateOutputType> | number
          }
        }
      }
      KioskAssetRegistry: {
        payload: Prisma.$KioskAssetRegistryPayload<ExtArgs>
        fields: Prisma.KioskAssetRegistryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KioskAssetRegistryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskAssetRegistryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KioskAssetRegistryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskAssetRegistryPayload>
          }
          findFirst: {
            args: Prisma.KioskAssetRegistryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskAssetRegistryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KioskAssetRegistryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskAssetRegistryPayload>
          }
          findMany: {
            args: Prisma.KioskAssetRegistryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskAssetRegistryPayload>[]
          }
          create: {
            args: Prisma.KioskAssetRegistryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskAssetRegistryPayload>
          }
          createMany: {
            args: Prisma.KioskAssetRegistryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KioskAssetRegistryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskAssetRegistryPayload>[]
          }
          delete: {
            args: Prisma.KioskAssetRegistryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskAssetRegistryPayload>
          }
          update: {
            args: Prisma.KioskAssetRegistryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskAssetRegistryPayload>
          }
          deleteMany: {
            args: Prisma.KioskAssetRegistryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KioskAssetRegistryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KioskAssetRegistryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskAssetRegistryPayload>[]
          }
          upsert: {
            args: Prisma.KioskAssetRegistryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskAssetRegistryPayload>
          }
          aggregate: {
            args: Prisma.KioskAssetRegistryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKioskAssetRegistry>
          }
          groupBy: {
            args: Prisma.KioskAssetRegistryGroupByArgs<ExtArgs>
            result: $Utils.Optional<KioskAssetRegistryGroupByOutputType>[]
          }
          count: {
            args: Prisma.KioskAssetRegistryCountArgs<ExtArgs>
            result: $Utils.Optional<KioskAssetRegistryCountAggregateOutputType> | number
          }
        }
      }
      HelixSyncFailure: {
        payload: Prisma.$HelixSyncFailurePayload<ExtArgs>
        fields: Prisma.HelixSyncFailureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HelixSyncFailureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelixSyncFailurePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HelixSyncFailureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelixSyncFailurePayload>
          }
          findFirst: {
            args: Prisma.HelixSyncFailureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelixSyncFailurePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HelixSyncFailureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelixSyncFailurePayload>
          }
          findMany: {
            args: Prisma.HelixSyncFailureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelixSyncFailurePayload>[]
          }
          create: {
            args: Prisma.HelixSyncFailureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelixSyncFailurePayload>
          }
          createMany: {
            args: Prisma.HelixSyncFailureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HelixSyncFailureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelixSyncFailurePayload>[]
          }
          delete: {
            args: Prisma.HelixSyncFailureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelixSyncFailurePayload>
          }
          update: {
            args: Prisma.HelixSyncFailureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelixSyncFailurePayload>
          }
          deleteMany: {
            args: Prisma.HelixSyncFailureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HelixSyncFailureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HelixSyncFailureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelixSyncFailurePayload>[]
          }
          upsert: {
            args: Prisma.HelixSyncFailureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelixSyncFailurePayload>
          }
          aggregate: {
            args: Prisma.HelixSyncFailureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHelixSyncFailure>
          }
          groupBy: {
            args: Prisma.HelixSyncFailureGroupByArgs<ExtArgs>
            result: $Utils.Optional<HelixSyncFailureGroupByOutputType>[]
          }
          count: {
            args: Prisma.HelixSyncFailureCountArgs<ExtArgs>
            result: $Utils.Optional<HelixSyncFailureCountAggregateOutputType> | number
          }
        }
      }
      KioskOrganizationAssignment: {
        payload: Prisma.$KioskOrganizationAssignmentPayload<ExtArgs>
        fields: Prisma.KioskOrganizationAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KioskOrganizationAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskOrganizationAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KioskOrganizationAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskOrganizationAssignmentPayload>
          }
          findFirst: {
            args: Prisma.KioskOrganizationAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskOrganizationAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KioskOrganizationAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskOrganizationAssignmentPayload>
          }
          findMany: {
            args: Prisma.KioskOrganizationAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskOrganizationAssignmentPayload>[]
          }
          create: {
            args: Prisma.KioskOrganizationAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskOrganizationAssignmentPayload>
          }
          createMany: {
            args: Prisma.KioskOrganizationAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KioskOrganizationAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskOrganizationAssignmentPayload>[]
          }
          delete: {
            args: Prisma.KioskOrganizationAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskOrganizationAssignmentPayload>
          }
          update: {
            args: Prisma.KioskOrganizationAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskOrganizationAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.KioskOrganizationAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KioskOrganizationAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KioskOrganizationAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskOrganizationAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.KioskOrganizationAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskOrganizationAssignmentPayload>
          }
          aggregate: {
            args: Prisma.KioskOrganizationAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKioskOrganizationAssignment>
          }
          groupBy: {
            args: Prisma.KioskOrganizationAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<KioskOrganizationAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.KioskOrganizationAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<KioskOrganizationAssignmentCountAggregateOutputType> | number
          }
        }
      }
      KioskMetadataLog: {
        payload: Prisma.$KioskMetadataLogPayload<ExtArgs>
        fields: Prisma.KioskMetadataLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KioskMetadataLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskMetadataLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KioskMetadataLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskMetadataLogPayload>
          }
          findFirst: {
            args: Prisma.KioskMetadataLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskMetadataLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KioskMetadataLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskMetadataLogPayload>
          }
          findMany: {
            args: Prisma.KioskMetadataLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskMetadataLogPayload>[]
          }
          create: {
            args: Prisma.KioskMetadataLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskMetadataLogPayload>
          }
          createMany: {
            args: Prisma.KioskMetadataLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KioskMetadataLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskMetadataLogPayload>[]
          }
          delete: {
            args: Prisma.KioskMetadataLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskMetadataLogPayload>
          }
          update: {
            args: Prisma.KioskMetadataLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskMetadataLogPayload>
          }
          deleteMany: {
            args: Prisma.KioskMetadataLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KioskMetadataLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KioskMetadataLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskMetadataLogPayload>[]
          }
          upsert: {
            args: Prisma.KioskMetadataLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KioskMetadataLogPayload>
          }
          aggregate: {
            args: Prisma.KioskMetadataLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKioskMetadataLog>
          }
          groupBy: {
            args: Prisma.KioskMetadataLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<KioskMetadataLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.KioskMetadataLogCountArgs<ExtArgs>
            result: $Utils.Optional<KioskMetadataLogCountAggregateOutputType> | number
          }
        }
      }
      XpEvent: {
        payload: Prisma.$XpEventPayload<ExtArgs>
        fields: Prisma.XpEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.XpEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XpEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.XpEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XpEventPayload>
          }
          findFirst: {
            args: Prisma.XpEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XpEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.XpEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XpEventPayload>
          }
          findMany: {
            args: Prisma.XpEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XpEventPayload>[]
          }
          create: {
            args: Prisma.XpEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XpEventPayload>
          }
          createMany: {
            args: Prisma.XpEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.XpEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XpEventPayload>[]
          }
          delete: {
            args: Prisma.XpEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XpEventPayload>
          }
          update: {
            args: Prisma.XpEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XpEventPayload>
          }
          deleteMany: {
            args: Prisma.XpEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.XpEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.XpEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XpEventPayload>[]
          }
          upsert: {
            args: Prisma.XpEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XpEventPayload>
          }
          aggregate: {
            args: Prisma.XpEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateXpEvent>
          }
          groupBy: {
            args: Prisma.XpEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<XpEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.XpEventCountArgs<ExtArgs>
            result: $Utils.Optional<XpEventCountAggregateOutputType> | number
          }
        }
      }
      Leaderboard: {
        payload: Prisma.$LeaderboardPayload<ExtArgs>
        fields: Prisma.LeaderboardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaderboardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaderboardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          findFirst: {
            args: Prisma.LeaderboardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaderboardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          findMany: {
            args: Prisma.LeaderboardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>[]
          }
          create: {
            args: Prisma.LeaderboardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          createMany: {
            args: Prisma.LeaderboardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaderboardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>[]
          }
          delete: {
            args: Prisma.LeaderboardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          update: {
            args: Prisma.LeaderboardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          deleteMany: {
            args: Prisma.LeaderboardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaderboardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeaderboardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>[]
          }
          upsert: {
            args: Prisma.LeaderboardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          aggregate: {
            args: Prisma.LeaderboardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaderboard>
          }
          groupBy: {
            args: Prisma.LeaderboardGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaderboardGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaderboardCountArgs<ExtArgs>
            result: $Utils.Optional<LeaderboardCountAggregateOutputType> | number
          }
        }
      }
      ScimMapping: {
        payload: Prisma.$ScimMappingPayload<ExtArgs>
        fields: Prisma.ScimMappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScimMappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScimMappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScimMappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScimMappingPayload>
          }
          findFirst: {
            args: Prisma.ScimMappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScimMappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScimMappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScimMappingPayload>
          }
          findMany: {
            args: Prisma.ScimMappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScimMappingPayload>[]
          }
          create: {
            args: Prisma.ScimMappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScimMappingPayload>
          }
          createMany: {
            args: Prisma.ScimMappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScimMappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScimMappingPayload>[]
          }
          delete: {
            args: Prisma.ScimMappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScimMappingPayload>
          }
          update: {
            args: Prisma.ScimMappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScimMappingPayload>
          }
          deleteMany: {
            args: Prisma.ScimMappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScimMappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScimMappingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScimMappingPayload>[]
          }
          upsert: {
            args: Prisma.ScimMappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScimMappingPayload>
          }
          aggregate: {
            args: Prisma.ScimMappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScimMapping>
          }
          groupBy: {
            args: Prisma.ScimMappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScimMappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScimMappingCountArgs<ExtArgs>
            result: $Utils.Optional<ScimMappingCountAggregateOutputType> | number
          }
        }
      }
      ScimLog: {
        payload: Prisma.$ScimLogPayload<ExtArgs>
        fields: Prisma.ScimLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScimLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScimLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScimLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScimLogPayload>
          }
          findFirst: {
            args: Prisma.ScimLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScimLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScimLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScimLogPayload>
          }
          findMany: {
            args: Prisma.ScimLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScimLogPayload>[]
          }
          create: {
            args: Prisma.ScimLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScimLogPayload>
          }
          createMany: {
            args: Prisma.ScimLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScimLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScimLogPayload>[]
          }
          delete: {
            args: Prisma.ScimLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScimLogPayload>
          }
          update: {
            args: Prisma.ScimLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScimLogPayload>
          }
          deleteMany: {
            args: Prisma.ScimLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScimLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScimLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScimLogPayload>[]
          }
          upsert: {
            args: Prisma.ScimLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScimLogPayload>
          }
          aggregate: {
            args: Prisma.ScimLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScimLog>
          }
          groupBy: {
            args: Prisma.ScimLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScimLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScimLogCountArgs<ExtArgs>
            result: $Utils.Optional<ScimLogCountAggregateOutputType> | number
          }
        }
      }
      MailroomPackage: {
        payload: Prisma.$MailroomPackagePayload<ExtArgs>
        fields: Prisma.MailroomPackageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MailroomPackageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailroomPackagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MailroomPackageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailroomPackagePayload>
          }
          findFirst: {
            args: Prisma.MailroomPackageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailroomPackagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MailroomPackageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailroomPackagePayload>
          }
          findMany: {
            args: Prisma.MailroomPackageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailroomPackagePayload>[]
          }
          create: {
            args: Prisma.MailroomPackageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailroomPackagePayload>
          }
          createMany: {
            args: Prisma.MailroomPackageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MailroomPackageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailroomPackagePayload>[]
          }
          delete: {
            args: Prisma.MailroomPackageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailroomPackagePayload>
          }
          update: {
            args: Prisma.MailroomPackageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailroomPackagePayload>
          }
          deleteMany: {
            args: Prisma.MailroomPackageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MailroomPackageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MailroomPackageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailroomPackagePayload>[]
          }
          upsert: {
            args: Prisma.MailroomPackageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailroomPackagePayload>
          }
          aggregate: {
            args: Prisma.MailroomPackageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMailroomPackage>
          }
          groupBy: {
            args: Prisma.MailroomPackageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MailroomPackageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MailroomPackageCountArgs<ExtArgs>
            result: $Utils.Optional<MailroomPackageCountAggregateOutputType> | number
          }
        }
      }
      DeliveryEvent: {
        payload: Prisma.$DeliveryEventPayload<ExtArgs>
        fields: Prisma.DeliveryEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryEventPayload>
          }
          findFirst: {
            args: Prisma.DeliveryEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryEventPayload>
          }
          findMany: {
            args: Prisma.DeliveryEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryEventPayload>[]
          }
          create: {
            args: Prisma.DeliveryEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryEventPayload>
          }
          createMany: {
            args: Prisma.DeliveryEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryEventPayload>[]
          }
          delete: {
            args: Prisma.DeliveryEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryEventPayload>
          }
          update: {
            args: Prisma.DeliveryEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryEventPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeliveryEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryEventPayload>[]
          }
          upsert: {
            args: Prisma.DeliveryEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryEventPayload>
          }
          aggregate: {
            args: Prisma.DeliveryEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryEvent>
          }
          groupBy: {
            args: Prisma.DeliveryEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryEventCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryEventCountAggregateOutputType> | number
          }
        }
      }
      ProxyAuthorization: {
        payload: Prisma.$ProxyAuthorizationPayload<ExtArgs>
        fields: Prisma.ProxyAuthorizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProxyAuthorizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyAuthorizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProxyAuthorizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyAuthorizationPayload>
          }
          findFirst: {
            args: Prisma.ProxyAuthorizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyAuthorizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProxyAuthorizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyAuthorizationPayload>
          }
          findMany: {
            args: Prisma.ProxyAuthorizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyAuthorizationPayload>[]
          }
          create: {
            args: Prisma.ProxyAuthorizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyAuthorizationPayload>
          }
          createMany: {
            args: Prisma.ProxyAuthorizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProxyAuthorizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyAuthorizationPayload>[]
          }
          delete: {
            args: Prisma.ProxyAuthorizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyAuthorizationPayload>
          }
          update: {
            args: Prisma.ProxyAuthorizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyAuthorizationPayload>
          }
          deleteMany: {
            args: Prisma.ProxyAuthorizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProxyAuthorizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProxyAuthorizationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyAuthorizationPayload>[]
          }
          upsert: {
            args: Prisma.ProxyAuthorizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyAuthorizationPayload>
          }
          aggregate: {
            args: Prisma.ProxyAuthorizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProxyAuthorization>
          }
          groupBy: {
            args: Prisma.ProxyAuthorizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProxyAuthorizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProxyAuthorizationCountArgs<ExtArgs>
            result: $Utils.Optional<ProxyAuthorizationCountAggregateOutputType> | number
          }
        }
      }
      RequestCatalogItem: {
        payload: Prisma.$RequestCatalogItemPayload<ExtArgs>
        fields: Prisma.RequestCatalogItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RequestCatalogItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestCatalogItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RequestCatalogItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestCatalogItemPayload>
          }
          findFirst: {
            args: Prisma.RequestCatalogItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestCatalogItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RequestCatalogItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestCatalogItemPayload>
          }
          findMany: {
            args: Prisma.RequestCatalogItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestCatalogItemPayload>[]
          }
          create: {
            args: Prisma.RequestCatalogItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestCatalogItemPayload>
          }
          createMany: {
            args: Prisma.RequestCatalogItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RequestCatalogItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestCatalogItemPayload>[]
          }
          delete: {
            args: Prisma.RequestCatalogItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestCatalogItemPayload>
          }
          update: {
            args: Prisma.RequestCatalogItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestCatalogItemPayload>
          }
          deleteMany: {
            args: Prisma.RequestCatalogItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RequestCatalogItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RequestCatalogItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestCatalogItemPayload>[]
          }
          upsert: {
            args: Prisma.RequestCatalogItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestCatalogItemPayload>
          }
          aggregate: {
            args: Prisma.RequestCatalogItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequestCatalogItem>
          }
          groupBy: {
            args: Prisma.RequestCatalogItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequestCatalogItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.RequestCatalogItemCountArgs<ExtArgs>
            result: $Utils.Optional<RequestCatalogItemCountAggregateOutputType> | number
          }
        }
      }
      RITM: {
        payload: Prisma.$RITMPayload<ExtArgs>
        fields: Prisma.RITMFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RITMFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RITMPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RITMFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RITMPayload>
          }
          findFirst: {
            args: Prisma.RITMFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RITMPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RITMFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RITMPayload>
          }
          findMany: {
            args: Prisma.RITMFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RITMPayload>[]
          }
          create: {
            args: Prisma.RITMCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RITMPayload>
          }
          createMany: {
            args: Prisma.RITMCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RITMCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RITMPayload>[]
          }
          delete: {
            args: Prisma.RITMDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RITMPayload>
          }
          update: {
            args: Prisma.RITMUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RITMPayload>
          }
          deleteMany: {
            args: Prisma.RITMDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RITMUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RITMUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RITMPayload>[]
          }
          upsert: {
            args: Prisma.RITMUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RITMPayload>
          }
          aggregate: {
            args: Prisma.RITMAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRITM>
          }
          groupBy: {
            args: Prisma.RITMGroupByArgs<ExtArgs>
            result: $Utils.Optional<RITMGroupByOutputType>[]
          }
          count: {
            args: Prisma.RITMCountArgs<ExtArgs>
            result: $Utils.Optional<RITMCountAggregateOutputType> | number
          }
        }
      }
      VipProxy: {
        payload: Prisma.$VipProxyPayload<ExtArgs>
        fields: Prisma.VipProxyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VipProxyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipProxyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VipProxyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipProxyPayload>
          }
          findFirst: {
            args: Prisma.VipProxyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipProxyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VipProxyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipProxyPayload>
          }
          findMany: {
            args: Prisma.VipProxyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipProxyPayload>[]
          }
          create: {
            args: Prisma.VipProxyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipProxyPayload>
          }
          createMany: {
            args: Prisma.VipProxyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VipProxyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipProxyPayload>[]
          }
          delete: {
            args: Prisma.VipProxyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipProxyPayload>
          }
          update: {
            args: Prisma.VipProxyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipProxyPayload>
          }
          deleteMany: {
            args: Prisma.VipProxyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VipProxyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VipProxyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipProxyPayload>[]
          }
          upsert: {
            args: Prisma.VipProxyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipProxyPayload>
          }
          aggregate: {
            args: Prisma.VipProxyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVipProxy>
          }
          groupBy: {
            args: Prisma.VipProxyGroupByArgs<ExtArgs>
            result: $Utils.Optional<VipProxyGroupByOutputType>[]
          }
          count: {
            args: Prisma.VipProxyCountArgs<ExtArgs>
            result: $Utils.Optional<VipProxyCountAggregateOutputType> | number
          }
        }
      }
      VipSlaHistory: {
        payload: Prisma.$VipSlaHistoryPayload<ExtArgs>
        fields: Prisma.VipSlaHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VipSlaHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipSlaHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VipSlaHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipSlaHistoryPayload>
          }
          findFirst: {
            args: Prisma.VipSlaHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipSlaHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VipSlaHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipSlaHistoryPayload>
          }
          findMany: {
            args: Prisma.VipSlaHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipSlaHistoryPayload>[]
          }
          create: {
            args: Prisma.VipSlaHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipSlaHistoryPayload>
          }
          createMany: {
            args: Prisma.VipSlaHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VipSlaHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipSlaHistoryPayload>[]
          }
          delete: {
            args: Prisma.VipSlaHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipSlaHistoryPayload>
          }
          update: {
            args: Prisma.VipSlaHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipSlaHistoryPayload>
          }
          deleteMany: {
            args: Prisma.VipSlaHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VipSlaHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VipSlaHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipSlaHistoryPayload>[]
          }
          upsert: {
            args: Prisma.VipSlaHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipSlaHistoryPayload>
          }
          aggregate: {
            args: Prisma.VipSlaHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVipSlaHistory>
          }
          groupBy: {
            args: Prisma.VipSlaHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<VipSlaHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.VipSlaHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<VipSlaHistoryCountAggregateOutputType> | number
          }
        }
      }
      AgentAvailability: {
        payload: Prisma.$AgentAvailabilityPayload<ExtArgs>
        fields: Prisma.AgentAvailabilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentAvailabilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentAvailabilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentAvailabilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentAvailabilityPayload>
          }
          findFirst: {
            args: Prisma.AgentAvailabilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentAvailabilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentAvailabilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentAvailabilityPayload>
          }
          findMany: {
            args: Prisma.AgentAvailabilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentAvailabilityPayload>[]
          }
          create: {
            args: Prisma.AgentAvailabilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentAvailabilityPayload>
          }
          createMany: {
            args: Prisma.AgentAvailabilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentAvailabilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentAvailabilityPayload>[]
          }
          delete: {
            args: Prisma.AgentAvailabilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentAvailabilityPayload>
          }
          update: {
            args: Prisma.AgentAvailabilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentAvailabilityPayload>
          }
          deleteMany: {
            args: Prisma.AgentAvailabilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentAvailabilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentAvailabilityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentAvailabilityPayload>[]
          }
          upsert: {
            args: Prisma.AgentAvailabilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentAvailabilityPayload>
          }
          aggregate: {
            args: Prisma.AgentAvailabilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgentAvailability>
          }
          groupBy: {
            args: Prisma.AgentAvailabilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentAvailabilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentAvailabilityCountArgs<ExtArgs>
            result: $Utils.Optional<AgentAvailabilityCountAggregateOutputType> | number
          }
        }
      }
      QueueMetrics: {
        payload: Prisma.$QueueMetricsPayload<ExtArgs>
        fields: Prisma.QueueMetricsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QueueMetricsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueMetricsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QueueMetricsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueMetricsPayload>
          }
          findFirst: {
            args: Prisma.QueueMetricsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueMetricsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QueueMetricsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueMetricsPayload>
          }
          findMany: {
            args: Prisma.QueueMetricsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueMetricsPayload>[]
          }
          create: {
            args: Prisma.QueueMetricsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueMetricsPayload>
          }
          createMany: {
            args: Prisma.QueueMetricsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QueueMetricsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueMetricsPayload>[]
          }
          delete: {
            args: Prisma.QueueMetricsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueMetricsPayload>
          }
          update: {
            args: Prisma.QueueMetricsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueMetricsPayload>
          }
          deleteMany: {
            args: Prisma.QueueMetricsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QueueMetricsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QueueMetricsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueMetricsPayload>[]
          }
          upsert: {
            args: Prisma.QueueMetricsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueMetricsPayload>
          }
          aggregate: {
            args: Prisma.QueueMetricsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQueueMetrics>
          }
          groupBy: {
            args: Prisma.QueueMetricsGroupByArgs<ExtArgs>
            result: $Utils.Optional<QueueMetricsGroupByOutputType>[]
          }
          count: {
            args: Prisma.QueueMetricsCountArgs<ExtArgs>
            result: $Utils.Optional<QueueMetricsCountAggregateOutputType> | number
          }
        }
      }
      QueueAlert: {
        payload: Prisma.$QueueAlertPayload<ExtArgs>
        fields: Prisma.QueueAlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QueueAlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueAlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QueueAlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueAlertPayload>
          }
          findFirst: {
            args: Prisma.QueueAlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueAlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QueueAlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueAlertPayload>
          }
          findMany: {
            args: Prisma.QueueAlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueAlertPayload>[]
          }
          create: {
            args: Prisma.QueueAlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueAlertPayload>
          }
          createMany: {
            args: Prisma.QueueAlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QueueAlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueAlertPayload>[]
          }
          delete: {
            args: Prisma.QueueAlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueAlertPayload>
          }
          update: {
            args: Prisma.QueueAlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueAlertPayload>
          }
          deleteMany: {
            args: Prisma.QueueAlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QueueAlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QueueAlertUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueAlertPayload>[]
          }
          upsert: {
            args: Prisma.QueueAlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueAlertPayload>
          }
          aggregate: {
            args: Prisma.QueueAlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQueueAlert>
          }
          groupBy: {
            args: Prisma.QueueAlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<QueueAlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.QueueAlertCountArgs<ExtArgs>
            result: $Utils.Optional<QueueAlertCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    role?: RoleOmit
    permission?: PermissionOmit
    userRole?: UserRoleOmit
    rolePermission?: RolePermissionOmit
    passkey?: PasskeyOmit
    log?: LogOmit
    config?: ConfigOmit
    configHistory?: ConfigHistoryOmit
    configTemplate?: ConfigTemplateOmit
    kiosk?: KioskOmit
    feedback?: FeedbackOmit
    notification?: NotificationOmit
    directoryIntegration?: DirectoryIntegrationOmit
    asset?: AssetOmit
    kioskActivation?: KioskActivationOmit
    ssoConfiguration?: SsoConfigurationOmit
    adminPin?: AdminPinOmit
    kbArticle?: KbArticleOmit
    kbArticleVersion?: KbArticleVersionOmit
    kbArticleComment?: KbArticleCommentOmit
    supportTicket?: SupportTicketOmit
    inventoryAsset?: InventoryAssetOmit
    assetStatusLog?: AssetStatusLogOmit
    assetAssignment?: AssetAssignmentOmit
    assetTicketHistory?: AssetTicketHistoryOmit
    assetWarrantyAlert?: AssetWarrantyAlertOmit
    assetImportBatch?: AssetImportBatchOmit
    assetValidationLog?: AssetValidationLogOmit
    kioskAssetRegistry?: KioskAssetRegistryOmit
    helixSyncFailure?: HelixSyncFailureOmit
    kioskOrganizationAssignment?: KioskOrganizationAssignmentOmit
    kioskMetadataLog?: KioskMetadataLogOmit
    xpEvent?: XpEventOmit
    leaderboard?: LeaderboardOmit
    scimMapping?: ScimMappingOmit
    scimLog?: ScimLogOmit
    mailroomPackage?: MailroomPackageOmit
    deliveryEvent?: DeliveryEventOmit
    proxyAuthorization?: ProxyAuthorizationOmit
    requestCatalogItem?: RequestCatalogItemOmit
    rITM?: RITMOmit
    vipProxy?: VipProxyOmit
    vipSlaHistory?: VipSlaHistoryOmit
    agentAvailability?: AgentAvailabilityOmit
    queueMetrics?: QueueMetricsOmit
    queueAlert?: QueueAlertOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    feedback: number
    logs: number
    passkeys: number
    support_tickets_support_tickets_assigneeIdTousers: number
    support_tickets_support_tickets_userIdTousers: number
    roles: number
    scimMappings: number
    kbArticlesAuthored: number
    kbArticleVersionsAuthored: number
    kbArticleComments: number
    xpEvents: number
    mailroomPackages: number
    deliveryEvents: number
    proxyAuthorizationsAsRecipient: number
    proxyAuthorizationsAsProxy: number
    vipProxiesAsVip: number
    vipProxiesAsProxy: number
    vipSlaHistory: number
    agentAvailability: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feedback?: boolean | UserCountOutputTypeCountFeedbackArgs
    logs?: boolean | UserCountOutputTypeCountLogsArgs
    passkeys?: boolean | UserCountOutputTypeCountPasskeysArgs
    support_tickets_support_tickets_assigneeIdTousers?: boolean | UserCountOutputTypeCountSupport_tickets_support_tickets_assigneeIdTousersArgs
    support_tickets_support_tickets_userIdTousers?: boolean | UserCountOutputTypeCountSupport_tickets_support_tickets_userIdTousersArgs
    roles?: boolean | UserCountOutputTypeCountRolesArgs
    scimMappings?: boolean | UserCountOutputTypeCountScimMappingsArgs
    kbArticlesAuthored?: boolean | UserCountOutputTypeCountKbArticlesAuthoredArgs
    kbArticleVersionsAuthored?: boolean | UserCountOutputTypeCountKbArticleVersionsAuthoredArgs
    kbArticleComments?: boolean | UserCountOutputTypeCountKbArticleCommentsArgs
    xpEvents?: boolean | UserCountOutputTypeCountXpEventsArgs
    mailroomPackages?: boolean | UserCountOutputTypeCountMailroomPackagesArgs
    deliveryEvents?: boolean | UserCountOutputTypeCountDeliveryEventsArgs
    proxyAuthorizationsAsRecipient?: boolean | UserCountOutputTypeCountProxyAuthorizationsAsRecipientArgs
    proxyAuthorizationsAsProxy?: boolean | UserCountOutputTypeCountProxyAuthorizationsAsProxyArgs
    vipProxiesAsVip?: boolean | UserCountOutputTypeCountVipProxiesAsVipArgs
    vipProxiesAsProxy?: boolean | UserCountOutputTypeCountVipProxiesAsProxyArgs
    vipSlaHistory?: boolean | UserCountOutputTypeCountVipSlaHistoryArgs
    agentAvailability?: boolean | UserCountOutputTypeCountAgentAvailabilityArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasskeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasskeyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSupport_tickets_support_tickets_assigneeIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSupport_tickets_support_tickets_userIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountScimMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScimMappingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountKbArticlesAuthoredArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KbArticleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountKbArticleVersionsAuthoredArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KbArticleVersionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountKbArticleCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KbArticleCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountXpEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XpEventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMailroomPackagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MailroomPackageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeliveryEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryEventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProxyAuthorizationsAsRecipientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProxyAuthorizationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProxyAuthorizationsAsProxyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProxyAuthorizationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVipProxiesAsVipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VipProxyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVipProxiesAsProxyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VipProxyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVipSlaHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VipSlaHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAgentAvailabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentAvailabilityWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    permissions: number
    users: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | RoleCountOutputTypeCountPermissionsArgs
    users?: boolean | RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    roles: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | PermissionCountOutputTypeCountRolesArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Count Type ConfigCountOutputType
   */

  export type ConfigCountOutputType = {
    history: number
  }

  export type ConfigCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    history?: boolean | ConfigCountOutputTypeCountHistoryArgs
  }

  // Custom InputTypes
  /**
   * ConfigCountOutputType without action
   */
  export type ConfigCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigCountOutputType
     */
    select?: ConfigCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConfigCountOutputType without action
   */
  export type ConfigCountOutputTypeCountHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigHistoryWhereInput
  }


  /**
   * Count Type KioskCountOutputType
   */

  export type KioskCountOutputType = {
    activations: number
    assetRegistry: number
    syncFailures: number
    metadataLogs: number
  }

  export type KioskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activations?: boolean | KioskCountOutputTypeCountActivationsArgs
    assetRegistry?: boolean | KioskCountOutputTypeCountAssetRegistryArgs
    syncFailures?: boolean | KioskCountOutputTypeCountSyncFailuresArgs
    metadataLogs?: boolean | KioskCountOutputTypeCountMetadataLogsArgs
  }

  // Custom InputTypes
  /**
   * KioskCountOutputType without action
   */
  export type KioskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskCountOutputType
     */
    select?: KioskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KioskCountOutputType without action
   */
  export type KioskCountOutputTypeCountActivationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KioskActivationWhereInput
  }

  /**
   * KioskCountOutputType without action
   */
  export type KioskCountOutputTypeCountAssetRegistryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KioskAssetRegistryWhereInput
  }

  /**
   * KioskCountOutputType without action
   */
  export type KioskCountOutputTypeCountSyncFailuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelixSyncFailureWhereInput
  }

  /**
   * KioskCountOutputType without action
   */
  export type KioskCountOutputTypeCountMetadataLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KioskMetadataLogWhereInput
  }


  /**
   * Count Type KbArticleCountOutputType
   */

  export type KbArticleCountOutputType = {
    versions: number
    comments: number
  }

  export type KbArticleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    versions?: boolean | KbArticleCountOutputTypeCountVersionsArgs
    comments?: boolean | KbArticleCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * KbArticleCountOutputType without action
   */
  export type KbArticleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticleCountOutputType
     */
    select?: KbArticleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KbArticleCountOutputType without action
   */
  export type KbArticleCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KbArticleVersionWhereInput
  }

  /**
   * KbArticleCountOutputType without action
   */
  export type KbArticleCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KbArticleCommentWhereInput
  }


  /**
   * Count Type KbArticleVersionCountOutputType
   */

  export type KbArticleVersionCountOutputType = {
    currentForArticle: number
  }

  export type KbArticleVersionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currentForArticle?: boolean | KbArticleVersionCountOutputTypeCountCurrentForArticleArgs
  }

  // Custom InputTypes
  /**
   * KbArticleVersionCountOutputType without action
   */
  export type KbArticleVersionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticleVersionCountOutputType
     */
    select?: KbArticleVersionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KbArticleVersionCountOutputType without action
   */
  export type KbArticleVersionCountOutputTypeCountCurrentForArticleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KbArticleWhereInput
  }


  /**
   * Count Type SupportTicketCountOutputType
   */

  export type SupportTicketCountOutputType = {
    mailroomPackages: number
    assetHistory: number
    ritms: number
  }

  export type SupportTicketCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mailroomPackages?: boolean | SupportTicketCountOutputTypeCountMailroomPackagesArgs
    assetHistory?: boolean | SupportTicketCountOutputTypeCountAssetHistoryArgs
    ritms?: boolean | SupportTicketCountOutputTypeCountRitmsArgs
  }

  // Custom InputTypes
  /**
   * SupportTicketCountOutputType without action
   */
  export type SupportTicketCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicketCountOutputType
     */
    select?: SupportTicketCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupportTicketCountOutputType without action
   */
  export type SupportTicketCountOutputTypeCountMailroomPackagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MailroomPackageWhereInput
  }

  /**
   * SupportTicketCountOutputType without action
   */
  export type SupportTicketCountOutputTypeCountAssetHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetTicketHistoryWhereInput
  }

  /**
   * SupportTicketCountOutputType without action
   */
  export type SupportTicketCountOutputTypeCountRitmsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RITMWhereInput
  }


  /**
   * Count Type InventoryAssetCountOutputType
   */

  export type InventoryAssetCountOutputType = {
    statusLogs: number
    assignments: number
    mailroomPackages: number
    ticketHistory: number
    warrantyAlerts: number
    kioskRegistrations: number
    validationLogs: number
    syncFailures: number
  }

  export type InventoryAssetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    statusLogs?: boolean | InventoryAssetCountOutputTypeCountStatusLogsArgs
    assignments?: boolean | InventoryAssetCountOutputTypeCountAssignmentsArgs
    mailroomPackages?: boolean | InventoryAssetCountOutputTypeCountMailroomPackagesArgs
    ticketHistory?: boolean | InventoryAssetCountOutputTypeCountTicketHistoryArgs
    warrantyAlerts?: boolean | InventoryAssetCountOutputTypeCountWarrantyAlertsArgs
    kioskRegistrations?: boolean | InventoryAssetCountOutputTypeCountKioskRegistrationsArgs
    validationLogs?: boolean | InventoryAssetCountOutputTypeCountValidationLogsArgs
    syncFailures?: boolean | InventoryAssetCountOutputTypeCountSyncFailuresArgs
  }

  // Custom InputTypes
  /**
   * InventoryAssetCountOutputType without action
   */
  export type InventoryAssetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAssetCountOutputType
     */
    select?: InventoryAssetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InventoryAssetCountOutputType without action
   */
  export type InventoryAssetCountOutputTypeCountStatusLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetStatusLogWhereInput
  }

  /**
   * InventoryAssetCountOutputType without action
   */
  export type InventoryAssetCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetAssignmentWhereInput
  }

  /**
   * InventoryAssetCountOutputType without action
   */
  export type InventoryAssetCountOutputTypeCountMailroomPackagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MailroomPackageWhereInput
  }

  /**
   * InventoryAssetCountOutputType without action
   */
  export type InventoryAssetCountOutputTypeCountTicketHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetTicketHistoryWhereInput
  }

  /**
   * InventoryAssetCountOutputType without action
   */
  export type InventoryAssetCountOutputTypeCountWarrantyAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWarrantyAlertWhereInput
  }

  /**
   * InventoryAssetCountOutputType without action
   */
  export type InventoryAssetCountOutputTypeCountKioskRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KioskAssetRegistryWhereInput
  }

  /**
   * InventoryAssetCountOutputType without action
   */
  export type InventoryAssetCountOutputTypeCountValidationLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetValidationLogWhereInput
  }

  /**
   * InventoryAssetCountOutputType without action
   */
  export type InventoryAssetCountOutputTypeCountSyncFailuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelixSyncFailureWhereInput
  }


  /**
   * Count Type AssetImportBatchCountOutputType
   */

  export type AssetImportBatchCountOutputType = {
    assets: number
    validationLogs: number
  }

  export type AssetImportBatchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assets?: boolean | AssetImportBatchCountOutputTypeCountAssetsArgs
    validationLogs?: boolean | AssetImportBatchCountOutputTypeCountValidationLogsArgs
  }

  // Custom InputTypes
  /**
   * AssetImportBatchCountOutputType without action
   */
  export type AssetImportBatchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetImportBatchCountOutputType
     */
    select?: AssetImportBatchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssetImportBatchCountOutputType without action
   */
  export type AssetImportBatchCountOutputTypeCountAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryAssetWhereInput
  }

  /**
   * AssetImportBatchCountOutputType without action
   */
  export type AssetImportBatchCountOutputTypeCountValidationLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetValidationLogWhereInput
  }


  /**
   * Count Type MailroomPackageCountOutputType
   */

  export type MailroomPackageCountOutputType = {
    deliveryEvents: number
    proxyAuthorizations: number
  }

  export type MailroomPackageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliveryEvents?: boolean | MailroomPackageCountOutputTypeCountDeliveryEventsArgs
    proxyAuthorizations?: boolean | MailroomPackageCountOutputTypeCountProxyAuthorizationsArgs
  }

  // Custom InputTypes
  /**
   * MailroomPackageCountOutputType without action
   */
  export type MailroomPackageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailroomPackageCountOutputType
     */
    select?: MailroomPackageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MailroomPackageCountOutputType without action
   */
  export type MailroomPackageCountOutputTypeCountDeliveryEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryEventWhereInput
  }

  /**
   * MailroomPackageCountOutputType without action
   */
  export type MailroomPackageCountOutputTypeCountProxyAuthorizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProxyAuthorizationWhereInput
  }


  /**
   * Count Type RequestCatalogItemCountOutputType
   */

  export type RequestCatalogItemCountOutputType = {
    ritms: number
  }

  export type RequestCatalogItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ritms?: boolean | RequestCatalogItemCountOutputTypeCountRitmsArgs
  }

  // Custom InputTypes
  /**
   * RequestCatalogItemCountOutputType without action
   */
  export type RequestCatalogItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestCatalogItemCountOutputType
     */
    select?: RequestCatalogItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RequestCatalogItemCountOutputType without action
   */
  export type RequestCatalogItemCountOutputTypeCountRitmsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RITMWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    passwordHash: string | null
    disabled: boolean | null
    isDefault: boolean | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    twoFactorEnabled: boolean | null
    twoFactorSecret: string | null
    twoFactorVerified: boolean | null
    samlNameId: string | null
    samlSessionIndex: string | null
    scimExternalId: string | null
    department: string | null
    lastSamlLogin: Date | null
    isVip: boolean | null
    vipLevel: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    passwordHash: string | null
    disabled: boolean | null
    isDefault: boolean | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    twoFactorEnabled: boolean | null
    twoFactorSecret: string | null
    twoFactorVerified: boolean | null
    samlNameId: string | null
    samlSessionIndex: string | null
    scimExternalId: string | null
    department: string | null
    lastSamlLogin: Date | null
    isVip: boolean | null
    vipLevel: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    passwordHash: number
    disabled: number
    isDefault: number
    lastLogin: number
    createdAt: number
    updatedAt: number
    twoFactorEnabled: number
    twoFactorSecret: number
    twoFactorBackupCodes: number
    twoFactorVerified: number
    samlNameId: number
    samlSessionIndex: number
    scimExternalId: number
    department: number
    lastSamlLogin: number
    isVip: number
    vipLevel: number
    vipSlaOverride: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    passwordHash?: true
    disabled?: true
    isDefault?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    twoFactorVerified?: true
    samlNameId?: true
    samlSessionIndex?: true
    scimExternalId?: true
    department?: true
    lastSamlLogin?: true
    isVip?: true
    vipLevel?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    passwordHash?: true
    disabled?: true
    isDefault?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    twoFactorVerified?: true
    samlNameId?: true
    samlSessionIndex?: true
    scimExternalId?: true
    department?: true
    lastSamlLogin?: true
    isVip?: true
    vipLevel?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    passwordHash?: true
    disabled?: true
    isDefault?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    twoFactorBackupCodes?: true
    twoFactorVerified?: true
    samlNameId?: true
    samlSessionIndex?: true
    scimExternalId?: true
    department?: true
    lastSamlLogin?: true
    isVip?: true
    vipLevel?: true
    vipSlaOverride?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string
    passwordHash: string | null
    disabled: boolean
    isDefault: boolean
    lastLogin: Date | null
    createdAt: Date
    updatedAt: Date
    twoFactorEnabled: boolean
    twoFactorSecret: string | null
    twoFactorBackupCodes: JsonValue | null
    twoFactorVerified: boolean
    samlNameId: string | null
    samlSessionIndex: string | null
    scimExternalId: string | null
    department: string | null
    lastSamlLogin: Date | null
    isVip: boolean
    vipLevel: string | null
    vipSlaOverride: JsonValue | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    twoFactorBackupCodes?: boolean
    twoFactorVerified?: boolean
    samlNameId?: boolean
    samlSessionIndex?: boolean
    scimExternalId?: boolean
    department?: boolean
    lastSamlLogin?: boolean
    isVip?: boolean
    vipLevel?: boolean
    vipSlaOverride?: boolean
    feedback?: boolean | User$feedbackArgs<ExtArgs>
    logs?: boolean | User$logsArgs<ExtArgs>
    passkeys?: boolean | User$passkeysArgs<ExtArgs>
    support_tickets_support_tickets_assigneeIdTousers?: boolean | User$support_tickets_support_tickets_assigneeIdTousersArgs<ExtArgs>
    support_tickets_support_tickets_userIdTousers?: boolean | User$support_tickets_support_tickets_userIdTousersArgs<ExtArgs>
    roles?: boolean | User$rolesArgs<ExtArgs>
    scimMappings?: boolean | User$scimMappingsArgs<ExtArgs>
    kbArticlesAuthored?: boolean | User$kbArticlesAuthoredArgs<ExtArgs>
    kbArticleVersionsAuthored?: boolean | User$kbArticleVersionsAuthoredArgs<ExtArgs>
    kbArticleComments?: boolean | User$kbArticleCommentsArgs<ExtArgs>
    xpEvents?: boolean | User$xpEventsArgs<ExtArgs>
    leaderboard?: boolean | User$leaderboardArgs<ExtArgs>
    mailroomPackages?: boolean | User$mailroomPackagesArgs<ExtArgs>
    deliveryEvents?: boolean | User$deliveryEventsArgs<ExtArgs>
    proxyAuthorizationsAsRecipient?: boolean | User$proxyAuthorizationsAsRecipientArgs<ExtArgs>
    proxyAuthorizationsAsProxy?: boolean | User$proxyAuthorizationsAsProxyArgs<ExtArgs>
    vipProxiesAsVip?: boolean | User$vipProxiesAsVipArgs<ExtArgs>
    vipProxiesAsProxy?: boolean | User$vipProxiesAsProxyArgs<ExtArgs>
    vipSlaHistory?: boolean | User$vipSlaHistoryArgs<ExtArgs>
    agentAvailability?: boolean | User$agentAvailabilityArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    twoFactorBackupCodes?: boolean
    twoFactorVerified?: boolean
    samlNameId?: boolean
    samlSessionIndex?: boolean
    scimExternalId?: boolean
    department?: boolean
    lastSamlLogin?: boolean
    isVip?: boolean
    vipLevel?: boolean
    vipSlaOverride?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    twoFactorBackupCodes?: boolean
    twoFactorVerified?: boolean
    samlNameId?: boolean
    samlSessionIndex?: boolean
    scimExternalId?: boolean
    department?: boolean
    lastSamlLogin?: boolean
    isVip?: boolean
    vipLevel?: boolean
    vipSlaOverride?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    twoFactorBackupCodes?: boolean
    twoFactorVerified?: boolean
    samlNameId?: boolean
    samlSessionIndex?: boolean
    scimExternalId?: boolean
    department?: boolean
    lastSamlLogin?: boolean
    isVip?: boolean
    vipLevel?: boolean
    vipSlaOverride?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "passwordHash" | "disabled" | "isDefault" | "lastLogin" | "createdAt" | "updatedAt" | "twoFactorEnabled" | "twoFactorSecret" | "twoFactorBackupCodes" | "twoFactorVerified" | "samlNameId" | "samlSessionIndex" | "scimExternalId" | "department" | "lastSamlLogin" | "isVip" | "vipLevel" | "vipSlaOverride", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feedback?: boolean | User$feedbackArgs<ExtArgs>
    logs?: boolean | User$logsArgs<ExtArgs>
    passkeys?: boolean | User$passkeysArgs<ExtArgs>
    support_tickets_support_tickets_assigneeIdTousers?: boolean | User$support_tickets_support_tickets_assigneeIdTousersArgs<ExtArgs>
    support_tickets_support_tickets_userIdTousers?: boolean | User$support_tickets_support_tickets_userIdTousersArgs<ExtArgs>
    roles?: boolean | User$rolesArgs<ExtArgs>
    scimMappings?: boolean | User$scimMappingsArgs<ExtArgs>
    kbArticlesAuthored?: boolean | User$kbArticlesAuthoredArgs<ExtArgs>
    kbArticleVersionsAuthored?: boolean | User$kbArticleVersionsAuthoredArgs<ExtArgs>
    kbArticleComments?: boolean | User$kbArticleCommentsArgs<ExtArgs>
    xpEvents?: boolean | User$xpEventsArgs<ExtArgs>
    leaderboard?: boolean | User$leaderboardArgs<ExtArgs>
    mailroomPackages?: boolean | User$mailroomPackagesArgs<ExtArgs>
    deliveryEvents?: boolean | User$deliveryEventsArgs<ExtArgs>
    proxyAuthorizationsAsRecipient?: boolean | User$proxyAuthorizationsAsRecipientArgs<ExtArgs>
    proxyAuthorizationsAsProxy?: boolean | User$proxyAuthorizationsAsProxyArgs<ExtArgs>
    vipProxiesAsVip?: boolean | User$vipProxiesAsVipArgs<ExtArgs>
    vipProxiesAsProxy?: boolean | User$vipProxiesAsProxyArgs<ExtArgs>
    vipSlaHistory?: boolean | User$vipSlaHistoryArgs<ExtArgs>
    agentAvailability?: boolean | User$agentAvailabilityArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      feedback: Prisma.$FeedbackPayload<ExtArgs>[]
      logs: Prisma.$LogPayload<ExtArgs>[]
      passkeys: Prisma.$PasskeyPayload<ExtArgs>[]
      support_tickets_support_tickets_assigneeIdTousers: Prisma.$SupportTicketPayload<ExtArgs>[]
      support_tickets_support_tickets_userIdTousers: Prisma.$SupportTicketPayload<ExtArgs>[]
      roles: Prisma.$UserRolePayload<ExtArgs>[]
      scimMappings: Prisma.$ScimMappingPayload<ExtArgs>[]
      kbArticlesAuthored: Prisma.$KbArticlePayload<ExtArgs>[]
      kbArticleVersionsAuthored: Prisma.$KbArticleVersionPayload<ExtArgs>[]
      kbArticleComments: Prisma.$KbArticleCommentPayload<ExtArgs>[]
      xpEvents: Prisma.$XpEventPayload<ExtArgs>[]
      leaderboard: Prisma.$LeaderboardPayload<ExtArgs> | null
      mailroomPackages: Prisma.$MailroomPackagePayload<ExtArgs>[]
      deliveryEvents: Prisma.$DeliveryEventPayload<ExtArgs>[]
      proxyAuthorizationsAsRecipient: Prisma.$ProxyAuthorizationPayload<ExtArgs>[]
      proxyAuthorizationsAsProxy: Prisma.$ProxyAuthorizationPayload<ExtArgs>[]
      vipProxiesAsVip: Prisma.$VipProxyPayload<ExtArgs>[]
      vipProxiesAsProxy: Prisma.$VipProxyPayload<ExtArgs>[]
      vipSlaHistory: Prisma.$VipSlaHistoryPayload<ExtArgs>[]
      agentAvailability: Prisma.$AgentAvailabilityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string
      passwordHash: string | null
      disabled: boolean
      isDefault: boolean
      lastLogin: Date | null
      createdAt: Date
      updatedAt: Date
      twoFactorEnabled: boolean
      twoFactorSecret: string | null
      twoFactorBackupCodes: Prisma.JsonValue | null
      twoFactorVerified: boolean
      samlNameId: string | null
      samlSessionIndex: string | null
      scimExternalId: string | null
      department: string | null
      lastSamlLogin: Date | null
      isVip: boolean
      vipLevel: string | null
      vipSlaOverride: Prisma.JsonValue | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feedback<T extends User$feedbackArgs<ExtArgs> = {}>(args?: Subset<T, User$feedbackArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    logs<T extends User$logsArgs<ExtArgs> = {}>(args?: Subset<T, User$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passkeys<T extends User$passkeysArgs<ExtArgs> = {}>(args?: Subset<T, User$passkeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    support_tickets_support_tickets_assigneeIdTousers<T extends User$support_tickets_support_tickets_assigneeIdTousersArgs<ExtArgs> = {}>(args?: Subset<T, User$support_tickets_support_tickets_assigneeIdTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    support_tickets_support_tickets_userIdTousers<T extends User$support_tickets_support_tickets_userIdTousersArgs<ExtArgs> = {}>(args?: Subset<T, User$support_tickets_support_tickets_userIdTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roles<T extends User$rolesArgs<ExtArgs> = {}>(args?: Subset<T, User$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    scimMappings<T extends User$scimMappingsArgs<ExtArgs> = {}>(args?: Subset<T, User$scimMappingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScimMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    kbArticlesAuthored<T extends User$kbArticlesAuthoredArgs<ExtArgs> = {}>(args?: Subset<T, User$kbArticlesAuthoredArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KbArticlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    kbArticleVersionsAuthored<T extends User$kbArticleVersionsAuthoredArgs<ExtArgs> = {}>(args?: Subset<T, User$kbArticleVersionsAuthoredArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KbArticleVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    kbArticleComments<T extends User$kbArticleCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$kbArticleCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KbArticleCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    xpEvents<T extends User$xpEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$xpEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XpEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leaderboard<T extends User$leaderboardArgs<ExtArgs> = {}>(args?: Subset<T, User$leaderboardArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    mailroomPackages<T extends User$mailroomPackagesArgs<ExtArgs> = {}>(args?: Subset<T, User$mailroomPackagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MailroomPackagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deliveryEvents<T extends User$deliveryEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$deliveryEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    proxyAuthorizationsAsRecipient<T extends User$proxyAuthorizationsAsRecipientArgs<ExtArgs> = {}>(args?: Subset<T, User$proxyAuthorizationsAsRecipientArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxyAuthorizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    proxyAuthorizationsAsProxy<T extends User$proxyAuthorizationsAsProxyArgs<ExtArgs> = {}>(args?: Subset<T, User$proxyAuthorizationsAsProxyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxyAuthorizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vipProxiesAsVip<T extends User$vipProxiesAsVipArgs<ExtArgs> = {}>(args?: Subset<T, User$vipProxiesAsVipArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VipProxyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vipProxiesAsProxy<T extends User$vipProxiesAsProxyArgs<ExtArgs> = {}>(args?: Subset<T, User$vipProxiesAsProxyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VipProxyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vipSlaHistory<T extends User$vipSlaHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$vipSlaHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VipSlaHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    agentAvailability<T extends User$agentAvailabilityArgs<ExtArgs> = {}>(args?: Subset<T, User$agentAvailabilityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentAvailabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly disabled: FieldRef<"User", 'Boolean'>
    readonly isDefault: FieldRef<"User", 'Boolean'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly twoFactorEnabled: FieldRef<"User", 'Boolean'>
    readonly twoFactorSecret: FieldRef<"User", 'String'>
    readonly twoFactorBackupCodes: FieldRef<"User", 'Json'>
    readonly twoFactorVerified: FieldRef<"User", 'Boolean'>
    readonly samlNameId: FieldRef<"User", 'String'>
    readonly samlSessionIndex: FieldRef<"User", 'String'>
    readonly scimExternalId: FieldRef<"User", 'String'>
    readonly department: FieldRef<"User", 'String'>
    readonly lastSamlLogin: FieldRef<"User", 'DateTime'>
    readonly isVip: FieldRef<"User", 'Boolean'>
    readonly vipLevel: FieldRef<"User", 'String'>
    readonly vipSlaOverride: FieldRef<"User", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.feedback
   */
  export type User$feedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    cursor?: FeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * User.logs
   */
  export type User$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    where?: LogWhereInput
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    cursor?: LogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * User.passkeys
   */
  export type User$passkeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyInclude<ExtArgs> | null
    where?: PasskeyWhereInput
    orderBy?: PasskeyOrderByWithRelationInput | PasskeyOrderByWithRelationInput[]
    cursor?: PasskeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasskeyScalarFieldEnum | PasskeyScalarFieldEnum[]
  }

  /**
   * User.support_tickets_support_tickets_assigneeIdTousers
   */
  export type User$support_tickets_support_tickets_assigneeIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    cursor?: SupportTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * User.support_tickets_support_tickets_userIdTousers
   */
  export type User$support_tickets_support_tickets_userIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    cursor?: SupportTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * User.roles
   */
  export type User$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * User.scimMappings
   */
  export type User$scimMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScimMapping
     */
    select?: ScimMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScimMapping
     */
    omit?: ScimMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScimMappingInclude<ExtArgs> | null
    where?: ScimMappingWhereInput
    orderBy?: ScimMappingOrderByWithRelationInput | ScimMappingOrderByWithRelationInput[]
    cursor?: ScimMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScimMappingScalarFieldEnum | ScimMappingScalarFieldEnum[]
  }

  /**
   * User.kbArticlesAuthored
   */
  export type User$kbArticlesAuthoredArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticle
     */
    select?: KbArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticle
     */
    omit?: KbArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleInclude<ExtArgs> | null
    where?: KbArticleWhereInput
    orderBy?: KbArticleOrderByWithRelationInput | KbArticleOrderByWithRelationInput[]
    cursor?: KbArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KbArticleScalarFieldEnum | KbArticleScalarFieldEnum[]
  }

  /**
   * User.kbArticleVersionsAuthored
   */
  export type User$kbArticleVersionsAuthoredArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticleVersion
     */
    select?: KbArticleVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticleVersion
     */
    omit?: KbArticleVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleVersionInclude<ExtArgs> | null
    where?: KbArticleVersionWhereInput
    orderBy?: KbArticleVersionOrderByWithRelationInput | KbArticleVersionOrderByWithRelationInput[]
    cursor?: KbArticleVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KbArticleVersionScalarFieldEnum | KbArticleVersionScalarFieldEnum[]
  }

  /**
   * User.kbArticleComments
   */
  export type User$kbArticleCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticleComment
     */
    select?: KbArticleCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticleComment
     */
    omit?: KbArticleCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleCommentInclude<ExtArgs> | null
    where?: KbArticleCommentWhereInput
    orderBy?: KbArticleCommentOrderByWithRelationInput | KbArticleCommentOrderByWithRelationInput[]
    cursor?: KbArticleCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KbArticleCommentScalarFieldEnum | KbArticleCommentScalarFieldEnum[]
  }

  /**
   * User.xpEvents
   */
  export type User$xpEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XpEvent
     */
    select?: XpEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XpEvent
     */
    omit?: XpEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XpEventInclude<ExtArgs> | null
    where?: XpEventWhereInput
    orderBy?: XpEventOrderByWithRelationInput | XpEventOrderByWithRelationInput[]
    cursor?: XpEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: XpEventScalarFieldEnum | XpEventScalarFieldEnum[]
  }

  /**
   * User.leaderboard
   */
  export type User$leaderboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leaderboard
     */
    omit?: LeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    where?: LeaderboardWhereInput
  }

  /**
   * User.mailroomPackages
   */
  export type User$mailroomPackagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailroomPackage
     */
    select?: MailroomPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MailroomPackage
     */
    omit?: MailroomPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailroomPackageInclude<ExtArgs> | null
    where?: MailroomPackageWhereInput
    orderBy?: MailroomPackageOrderByWithRelationInput | MailroomPackageOrderByWithRelationInput[]
    cursor?: MailroomPackageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MailroomPackageScalarFieldEnum | MailroomPackageScalarFieldEnum[]
  }

  /**
   * User.deliveryEvents
   */
  export type User$deliveryEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEvent
     */
    select?: DeliveryEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEvent
     */
    omit?: DeliveryEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEventInclude<ExtArgs> | null
    where?: DeliveryEventWhereInput
    orderBy?: DeliveryEventOrderByWithRelationInput | DeliveryEventOrderByWithRelationInput[]
    cursor?: DeliveryEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryEventScalarFieldEnum | DeliveryEventScalarFieldEnum[]
  }

  /**
   * User.proxyAuthorizationsAsRecipient
   */
  export type User$proxyAuthorizationsAsRecipientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyAuthorization
     */
    select?: ProxyAuthorizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyAuthorization
     */
    omit?: ProxyAuthorizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyAuthorizationInclude<ExtArgs> | null
    where?: ProxyAuthorizationWhereInput
    orderBy?: ProxyAuthorizationOrderByWithRelationInput | ProxyAuthorizationOrderByWithRelationInput[]
    cursor?: ProxyAuthorizationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProxyAuthorizationScalarFieldEnum | ProxyAuthorizationScalarFieldEnum[]
  }

  /**
   * User.proxyAuthorizationsAsProxy
   */
  export type User$proxyAuthorizationsAsProxyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyAuthorization
     */
    select?: ProxyAuthorizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyAuthorization
     */
    omit?: ProxyAuthorizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyAuthorizationInclude<ExtArgs> | null
    where?: ProxyAuthorizationWhereInput
    orderBy?: ProxyAuthorizationOrderByWithRelationInput | ProxyAuthorizationOrderByWithRelationInput[]
    cursor?: ProxyAuthorizationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProxyAuthorizationScalarFieldEnum | ProxyAuthorizationScalarFieldEnum[]
  }

  /**
   * User.vipProxiesAsVip
   */
  export type User$vipProxiesAsVipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipProxy
     */
    select?: VipProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipProxy
     */
    omit?: VipProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipProxyInclude<ExtArgs> | null
    where?: VipProxyWhereInput
    orderBy?: VipProxyOrderByWithRelationInput | VipProxyOrderByWithRelationInput[]
    cursor?: VipProxyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VipProxyScalarFieldEnum | VipProxyScalarFieldEnum[]
  }

  /**
   * User.vipProxiesAsProxy
   */
  export type User$vipProxiesAsProxyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipProxy
     */
    select?: VipProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipProxy
     */
    omit?: VipProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipProxyInclude<ExtArgs> | null
    where?: VipProxyWhereInput
    orderBy?: VipProxyOrderByWithRelationInput | VipProxyOrderByWithRelationInput[]
    cursor?: VipProxyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VipProxyScalarFieldEnum | VipProxyScalarFieldEnum[]
  }

  /**
   * User.vipSlaHistory
   */
  export type User$vipSlaHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipSlaHistory
     */
    select?: VipSlaHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipSlaHistory
     */
    omit?: VipSlaHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipSlaHistoryInclude<ExtArgs> | null
    where?: VipSlaHistoryWhereInput
    orderBy?: VipSlaHistoryOrderByWithRelationInput | VipSlaHistoryOrderByWithRelationInput[]
    cursor?: VipSlaHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VipSlaHistoryScalarFieldEnum | VipSlaHistoryScalarFieldEnum[]
  }

  /**
   * User.agentAvailability
   */
  export type User$agentAvailabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentAvailability
     */
    select?: AgentAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentAvailability
     */
    omit?: AgentAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentAvailabilityInclude<ExtArgs> | null
    where?: AgentAvailabilityWhereInput
    orderBy?: AgentAvailabilityOrderByWithRelationInput | AgentAvailabilityOrderByWithRelationInput[]
    cursor?: AgentAvailabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentAvailabilityScalarFieldEnum | AgentAvailabilityScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: number
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      permissions: Prisma.$RolePermissionPayload<ExtArgs>[]
      users: Prisma.$UserRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permissions<T extends Role$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, Role$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'Int'>
    readonly name: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.permissions
   */
  export type Role$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionAvgAggregateOutputType = {
    id: number | null
  }

  export type PermissionSumAggregateOutputType = {
    id: number | null
  }

  export type PermissionMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    resource: string | null
    action: string | null
    createdAt: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    resource: string | null
    action: string | null
    createdAt: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    resource: number
    action: number
    createdAt: number
    _all: number
  }


  export type PermissionAvgAggregateInputType = {
    id?: true
  }

  export type PermissionSumAggregateInputType = {
    id?: true
  }

  export type PermissionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    resource?: true
    action?: true
    createdAt?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    resource?: true
    action?: true
    createdAt?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    resource?: true
    action?: true
    createdAt?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _avg?: PermissionAvgAggregateInputType
    _sum?: PermissionSumAggregateInputType
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: number
    name: string
    description: string | null
    resource: string | null
    action: string | null
    createdAt: Date
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    resource?: boolean
    action?: boolean
    createdAt?: boolean
    roles?: boolean | Permission$rolesArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    resource?: boolean
    action?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    resource?: boolean
    action?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    resource?: boolean
    action?: boolean
    createdAt?: boolean
  }

  export type PermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "resource" | "action" | "createdAt", ExtArgs["result"]["permission"]>
  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | Permission$rolesArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      roles: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      resource: string | null
      action: string | null
      createdAt: Date
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions and returns the data updated in the database.
     * @param {PermissionUpdateManyAndReturnArgs} args - Arguments to update many Permissions.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, PermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends Permission$rolesArgs<ExtArgs> = {}>(args?: Subset<T, Permission$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'Int'>
    readonly name: FieldRef<"Permission", 'String'>
    readonly description: FieldRef<"Permission", 'String'>
    readonly resource: FieldRef<"Permission", 'String'>
    readonly action: FieldRef<"Permission", 'String'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission createManyAndReturn
   */
  export type PermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission updateManyAndReturn
   */
  export type PermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to delete.
     */
    limit?: number
  }

  /**
   * Permission.roles
   */
  export type Permission$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _avg: UserRoleAvgAggregateOutputType | null
    _sum: UserRoleSumAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleAvgAggregateOutputType = {
    roleId: number | null
  }

  export type UserRoleSumAggregateOutputType = {
    roleId: number | null
  }

  export type UserRoleMinAggregateOutputType = {
    userId: string | null
    roleId: number | null
    assignedAt: Date | null
  }

  export type UserRoleMaxAggregateOutputType = {
    userId: string | null
    roleId: number | null
    assignedAt: Date | null
  }

  export type UserRoleCountAggregateOutputType = {
    userId: number
    roleId: number
    assignedAt: number
    _all: number
  }


  export type UserRoleAvgAggregateInputType = {
    roleId?: true
  }

  export type UserRoleSumAggregateInputType = {
    roleId?: true
  }

  export type UserRoleMinAggregateInputType = {
    userId?: true
    roleId?: true
    assignedAt?: true
  }

  export type UserRoleMaxAggregateInputType = {
    userId?: true
    roleId?: true
    assignedAt?: true
  }

  export type UserRoleCountAggregateInputType = {
    userId?: true
    roleId?: true
    assignedAt?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserRoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserRoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _avg?: UserRoleAvgAggregateInputType
    _sum?: UserRoleSumAggregateInputType
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    userId: string
    roleId: number
    assignedAt: Date
    _count: UserRoleCountAggregateOutputType | null
    _avg: UserRoleAvgAggregateOutputType | null
    _sum: UserRoleSumAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    assignedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    assignedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    assignedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectScalar = {
    userId?: boolean
    roleId?: boolean
    assignedAt?: boolean
  }

  export type UserRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "roleId" | "assignedAt", ExtArgs["result"]["userRole"]>
  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      roleId: number
      assignedAt: Date
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRoles and returns the data saved in the database.
     * @param {UserRoleCreateManyAndReturnArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRoles and only return the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles and returns the data updated in the database.
     * @param {UserRoleUpdateManyAndReturnArgs} args - Arguments to update many UserRoles.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserRoles and only return the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, UserRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */
  interface UserRoleFieldRefs {
    readonly userId: FieldRef<"UserRole", 'String'>
    readonly roleId: FieldRef<"UserRole", 'Int'>
    readonly assignedAt: FieldRef<"UserRole", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole createManyAndReturn
   */
  export type UserRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
  }

  /**
   * UserRole updateManyAndReturn
   */
  export type UserRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to delete.
     */
    limit?: number
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
  }


  /**
   * Model RolePermission
   */

  export type AggregateRolePermission = {
    _count: RolePermissionCountAggregateOutputType | null
    _avg: RolePermissionAvgAggregateOutputType | null
    _sum: RolePermissionSumAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  export type RolePermissionAvgAggregateOutputType = {
    roleId: number | null
    permissionId: number | null
  }

  export type RolePermissionSumAggregateOutputType = {
    roleId: number | null
    permissionId: number | null
  }

  export type RolePermissionMinAggregateOutputType = {
    roleId: number | null
    permissionId: number | null
    assignedAt: Date | null
  }

  export type RolePermissionMaxAggregateOutputType = {
    roleId: number | null
    permissionId: number | null
    assignedAt: Date | null
  }

  export type RolePermissionCountAggregateOutputType = {
    roleId: number
    permissionId: number
    assignedAt: number
    _all: number
  }


  export type RolePermissionAvgAggregateInputType = {
    roleId?: true
    permissionId?: true
  }

  export type RolePermissionSumAggregateInputType = {
    roleId?: true
    permissionId?: true
  }

  export type RolePermissionMinAggregateInputType = {
    roleId?: true
    permissionId?: true
    assignedAt?: true
  }

  export type RolePermissionMaxAggregateInputType = {
    roleId?: true
    permissionId?: true
    assignedAt?: true
  }

  export type RolePermissionCountAggregateInputType = {
    roleId?: true
    permissionId?: true
    assignedAt?: true
    _all?: true
  }

  export type RolePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermission to aggregate.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolePermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolePermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionMaxAggregateInputType
  }

  export type GetRolePermissionAggregateType<T extends RolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermission[P]>
      : GetScalarType<T[P], AggregateRolePermission[P]>
  }




  export type RolePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithAggregationInput | RolePermissionOrderByWithAggregationInput[]
    by: RolePermissionScalarFieldEnum[] | RolePermissionScalarFieldEnum
    having?: RolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionCountAggregateInputType | true
    _avg?: RolePermissionAvgAggregateInputType
    _sum?: RolePermissionSumAggregateInputType
    _min?: RolePermissionMinAggregateInputType
    _max?: RolePermissionMaxAggregateInputType
  }

  export type RolePermissionGroupByOutputType = {
    roleId: number
    permissionId: number
    assignedAt: Date
    _count: RolePermissionCountAggregateOutputType | null
    _avg: RolePermissionAvgAggregateOutputType | null
    _sum: RolePermissionSumAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  type GetRolePermissionGroupByPayload<T extends RolePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleId?: boolean
    permissionId?: boolean
    assignedAt?: boolean
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleId?: boolean
    permissionId?: boolean
    assignedAt?: boolean
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleId?: boolean
    permissionId?: boolean
    assignedAt?: boolean
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectScalar = {
    roleId?: boolean
    permissionId?: boolean
    assignedAt?: boolean
  }

  export type RolePermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"roleId" | "permissionId" | "assignedAt", ExtArgs["result"]["rolePermission"]>
  export type RolePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type RolePermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type RolePermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $RolePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePermission"
    objects: {
      permission: Prisma.$PermissionPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      roleId: number
      permissionId: number
      assignedAt: Date
    }, ExtArgs["result"]["rolePermission"]>
    composites: {}
  }

  type RolePermissionGetPayload<S extends boolean | null | undefined | RolePermissionDefaultArgs> = $Result.GetResult<Prisma.$RolePermissionPayload, S>

  type RolePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolePermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolePermissionCountAggregateInputType | true
    }

  export interface RolePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePermission'], meta: { name: 'RolePermission' } }
    /**
     * Find zero or one RolePermission that matches the filter.
     * @param {RolePermissionFindUniqueArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePermissionFindUniqueArgs>(args: SelectSubset<T, RolePermissionFindUniqueArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RolePermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolePermissionFindUniqueOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePermissionFindFirstArgs>(args?: SelectSubset<T, RolePermissionFindFirstArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany({ take: 10 })
     * 
     * // Only select the `roleId`
     * const rolePermissionWithRoleIdOnly = await prisma.rolePermission.findMany({ select: { roleId: true } })
     * 
     */
    findMany<T extends RolePermissionFindManyArgs>(args?: SelectSubset<T, RolePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RolePermission.
     * @param {RolePermissionCreateArgs} args - Arguments to create a RolePermission.
     * @example
     * // Create one RolePermission
     * const RolePermission = await prisma.rolePermission.create({
     *   data: {
     *     // ... data to create a RolePermission
     *   }
     * })
     * 
     */
    create<T extends RolePermissionCreateArgs>(args: SelectSubset<T, RolePermissionCreateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RolePermissions.
     * @param {RolePermissionCreateManyArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePermissionCreateManyArgs>(args?: SelectSubset<T, RolePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RolePermissions and returns the data saved in the database.
     * @param {RolePermissionCreateManyAndReturnArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RolePermissions and only return the `roleId`
     * const rolePermissionWithRoleIdOnly = await prisma.rolePermission.createManyAndReturn({
     *   select: { roleId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolePermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, RolePermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RolePermission.
     * @param {RolePermissionDeleteArgs} args - Arguments to delete one RolePermission.
     * @example
     * // Delete one RolePermission
     * const RolePermission = await prisma.rolePermission.delete({
     *   where: {
     *     // ... filter to delete one RolePermission
     *   }
     * })
     * 
     */
    delete<T extends RolePermissionDeleteArgs>(args: SelectSubset<T, RolePermissionDeleteArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RolePermission.
     * @param {RolePermissionUpdateArgs} args - Arguments to update one RolePermission.
     * @example
     * // Update one RolePermission
     * const rolePermission = await prisma.rolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePermissionUpdateArgs>(args: SelectSubset<T, RolePermissionUpdateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePermissionDeleteManyArgs>(args?: SelectSubset<T, RolePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePermissionUpdateManyArgs>(args: SelectSubset<T, RolePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions and returns the data updated in the database.
     * @param {RolePermissionUpdateManyAndReturnArgs} args - Arguments to update many RolePermissions.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RolePermissions and only return the `roleId`
     * const rolePermissionWithRoleIdOnly = await prisma.rolePermission.updateManyAndReturn({
     *   select: { roleId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RolePermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, RolePermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RolePermission.
     * @param {RolePermissionUpsertArgs} args - Arguments to update or create a RolePermission.
     * @example
     * // Update or create a RolePermission
     * const rolePermission = await prisma.rolePermission.upsert({
     *   create: {
     *     // ... data to create a RolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermission we want to update
     *   }
     * })
     */
    upsert<T extends RolePermissionUpsertArgs>(args: SelectSubset<T, RolePermissionUpsertArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermission.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionCountArgs>(
      args?: Subset<T, RolePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionAggregateArgs>(args: Subset<T, RolePermissionAggregateArgs>): Prisma.PrismaPromise<GetRolePermissionAggregateType<T>>

    /**
     * Group by RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePermission model
   */
  readonly fields: RolePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permission<T extends PermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionDefaultArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePermission model
   */
  interface RolePermissionFieldRefs {
    readonly roleId: FieldRef<"RolePermission", 'Int'>
    readonly permissionId: FieldRef<"RolePermission", 'Int'>
    readonly assignedAt: FieldRef<"RolePermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RolePermission findUnique
   */
  export type RolePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findUniqueOrThrow
   */
  export type RolePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findFirst
   */
  export type RolePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findFirstOrThrow
   */
  export type RolePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findMany
   */
  export type RolePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission create
   */
  export type RolePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePermission.
     */
    data: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
  }

  /**
   * RolePermission createMany
   */
  export type RolePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolePermission createManyAndReturn
   */
  export type RolePermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePermission update
   */
  export type RolePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePermission.
     */
    data: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
    /**
     * Choose, which RolePermission to update.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission updateMany
   */
  export type RolePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to update.
     */
    limit?: number
  }

  /**
   * RolePermission updateManyAndReturn
   */
  export type RolePermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePermission upsert
   */
  export type RolePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePermission to update in case it exists.
     */
    where: RolePermissionWhereUniqueInput
    /**
     * In case the RolePermission found by the `where` argument doesn't exist, create a new RolePermission with this data.
     */
    create: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
    /**
     * In case the RolePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
  }

  /**
   * RolePermission delete
   */
  export type RolePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter which RolePermission to delete.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission deleteMany
   */
  export type RolePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to delete
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to delete.
     */
    limit?: number
  }

  /**
   * RolePermission without action
   */
  export type RolePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
  }


  /**
   * Model Passkey
   */

  export type AggregatePasskey = {
    _count: PasskeyCountAggregateOutputType | null
    _avg: PasskeyAvgAggregateOutputType | null
    _sum: PasskeySumAggregateOutputType | null
    _min: PasskeyMinAggregateOutputType | null
    _max: PasskeyMaxAggregateOutputType | null
  }

  export type PasskeyAvgAggregateOutputType = {
    id: number | null
    counter: number | null
  }

  export type PasskeySumAggregateOutputType = {
    id: number | null
    counter: number | null
  }

  export type PasskeyMinAggregateOutputType = {
    id: number | null
    userId: string | null
    credentialId: string | null
    publicKey: string | null
    counter: number | null
    transports: string | null
    deviceType: string | null
    backedUp: boolean | null
    createdAt: Date | null
    lastUsed: Date | null
  }

  export type PasskeyMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    credentialId: string | null
    publicKey: string | null
    counter: number | null
    transports: string | null
    deviceType: string | null
    backedUp: boolean | null
    createdAt: Date | null
    lastUsed: Date | null
  }

  export type PasskeyCountAggregateOutputType = {
    id: number
    userId: number
    credentialId: number
    publicKey: number
    counter: number
    transports: number
    deviceType: number
    backedUp: number
    createdAt: number
    lastUsed: number
    _all: number
  }


  export type PasskeyAvgAggregateInputType = {
    id?: true
    counter?: true
  }

  export type PasskeySumAggregateInputType = {
    id?: true
    counter?: true
  }

  export type PasskeyMinAggregateInputType = {
    id?: true
    userId?: true
    credentialId?: true
    publicKey?: true
    counter?: true
    transports?: true
    deviceType?: true
    backedUp?: true
    createdAt?: true
    lastUsed?: true
  }

  export type PasskeyMaxAggregateInputType = {
    id?: true
    userId?: true
    credentialId?: true
    publicKey?: true
    counter?: true
    transports?: true
    deviceType?: true
    backedUp?: true
    createdAt?: true
    lastUsed?: true
  }

  export type PasskeyCountAggregateInputType = {
    id?: true
    userId?: true
    credentialId?: true
    publicKey?: true
    counter?: true
    transports?: true
    deviceType?: true
    backedUp?: true
    createdAt?: true
    lastUsed?: true
    _all?: true
  }

  export type PasskeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Passkey to aggregate.
     */
    where?: PasskeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passkeys to fetch.
     */
    orderBy?: PasskeyOrderByWithRelationInput | PasskeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasskeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passkeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passkeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Passkeys
    **/
    _count?: true | PasskeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PasskeyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PasskeySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasskeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasskeyMaxAggregateInputType
  }

  export type GetPasskeyAggregateType<T extends PasskeyAggregateArgs> = {
        [P in keyof T & keyof AggregatePasskey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasskey[P]>
      : GetScalarType<T[P], AggregatePasskey[P]>
  }




  export type PasskeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasskeyWhereInput
    orderBy?: PasskeyOrderByWithAggregationInput | PasskeyOrderByWithAggregationInput[]
    by: PasskeyScalarFieldEnum[] | PasskeyScalarFieldEnum
    having?: PasskeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasskeyCountAggregateInputType | true
    _avg?: PasskeyAvgAggregateInputType
    _sum?: PasskeySumAggregateInputType
    _min?: PasskeyMinAggregateInputType
    _max?: PasskeyMaxAggregateInputType
  }

  export type PasskeyGroupByOutputType = {
    id: number
    userId: string
    credentialId: string
    publicKey: string
    counter: number
    transports: string | null
    deviceType: string | null
    backedUp: boolean
    createdAt: Date
    lastUsed: Date | null
    _count: PasskeyCountAggregateOutputType | null
    _avg: PasskeyAvgAggregateOutputType | null
    _sum: PasskeySumAggregateOutputType | null
    _min: PasskeyMinAggregateOutputType | null
    _max: PasskeyMaxAggregateOutputType | null
  }

  type GetPasskeyGroupByPayload<T extends PasskeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasskeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasskeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasskeyGroupByOutputType[P]>
            : GetScalarType<T[P], PasskeyGroupByOutputType[P]>
        }
      >
    >


  export type PasskeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    credentialId?: boolean
    publicKey?: boolean
    counter?: boolean
    transports?: boolean
    deviceType?: boolean
    backedUp?: boolean
    createdAt?: boolean
    lastUsed?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passkey"]>

  export type PasskeySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    credentialId?: boolean
    publicKey?: boolean
    counter?: boolean
    transports?: boolean
    deviceType?: boolean
    backedUp?: boolean
    createdAt?: boolean
    lastUsed?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passkey"]>

  export type PasskeySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    credentialId?: boolean
    publicKey?: boolean
    counter?: boolean
    transports?: boolean
    deviceType?: boolean
    backedUp?: boolean
    createdAt?: boolean
    lastUsed?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passkey"]>

  export type PasskeySelectScalar = {
    id?: boolean
    userId?: boolean
    credentialId?: boolean
    publicKey?: boolean
    counter?: boolean
    transports?: boolean
    deviceType?: boolean
    backedUp?: boolean
    createdAt?: boolean
    lastUsed?: boolean
  }

  export type PasskeyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "credentialId" | "publicKey" | "counter" | "transports" | "deviceType" | "backedUp" | "createdAt" | "lastUsed", ExtArgs["result"]["passkey"]>
  export type PasskeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasskeyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasskeyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasskeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Passkey"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      credentialId: string
      publicKey: string
      counter: number
      transports: string | null
      deviceType: string | null
      backedUp: boolean
      createdAt: Date
      lastUsed: Date | null
    }, ExtArgs["result"]["passkey"]>
    composites: {}
  }

  type PasskeyGetPayload<S extends boolean | null | undefined | PasskeyDefaultArgs> = $Result.GetResult<Prisma.$PasskeyPayload, S>

  type PasskeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasskeyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasskeyCountAggregateInputType | true
    }

  export interface PasskeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Passkey'], meta: { name: 'Passkey' } }
    /**
     * Find zero or one Passkey that matches the filter.
     * @param {PasskeyFindUniqueArgs} args - Arguments to find a Passkey
     * @example
     * // Get one Passkey
     * const passkey = await prisma.passkey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasskeyFindUniqueArgs>(args: SelectSubset<T, PasskeyFindUniqueArgs<ExtArgs>>): Prisma__PasskeyClient<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Passkey that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasskeyFindUniqueOrThrowArgs} args - Arguments to find a Passkey
     * @example
     * // Get one Passkey
     * const passkey = await prisma.passkey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasskeyFindUniqueOrThrowArgs>(args: SelectSubset<T, PasskeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasskeyClient<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Passkey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasskeyFindFirstArgs} args - Arguments to find a Passkey
     * @example
     * // Get one Passkey
     * const passkey = await prisma.passkey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasskeyFindFirstArgs>(args?: SelectSubset<T, PasskeyFindFirstArgs<ExtArgs>>): Prisma__PasskeyClient<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Passkey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasskeyFindFirstOrThrowArgs} args - Arguments to find a Passkey
     * @example
     * // Get one Passkey
     * const passkey = await prisma.passkey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasskeyFindFirstOrThrowArgs>(args?: SelectSubset<T, PasskeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasskeyClient<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Passkeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasskeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Passkeys
     * const passkeys = await prisma.passkey.findMany()
     * 
     * // Get first 10 Passkeys
     * const passkeys = await prisma.passkey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passkeyWithIdOnly = await prisma.passkey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasskeyFindManyArgs>(args?: SelectSubset<T, PasskeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Passkey.
     * @param {PasskeyCreateArgs} args - Arguments to create a Passkey.
     * @example
     * // Create one Passkey
     * const Passkey = await prisma.passkey.create({
     *   data: {
     *     // ... data to create a Passkey
     *   }
     * })
     * 
     */
    create<T extends PasskeyCreateArgs>(args: SelectSubset<T, PasskeyCreateArgs<ExtArgs>>): Prisma__PasskeyClient<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Passkeys.
     * @param {PasskeyCreateManyArgs} args - Arguments to create many Passkeys.
     * @example
     * // Create many Passkeys
     * const passkey = await prisma.passkey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasskeyCreateManyArgs>(args?: SelectSubset<T, PasskeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Passkeys and returns the data saved in the database.
     * @param {PasskeyCreateManyAndReturnArgs} args - Arguments to create many Passkeys.
     * @example
     * // Create many Passkeys
     * const passkey = await prisma.passkey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Passkeys and only return the `id`
     * const passkeyWithIdOnly = await prisma.passkey.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasskeyCreateManyAndReturnArgs>(args?: SelectSubset<T, PasskeyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Passkey.
     * @param {PasskeyDeleteArgs} args - Arguments to delete one Passkey.
     * @example
     * // Delete one Passkey
     * const Passkey = await prisma.passkey.delete({
     *   where: {
     *     // ... filter to delete one Passkey
     *   }
     * })
     * 
     */
    delete<T extends PasskeyDeleteArgs>(args: SelectSubset<T, PasskeyDeleteArgs<ExtArgs>>): Prisma__PasskeyClient<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Passkey.
     * @param {PasskeyUpdateArgs} args - Arguments to update one Passkey.
     * @example
     * // Update one Passkey
     * const passkey = await prisma.passkey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasskeyUpdateArgs>(args: SelectSubset<T, PasskeyUpdateArgs<ExtArgs>>): Prisma__PasskeyClient<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Passkeys.
     * @param {PasskeyDeleteManyArgs} args - Arguments to filter Passkeys to delete.
     * @example
     * // Delete a few Passkeys
     * const { count } = await prisma.passkey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasskeyDeleteManyArgs>(args?: SelectSubset<T, PasskeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Passkeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasskeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Passkeys
     * const passkey = await prisma.passkey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasskeyUpdateManyArgs>(args: SelectSubset<T, PasskeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Passkeys and returns the data updated in the database.
     * @param {PasskeyUpdateManyAndReturnArgs} args - Arguments to update many Passkeys.
     * @example
     * // Update many Passkeys
     * const passkey = await prisma.passkey.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Passkeys and only return the `id`
     * const passkeyWithIdOnly = await prisma.passkey.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasskeyUpdateManyAndReturnArgs>(args: SelectSubset<T, PasskeyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Passkey.
     * @param {PasskeyUpsertArgs} args - Arguments to update or create a Passkey.
     * @example
     * // Update or create a Passkey
     * const passkey = await prisma.passkey.upsert({
     *   create: {
     *     // ... data to create a Passkey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Passkey we want to update
     *   }
     * })
     */
    upsert<T extends PasskeyUpsertArgs>(args: SelectSubset<T, PasskeyUpsertArgs<ExtArgs>>): Prisma__PasskeyClient<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Passkeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasskeyCountArgs} args - Arguments to filter Passkeys to count.
     * @example
     * // Count the number of Passkeys
     * const count = await prisma.passkey.count({
     *   where: {
     *     // ... the filter for the Passkeys we want to count
     *   }
     * })
    **/
    count<T extends PasskeyCountArgs>(
      args?: Subset<T, PasskeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasskeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Passkey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasskeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasskeyAggregateArgs>(args: Subset<T, PasskeyAggregateArgs>): Prisma.PrismaPromise<GetPasskeyAggregateType<T>>

    /**
     * Group by Passkey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasskeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasskeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasskeyGroupByArgs['orderBy'] }
        : { orderBy?: PasskeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasskeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasskeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Passkey model
   */
  readonly fields: PasskeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Passkey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasskeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Passkey model
   */
  interface PasskeyFieldRefs {
    readonly id: FieldRef<"Passkey", 'Int'>
    readonly userId: FieldRef<"Passkey", 'String'>
    readonly credentialId: FieldRef<"Passkey", 'String'>
    readonly publicKey: FieldRef<"Passkey", 'String'>
    readonly counter: FieldRef<"Passkey", 'Int'>
    readonly transports: FieldRef<"Passkey", 'String'>
    readonly deviceType: FieldRef<"Passkey", 'String'>
    readonly backedUp: FieldRef<"Passkey", 'Boolean'>
    readonly createdAt: FieldRef<"Passkey", 'DateTime'>
    readonly lastUsed: FieldRef<"Passkey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Passkey findUnique
   */
  export type PasskeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyInclude<ExtArgs> | null
    /**
     * Filter, which Passkey to fetch.
     */
    where: PasskeyWhereUniqueInput
  }

  /**
   * Passkey findUniqueOrThrow
   */
  export type PasskeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyInclude<ExtArgs> | null
    /**
     * Filter, which Passkey to fetch.
     */
    where: PasskeyWhereUniqueInput
  }

  /**
   * Passkey findFirst
   */
  export type PasskeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyInclude<ExtArgs> | null
    /**
     * Filter, which Passkey to fetch.
     */
    where?: PasskeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passkeys to fetch.
     */
    orderBy?: PasskeyOrderByWithRelationInput | PasskeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Passkeys.
     */
    cursor?: PasskeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passkeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passkeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Passkeys.
     */
    distinct?: PasskeyScalarFieldEnum | PasskeyScalarFieldEnum[]
  }

  /**
   * Passkey findFirstOrThrow
   */
  export type PasskeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyInclude<ExtArgs> | null
    /**
     * Filter, which Passkey to fetch.
     */
    where?: PasskeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passkeys to fetch.
     */
    orderBy?: PasskeyOrderByWithRelationInput | PasskeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Passkeys.
     */
    cursor?: PasskeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passkeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passkeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Passkeys.
     */
    distinct?: PasskeyScalarFieldEnum | PasskeyScalarFieldEnum[]
  }

  /**
   * Passkey findMany
   */
  export type PasskeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyInclude<ExtArgs> | null
    /**
     * Filter, which Passkeys to fetch.
     */
    where?: PasskeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passkeys to fetch.
     */
    orderBy?: PasskeyOrderByWithRelationInput | PasskeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Passkeys.
     */
    cursor?: PasskeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passkeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passkeys.
     */
    skip?: number
    distinct?: PasskeyScalarFieldEnum | PasskeyScalarFieldEnum[]
  }

  /**
   * Passkey create
   */
  export type PasskeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyInclude<ExtArgs> | null
    /**
     * The data needed to create a Passkey.
     */
    data: XOR<PasskeyCreateInput, PasskeyUncheckedCreateInput>
  }

  /**
   * Passkey createMany
   */
  export type PasskeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Passkeys.
     */
    data: PasskeyCreateManyInput | PasskeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Passkey createManyAndReturn
   */
  export type PasskeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * The data used to create many Passkeys.
     */
    data: PasskeyCreateManyInput | PasskeyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Passkey update
   */
  export type PasskeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyInclude<ExtArgs> | null
    /**
     * The data needed to update a Passkey.
     */
    data: XOR<PasskeyUpdateInput, PasskeyUncheckedUpdateInput>
    /**
     * Choose, which Passkey to update.
     */
    where: PasskeyWhereUniqueInput
  }

  /**
   * Passkey updateMany
   */
  export type PasskeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Passkeys.
     */
    data: XOR<PasskeyUpdateManyMutationInput, PasskeyUncheckedUpdateManyInput>
    /**
     * Filter which Passkeys to update
     */
    where?: PasskeyWhereInput
    /**
     * Limit how many Passkeys to update.
     */
    limit?: number
  }

  /**
   * Passkey updateManyAndReturn
   */
  export type PasskeyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * The data used to update Passkeys.
     */
    data: XOR<PasskeyUpdateManyMutationInput, PasskeyUncheckedUpdateManyInput>
    /**
     * Filter which Passkeys to update
     */
    where?: PasskeyWhereInput
    /**
     * Limit how many Passkeys to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Passkey upsert
   */
  export type PasskeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyInclude<ExtArgs> | null
    /**
     * The filter to search for the Passkey to update in case it exists.
     */
    where: PasskeyWhereUniqueInput
    /**
     * In case the Passkey found by the `where` argument doesn't exist, create a new Passkey with this data.
     */
    create: XOR<PasskeyCreateInput, PasskeyUncheckedCreateInput>
    /**
     * In case the Passkey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasskeyUpdateInput, PasskeyUncheckedUpdateInput>
  }

  /**
   * Passkey delete
   */
  export type PasskeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyInclude<ExtArgs> | null
    /**
     * Filter which Passkey to delete.
     */
    where: PasskeyWhereUniqueInput
  }

  /**
   * Passkey deleteMany
   */
  export type PasskeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Passkeys to delete
     */
    where?: PasskeyWhereInput
    /**
     * Limit how many Passkeys to delete.
     */
    limit?: number
  }

  /**
   * Passkey without action
   */
  export type PasskeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyInclude<ExtArgs> | null
  }


  /**
   * Model Log
   */

  export type AggregateLog = {
    _count: LogCountAggregateOutputType | null
    _avg: LogAvgAggregateOutputType | null
    _sum: LogSumAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  export type LogAvgAggregateOutputType = {
    id: number | null
  }

  export type LogSumAggregateOutputType = {
    id: number | null
  }

  export type LogMinAggregateOutputType = {
    id: number | null
    ticketId: string | null
    name: string | null
    email: string | null
    title: string | null
    system: string | null
    urgency: string | null
    timestamp: Date | null
    emailStatus: string | null
    userId: string | null
  }

  export type LogMaxAggregateOutputType = {
    id: number | null
    ticketId: string | null
    name: string | null
    email: string | null
    title: string | null
    system: string | null
    urgency: string | null
    timestamp: Date | null
    emailStatus: string | null
    userId: string | null
  }

  export type LogCountAggregateOutputType = {
    id: number
    ticketId: number
    name: number
    email: number
    title: number
    system: number
    urgency: number
    timestamp: number
    emailStatus: number
    userId: number
    _all: number
  }


  export type LogAvgAggregateInputType = {
    id?: true
  }

  export type LogSumAggregateInputType = {
    id?: true
  }

  export type LogMinAggregateInputType = {
    id?: true
    ticketId?: true
    name?: true
    email?: true
    title?: true
    system?: true
    urgency?: true
    timestamp?: true
    emailStatus?: true
    userId?: true
  }

  export type LogMaxAggregateInputType = {
    id?: true
    ticketId?: true
    name?: true
    email?: true
    title?: true
    system?: true
    urgency?: true
    timestamp?: true
    emailStatus?: true
    userId?: true
  }

  export type LogCountAggregateInputType = {
    id?: true
    ticketId?: true
    name?: true
    email?: true
    title?: true
    system?: true
    urgency?: true
    timestamp?: true
    emailStatus?: true
    userId?: true
    _all?: true
  }

  export type LogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Log to aggregate.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logs
    **/
    _count?: true | LogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogMaxAggregateInputType
  }

  export type GetLogAggregateType<T extends LogAggregateArgs> = {
        [P in keyof T & keyof AggregateLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLog[P]>
      : GetScalarType<T[P], AggregateLog[P]>
  }




  export type LogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
    orderBy?: LogOrderByWithAggregationInput | LogOrderByWithAggregationInput[]
    by: LogScalarFieldEnum[] | LogScalarFieldEnum
    having?: LogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogCountAggregateInputType | true
    _avg?: LogAvgAggregateInputType
    _sum?: LogSumAggregateInputType
    _min?: LogMinAggregateInputType
    _max?: LogMaxAggregateInputType
  }

  export type LogGroupByOutputType = {
    id: number
    ticketId: string | null
    name: string | null
    email: string | null
    title: string | null
    system: string | null
    urgency: string | null
    timestamp: Date
    emailStatus: string | null
    userId: string | null
    _count: LogCountAggregateOutputType | null
    _avg: LogAvgAggregateOutputType | null
    _sum: LogSumAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  type GetLogGroupByPayload<T extends LogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogGroupByOutputType[P]>
            : GetScalarType<T[P], LogGroupByOutputType[P]>
        }
      >
    >


  export type LogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    name?: boolean
    email?: boolean
    title?: boolean
    system?: boolean
    urgency?: boolean
    timestamp?: boolean
    emailStatus?: boolean
    userId?: boolean
    user?: boolean | Log$userArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>

  export type LogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    name?: boolean
    email?: boolean
    title?: boolean
    system?: boolean
    urgency?: boolean
    timestamp?: boolean
    emailStatus?: boolean
    userId?: boolean
    user?: boolean | Log$userArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>

  export type LogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    name?: boolean
    email?: boolean
    title?: boolean
    system?: boolean
    urgency?: boolean
    timestamp?: boolean
    emailStatus?: boolean
    userId?: boolean
    user?: boolean | Log$userArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>

  export type LogSelectScalar = {
    id?: boolean
    ticketId?: boolean
    name?: boolean
    email?: boolean
    title?: boolean
    system?: boolean
    urgency?: boolean
    timestamp?: boolean
    emailStatus?: boolean
    userId?: boolean
  }

  export type LogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ticketId" | "name" | "email" | "title" | "system" | "urgency" | "timestamp" | "emailStatus" | "userId", ExtArgs["result"]["log"]>
  export type LogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Log$userArgs<ExtArgs>
  }
  export type LogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Log$userArgs<ExtArgs>
  }
  export type LogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Log$userArgs<ExtArgs>
  }

  export type $LogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Log"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ticketId: string | null
      name: string | null
      email: string | null
      title: string | null
      system: string | null
      urgency: string | null
      timestamp: Date
      emailStatus: string | null
      userId: string | null
    }, ExtArgs["result"]["log"]>
    composites: {}
  }

  type LogGetPayload<S extends boolean | null | undefined | LogDefaultArgs> = $Result.GetResult<Prisma.$LogPayload, S>

  type LogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LogCountAggregateInputType | true
    }

  export interface LogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Log'], meta: { name: 'Log' } }
    /**
     * Find zero or one Log that matches the filter.
     * @param {LogFindUniqueArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogFindUniqueArgs>(args: SelectSubset<T, LogFindUniqueArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Log that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LogFindUniqueOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogFindUniqueOrThrowArgs>(args: SelectSubset<T, LogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogFindFirstArgs>(args?: SelectSubset<T, LogFindFirstArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogFindFirstOrThrowArgs>(args?: SelectSubset<T, LogFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs
     * const logs = await prisma.log.findMany()
     * 
     * // Get first 10 Logs
     * const logs = await prisma.log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logWithIdOnly = await prisma.log.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LogFindManyArgs>(args?: SelectSubset<T, LogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Log.
     * @param {LogCreateArgs} args - Arguments to create a Log.
     * @example
     * // Create one Log
     * const Log = await prisma.log.create({
     *   data: {
     *     // ... data to create a Log
     *   }
     * })
     * 
     */
    create<T extends LogCreateArgs>(args: SelectSubset<T, LogCreateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Logs.
     * @param {LogCreateManyArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const log = await prisma.log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogCreateManyArgs>(args?: SelectSubset<T, LogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Logs and returns the data saved in the database.
     * @param {LogCreateManyAndReturnArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const log = await prisma.log.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Logs and only return the `id`
     * const logWithIdOnly = await prisma.log.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LogCreateManyAndReturnArgs>(args?: SelectSubset<T, LogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Log.
     * @param {LogDeleteArgs} args - Arguments to delete one Log.
     * @example
     * // Delete one Log
     * const Log = await prisma.log.delete({
     *   where: {
     *     // ... filter to delete one Log
     *   }
     * })
     * 
     */
    delete<T extends LogDeleteArgs>(args: SelectSubset<T, LogDeleteArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Log.
     * @param {LogUpdateArgs} args - Arguments to update one Log.
     * @example
     * // Update one Log
     * const log = await prisma.log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogUpdateArgs>(args: SelectSubset<T, LogUpdateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Logs.
     * @param {LogDeleteManyArgs} args - Arguments to filter Logs to delete.
     * @example
     * // Delete a few Logs
     * const { count } = await prisma.log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogDeleteManyArgs>(args?: SelectSubset<T, LogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs
     * const log = await prisma.log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogUpdateManyArgs>(args: SelectSubset<T, LogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs and returns the data updated in the database.
     * @param {LogUpdateManyAndReturnArgs} args - Arguments to update many Logs.
     * @example
     * // Update many Logs
     * const log = await prisma.log.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Logs and only return the `id`
     * const logWithIdOnly = await prisma.log.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LogUpdateManyAndReturnArgs>(args: SelectSubset<T, LogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Log.
     * @param {LogUpsertArgs} args - Arguments to update or create a Log.
     * @example
     * // Update or create a Log
     * const log = await prisma.log.upsert({
     *   create: {
     *     // ... data to create a Log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Log we want to update
     *   }
     * })
     */
    upsert<T extends LogUpsertArgs>(args: SelectSubset<T, LogUpsertArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogCountArgs} args - Arguments to filter Logs to count.
     * @example
     * // Count the number of Logs
     * const count = await prisma.log.count({
     *   where: {
     *     // ... the filter for the Logs we want to count
     *   }
     * })
    **/
    count<T extends LogCountArgs>(
      args?: Subset<T, LogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogAggregateArgs>(args: Subset<T, LogAggregateArgs>): Prisma.PrismaPromise<GetLogAggregateType<T>>

    /**
     * Group by Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogGroupByArgs['orderBy'] }
        : { orderBy?: LogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Log model
   */
  readonly fields: LogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Log$userArgs<ExtArgs> = {}>(args?: Subset<T, Log$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Log model
   */
  interface LogFieldRefs {
    readonly id: FieldRef<"Log", 'Int'>
    readonly ticketId: FieldRef<"Log", 'String'>
    readonly name: FieldRef<"Log", 'String'>
    readonly email: FieldRef<"Log", 'String'>
    readonly title: FieldRef<"Log", 'String'>
    readonly system: FieldRef<"Log", 'String'>
    readonly urgency: FieldRef<"Log", 'String'>
    readonly timestamp: FieldRef<"Log", 'DateTime'>
    readonly emailStatus: FieldRef<"Log", 'String'>
    readonly userId: FieldRef<"Log", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Log findUnique
   */
  export type LogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log findUniqueOrThrow
   */
  export type LogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log findFirst
   */
  export type LogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log findFirstOrThrow
   */
  export type LogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log findMany
   */
  export type LogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log create
   */
  export type LogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The data needed to create a Log.
     */
    data?: XOR<LogCreateInput, LogUncheckedCreateInput>
  }

  /**
   * Log createMany
   */
  export type LogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Logs.
     */
    data: LogCreateManyInput | LogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Log createManyAndReturn
   */
  export type LogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * The data used to create many Logs.
     */
    data: LogCreateManyInput | LogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Log update
   */
  export type LogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The data needed to update a Log.
     */
    data: XOR<LogUpdateInput, LogUncheckedUpdateInput>
    /**
     * Choose, which Log to update.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log updateMany
   */
  export type LogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Logs.
     */
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to update.
     */
    limit?: number
  }

  /**
   * Log updateManyAndReturn
   */
  export type LogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * The data used to update Logs.
     */
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Log upsert
   */
  export type LogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The filter to search for the Log to update in case it exists.
     */
    where: LogWhereUniqueInput
    /**
     * In case the Log found by the `where` argument doesn't exist, create a new Log with this data.
     */
    create: XOR<LogCreateInput, LogUncheckedCreateInput>
    /**
     * In case the Log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogUpdateInput, LogUncheckedUpdateInput>
  }

  /**
   * Log delete
   */
  export type LogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter which Log to delete.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log deleteMany
   */
  export type LogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logs to delete
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to delete.
     */
    limit?: number
  }

  /**
   * Log.user
   */
  export type Log$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Log without action
   */
  export type LogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
  }


  /**
   * Model Config
   */

  export type AggregateConfig = {
    _count: ConfigCountAggregateOutputType | null
    _avg: ConfigAvgAggregateOutputType | null
    _sum: ConfigSumAggregateOutputType | null
    _min: ConfigMinAggregateOutputType | null
    _max: ConfigMaxAggregateOutputType | null
  }

  export type ConfigAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type ConfigSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type ConfigMinAggregateOutputType = {
    key: string | null
    value: string | null
    valueType: string | null
    description: string | null
    isPublic: boolean | null
    category: string | null
    subcategory: string | null
    isUIEditable: boolean | null
    isRequired: boolean | null
    defaultValue: string | null
    displayOrder: number | null
    helpText: string | null
    isAdvanced: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ConfigMaxAggregateOutputType = {
    key: string | null
    value: string | null
    valueType: string | null
    description: string | null
    isPublic: boolean | null
    category: string | null
    subcategory: string | null
    isUIEditable: boolean | null
    isRequired: boolean | null
    defaultValue: string | null
    displayOrder: number | null
    helpText: string | null
    isAdvanced: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ConfigCountAggregateOutputType = {
    key: number
    value: number
    valueType: number
    description: number
    isPublic: number
    category: number
    subcategory: number
    isUIEditable: number
    isRequired: number
    defaultValue: number
    validationRules: number
    displayOrder: number
    helpText: number
    isAdvanced: number
    createdAt: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type ConfigAvgAggregateInputType = {
    displayOrder?: true
  }

  export type ConfigSumAggregateInputType = {
    displayOrder?: true
  }

  export type ConfigMinAggregateInputType = {
    key?: true
    value?: true
    valueType?: true
    description?: true
    isPublic?: true
    category?: true
    subcategory?: true
    isUIEditable?: true
    isRequired?: true
    defaultValue?: true
    displayOrder?: true
    helpText?: true
    isAdvanced?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ConfigMaxAggregateInputType = {
    key?: true
    value?: true
    valueType?: true
    description?: true
    isPublic?: true
    category?: true
    subcategory?: true
    isUIEditable?: true
    isRequired?: true
    defaultValue?: true
    displayOrder?: true
    helpText?: true
    isAdvanced?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ConfigCountAggregateInputType = {
    key?: true
    value?: true
    valueType?: true
    description?: true
    isPublic?: true
    category?: true
    subcategory?: true
    isUIEditable?: true
    isRequired?: true
    defaultValue?: true
    validationRules?: true
    displayOrder?: true
    helpText?: true
    isAdvanced?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type ConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Config to aggregate.
     */
    where?: ConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configs to fetch.
     */
    orderBy?: ConfigOrderByWithRelationInput | ConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Configs
    **/
    _count?: true | ConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfigMaxAggregateInputType
  }

  export type GetConfigAggregateType<T extends ConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfig[P]>
      : GetScalarType<T[P], AggregateConfig[P]>
  }




  export type ConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigWhereInput
    orderBy?: ConfigOrderByWithAggregationInput | ConfigOrderByWithAggregationInput[]
    by: ConfigScalarFieldEnum[] | ConfigScalarFieldEnum
    having?: ConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfigCountAggregateInputType | true
    _avg?: ConfigAvgAggregateInputType
    _sum?: ConfigSumAggregateInputType
    _min?: ConfigMinAggregateInputType
    _max?: ConfigMaxAggregateInputType
  }

  export type ConfigGroupByOutputType = {
    key: string
    value: string | null
    valueType: string | null
    description: string | null
    isPublic: boolean
    category: string | null
    subcategory: string | null
    isUIEditable: boolean
    isRequired: boolean
    defaultValue: string | null
    validationRules: JsonValue | null
    displayOrder: number | null
    helpText: string | null
    isAdvanced: boolean
    createdAt: Date
    updatedAt: Date
    updatedBy: string | null
    _count: ConfigCountAggregateOutputType | null
    _avg: ConfigAvgAggregateOutputType | null
    _sum: ConfigSumAggregateOutputType | null
    _min: ConfigMinAggregateOutputType | null
    _max: ConfigMaxAggregateOutputType | null
  }

  type GetConfigGroupByPayload<T extends ConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfigGroupByOutputType[P]>
            : GetScalarType<T[P], ConfigGroupByOutputType[P]>
        }
      >
    >


  export type ConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    valueType?: boolean
    description?: boolean
    isPublic?: boolean
    category?: boolean
    subcategory?: boolean
    isUIEditable?: boolean
    isRequired?: boolean
    defaultValue?: boolean
    validationRules?: boolean
    displayOrder?: boolean
    helpText?: boolean
    isAdvanced?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    history?: boolean | Config$historyArgs<ExtArgs>
    _count?: boolean | ConfigCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["config"]>

  export type ConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    valueType?: boolean
    description?: boolean
    isPublic?: boolean
    category?: boolean
    subcategory?: boolean
    isUIEditable?: boolean
    isRequired?: boolean
    defaultValue?: boolean
    validationRules?: boolean
    displayOrder?: boolean
    helpText?: boolean
    isAdvanced?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["config"]>

  export type ConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    valueType?: boolean
    description?: boolean
    isPublic?: boolean
    category?: boolean
    subcategory?: boolean
    isUIEditable?: boolean
    isRequired?: boolean
    defaultValue?: boolean
    validationRules?: boolean
    displayOrder?: boolean
    helpText?: boolean
    isAdvanced?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["config"]>

  export type ConfigSelectScalar = {
    key?: boolean
    value?: boolean
    valueType?: boolean
    description?: boolean
    isPublic?: boolean
    category?: boolean
    subcategory?: boolean
    isUIEditable?: boolean
    isRequired?: boolean
    defaultValue?: boolean
    validationRules?: boolean
    displayOrder?: boolean
    helpText?: boolean
    isAdvanced?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type ConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"key" | "value" | "valueType" | "description" | "isPublic" | "category" | "subcategory" | "isUIEditable" | "isRequired" | "defaultValue" | "validationRules" | "displayOrder" | "helpText" | "isAdvanced" | "createdAt" | "updatedAt" | "updatedBy", ExtArgs["result"]["config"]>
  export type ConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    history?: boolean | Config$historyArgs<ExtArgs>
    _count?: boolean | ConfigCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ConfigIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Config"
    objects: {
      history: Prisma.$ConfigHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      key: string
      value: string | null
      valueType: string | null
      description: string | null
      isPublic: boolean
      category: string | null
      subcategory: string | null
      isUIEditable: boolean
      isRequired: boolean
      defaultValue: string | null
      validationRules: Prisma.JsonValue | null
      displayOrder: number | null
      helpText: string | null
      isAdvanced: boolean
      createdAt: Date
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["config"]>
    composites: {}
  }

  type ConfigGetPayload<S extends boolean | null | undefined | ConfigDefaultArgs> = $Result.GetResult<Prisma.$ConfigPayload, S>

  type ConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConfigCountAggregateInputType | true
    }

  export interface ConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Config'], meta: { name: 'Config' } }
    /**
     * Find zero or one Config that matches the filter.
     * @param {ConfigFindUniqueArgs} args - Arguments to find a Config
     * @example
     * // Get one Config
     * const config = await prisma.config.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConfigFindUniqueArgs>(args: SelectSubset<T, ConfigFindUniqueArgs<ExtArgs>>): Prisma__ConfigClient<$Result.GetResult<Prisma.$ConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Config that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConfigFindUniqueOrThrowArgs} args - Arguments to find a Config
     * @example
     * // Get one Config
     * const config = await prisma.config.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, ConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConfigClient<$Result.GetResult<Prisma.$ConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Config that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigFindFirstArgs} args - Arguments to find a Config
     * @example
     * // Get one Config
     * const config = await prisma.config.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConfigFindFirstArgs>(args?: SelectSubset<T, ConfigFindFirstArgs<ExtArgs>>): Prisma__ConfigClient<$Result.GetResult<Prisma.$ConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Config that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigFindFirstOrThrowArgs} args - Arguments to find a Config
     * @example
     * // Get one Config
     * const config = await prisma.config.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, ConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConfigClient<$Result.GetResult<Prisma.$ConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Configs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Configs
     * const configs = await prisma.config.findMany()
     * 
     * // Get first 10 Configs
     * const configs = await prisma.config.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const configWithKeyOnly = await prisma.config.findMany({ select: { key: true } })
     * 
     */
    findMany<T extends ConfigFindManyArgs>(args?: SelectSubset<T, ConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Config.
     * @param {ConfigCreateArgs} args - Arguments to create a Config.
     * @example
     * // Create one Config
     * const Config = await prisma.config.create({
     *   data: {
     *     // ... data to create a Config
     *   }
     * })
     * 
     */
    create<T extends ConfigCreateArgs>(args: SelectSubset<T, ConfigCreateArgs<ExtArgs>>): Prisma__ConfigClient<$Result.GetResult<Prisma.$ConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Configs.
     * @param {ConfigCreateManyArgs} args - Arguments to create many Configs.
     * @example
     * // Create many Configs
     * const config = await prisma.config.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConfigCreateManyArgs>(args?: SelectSubset<T, ConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Configs and returns the data saved in the database.
     * @param {ConfigCreateManyAndReturnArgs} args - Arguments to create many Configs.
     * @example
     * // Create many Configs
     * const config = await prisma.config.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Configs and only return the `key`
     * const configWithKeyOnly = await prisma.config.createManyAndReturn({
     *   select: { key: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, ConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Config.
     * @param {ConfigDeleteArgs} args - Arguments to delete one Config.
     * @example
     * // Delete one Config
     * const Config = await prisma.config.delete({
     *   where: {
     *     // ... filter to delete one Config
     *   }
     * })
     * 
     */
    delete<T extends ConfigDeleteArgs>(args: SelectSubset<T, ConfigDeleteArgs<ExtArgs>>): Prisma__ConfigClient<$Result.GetResult<Prisma.$ConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Config.
     * @param {ConfigUpdateArgs} args - Arguments to update one Config.
     * @example
     * // Update one Config
     * const config = await prisma.config.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConfigUpdateArgs>(args: SelectSubset<T, ConfigUpdateArgs<ExtArgs>>): Prisma__ConfigClient<$Result.GetResult<Prisma.$ConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Configs.
     * @param {ConfigDeleteManyArgs} args - Arguments to filter Configs to delete.
     * @example
     * // Delete a few Configs
     * const { count } = await prisma.config.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConfigDeleteManyArgs>(args?: SelectSubset<T, ConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Configs
     * const config = await prisma.config.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConfigUpdateManyArgs>(args: SelectSubset<T, ConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Configs and returns the data updated in the database.
     * @param {ConfigUpdateManyAndReturnArgs} args - Arguments to update many Configs.
     * @example
     * // Update many Configs
     * const config = await prisma.config.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Configs and only return the `key`
     * const configWithKeyOnly = await prisma.config.updateManyAndReturn({
     *   select: { key: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, ConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Config.
     * @param {ConfigUpsertArgs} args - Arguments to update or create a Config.
     * @example
     * // Update or create a Config
     * const config = await prisma.config.upsert({
     *   create: {
     *     // ... data to create a Config
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Config we want to update
     *   }
     * })
     */
    upsert<T extends ConfigUpsertArgs>(args: SelectSubset<T, ConfigUpsertArgs<ExtArgs>>): Prisma__ConfigClient<$Result.GetResult<Prisma.$ConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigCountArgs} args - Arguments to filter Configs to count.
     * @example
     * // Count the number of Configs
     * const count = await prisma.config.count({
     *   where: {
     *     // ... the filter for the Configs we want to count
     *   }
     * })
    **/
    count<T extends ConfigCountArgs>(
      args?: Subset<T, ConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfigAggregateArgs>(args: Subset<T, ConfigAggregateArgs>): Prisma.PrismaPromise<GetConfigAggregateType<T>>

    /**
     * Group by Config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConfigGroupByArgs['orderBy'] }
        : { orderBy?: ConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Config model
   */
  readonly fields: ConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Config.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    history<T extends Config$historyArgs<ExtArgs> = {}>(args?: Subset<T, Config$historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Config model
   */
  interface ConfigFieldRefs {
    readonly key: FieldRef<"Config", 'String'>
    readonly value: FieldRef<"Config", 'String'>
    readonly valueType: FieldRef<"Config", 'String'>
    readonly description: FieldRef<"Config", 'String'>
    readonly isPublic: FieldRef<"Config", 'Boolean'>
    readonly category: FieldRef<"Config", 'String'>
    readonly subcategory: FieldRef<"Config", 'String'>
    readonly isUIEditable: FieldRef<"Config", 'Boolean'>
    readonly isRequired: FieldRef<"Config", 'Boolean'>
    readonly defaultValue: FieldRef<"Config", 'String'>
    readonly validationRules: FieldRef<"Config", 'Json'>
    readonly displayOrder: FieldRef<"Config", 'Int'>
    readonly helpText: FieldRef<"Config", 'String'>
    readonly isAdvanced: FieldRef<"Config", 'Boolean'>
    readonly createdAt: FieldRef<"Config", 'DateTime'>
    readonly updatedAt: FieldRef<"Config", 'DateTime'>
    readonly updatedBy: FieldRef<"Config", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Config findUnique
   */
  export type ConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Config
     */
    omit?: ConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigInclude<ExtArgs> | null
    /**
     * Filter, which Config to fetch.
     */
    where: ConfigWhereUniqueInput
  }

  /**
   * Config findUniqueOrThrow
   */
  export type ConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Config
     */
    omit?: ConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigInclude<ExtArgs> | null
    /**
     * Filter, which Config to fetch.
     */
    where: ConfigWhereUniqueInput
  }

  /**
   * Config findFirst
   */
  export type ConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Config
     */
    omit?: ConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigInclude<ExtArgs> | null
    /**
     * Filter, which Config to fetch.
     */
    where?: ConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configs to fetch.
     */
    orderBy?: ConfigOrderByWithRelationInput | ConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Configs.
     */
    cursor?: ConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Configs.
     */
    distinct?: ConfigScalarFieldEnum | ConfigScalarFieldEnum[]
  }

  /**
   * Config findFirstOrThrow
   */
  export type ConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Config
     */
    omit?: ConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigInclude<ExtArgs> | null
    /**
     * Filter, which Config to fetch.
     */
    where?: ConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configs to fetch.
     */
    orderBy?: ConfigOrderByWithRelationInput | ConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Configs.
     */
    cursor?: ConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Configs.
     */
    distinct?: ConfigScalarFieldEnum | ConfigScalarFieldEnum[]
  }

  /**
   * Config findMany
   */
  export type ConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Config
     */
    omit?: ConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigInclude<ExtArgs> | null
    /**
     * Filter, which Configs to fetch.
     */
    where?: ConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configs to fetch.
     */
    orderBy?: ConfigOrderByWithRelationInput | ConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Configs.
     */
    cursor?: ConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configs.
     */
    skip?: number
    distinct?: ConfigScalarFieldEnum | ConfigScalarFieldEnum[]
  }

  /**
   * Config create
   */
  export type ConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Config
     */
    omit?: ConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a Config.
     */
    data: XOR<ConfigCreateInput, ConfigUncheckedCreateInput>
  }

  /**
   * Config createMany
   */
  export type ConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Configs.
     */
    data: ConfigCreateManyInput | ConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Config createManyAndReturn
   */
  export type ConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Config
     */
    omit?: ConfigOmit<ExtArgs> | null
    /**
     * The data used to create many Configs.
     */
    data: ConfigCreateManyInput | ConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Config update
   */
  export type ConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Config
     */
    omit?: ConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a Config.
     */
    data: XOR<ConfigUpdateInput, ConfigUncheckedUpdateInput>
    /**
     * Choose, which Config to update.
     */
    where: ConfigWhereUniqueInput
  }

  /**
   * Config updateMany
   */
  export type ConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Configs.
     */
    data: XOR<ConfigUpdateManyMutationInput, ConfigUncheckedUpdateManyInput>
    /**
     * Filter which Configs to update
     */
    where?: ConfigWhereInput
    /**
     * Limit how many Configs to update.
     */
    limit?: number
  }

  /**
   * Config updateManyAndReturn
   */
  export type ConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Config
     */
    omit?: ConfigOmit<ExtArgs> | null
    /**
     * The data used to update Configs.
     */
    data: XOR<ConfigUpdateManyMutationInput, ConfigUncheckedUpdateManyInput>
    /**
     * Filter which Configs to update
     */
    where?: ConfigWhereInput
    /**
     * Limit how many Configs to update.
     */
    limit?: number
  }

  /**
   * Config upsert
   */
  export type ConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Config
     */
    omit?: ConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the Config to update in case it exists.
     */
    where: ConfigWhereUniqueInput
    /**
     * In case the Config found by the `where` argument doesn't exist, create a new Config with this data.
     */
    create: XOR<ConfigCreateInput, ConfigUncheckedCreateInput>
    /**
     * In case the Config was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConfigUpdateInput, ConfigUncheckedUpdateInput>
  }

  /**
   * Config delete
   */
  export type ConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Config
     */
    omit?: ConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigInclude<ExtArgs> | null
    /**
     * Filter which Config to delete.
     */
    where: ConfigWhereUniqueInput
  }

  /**
   * Config deleteMany
   */
  export type ConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Configs to delete
     */
    where?: ConfigWhereInput
    /**
     * Limit how many Configs to delete.
     */
    limit?: number
  }

  /**
   * Config.history
   */
  export type Config$historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigHistory
     */
    select?: ConfigHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigHistory
     */
    omit?: ConfigHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigHistoryInclude<ExtArgs> | null
    where?: ConfigHistoryWhereInput
    orderBy?: ConfigHistoryOrderByWithRelationInput | ConfigHistoryOrderByWithRelationInput[]
    cursor?: ConfigHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConfigHistoryScalarFieldEnum | ConfigHistoryScalarFieldEnum[]
  }

  /**
   * Config without action
   */
  export type ConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Config
     */
    omit?: ConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigInclude<ExtArgs> | null
  }


  /**
   * Model ConfigHistory
   */

  export type AggregateConfigHistory = {
    _count: ConfigHistoryCountAggregateOutputType | null
    _avg: ConfigHistoryAvgAggregateOutputType | null
    _sum: ConfigHistorySumAggregateOutputType | null
    _min: ConfigHistoryMinAggregateOutputType | null
    _max: ConfigHistoryMaxAggregateOutputType | null
  }

  export type ConfigHistoryAvgAggregateOutputType = {
    id: number | null
  }

  export type ConfigHistorySumAggregateOutputType = {
    id: number | null
  }

  export type ConfigHistoryMinAggregateOutputType = {
    id: number | null
    configKey: string | null
    oldValue: string | null
    newValue: string | null
    changedBy: string | null
    changeReason: string | null
    createdAt: Date | null
  }

  export type ConfigHistoryMaxAggregateOutputType = {
    id: number | null
    configKey: string | null
    oldValue: string | null
    newValue: string | null
    changedBy: string | null
    changeReason: string | null
    createdAt: Date | null
  }

  export type ConfigHistoryCountAggregateOutputType = {
    id: number
    configKey: number
    oldValue: number
    newValue: number
    changedBy: number
    changeReason: number
    createdAt: number
    _all: number
  }


  export type ConfigHistoryAvgAggregateInputType = {
    id?: true
  }

  export type ConfigHistorySumAggregateInputType = {
    id?: true
  }

  export type ConfigHistoryMinAggregateInputType = {
    id?: true
    configKey?: true
    oldValue?: true
    newValue?: true
    changedBy?: true
    changeReason?: true
    createdAt?: true
  }

  export type ConfigHistoryMaxAggregateInputType = {
    id?: true
    configKey?: true
    oldValue?: true
    newValue?: true
    changedBy?: true
    changeReason?: true
    createdAt?: true
  }

  export type ConfigHistoryCountAggregateInputType = {
    id?: true
    configKey?: true
    oldValue?: true
    newValue?: true
    changedBy?: true
    changeReason?: true
    createdAt?: true
    _all?: true
  }

  export type ConfigHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfigHistory to aggregate.
     */
    where?: ConfigHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigHistories to fetch.
     */
    orderBy?: ConfigHistoryOrderByWithRelationInput | ConfigHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConfigHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConfigHistories
    **/
    _count?: true | ConfigHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConfigHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConfigHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfigHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfigHistoryMaxAggregateInputType
  }

  export type GetConfigHistoryAggregateType<T extends ConfigHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateConfigHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfigHistory[P]>
      : GetScalarType<T[P], AggregateConfigHistory[P]>
  }




  export type ConfigHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigHistoryWhereInput
    orderBy?: ConfigHistoryOrderByWithAggregationInput | ConfigHistoryOrderByWithAggregationInput[]
    by: ConfigHistoryScalarFieldEnum[] | ConfigHistoryScalarFieldEnum
    having?: ConfigHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfigHistoryCountAggregateInputType | true
    _avg?: ConfigHistoryAvgAggregateInputType
    _sum?: ConfigHistorySumAggregateInputType
    _min?: ConfigHistoryMinAggregateInputType
    _max?: ConfigHistoryMaxAggregateInputType
  }

  export type ConfigHistoryGroupByOutputType = {
    id: number
    configKey: string
    oldValue: string | null
    newValue: string | null
    changedBy: string | null
    changeReason: string | null
    createdAt: Date
    _count: ConfigHistoryCountAggregateOutputType | null
    _avg: ConfigHistoryAvgAggregateOutputType | null
    _sum: ConfigHistorySumAggregateOutputType | null
    _min: ConfigHistoryMinAggregateOutputType | null
    _max: ConfigHistoryMaxAggregateOutputType | null
  }

  type GetConfigHistoryGroupByPayload<T extends ConfigHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfigHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfigHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfigHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], ConfigHistoryGroupByOutputType[P]>
        }
      >
    >


  export type ConfigHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    configKey?: boolean
    oldValue?: boolean
    newValue?: boolean
    changedBy?: boolean
    changeReason?: boolean
    createdAt?: boolean
    config?: boolean | ConfigDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["configHistory"]>

  export type ConfigHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    configKey?: boolean
    oldValue?: boolean
    newValue?: boolean
    changedBy?: boolean
    changeReason?: boolean
    createdAt?: boolean
    config?: boolean | ConfigDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["configHistory"]>

  export type ConfigHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    configKey?: boolean
    oldValue?: boolean
    newValue?: boolean
    changedBy?: boolean
    changeReason?: boolean
    createdAt?: boolean
    config?: boolean | ConfigDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["configHistory"]>

  export type ConfigHistorySelectScalar = {
    id?: boolean
    configKey?: boolean
    oldValue?: boolean
    newValue?: boolean
    changedBy?: boolean
    changeReason?: boolean
    createdAt?: boolean
  }

  export type ConfigHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "configKey" | "oldValue" | "newValue" | "changedBy" | "changeReason" | "createdAt", ExtArgs["result"]["configHistory"]>
  export type ConfigHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    config?: boolean | ConfigDefaultArgs<ExtArgs>
  }
  export type ConfigHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    config?: boolean | ConfigDefaultArgs<ExtArgs>
  }
  export type ConfigHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    config?: boolean | ConfigDefaultArgs<ExtArgs>
  }

  export type $ConfigHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConfigHistory"
    objects: {
      config: Prisma.$ConfigPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      configKey: string
      oldValue: string | null
      newValue: string | null
      changedBy: string | null
      changeReason: string | null
      createdAt: Date
    }, ExtArgs["result"]["configHistory"]>
    composites: {}
  }

  type ConfigHistoryGetPayload<S extends boolean | null | undefined | ConfigHistoryDefaultArgs> = $Result.GetResult<Prisma.$ConfigHistoryPayload, S>

  type ConfigHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConfigHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConfigHistoryCountAggregateInputType | true
    }

  export interface ConfigHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConfigHistory'], meta: { name: 'ConfigHistory' } }
    /**
     * Find zero or one ConfigHistory that matches the filter.
     * @param {ConfigHistoryFindUniqueArgs} args - Arguments to find a ConfigHistory
     * @example
     * // Get one ConfigHistory
     * const configHistory = await prisma.configHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConfigHistoryFindUniqueArgs>(args: SelectSubset<T, ConfigHistoryFindUniqueArgs<ExtArgs>>): Prisma__ConfigHistoryClient<$Result.GetResult<Prisma.$ConfigHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConfigHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConfigHistoryFindUniqueOrThrowArgs} args - Arguments to find a ConfigHistory
     * @example
     * // Get one ConfigHistory
     * const configHistory = await prisma.configHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConfigHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ConfigHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConfigHistoryClient<$Result.GetResult<Prisma.$ConfigHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConfigHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigHistoryFindFirstArgs} args - Arguments to find a ConfigHistory
     * @example
     * // Get one ConfigHistory
     * const configHistory = await prisma.configHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConfigHistoryFindFirstArgs>(args?: SelectSubset<T, ConfigHistoryFindFirstArgs<ExtArgs>>): Prisma__ConfigHistoryClient<$Result.GetResult<Prisma.$ConfigHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConfigHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigHistoryFindFirstOrThrowArgs} args - Arguments to find a ConfigHistory
     * @example
     * // Get one ConfigHistory
     * const configHistory = await prisma.configHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConfigHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ConfigHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConfigHistoryClient<$Result.GetResult<Prisma.$ConfigHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConfigHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConfigHistories
     * const configHistories = await prisma.configHistory.findMany()
     * 
     * // Get first 10 ConfigHistories
     * const configHistories = await prisma.configHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const configHistoryWithIdOnly = await prisma.configHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConfigHistoryFindManyArgs>(args?: SelectSubset<T, ConfigHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConfigHistory.
     * @param {ConfigHistoryCreateArgs} args - Arguments to create a ConfigHistory.
     * @example
     * // Create one ConfigHistory
     * const ConfigHistory = await prisma.configHistory.create({
     *   data: {
     *     // ... data to create a ConfigHistory
     *   }
     * })
     * 
     */
    create<T extends ConfigHistoryCreateArgs>(args: SelectSubset<T, ConfigHistoryCreateArgs<ExtArgs>>): Prisma__ConfigHistoryClient<$Result.GetResult<Prisma.$ConfigHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConfigHistories.
     * @param {ConfigHistoryCreateManyArgs} args - Arguments to create many ConfigHistories.
     * @example
     * // Create many ConfigHistories
     * const configHistory = await prisma.configHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConfigHistoryCreateManyArgs>(args?: SelectSubset<T, ConfigHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConfigHistories and returns the data saved in the database.
     * @param {ConfigHistoryCreateManyAndReturnArgs} args - Arguments to create many ConfigHistories.
     * @example
     * // Create many ConfigHistories
     * const configHistory = await prisma.configHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConfigHistories and only return the `id`
     * const configHistoryWithIdOnly = await prisma.configHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConfigHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ConfigHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConfigHistory.
     * @param {ConfigHistoryDeleteArgs} args - Arguments to delete one ConfigHistory.
     * @example
     * // Delete one ConfigHistory
     * const ConfigHistory = await prisma.configHistory.delete({
     *   where: {
     *     // ... filter to delete one ConfigHistory
     *   }
     * })
     * 
     */
    delete<T extends ConfigHistoryDeleteArgs>(args: SelectSubset<T, ConfigHistoryDeleteArgs<ExtArgs>>): Prisma__ConfigHistoryClient<$Result.GetResult<Prisma.$ConfigHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConfigHistory.
     * @param {ConfigHistoryUpdateArgs} args - Arguments to update one ConfigHistory.
     * @example
     * // Update one ConfigHistory
     * const configHistory = await prisma.configHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConfigHistoryUpdateArgs>(args: SelectSubset<T, ConfigHistoryUpdateArgs<ExtArgs>>): Prisma__ConfigHistoryClient<$Result.GetResult<Prisma.$ConfigHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConfigHistories.
     * @param {ConfigHistoryDeleteManyArgs} args - Arguments to filter ConfigHistories to delete.
     * @example
     * // Delete a few ConfigHistories
     * const { count } = await prisma.configHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConfigHistoryDeleteManyArgs>(args?: SelectSubset<T, ConfigHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConfigHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConfigHistories
     * const configHistory = await prisma.configHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConfigHistoryUpdateManyArgs>(args: SelectSubset<T, ConfigHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConfigHistories and returns the data updated in the database.
     * @param {ConfigHistoryUpdateManyAndReturnArgs} args - Arguments to update many ConfigHistories.
     * @example
     * // Update many ConfigHistories
     * const configHistory = await prisma.configHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConfigHistories and only return the `id`
     * const configHistoryWithIdOnly = await prisma.configHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConfigHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ConfigHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConfigHistory.
     * @param {ConfigHistoryUpsertArgs} args - Arguments to update or create a ConfigHistory.
     * @example
     * // Update or create a ConfigHistory
     * const configHistory = await prisma.configHistory.upsert({
     *   create: {
     *     // ... data to create a ConfigHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConfigHistory we want to update
     *   }
     * })
     */
    upsert<T extends ConfigHistoryUpsertArgs>(args: SelectSubset<T, ConfigHistoryUpsertArgs<ExtArgs>>): Prisma__ConfigHistoryClient<$Result.GetResult<Prisma.$ConfigHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConfigHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigHistoryCountArgs} args - Arguments to filter ConfigHistories to count.
     * @example
     * // Count the number of ConfigHistories
     * const count = await prisma.configHistory.count({
     *   where: {
     *     // ... the filter for the ConfigHistories we want to count
     *   }
     * })
    **/
    count<T extends ConfigHistoryCountArgs>(
      args?: Subset<T, ConfigHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfigHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConfigHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfigHistoryAggregateArgs>(args: Subset<T, ConfigHistoryAggregateArgs>): Prisma.PrismaPromise<GetConfigHistoryAggregateType<T>>

    /**
     * Group by ConfigHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConfigHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConfigHistoryGroupByArgs['orderBy'] }
        : { orderBy?: ConfigHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConfigHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfigHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConfigHistory model
   */
  readonly fields: ConfigHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConfigHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConfigHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    config<T extends ConfigDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConfigDefaultArgs<ExtArgs>>): Prisma__ConfigClient<$Result.GetResult<Prisma.$ConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConfigHistory model
   */
  interface ConfigHistoryFieldRefs {
    readonly id: FieldRef<"ConfigHistory", 'Int'>
    readonly configKey: FieldRef<"ConfigHistory", 'String'>
    readonly oldValue: FieldRef<"ConfigHistory", 'String'>
    readonly newValue: FieldRef<"ConfigHistory", 'String'>
    readonly changedBy: FieldRef<"ConfigHistory", 'String'>
    readonly changeReason: FieldRef<"ConfigHistory", 'String'>
    readonly createdAt: FieldRef<"ConfigHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConfigHistory findUnique
   */
  export type ConfigHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigHistory
     */
    select?: ConfigHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigHistory
     */
    omit?: ConfigHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ConfigHistory to fetch.
     */
    where: ConfigHistoryWhereUniqueInput
  }

  /**
   * ConfigHistory findUniqueOrThrow
   */
  export type ConfigHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigHistory
     */
    select?: ConfigHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigHistory
     */
    omit?: ConfigHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ConfigHistory to fetch.
     */
    where: ConfigHistoryWhereUniqueInput
  }

  /**
   * ConfigHistory findFirst
   */
  export type ConfigHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigHistory
     */
    select?: ConfigHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigHistory
     */
    omit?: ConfigHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ConfigHistory to fetch.
     */
    where?: ConfigHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigHistories to fetch.
     */
    orderBy?: ConfigHistoryOrderByWithRelationInput | ConfigHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfigHistories.
     */
    cursor?: ConfigHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfigHistories.
     */
    distinct?: ConfigHistoryScalarFieldEnum | ConfigHistoryScalarFieldEnum[]
  }

  /**
   * ConfigHistory findFirstOrThrow
   */
  export type ConfigHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigHistory
     */
    select?: ConfigHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigHistory
     */
    omit?: ConfigHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ConfigHistory to fetch.
     */
    where?: ConfigHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigHistories to fetch.
     */
    orderBy?: ConfigHistoryOrderByWithRelationInput | ConfigHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfigHistories.
     */
    cursor?: ConfigHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfigHistories.
     */
    distinct?: ConfigHistoryScalarFieldEnum | ConfigHistoryScalarFieldEnum[]
  }

  /**
   * ConfigHistory findMany
   */
  export type ConfigHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigHistory
     */
    select?: ConfigHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigHistory
     */
    omit?: ConfigHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ConfigHistories to fetch.
     */
    where?: ConfigHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigHistories to fetch.
     */
    orderBy?: ConfigHistoryOrderByWithRelationInput | ConfigHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConfigHistories.
     */
    cursor?: ConfigHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigHistories.
     */
    skip?: number
    distinct?: ConfigHistoryScalarFieldEnum | ConfigHistoryScalarFieldEnum[]
  }

  /**
   * ConfigHistory create
   */
  export type ConfigHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigHistory
     */
    select?: ConfigHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigHistory
     */
    omit?: ConfigHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ConfigHistory.
     */
    data: XOR<ConfigHistoryCreateInput, ConfigHistoryUncheckedCreateInput>
  }

  /**
   * ConfigHistory createMany
   */
  export type ConfigHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConfigHistories.
     */
    data: ConfigHistoryCreateManyInput | ConfigHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConfigHistory createManyAndReturn
   */
  export type ConfigHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigHistory
     */
    select?: ConfigHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigHistory
     */
    omit?: ConfigHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many ConfigHistories.
     */
    data: ConfigHistoryCreateManyInput | ConfigHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConfigHistory update
   */
  export type ConfigHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigHistory
     */
    select?: ConfigHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigHistory
     */
    omit?: ConfigHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ConfigHistory.
     */
    data: XOR<ConfigHistoryUpdateInput, ConfigHistoryUncheckedUpdateInput>
    /**
     * Choose, which ConfigHistory to update.
     */
    where: ConfigHistoryWhereUniqueInput
  }

  /**
   * ConfigHistory updateMany
   */
  export type ConfigHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConfigHistories.
     */
    data: XOR<ConfigHistoryUpdateManyMutationInput, ConfigHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ConfigHistories to update
     */
    where?: ConfigHistoryWhereInput
    /**
     * Limit how many ConfigHistories to update.
     */
    limit?: number
  }

  /**
   * ConfigHistory updateManyAndReturn
   */
  export type ConfigHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigHistory
     */
    select?: ConfigHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigHistory
     */
    omit?: ConfigHistoryOmit<ExtArgs> | null
    /**
     * The data used to update ConfigHistories.
     */
    data: XOR<ConfigHistoryUpdateManyMutationInput, ConfigHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ConfigHistories to update
     */
    where?: ConfigHistoryWhereInput
    /**
     * Limit how many ConfigHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConfigHistory upsert
   */
  export type ConfigHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigHistory
     */
    select?: ConfigHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigHistory
     */
    omit?: ConfigHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ConfigHistory to update in case it exists.
     */
    where: ConfigHistoryWhereUniqueInput
    /**
     * In case the ConfigHistory found by the `where` argument doesn't exist, create a new ConfigHistory with this data.
     */
    create: XOR<ConfigHistoryCreateInput, ConfigHistoryUncheckedCreateInput>
    /**
     * In case the ConfigHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConfigHistoryUpdateInput, ConfigHistoryUncheckedUpdateInput>
  }

  /**
   * ConfigHistory delete
   */
  export type ConfigHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigHistory
     */
    select?: ConfigHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigHistory
     */
    omit?: ConfigHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigHistoryInclude<ExtArgs> | null
    /**
     * Filter which ConfigHistory to delete.
     */
    where: ConfigHistoryWhereUniqueInput
  }

  /**
   * ConfigHistory deleteMany
   */
  export type ConfigHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfigHistories to delete
     */
    where?: ConfigHistoryWhereInput
    /**
     * Limit how many ConfigHistories to delete.
     */
    limit?: number
  }

  /**
   * ConfigHistory without action
   */
  export type ConfigHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigHistory
     */
    select?: ConfigHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigHistory
     */
    omit?: ConfigHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigHistoryInclude<ExtArgs> | null
  }


  /**
   * Model ConfigTemplate
   */

  export type AggregateConfigTemplate = {
    _count: ConfigTemplateCountAggregateOutputType | null
    _avg: ConfigTemplateAvgAggregateOutputType | null
    _sum: ConfigTemplateSumAggregateOutputType | null
    _min: ConfigTemplateMinAggregateOutputType | null
    _max: ConfigTemplateMaxAggregateOutputType | null
  }

  export type ConfigTemplateAvgAggregateOutputType = {
    id: number | null
  }

  export type ConfigTemplateSumAggregateOutputType = {
    id: number | null
  }

  export type ConfigTemplateMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    category: string | null
    isDefault: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConfigTemplateMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    category: string | null
    isDefault: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConfigTemplateCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    template: number
    isDefault: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConfigTemplateAvgAggregateInputType = {
    id?: true
  }

  export type ConfigTemplateSumAggregateInputType = {
    id?: true
  }

  export type ConfigTemplateMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    isDefault?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConfigTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    isDefault?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConfigTemplateCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    template?: true
    isDefault?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConfigTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfigTemplate to aggregate.
     */
    where?: ConfigTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigTemplates to fetch.
     */
    orderBy?: ConfigTemplateOrderByWithRelationInput | ConfigTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConfigTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConfigTemplates
    **/
    _count?: true | ConfigTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConfigTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConfigTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfigTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfigTemplateMaxAggregateInputType
  }

  export type GetConfigTemplateAggregateType<T extends ConfigTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateConfigTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfigTemplate[P]>
      : GetScalarType<T[P], AggregateConfigTemplate[P]>
  }




  export type ConfigTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigTemplateWhereInput
    orderBy?: ConfigTemplateOrderByWithAggregationInput | ConfigTemplateOrderByWithAggregationInput[]
    by: ConfigTemplateScalarFieldEnum[] | ConfigTemplateScalarFieldEnum
    having?: ConfigTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfigTemplateCountAggregateInputType | true
    _avg?: ConfigTemplateAvgAggregateInputType
    _sum?: ConfigTemplateSumAggregateInputType
    _min?: ConfigTemplateMinAggregateInputType
    _max?: ConfigTemplateMaxAggregateInputType
  }

  export type ConfigTemplateGroupByOutputType = {
    id: number
    name: string
    description: string | null
    category: string
    template: JsonValue
    isDefault: boolean
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: ConfigTemplateCountAggregateOutputType | null
    _avg: ConfigTemplateAvgAggregateOutputType | null
    _sum: ConfigTemplateSumAggregateOutputType | null
    _min: ConfigTemplateMinAggregateOutputType | null
    _max: ConfigTemplateMaxAggregateOutputType | null
  }

  type GetConfigTemplateGroupByPayload<T extends ConfigTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfigTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfigTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfigTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], ConfigTemplateGroupByOutputType[P]>
        }
      >
    >


  export type ConfigTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    template?: boolean
    isDefault?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["configTemplate"]>

  export type ConfigTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    template?: boolean
    isDefault?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["configTemplate"]>

  export type ConfigTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    template?: boolean
    isDefault?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["configTemplate"]>

  export type ConfigTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    template?: boolean
    isDefault?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConfigTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "category" | "template" | "isDefault" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["configTemplate"]>

  export type $ConfigTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConfigTemplate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      category: string
      template: Prisma.JsonValue
      isDefault: boolean
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["configTemplate"]>
    composites: {}
  }

  type ConfigTemplateGetPayload<S extends boolean | null | undefined | ConfigTemplateDefaultArgs> = $Result.GetResult<Prisma.$ConfigTemplatePayload, S>

  type ConfigTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConfigTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConfigTemplateCountAggregateInputType | true
    }

  export interface ConfigTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConfigTemplate'], meta: { name: 'ConfigTemplate' } }
    /**
     * Find zero or one ConfigTemplate that matches the filter.
     * @param {ConfigTemplateFindUniqueArgs} args - Arguments to find a ConfigTemplate
     * @example
     * // Get one ConfigTemplate
     * const configTemplate = await prisma.configTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConfigTemplateFindUniqueArgs>(args: SelectSubset<T, ConfigTemplateFindUniqueArgs<ExtArgs>>): Prisma__ConfigTemplateClient<$Result.GetResult<Prisma.$ConfigTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConfigTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConfigTemplateFindUniqueOrThrowArgs} args - Arguments to find a ConfigTemplate
     * @example
     * // Get one ConfigTemplate
     * const configTemplate = await prisma.configTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConfigTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, ConfigTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConfigTemplateClient<$Result.GetResult<Prisma.$ConfigTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConfigTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigTemplateFindFirstArgs} args - Arguments to find a ConfigTemplate
     * @example
     * // Get one ConfigTemplate
     * const configTemplate = await prisma.configTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConfigTemplateFindFirstArgs>(args?: SelectSubset<T, ConfigTemplateFindFirstArgs<ExtArgs>>): Prisma__ConfigTemplateClient<$Result.GetResult<Prisma.$ConfigTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConfigTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigTemplateFindFirstOrThrowArgs} args - Arguments to find a ConfigTemplate
     * @example
     * // Get one ConfigTemplate
     * const configTemplate = await prisma.configTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConfigTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, ConfigTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConfigTemplateClient<$Result.GetResult<Prisma.$ConfigTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConfigTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConfigTemplates
     * const configTemplates = await prisma.configTemplate.findMany()
     * 
     * // Get first 10 ConfigTemplates
     * const configTemplates = await prisma.configTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const configTemplateWithIdOnly = await prisma.configTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConfigTemplateFindManyArgs>(args?: SelectSubset<T, ConfigTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConfigTemplate.
     * @param {ConfigTemplateCreateArgs} args - Arguments to create a ConfigTemplate.
     * @example
     * // Create one ConfigTemplate
     * const ConfigTemplate = await prisma.configTemplate.create({
     *   data: {
     *     // ... data to create a ConfigTemplate
     *   }
     * })
     * 
     */
    create<T extends ConfigTemplateCreateArgs>(args: SelectSubset<T, ConfigTemplateCreateArgs<ExtArgs>>): Prisma__ConfigTemplateClient<$Result.GetResult<Prisma.$ConfigTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConfigTemplates.
     * @param {ConfigTemplateCreateManyArgs} args - Arguments to create many ConfigTemplates.
     * @example
     * // Create many ConfigTemplates
     * const configTemplate = await prisma.configTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConfigTemplateCreateManyArgs>(args?: SelectSubset<T, ConfigTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConfigTemplates and returns the data saved in the database.
     * @param {ConfigTemplateCreateManyAndReturnArgs} args - Arguments to create many ConfigTemplates.
     * @example
     * // Create many ConfigTemplates
     * const configTemplate = await prisma.configTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConfigTemplates and only return the `id`
     * const configTemplateWithIdOnly = await prisma.configTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConfigTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, ConfigTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConfigTemplate.
     * @param {ConfigTemplateDeleteArgs} args - Arguments to delete one ConfigTemplate.
     * @example
     * // Delete one ConfigTemplate
     * const ConfigTemplate = await prisma.configTemplate.delete({
     *   where: {
     *     // ... filter to delete one ConfigTemplate
     *   }
     * })
     * 
     */
    delete<T extends ConfigTemplateDeleteArgs>(args: SelectSubset<T, ConfigTemplateDeleteArgs<ExtArgs>>): Prisma__ConfigTemplateClient<$Result.GetResult<Prisma.$ConfigTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConfigTemplate.
     * @param {ConfigTemplateUpdateArgs} args - Arguments to update one ConfigTemplate.
     * @example
     * // Update one ConfigTemplate
     * const configTemplate = await prisma.configTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConfigTemplateUpdateArgs>(args: SelectSubset<T, ConfigTemplateUpdateArgs<ExtArgs>>): Prisma__ConfigTemplateClient<$Result.GetResult<Prisma.$ConfigTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConfigTemplates.
     * @param {ConfigTemplateDeleteManyArgs} args - Arguments to filter ConfigTemplates to delete.
     * @example
     * // Delete a few ConfigTemplates
     * const { count } = await prisma.configTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConfigTemplateDeleteManyArgs>(args?: SelectSubset<T, ConfigTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConfigTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConfigTemplates
     * const configTemplate = await prisma.configTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConfigTemplateUpdateManyArgs>(args: SelectSubset<T, ConfigTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConfigTemplates and returns the data updated in the database.
     * @param {ConfigTemplateUpdateManyAndReturnArgs} args - Arguments to update many ConfigTemplates.
     * @example
     * // Update many ConfigTemplates
     * const configTemplate = await prisma.configTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConfigTemplates and only return the `id`
     * const configTemplateWithIdOnly = await prisma.configTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConfigTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, ConfigTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConfigTemplate.
     * @param {ConfigTemplateUpsertArgs} args - Arguments to update or create a ConfigTemplate.
     * @example
     * // Update or create a ConfigTemplate
     * const configTemplate = await prisma.configTemplate.upsert({
     *   create: {
     *     // ... data to create a ConfigTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConfigTemplate we want to update
     *   }
     * })
     */
    upsert<T extends ConfigTemplateUpsertArgs>(args: SelectSubset<T, ConfigTemplateUpsertArgs<ExtArgs>>): Prisma__ConfigTemplateClient<$Result.GetResult<Prisma.$ConfigTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConfigTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigTemplateCountArgs} args - Arguments to filter ConfigTemplates to count.
     * @example
     * // Count the number of ConfigTemplates
     * const count = await prisma.configTemplate.count({
     *   where: {
     *     // ... the filter for the ConfigTemplates we want to count
     *   }
     * })
    **/
    count<T extends ConfigTemplateCountArgs>(
      args?: Subset<T, ConfigTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfigTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConfigTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfigTemplateAggregateArgs>(args: Subset<T, ConfigTemplateAggregateArgs>): Prisma.PrismaPromise<GetConfigTemplateAggregateType<T>>

    /**
     * Group by ConfigTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConfigTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConfigTemplateGroupByArgs['orderBy'] }
        : { orderBy?: ConfigTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConfigTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfigTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConfigTemplate model
   */
  readonly fields: ConfigTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConfigTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConfigTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConfigTemplate model
   */
  interface ConfigTemplateFieldRefs {
    readonly id: FieldRef<"ConfigTemplate", 'Int'>
    readonly name: FieldRef<"ConfigTemplate", 'String'>
    readonly description: FieldRef<"ConfigTemplate", 'String'>
    readonly category: FieldRef<"ConfigTemplate", 'String'>
    readonly template: FieldRef<"ConfigTemplate", 'Json'>
    readonly isDefault: FieldRef<"ConfigTemplate", 'Boolean'>
    readonly createdBy: FieldRef<"ConfigTemplate", 'String'>
    readonly createdAt: FieldRef<"ConfigTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"ConfigTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConfigTemplate findUnique
   */
  export type ConfigTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigTemplate
     */
    select?: ConfigTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigTemplate
     */
    omit?: ConfigTemplateOmit<ExtArgs> | null
    /**
     * Filter, which ConfigTemplate to fetch.
     */
    where: ConfigTemplateWhereUniqueInput
  }

  /**
   * ConfigTemplate findUniqueOrThrow
   */
  export type ConfigTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigTemplate
     */
    select?: ConfigTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigTemplate
     */
    omit?: ConfigTemplateOmit<ExtArgs> | null
    /**
     * Filter, which ConfigTemplate to fetch.
     */
    where: ConfigTemplateWhereUniqueInput
  }

  /**
   * ConfigTemplate findFirst
   */
  export type ConfigTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigTemplate
     */
    select?: ConfigTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigTemplate
     */
    omit?: ConfigTemplateOmit<ExtArgs> | null
    /**
     * Filter, which ConfigTemplate to fetch.
     */
    where?: ConfigTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigTemplates to fetch.
     */
    orderBy?: ConfigTemplateOrderByWithRelationInput | ConfigTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfigTemplates.
     */
    cursor?: ConfigTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfigTemplates.
     */
    distinct?: ConfigTemplateScalarFieldEnum | ConfigTemplateScalarFieldEnum[]
  }

  /**
   * ConfigTemplate findFirstOrThrow
   */
  export type ConfigTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigTemplate
     */
    select?: ConfigTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigTemplate
     */
    omit?: ConfigTemplateOmit<ExtArgs> | null
    /**
     * Filter, which ConfigTemplate to fetch.
     */
    where?: ConfigTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigTemplates to fetch.
     */
    orderBy?: ConfigTemplateOrderByWithRelationInput | ConfigTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfigTemplates.
     */
    cursor?: ConfigTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfigTemplates.
     */
    distinct?: ConfigTemplateScalarFieldEnum | ConfigTemplateScalarFieldEnum[]
  }

  /**
   * ConfigTemplate findMany
   */
  export type ConfigTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigTemplate
     */
    select?: ConfigTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigTemplate
     */
    omit?: ConfigTemplateOmit<ExtArgs> | null
    /**
     * Filter, which ConfigTemplates to fetch.
     */
    where?: ConfigTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigTemplates to fetch.
     */
    orderBy?: ConfigTemplateOrderByWithRelationInput | ConfigTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConfigTemplates.
     */
    cursor?: ConfigTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigTemplates.
     */
    skip?: number
    distinct?: ConfigTemplateScalarFieldEnum | ConfigTemplateScalarFieldEnum[]
  }

  /**
   * ConfigTemplate create
   */
  export type ConfigTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigTemplate
     */
    select?: ConfigTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigTemplate
     */
    omit?: ConfigTemplateOmit<ExtArgs> | null
    /**
     * The data needed to create a ConfigTemplate.
     */
    data: XOR<ConfigTemplateCreateInput, ConfigTemplateUncheckedCreateInput>
  }

  /**
   * ConfigTemplate createMany
   */
  export type ConfigTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConfigTemplates.
     */
    data: ConfigTemplateCreateManyInput | ConfigTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConfigTemplate createManyAndReturn
   */
  export type ConfigTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigTemplate
     */
    select?: ConfigTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigTemplate
     */
    omit?: ConfigTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many ConfigTemplates.
     */
    data: ConfigTemplateCreateManyInput | ConfigTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConfigTemplate update
   */
  export type ConfigTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigTemplate
     */
    select?: ConfigTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigTemplate
     */
    omit?: ConfigTemplateOmit<ExtArgs> | null
    /**
     * The data needed to update a ConfigTemplate.
     */
    data: XOR<ConfigTemplateUpdateInput, ConfigTemplateUncheckedUpdateInput>
    /**
     * Choose, which ConfigTemplate to update.
     */
    where: ConfigTemplateWhereUniqueInput
  }

  /**
   * ConfigTemplate updateMany
   */
  export type ConfigTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConfigTemplates.
     */
    data: XOR<ConfigTemplateUpdateManyMutationInput, ConfigTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ConfigTemplates to update
     */
    where?: ConfigTemplateWhereInput
    /**
     * Limit how many ConfigTemplates to update.
     */
    limit?: number
  }

  /**
   * ConfigTemplate updateManyAndReturn
   */
  export type ConfigTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigTemplate
     */
    select?: ConfigTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigTemplate
     */
    omit?: ConfigTemplateOmit<ExtArgs> | null
    /**
     * The data used to update ConfigTemplates.
     */
    data: XOR<ConfigTemplateUpdateManyMutationInput, ConfigTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ConfigTemplates to update
     */
    where?: ConfigTemplateWhereInput
    /**
     * Limit how many ConfigTemplates to update.
     */
    limit?: number
  }

  /**
   * ConfigTemplate upsert
   */
  export type ConfigTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigTemplate
     */
    select?: ConfigTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigTemplate
     */
    omit?: ConfigTemplateOmit<ExtArgs> | null
    /**
     * The filter to search for the ConfigTemplate to update in case it exists.
     */
    where: ConfigTemplateWhereUniqueInput
    /**
     * In case the ConfigTemplate found by the `where` argument doesn't exist, create a new ConfigTemplate with this data.
     */
    create: XOR<ConfigTemplateCreateInput, ConfigTemplateUncheckedCreateInput>
    /**
     * In case the ConfigTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConfigTemplateUpdateInput, ConfigTemplateUncheckedUpdateInput>
  }

  /**
   * ConfigTemplate delete
   */
  export type ConfigTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigTemplate
     */
    select?: ConfigTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigTemplate
     */
    omit?: ConfigTemplateOmit<ExtArgs> | null
    /**
     * Filter which ConfigTemplate to delete.
     */
    where: ConfigTemplateWhereUniqueInput
  }

  /**
   * ConfigTemplate deleteMany
   */
  export type ConfigTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfigTemplates to delete
     */
    where?: ConfigTemplateWhereInput
    /**
     * Limit how many ConfigTemplates to delete.
     */
    limit?: number
  }

  /**
   * ConfigTemplate without action
   */
  export type ConfigTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigTemplate
     */
    select?: ConfigTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigTemplate
     */
    omit?: ConfigTemplateOmit<ExtArgs> | null
  }


  /**
   * Model Kiosk
   */

  export type AggregateKiosk = {
    _count: KioskCountAggregateOutputType | null
    _min: KioskMinAggregateOutputType | null
    _max: KioskMaxAggregateOutputType | null
  }

  export type KioskMinAggregateOutputType = {
    id: string | null
    lastSeen: Date | null
    version: string | null
    active: boolean | null
    logoUrl: string | null
    bgUrl: string | null
    statusEnabled: boolean | null
    currentStatus: string | null
    openMsg: string | null
    closedMsg: string | null
    errorMsg: string | null
    meetingMsg: string | null
    brbMsg: string | null
    lunchMsg: string | null
    unavailableMsg: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KioskMaxAggregateOutputType = {
    id: string | null
    lastSeen: Date | null
    version: string | null
    active: boolean | null
    logoUrl: string | null
    bgUrl: string | null
    statusEnabled: boolean | null
    currentStatus: string | null
    openMsg: string | null
    closedMsg: string | null
    errorMsg: string | null
    meetingMsg: string | null
    brbMsg: string | null
    lunchMsg: string | null
    unavailableMsg: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KioskCountAggregateOutputType = {
    id: number
    lastSeen: number
    version: number
    active: number
    logoUrl: number
    bgUrl: number
    statusEnabled: number
    currentStatus: number
    openMsg: number
    closedMsg: number
    errorMsg: number
    meetingMsg: number
    brbMsg: number
    lunchMsg: number
    unavailableMsg: number
    schedule: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KioskMinAggregateInputType = {
    id?: true
    lastSeen?: true
    version?: true
    active?: true
    logoUrl?: true
    bgUrl?: true
    statusEnabled?: true
    currentStatus?: true
    openMsg?: true
    closedMsg?: true
    errorMsg?: true
    meetingMsg?: true
    brbMsg?: true
    lunchMsg?: true
    unavailableMsg?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KioskMaxAggregateInputType = {
    id?: true
    lastSeen?: true
    version?: true
    active?: true
    logoUrl?: true
    bgUrl?: true
    statusEnabled?: true
    currentStatus?: true
    openMsg?: true
    closedMsg?: true
    errorMsg?: true
    meetingMsg?: true
    brbMsg?: true
    lunchMsg?: true
    unavailableMsg?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KioskCountAggregateInputType = {
    id?: true
    lastSeen?: true
    version?: true
    active?: true
    logoUrl?: true
    bgUrl?: true
    statusEnabled?: true
    currentStatus?: true
    openMsg?: true
    closedMsg?: true
    errorMsg?: true
    meetingMsg?: true
    brbMsg?: true
    lunchMsg?: true
    unavailableMsg?: true
    schedule?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KioskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kiosk to aggregate.
     */
    where?: KioskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kiosks to fetch.
     */
    orderBy?: KioskOrderByWithRelationInput | KioskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KioskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kiosks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kiosks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Kiosks
    **/
    _count?: true | KioskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KioskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KioskMaxAggregateInputType
  }

  export type GetKioskAggregateType<T extends KioskAggregateArgs> = {
        [P in keyof T & keyof AggregateKiosk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKiosk[P]>
      : GetScalarType<T[P], AggregateKiosk[P]>
  }




  export type KioskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KioskWhereInput
    orderBy?: KioskOrderByWithAggregationInput | KioskOrderByWithAggregationInput[]
    by: KioskScalarFieldEnum[] | KioskScalarFieldEnum
    having?: KioskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KioskCountAggregateInputType | true
    _min?: KioskMinAggregateInputType
    _max?: KioskMaxAggregateInputType
  }

  export type KioskGroupByOutputType = {
    id: string
    lastSeen: Date | null
    version: string | null
    active: boolean
    logoUrl: string | null
    bgUrl: string | null
    statusEnabled: boolean
    currentStatus: string | null
    openMsg: string | null
    closedMsg: string | null
    errorMsg: string | null
    meetingMsg: string | null
    brbMsg: string | null
    lunchMsg: string | null
    unavailableMsg: string | null
    schedule: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: KioskCountAggregateOutputType | null
    _min: KioskMinAggregateOutputType | null
    _max: KioskMaxAggregateOutputType | null
  }

  type GetKioskGroupByPayload<T extends KioskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KioskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KioskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KioskGroupByOutputType[P]>
            : GetScalarType<T[P], KioskGroupByOutputType[P]>
        }
      >
    >


  export type KioskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lastSeen?: boolean
    version?: boolean
    active?: boolean
    logoUrl?: boolean
    bgUrl?: boolean
    statusEnabled?: boolean
    currentStatus?: boolean
    openMsg?: boolean
    closedMsg?: boolean
    errorMsg?: boolean
    meetingMsg?: boolean
    brbMsg?: boolean
    lunchMsg?: boolean
    unavailableMsg?: boolean
    schedule?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    activations?: boolean | Kiosk$activationsArgs<ExtArgs>
    assetRegistry?: boolean | Kiosk$assetRegistryArgs<ExtArgs>
    syncFailures?: boolean | Kiosk$syncFailuresArgs<ExtArgs>
    orgAssignment?: boolean | Kiosk$orgAssignmentArgs<ExtArgs>
    metadataLogs?: boolean | Kiosk$metadataLogsArgs<ExtArgs>
    _count?: boolean | KioskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kiosk"]>

  export type KioskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lastSeen?: boolean
    version?: boolean
    active?: boolean
    logoUrl?: boolean
    bgUrl?: boolean
    statusEnabled?: boolean
    currentStatus?: boolean
    openMsg?: boolean
    closedMsg?: boolean
    errorMsg?: boolean
    meetingMsg?: boolean
    brbMsg?: boolean
    lunchMsg?: boolean
    unavailableMsg?: boolean
    schedule?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["kiosk"]>

  export type KioskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lastSeen?: boolean
    version?: boolean
    active?: boolean
    logoUrl?: boolean
    bgUrl?: boolean
    statusEnabled?: boolean
    currentStatus?: boolean
    openMsg?: boolean
    closedMsg?: boolean
    errorMsg?: boolean
    meetingMsg?: boolean
    brbMsg?: boolean
    lunchMsg?: boolean
    unavailableMsg?: boolean
    schedule?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["kiosk"]>

  export type KioskSelectScalar = {
    id?: boolean
    lastSeen?: boolean
    version?: boolean
    active?: boolean
    logoUrl?: boolean
    bgUrl?: boolean
    statusEnabled?: boolean
    currentStatus?: boolean
    openMsg?: boolean
    closedMsg?: boolean
    errorMsg?: boolean
    meetingMsg?: boolean
    brbMsg?: boolean
    lunchMsg?: boolean
    unavailableMsg?: boolean
    schedule?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KioskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lastSeen" | "version" | "active" | "logoUrl" | "bgUrl" | "statusEnabled" | "currentStatus" | "openMsg" | "closedMsg" | "errorMsg" | "meetingMsg" | "brbMsg" | "lunchMsg" | "unavailableMsg" | "schedule" | "createdAt" | "updatedAt", ExtArgs["result"]["kiosk"]>
  export type KioskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activations?: boolean | Kiosk$activationsArgs<ExtArgs>
    assetRegistry?: boolean | Kiosk$assetRegistryArgs<ExtArgs>
    syncFailures?: boolean | Kiosk$syncFailuresArgs<ExtArgs>
    orgAssignment?: boolean | Kiosk$orgAssignmentArgs<ExtArgs>
    metadataLogs?: boolean | Kiosk$metadataLogsArgs<ExtArgs>
    _count?: boolean | KioskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KioskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type KioskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $KioskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Kiosk"
    objects: {
      activations: Prisma.$KioskActivationPayload<ExtArgs>[]
      assetRegistry: Prisma.$KioskAssetRegistryPayload<ExtArgs>[]
      syncFailures: Prisma.$HelixSyncFailurePayload<ExtArgs>[]
      orgAssignment: Prisma.$KioskOrganizationAssignmentPayload<ExtArgs> | null
      metadataLogs: Prisma.$KioskMetadataLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lastSeen: Date | null
      version: string | null
      active: boolean
      logoUrl: string | null
      bgUrl: string | null
      statusEnabled: boolean
      currentStatus: string | null
      openMsg: string | null
      closedMsg: string | null
      errorMsg: string | null
      meetingMsg: string | null
      brbMsg: string | null
      lunchMsg: string | null
      unavailableMsg: string | null
      schedule: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["kiosk"]>
    composites: {}
  }

  type KioskGetPayload<S extends boolean | null | undefined | KioskDefaultArgs> = $Result.GetResult<Prisma.$KioskPayload, S>

  type KioskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KioskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KioskCountAggregateInputType | true
    }

  export interface KioskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Kiosk'], meta: { name: 'Kiosk' } }
    /**
     * Find zero or one Kiosk that matches the filter.
     * @param {KioskFindUniqueArgs} args - Arguments to find a Kiosk
     * @example
     * // Get one Kiosk
     * const kiosk = await prisma.kiosk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KioskFindUniqueArgs>(args: SelectSubset<T, KioskFindUniqueArgs<ExtArgs>>): Prisma__KioskClient<$Result.GetResult<Prisma.$KioskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Kiosk that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KioskFindUniqueOrThrowArgs} args - Arguments to find a Kiosk
     * @example
     * // Get one Kiosk
     * const kiosk = await prisma.kiosk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KioskFindUniqueOrThrowArgs>(args: SelectSubset<T, KioskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KioskClient<$Result.GetResult<Prisma.$KioskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Kiosk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskFindFirstArgs} args - Arguments to find a Kiosk
     * @example
     * // Get one Kiosk
     * const kiosk = await prisma.kiosk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KioskFindFirstArgs>(args?: SelectSubset<T, KioskFindFirstArgs<ExtArgs>>): Prisma__KioskClient<$Result.GetResult<Prisma.$KioskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Kiosk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskFindFirstOrThrowArgs} args - Arguments to find a Kiosk
     * @example
     * // Get one Kiosk
     * const kiosk = await prisma.kiosk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KioskFindFirstOrThrowArgs>(args?: SelectSubset<T, KioskFindFirstOrThrowArgs<ExtArgs>>): Prisma__KioskClient<$Result.GetResult<Prisma.$KioskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Kiosks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kiosks
     * const kiosks = await prisma.kiosk.findMany()
     * 
     * // Get first 10 Kiosks
     * const kiosks = await prisma.kiosk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kioskWithIdOnly = await prisma.kiosk.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KioskFindManyArgs>(args?: SelectSubset<T, KioskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KioskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Kiosk.
     * @param {KioskCreateArgs} args - Arguments to create a Kiosk.
     * @example
     * // Create one Kiosk
     * const Kiosk = await prisma.kiosk.create({
     *   data: {
     *     // ... data to create a Kiosk
     *   }
     * })
     * 
     */
    create<T extends KioskCreateArgs>(args: SelectSubset<T, KioskCreateArgs<ExtArgs>>): Prisma__KioskClient<$Result.GetResult<Prisma.$KioskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Kiosks.
     * @param {KioskCreateManyArgs} args - Arguments to create many Kiosks.
     * @example
     * // Create many Kiosks
     * const kiosk = await prisma.kiosk.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KioskCreateManyArgs>(args?: SelectSubset<T, KioskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Kiosks and returns the data saved in the database.
     * @param {KioskCreateManyAndReturnArgs} args - Arguments to create many Kiosks.
     * @example
     * // Create many Kiosks
     * const kiosk = await prisma.kiosk.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Kiosks and only return the `id`
     * const kioskWithIdOnly = await prisma.kiosk.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KioskCreateManyAndReturnArgs>(args?: SelectSubset<T, KioskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KioskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Kiosk.
     * @param {KioskDeleteArgs} args - Arguments to delete one Kiosk.
     * @example
     * // Delete one Kiosk
     * const Kiosk = await prisma.kiosk.delete({
     *   where: {
     *     // ... filter to delete one Kiosk
     *   }
     * })
     * 
     */
    delete<T extends KioskDeleteArgs>(args: SelectSubset<T, KioskDeleteArgs<ExtArgs>>): Prisma__KioskClient<$Result.GetResult<Prisma.$KioskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Kiosk.
     * @param {KioskUpdateArgs} args - Arguments to update one Kiosk.
     * @example
     * // Update one Kiosk
     * const kiosk = await prisma.kiosk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KioskUpdateArgs>(args: SelectSubset<T, KioskUpdateArgs<ExtArgs>>): Prisma__KioskClient<$Result.GetResult<Prisma.$KioskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Kiosks.
     * @param {KioskDeleteManyArgs} args - Arguments to filter Kiosks to delete.
     * @example
     * // Delete a few Kiosks
     * const { count } = await prisma.kiosk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KioskDeleteManyArgs>(args?: SelectSubset<T, KioskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kiosks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kiosks
     * const kiosk = await prisma.kiosk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KioskUpdateManyArgs>(args: SelectSubset<T, KioskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kiosks and returns the data updated in the database.
     * @param {KioskUpdateManyAndReturnArgs} args - Arguments to update many Kiosks.
     * @example
     * // Update many Kiosks
     * const kiosk = await prisma.kiosk.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Kiosks and only return the `id`
     * const kioskWithIdOnly = await prisma.kiosk.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KioskUpdateManyAndReturnArgs>(args: SelectSubset<T, KioskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KioskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Kiosk.
     * @param {KioskUpsertArgs} args - Arguments to update or create a Kiosk.
     * @example
     * // Update or create a Kiosk
     * const kiosk = await prisma.kiosk.upsert({
     *   create: {
     *     // ... data to create a Kiosk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kiosk we want to update
     *   }
     * })
     */
    upsert<T extends KioskUpsertArgs>(args: SelectSubset<T, KioskUpsertArgs<ExtArgs>>): Prisma__KioskClient<$Result.GetResult<Prisma.$KioskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Kiosks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskCountArgs} args - Arguments to filter Kiosks to count.
     * @example
     * // Count the number of Kiosks
     * const count = await prisma.kiosk.count({
     *   where: {
     *     // ... the filter for the Kiosks we want to count
     *   }
     * })
    **/
    count<T extends KioskCountArgs>(
      args?: Subset<T, KioskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KioskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kiosk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KioskAggregateArgs>(args: Subset<T, KioskAggregateArgs>): Prisma.PrismaPromise<GetKioskAggregateType<T>>

    /**
     * Group by Kiosk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KioskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KioskGroupByArgs['orderBy'] }
        : { orderBy?: KioskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KioskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKioskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Kiosk model
   */
  readonly fields: KioskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Kiosk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KioskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activations<T extends Kiosk$activationsArgs<ExtArgs> = {}>(args?: Subset<T, Kiosk$activationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KioskActivationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assetRegistry<T extends Kiosk$assetRegistryArgs<ExtArgs> = {}>(args?: Subset<T, Kiosk$assetRegistryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KioskAssetRegistryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    syncFailures<T extends Kiosk$syncFailuresArgs<ExtArgs> = {}>(args?: Subset<T, Kiosk$syncFailuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelixSyncFailurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orgAssignment<T extends Kiosk$orgAssignmentArgs<ExtArgs> = {}>(args?: Subset<T, Kiosk$orgAssignmentArgs<ExtArgs>>): Prisma__KioskOrganizationAssignmentClient<$Result.GetResult<Prisma.$KioskOrganizationAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    metadataLogs<T extends Kiosk$metadataLogsArgs<ExtArgs> = {}>(args?: Subset<T, Kiosk$metadataLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KioskMetadataLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Kiosk model
   */
  interface KioskFieldRefs {
    readonly id: FieldRef<"Kiosk", 'String'>
    readonly lastSeen: FieldRef<"Kiosk", 'DateTime'>
    readonly version: FieldRef<"Kiosk", 'String'>
    readonly active: FieldRef<"Kiosk", 'Boolean'>
    readonly logoUrl: FieldRef<"Kiosk", 'String'>
    readonly bgUrl: FieldRef<"Kiosk", 'String'>
    readonly statusEnabled: FieldRef<"Kiosk", 'Boolean'>
    readonly currentStatus: FieldRef<"Kiosk", 'String'>
    readonly openMsg: FieldRef<"Kiosk", 'String'>
    readonly closedMsg: FieldRef<"Kiosk", 'String'>
    readonly errorMsg: FieldRef<"Kiosk", 'String'>
    readonly meetingMsg: FieldRef<"Kiosk", 'String'>
    readonly brbMsg: FieldRef<"Kiosk", 'String'>
    readonly lunchMsg: FieldRef<"Kiosk", 'String'>
    readonly unavailableMsg: FieldRef<"Kiosk", 'String'>
    readonly schedule: FieldRef<"Kiosk", 'Json'>
    readonly createdAt: FieldRef<"Kiosk", 'DateTime'>
    readonly updatedAt: FieldRef<"Kiosk", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Kiosk findUnique
   */
  export type KioskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kiosk
     */
    select?: KioskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kiosk
     */
    omit?: KioskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskInclude<ExtArgs> | null
    /**
     * Filter, which Kiosk to fetch.
     */
    where: KioskWhereUniqueInput
  }

  /**
   * Kiosk findUniqueOrThrow
   */
  export type KioskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kiosk
     */
    select?: KioskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kiosk
     */
    omit?: KioskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskInclude<ExtArgs> | null
    /**
     * Filter, which Kiosk to fetch.
     */
    where: KioskWhereUniqueInput
  }

  /**
   * Kiosk findFirst
   */
  export type KioskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kiosk
     */
    select?: KioskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kiosk
     */
    omit?: KioskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskInclude<ExtArgs> | null
    /**
     * Filter, which Kiosk to fetch.
     */
    where?: KioskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kiosks to fetch.
     */
    orderBy?: KioskOrderByWithRelationInput | KioskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kiosks.
     */
    cursor?: KioskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kiosks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kiosks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kiosks.
     */
    distinct?: KioskScalarFieldEnum | KioskScalarFieldEnum[]
  }

  /**
   * Kiosk findFirstOrThrow
   */
  export type KioskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kiosk
     */
    select?: KioskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kiosk
     */
    omit?: KioskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskInclude<ExtArgs> | null
    /**
     * Filter, which Kiosk to fetch.
     */
    where?: KioskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kiosks to fetch.
     */
    orderBy?: KioskOrderByWithRelationInput | KioskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kiosks.
     */
    cursor?: KioskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kiosks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kiosks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kiosks.
     */
    distinct?: KioskScalarFieldEnum | KioskScalarFieldEnum[]
  }

  /**
   * Kiosk findMany
   */
  export type KioskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kiosk
     */
    select?: KioskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kiosk
     */
    omit?: KioskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskInclude<ExtArgs> | null
    /**
     * Filter, which Kiosks to fetch.
     */
    where?: KioskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kiosks to fetch.
     */
    orderBy?: KioskOrderByWithRelationInput | KioskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Kiosks.
     */
    cursor?: KioskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kiosks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kiosks.
     */
    skip?: number
    distinct?: KioskScalarFieldEnum | KioskScalarFieldEnum[]
  }

  /**
   * Kiosk create
   */
  export type KioskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kiosk
     */
    select?: KioskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kiosk
     */
    omit?: KioskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskInclude<ExtArgs> | null
    /**
     * The data needed to create a Kiosk.
     */
    data: XOR<KioskCreateInput, KioskUncheckedCreateInput>
  }

  /**
   * Kiosk createMany
   */
  export type KioskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Kiosks.
     */
    data: KioskCreateManyInput | KioskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Kiosk createManyAndReturn
   */
  export type KioskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kiosk
     */
    select?: KioskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Kiosk
     */
    omit?: KioskOmit<ExtArgs> | null
    /**
     * The data used to create many Kiosks.
     */
    data: KioskCreateManyInput | KioskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Kiosk update
   */
  export type KioskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kiosk
     */
    select?: KioskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kiosk
     */
    omit?: KioskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskInclude<ExtArgs> | null
    /**
     * The data needed to update a Kiosk.
     */
    data: XOR<KioskUpdateInput, KioskUncheckedUpdateInput>
    /**
     * Choose, which Kiosk to update.
     */
    where: KioskWhereUniqueInput
  }

  /**
   * Kiosk updateMany
   */
  export type KioskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Kiosks.
     */
    data: XOR<KioskUpdateManyMutationInput, KioskUncheckedUpdateManyInput>
    /**
     * Filter which Kiosks to update
     */
    where?: KioskWhereInput
    /**
     * Limit how many Kiosks to update.
     */
    limit?: number
  }

  /**
   * Kiosk updateManyAndReturn
   */
  export type KioskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kiosk
     */
    select?: KioskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Kiosk
     */
    omit?: KioskOmit<ExtArgs> | null
    /**
     * The data used to update Kiosks.
     */
    data: XOR<KioskUpdateManyMutationInput, KioskUncheckedUpdateManyInput>
    /**
     * Filter which Kiosks to update
     */
    where?: KioskWhereInput
    /**
     * Limit how many Kiosks to update.
     */
    limit?: number
  }

  /**
   * Kiosk upsert
   */
  export type KioskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kiosk
     */
    select?: KioskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kiosk
     */
    omit?: KioskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskInclude<ExtArgs> | null
    /**
     * The filter to search for the Kiosk to update in case it exists.
     */
    where: KioskWhereUniqueInput
    /**
     * In case the Kiosk found by the `where` argument doesn't exist, create a new Kiosk with this data.
     */
    create: XOR<KioskCreateInput, KioskUncheckedCreateInput>
    /**
     * In case the Kiosk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KioskUpdateInput, KioskUncheckedUpdateInput>
  }

  /**
   * Kiosk delete
   */
  export type KioskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kiosk
     */
    select?: KioskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kiosk
     */
    omit?: KioskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskInclude<ExtArgs> | null
    /**
     * Filter which Kiosk to delete.
     */
    where: KioskWhereUniqueInput
  }

  /**
   * Kiosk deleteMany
   */
  export type KioskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kiosks to delete
     */
    where?: KioskWhereInput
    /**
     * Limit how many Kiosks to delete.
     */
    limit?: number
  }

  /**
   * Kiosk.activations
   */
  export type Kiosk$activationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskActivation
     */
    select?: KioskActivationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskActivation
     */
    omit?: KioskActivationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskActivationInclude<ExtArgs> | null
    where?: KioskActivationWhereInput
    orderBy?: KioskActivationOrderByWithRelationInput | KioskActivationOrderByWithRelationInput[]
    cursor?: KioskActivationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KioskActivationScalarFieldEnum | KioskActivationScalarFieldEnum[]
  }

  /**
   * Kiosk.assetRegistry
   */
  export type Kiosk$assetRegistryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskAssetRegistry
     */
    select?: KioskAssetRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskAssetRegistry
     */
    omit?: KioskAssetRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskAssetRegistryInclude<ExtArgs> | null
    where?: KioskAssetRegistryWhereInput
    orderBy?: KioskAssetRegistryOrderByWithRelationInput | KioskAssetRegistryOrderByWithRelationInput[]
    cursor?: KioskAssetRegistryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KioskAssetRegistryScalarFieldEnum | KioskAssetRegistryScalarFieldEnum[]
  }

  /**
   * Kiosk.syncFailures
   */
  export type Kiosk$syncFailuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelixSyncFailure
     */
    select?: HelixSyncFailureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelixSyncFailure
     */
    omit?: HelixSyncFailureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelixSyncFailureInclude<ExtArgs> | null
    where?: HelixSyncFailureWhereInput
    orderBy?: HelixSyncFailureOrderByWithRelationInput | HelixSyncFailureOrderByWithRelationInput[]
    cursor?: HelixSyncFailureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HelixSyncFailureScalarFieldEnum | HelixSyncFailureScalarFieldEnum[]
  }

  /**
   * Kiosk.orgAssignment
   */
  export type Kiosk$orgAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskOrganizationAssignment
     */
    select?: KioskOrganizationAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskOrganizationAssignment
     */
    omit?: KioskOrganizationAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskOrganizationAssignmentInclude<ExtArgs> | null
    where?: KioskOrganizationAssignmentWhereInput
  }

  /**
   * Kiosk.metadataLogs
   */
  export type Kiosk$metadataLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskMetadataLog
     */
    select?: KioskMetadataLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskMetadataLog
     */
    omit?: KioskMetadataLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskMetadataLogInclude<ExtArgs> | null
    where?: KioskMetadataLogWhereInput
    orderBy?: KioskMetadataLogOrderByWithRelationInput | KioskMetadataLogOrderByWithRelationInput[]
    cursor?: KioskMetadataLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KioskMetadataLogScalarFieldEnum | KioskMetadataLogScalarFieldEnum[]
  }

  /**
   * Kiosk without action
   */
  export type KioskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kiosk
     */
    select?: KioskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kiosk
     */
    omit?: KioskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskInclude<ExtArgs> | null
  }


  /**
   * Model Feedback
   */

  export type AggregateFeedback = {
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  export type FeedbackAvgAggregateOutputType = {
    id: number | null
  }

  export type FeedbackSumAggregateOutputType = {
    id: number | null
  }

  export type FeedbackMinAggregateOutputType = {
    id: number | null
    name: string | null
    message: string | null
    timestamp: Date | null
    userId: string | null
  }

  export type FeedbackMaxAggregateOutputType = {
    id: number | null
    name: string | null
    message: string | null
    timestamp: Date | null
    userId: string | null
  }

  export type FeedbackCountAggregateOutputType = {
    id: number
    name: number
    message: number
    timestamp: number
    userId: number
    _all: number
  }


  export type FeedbackAvgAggregateInputType = {
    id?: true
  }

  export type FeedbackSumAggregateInputType = {
    id?: true
  }

  export type FeedbackMinAggregateInputType = {
    id?: true
    name?: true
    message?: true
    timestamp?: true
    userId?: true
  }

  export type FeedbackMaxAggregateInputType = {
    id?: true
    name?: true
    message?: true
    timestamp?: true
    userId?: true
  }

  export type FeedbackCountAggregateInputType = {
    id?: true
    name?: true
    message?: true
    timestamp?: true
    userId?: true
    _all?: true
  }

  export type FeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedback to aggregate.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Feedbacks
    **/
    _count?: true | FeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackMaxAggregateInputType
  }

  export type GetFeedbackAggregateType<T extends FeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedback[P]>
      : GetScalarType<T[P], AggregateFeedback[P]>
  }




  export type FeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithAggregationInput | FeedbackOrderByWithAggregationInput[]
    by: FeedbackScalarFieldEnum[] | FeedbackScalarFieldEnum
    having?: FeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackCountAggregateInputType | true
    _avg?: FeedbackAvgAggregateInputType
    _sum?: FeedbackSumAggregateInputType
    _min?: FeedbackMinAggregateInputType
    _max?: FeedbackMaxAggregateInputType
  }

  export type FeedbackGroupByOutputType = {
    id: number
    name: string | null
    message: string | null
    timestamp: Date
    userId: string | null
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  type GetFeedbackGroupByPayload<T extends FeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
        }
      >
    >


  export type FeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    message?: boolean
    timestamp?: boolean
    userId?: boolean
    user?: boolean | Feedback$userArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    message?: boolean
    timestamp?: boolean
    userId?: boolean
    user?: boolean | Feedback$userArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    message?: boolean
    timestamp?: boolean
    userId?: boolean
    user?: boolean | Feedback$userArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectScalar = {
    id?: boolean
    name?: boolean
    message?: boolean
    timestamp?: boolean
    userId?: boolean
  }

  export type FeedbackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "message" | "timestamp" | "userId", ExtArgs["result"]["feedback"]>
  export type FeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Feedback$userArgs<ExtArgs>
  }
  export type FeedbackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Feedback$userArgs<ExtArgs>
  }
  export type FeedbackIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Feedback$userArgs<ExtArgs>
  }

  export type $FeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Feedback"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      message: string | null
      timestamp: Date
      userId: string | null
    }, ExtArgs["result"]["feedback"]>
    composites: {}
  }

  type FeedbackGetPayload<S extends boolean | null | undefined | FeedbackDefaultArgs> = $Result.GetResult<Prisma.$FeedbackPayload, S>

  type FeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeedbackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeedbackCountAggregateInputType | true
    }

  export interface FeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Feedback'], meta: { name: 'Feedback' } }
    /**
     * Find zero or one Feedback that matches the filter.
     * @param {FeedbackFindUniqueArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeedbackFindUniqueArgs>(args: SelectSubset<T, FeedbackFindUniqueArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Feedback that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeedbackFindUniqueOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, FeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeedbackFindFirstArgs>(args?: SelectSubset<T, FeedbackFindFirstArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, FeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Feedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feedbacks
     * const feedbacks = await prisma.feedback.findMany()
     * 
     * // Get first 10 Feedbacks
     * const feedbacks = await prisma.feedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedbackWithIdOnly = await prisma.feedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeedbackFindManyArgs>(args?: SelectSubset<T, FeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Feedback.
     * @param {FeedbackCreateArgs} args - Arguments to create a Feedback.
     * @example
     * // Create one Feedback
     * const Feedback = await prisma.feedback.create({
     *   data: {
     *     // ... data to create a Feedback
     *   }
     * })
     * 
     */
    create<T extends FeedbackCreateArgs>(args: SelectSubset<T, FeedbackCreateArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Feedbacks.
     * @param {FeedbackCreateManyArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedback = await prisma.feedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeedbackCreateManyArgs>(args?: SelectSubset<T, FeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Feedbacks and returns the data saved in the database.
     * @param {FeedbackCreateManyAndReturnArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedback = await prisma.feedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Feedbacks and only return the `id`
     * const feedbackWithIdOnly = await prisma.feedback.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, FeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Feedback.
     * @param {FeedbackDeleteArgs} args - Arguments to delete one Feedback.
     * @example
     * // Delete one Feedback
     * const Feedback = await prisma.feedback.delete({
     *   where: {
     *     // ... filter to delete one Feedback
     *   }
     * })
     * 
     */
    delete<T extends FeedbackDeleteArgs>(args: SelectSubset<T, FeedbackDeleteArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Feedback.
     * @param {FeedbackUpdateArgs} args - Arguments to update one Feedback.
     * @example
     * // Update one Feedback
     * const feedback = await prisma.feedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeedbackUpdateArgs>(args: SelectSubset<T, FeedbackUpdateArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Feedbacks.
     * @param {FeedbackDeleteManyArgs} args - Arguments to filter Feedbacks to delete.
     * @example
     * // Delete a few Feedbacks
     * const { count } = await prisma.feedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeedbackDeleteManyArgs>(args?: SelectSubset<T, FeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feedbacks
     * const feedback = await prisma.feedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeedbackUpdateManyArgs>(args: SelectSubset<T, FeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks and returns the data updated in the database.
     * @param {FeedbackUpdateManyAndReturnArgs} args - Arguments to update many Feedbacks.
     * @example
     * // Update many Feedbacks
     * const feedback = await prisma.feedback.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Feedbacks and only return the `id`
     * const feedbackWithIdOnly = await prisma.feedback.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeedbackUpdateManyAndReturnArgs>(args: SelectSubset<T, FeedbackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Feedback.
     * @param {FeedbackUpsertArgs} args - Arguments to update or create a Feedback.
     * @example
     * // Update or create a Feedback
     * const feedback = await prisma.feedback.upsert({
     *   create: {
     *     // ... data to create a Feedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feedback we want to update
     *   }
     * })
     */
    upsert<T extends FeedbackUpsertArgs>(args: SelectSubset<T, FeedbackUpsertArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackCountArgs} args - Arguments to filter Feedbacks to count.
     * @example
     * // Count the number of Feedbacks
     * const count = await prisma.feedback.count({
     *   where: {
     *     // ... the filter for the Feedbacks we want to count
     *   }
     * })
    **/
    count<T extends FeedbackCountArgs>(
      args?: Subset<T, FeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackAggregateArgs>(args: Subset<T, FeedbackAggregateArgs>): Prisma.PrismaPromise<GetFeedbackAggregateType<T>>

    /**
     * Group by Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedbackGroupByArgs['orderBy'] }
        : { orderBy?: FeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Feedback model
   */
  readonly fields: FeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Feedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Feedback$userArgs<ExtArgs> = {}>(args?: Subset<T, Feedback$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Feedback model
   */
  interface FeedbackFieldRefs {
    readonly id: FieldRef<"Feedback", 'Int'>
    readonly name: FieldRef<"Feedback", 'String'>
    readonly message: FieldRef<"Feedback", 'String'>
    readonly timestamp: FieldRef<"Feedback", 'DateTime'>
    readonly userId: FieldRef<"Feedback", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Feedback findUnique
   */
  export type FeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findUniqueOrThrow
   */
  export type FeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findFirst
   */
  export type FeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback findFirstOrThrow
   */
  export type FeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback findMany
   */
  export type FeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedbacks to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback create
   */
  export type FeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a Feedback.
     */
    data?: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
  }

  /**
   * Feedback createMany
   */
  export type FeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Feedbacks.
     */
    data: FeedbackCreateManyInput | FeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Feedback createManyAndReturn
   */
  export type FeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * The data used to create many Feedbacks.
     */
    data: FeedbackCreateManyInput | FeedbackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Feedback update
   */
  export type FeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a Feedback.
     */
    data: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
    /**
     * Choose, which Feedback to update.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback updateMany
   */
  export type FeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Feedbacks.
     */
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyInput>
    /**
     * Filter which Feedbacks to update
     */
    where?: FeedbackWhereInput
    /**
     * Limit how many Feedbacks to update.
     */
    limit?: number
  }

  /**
   * Feedback updateManyAndReturn
   */
  export type FeedbackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * The data used to update Feedbacks.
     */
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyInput>
    /**
     * Filter which Feedbacks to update
     */
    where?: FeedbackWhereInput
    /**
     * Limit how many Feedbacks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Feedback upsert
   */
  export type FeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the Feedback to update in case it exists.
     */
    where: FeedbackWhereUniqueInput
    /**
     * In case the Feedback found by the `where` argument doesn't exist, create a new Feedback with this data.
     */
    create: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
    /**
     * In case the Feedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
  }

  /**
   * Feedback delete
   */
  export type FeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter which Feedback to delete.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback deleteMany
   */
  export type FeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedbacks to delete
     */
    where?: FeedbackWhereInput
    /**
     * Limit how many Feedbacks to delete.
     */
    limit?: number
  }

  /**
   * Feedback.user
   */
  export type Feedback$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Feedback without action
   */
  export type FeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    message: string | null
    level: string | null
    active: boolean | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    message: string | null
    level: string | null
    active: boolean | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    message: number
    level: number
    active: number
    type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    message?: true
    level?: true
    active?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    message?: true
    level?: true
    active?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    message?: true
    level?: true
    active?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    message: string
    level: string
    active: boolean
    type: string
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    level?: boolean
    active?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    level?: boolean
    active?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    level?: boolean
    active?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    message?: boolean
    level?: boolean
    active?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "message" | "level" | "active" | "type" | "createdAt" | "updatedAt", ExtArgs["result"]["notification"]>

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      message: string
      level: string
      active: boolean
      type: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly level: FieldRef<"Notification", 'String'>
    readonly active: FieldRef<"Notification", 'Boolean'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
  }


  /**
   * Model DirectoryIntegration
   */

  export type AggregateDirectoryIntegration = {
    _count: DirectoryIntegrationCountAggregateOutputType | null
    _avg: DirectoryIntegrationAvgAggregateOutputType | null
    _sum: DirectoryIntegrationSumAggregateOutputType | null
    _min: DirectoryIntegrationMinAggregateOutputType | null
    _max: DirectoryIntegrationMaxAggregateOutputType | null
  }

  export type DirectoryIntegrationAvgAggregateOutputType = {
    id: number | null
  }

  export type DirectoryIntegrationSumAggregateOutputType = {
    id: number | null
  }

  export type DirectoryIntegrationMinAggregateOutputType = {
    id: number | null
    provider: string | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DirectoryIntegrationMaxAggregateOutputType = {
    id: number | null
    provider: string | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DirectoryIntegrationCountAggregateOutputType = {
    id: number
    provider: number
    settings: number
    enabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DirectoryIntegrationAvgAggregateInputType = {
    id?: true
  }

  export type DirectoryIntegrationSumAggregateInputType = {
    id?: true
  }

  export type DirectoryIntegrationMinAggregateInputType = {
    id?: true
    provider?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DirectoryIntegrationMaxAggregateInputType = {
    id?: true
    provider?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DirectoryIntegrationCountAggregateInputType = {
    id?: true
    provider?: true
    settings?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DirectoryIntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DirectoryIntegration to aggregate.
     */
    where?: DirectoryIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectoryIntegrations to fetch.
     */
    orderBy?: DirectoryIntegrationOrderByWithRelationInput | DirectoryIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DirectoryIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectoryIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectoryIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DirectoryIntegrations
    **/
    _count?: true | DirectoryIntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DirectoryIntegrationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DirectoryIntegrationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DirectoryIntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DirectoryIntegrationMaxAggregateInputType
  }

  export type GetDirectoryIntegrationAggregateType<T extends DirectoryIntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregateDirectoryIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDirectoryIntegration[P]>
      : GetScalarType<T[P], AggregateDirectoryIntegration[P]>
  }




  export type DirectoryIntegrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DirectoryIntegrationWhereInput
    orderBy?: DirectoryIntegrationOrderByWithAggregationInput | DirectoryIntegrationOrderByWithAggregationInput[]
    by: DirectoryIntegrationScalarFieldEnum[] | DirectoryIntegrationScalarFieldEnum
    having?: DirectoryIntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DirectoryIntegrationCountAggregateInputType | true
    _avg?: DirectoryIntegrationAvgAggregateInputType
    _sum?: DirectoryIntegrationSumAggregateInputType
    _min?: DirectoryIntegrationMinAggregateInputType
    _max?: DirectoryIntegrationMaxAggregateInputType
  }

  export type DirectoryIntegrationGroupByOutputType = {
    id: number
    provider: string
    settings: JsonValue | null
    enabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: DirectoryIntegrationCountAggregateOutputType | null
    _avg: DirectoryIntegrationAvgAggregateOutputType | null
    _sum: DirectoryIntegrationSumAggregateOutputType | null
    _min: DirectoryIntegrationMinAggregateOutputType | null
    _max: DirectoryIntegrationMaxAggregateOutputType | null
  }

  type GetDirectoryIntegrationGroupByPayload<T extends DirectoryIntegrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DirectoryIntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DirectoryIntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DirectoryIntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], DirectoryIntegrationGroupByOutputType[P]>
        }
      >
    >


  export type DirectoryIntegrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    settings?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["directoryIntegration"]>

  export type DirectoryIntegrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    settings?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["directoryIntegration"]>

  export type DirectoryIntegrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    settings?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["directoryIntegration"]>

  export type DirectoryIntegrationSelectScalar = {
    id?: boolean
    provider?: boolean
    settings?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DirectoryIntegrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "provider" | "settings" | "enabled" | "createdAt" | "updatedAt", ExtArgs["result"]["directoryIntegration"]>

  export type $DirectoryIntegrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DirectoryIntegration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      provider: string
      settings: Prisma.JsonValue | null
      enabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["directoryIntegration"]>
    composites: {}
  }

  type DirectoryIntegrationGetPayload<S extends boolean | null | undefined | DirectoryIntegrationDefaultArgs> = $Result.GetResult<Prisma.$DirectoryIntegrationPayload, S>

  type DirectoryIntegrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DirectoryIntegrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DirectoryIntegrationCountAggregateInputType | true
    }

  export interface DirectoryIntegrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DirectoryIntegration'], meta: { name: 'DirectoryIntegration' } }
    /**
     * Find zero or one DirectoryIntegration that matches the filter.
     * @param {DirectoryIntegrationFindUniqueArgs} args - Arguments to find a DirectoryIntegration
     * @example
     * // Get one DirectoryIntegration
     * const directoryIntegration = await prisma.directoryIntegration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DirectoryIntegrationFindUniqueArgs>(args: SelectSubset<T, DirectoryIntegrationFindUniqueArgs<ExtArgs>>): Prisma__DirectoryIntegrationClient<$Result.GetResult<Prisma.$DirectoryIntegrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DirectoryIntegration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DirectoryIntegrationFindUniqueOrThrowArgs} args - Arguments to find a DirectoryIntegration
     * @example
     * // Get one DirectoryIntegration
     * const directoryIntegration = await prisma.directoryIntegration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DirectoryIntegrationFindUniqueOrThrowArgs>(args: SelectSubset<T, DirectoryIntegrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DirectoryIntegrationClient<$Result.GetResult<Prisma.$DirectoryIntegrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DirectoryIntegration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectoryIntegrationFindFirstArgs} args - Arguments to find a DirectoryIntegration
     * @example
     * // Get one DirectoryIntegration
     * const directoryIntegration = await prisma.directoryIntegration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DirectoryIntegrationFindFirstArgs>(args?: SelectSubset<T, DirectoryIntegrationFindFirstArgs<ExtArgs>>): Prisma__DirectoryIntegrationClient<$Result.GetResult<Prisma.$DirectoryIntegrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DirectoryIntegration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectoryIntegrationFindFirstOrThrowArgs} args - Arguments to find a DirectoryIntegration
     * @example
     * // Get one DirectoryIntegration
     * const directoryIntegration = await prisma.directoryIntegration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DirectoryIntegrationFindFirstOrThrowArgs>(args?: SelectSubset<T, DirectoryIntegrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DirectoryIntegrationClient<$Result.GetResult<Prisma.$DirectoryIntegrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DirectoryIntegrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectoryIntegrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DirectoryIntegrations
     * const directoryIntegrations = await prisma.directoryIntegration.findMany()
     * 
     * // Get first 10 DirectoryIntegrations
     * const directoryIntegrations = await prisma.directoryIntegration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const directoryIntegrationWithIdOnly = await prisma.directoryIntegration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DirectoryIntegrationFindManyArgs>(args?: SelectSubset<T, DirectoryIntegrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DirectoryIntegrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DirectoryIntegration.
     * @param {DirectoryIntegrationCreateArgs} args - Arguments to create a DirectoryIntegration.
     * @example
     * // Create one DirectoryIntegration
     * const DirectoryIntegration = await prisma.directoryIntegration.create({
     *   data: {
     *     // ... data to create a DirectoryIntegration
     *   }
     * })
     * 
     */
    create<T extends DirectoryIntegrationCreateArgs>(args: SelectSubset<T, DirectoryIntegrationCreateArgs<ExtArgs>>): Prisma__DirectoryIntegrationClient<$Result.GetResult<Prisma.$DirectoryIntegrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DirectoryIntegrations.
     * @param {DirectoryIntegrationCreateManyArgs} args - Arguments to create many DirectoryIntegrations.
     * @example
     * // Create many DirectoryIntegrations
     * const directoryIntegration = await prisma.directoryIntegration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DirectoryIntegrationCreateManyArgs>(args?: SelectSubset<T, DirectoryIntegrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DirectoryIntegrations and returns the data saved in the database.
     * @param {DirectoryIntegrationCreateManyAndReturnArgs} args - Arguments to create many DirectoryIntegrations.
     * @example
     * // Create many DirectoryIntegrations
     * const directoryIntegration = await prisma.directoryIntegration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DirectoryIntegrations and only return the `id`
     * const directoryIntegrationWithIdOnly = await prisma.directoryIntegration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DirectoryIntegrationCreateManyAndReturnArgs>(args?: SelectSubset<T, DirectoryIntegrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DirectoryIntegrationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DirectoryIntegration.
     * @param {DirectoryIntegrationDeleteArgs} args - Arguments to delete one DirectoryIntegration.
     * @example
     * // Delete one DirectoryIntegration
     * const DirectoryIntegration = await prisma.directoryIntegration.delete({
     *   where: {
     *     // ... filter to delete one DirectoryIntegration
     *   }
     * })
     * 
     */
    delete<T extends DirectoryIntegrationDeleteArgs>(args: SelectSubset<T, DirectoryIntegrationDeleteArgs<ExtArgs>>): Prisma__DirectoryIntegrationClient<$Result.GetResult<Prisma.$DirectoryIntegrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DirectoryIntegration.
     * @param {DirectoryIntegrationUpdateArgs} args - Arguments to update one DirectoryIntegration.
     * @example
     * // Update one DirectoryIntegration
     * const directoryIntegration = await prisma.directoryIntegration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DirectoryIntegrationUpdateArgs>(args: SelectSubset<T, DirectoryIntegrationUpdateArgs<ExtArgs>>): Prisma__DirectoryIntegrationClient<$Result.GetResult<Prisma.$DirectoryIntegrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DirectoryIntegrations.
     * @param {DirectoryIntegrationDeleteManyArgs} args - Arguments to filter DirectoryIntegrations to delete.
     * @example
     * // Delete a few DirectoryIntegrations
     * const { count } = await prisma.directoryIntegration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DirectoryIntegrationDeleteManyArgs>(args?: SelectSubset<T, DirectoryIntegrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DirectoryIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectoryIntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DirectoryIntegrations
     * const directoryIntegration = await prisma.directoryIntegration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DirectoryIntegrationUpdateManyArgs>(args: SelectSubset<T, DirectoryIntegrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DirectoryIntegrations and returns the data updated in the database.
     * @param {DirectoryIntegrationUpdateManyAndReturnArgs} args - Arguments to update many DirectoryIntegrations.
     * @example
     * // Update many DirectoryIntegrations
     * const directoryIntegration = await prisma.directoryIntegration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DirectoryIntegrations and only return the `id`
     * const directoryIntegrationWithIdOnly = await prisma.directoryIntegration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DirectoryIntegrationUpdateManyAndReturnArgs>(args: SelectSubset<T, DirectoryIntegrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DirectoryIntegrationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DirectoryIntegration.
     * @param {DirectoryIntegrationUpsertArgs} args - Arguments to update or create a DirectoryIntegration.
     * @example
     * // Update or create a DirectoryIntegration
     * const directoryIntegration = await prisma.directoryIntegration.upsert({
     *   create: {
     *     // ... data to create a DirectoryIntegration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DirectoryIntegration we want to update
     *   }
     * })
     */
    upsert<T extends DirectoryIntegrationUpsertArgs>(args: SelectSubset<T, DirectoryIntegrationUpsertArgs<ExtArgs>>): Prisma__DirectoryIntegrationClient<$Result.GetResult<Prisma.$DirectoryIntegrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DirectoryIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectoryIntegrationCountArgs} args - Arguments to filter DirectoryIntegrations to count.
     * @example
     * // Count the number of DirectoryIntegrations
     * const count = await prisma.directoryIntegration.count({
     *   where: {
     *     // ... the filter for the DirectoryIntegrations we want to count
     *   }
     * })
    **/
    count<T extends DirectoryIntegrationCountArgs>(
      args?: Subset<T, DirectoryIntegrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DirectoryIntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DirectoryIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectoryIntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DirectoryIntegrationAggregateArgs>(args: Subset<T, DirectoryIntegrationAggregateArgs>): Prisma.PrismaPromise<GetDirectoryIntegrationAggregateType<T>>

    /**
     * Group by DirectoryIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectoryIntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DirectoryIntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DirectoryIntegrationGroupByArgs['orderBy'] }
        : { orderBy?: DirectoryIntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DirectoryIntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDirectoryIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DirectoryIntegration model
   */
  readonly fields: DirectoryIntegrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DirectoryIntegration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DirectoryIntegrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DirectoryIntegration model
   */
  interface DirectoryIntegrationFieldRefs {
    readonly id: FieldRef<"DirectoryIntegration", 'Int'>
    readonly provider: FieldRef<"DirectoryIntegration", 'String'>
    readonly settings: FieldRef<"DirectoryIntegration", 'Json'>
    readonly enabled: FieldRef<"DirectoryIntegration", 'Boolean'>
    readonly createdAt: FieldRef<"DirectoryIntegration", 'DateTime'>
    readonly updatedAt: FieldRef<"DirectoryIntegration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DirectoryIntegration findUnique
   */
  export type DirectoryIntegrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectoryIntegration
     */
    select?: DirectoryIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectoryIntegration
     */
    omit?: DirectoryIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which DirectoryIntegration to fetch.
     */
    where: DirectoryIntegrationWhereUniqueInput
  }

  /**
   * DirectoryIntegration findUniqueOrThrow
   */
  export type DirectoryIntegrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectoryIntegration
     */
    select?: DirectoryIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectoryIntegration
     */
    omit?: DirectoryIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which DirectoryIntegration to fetch.
     */
    where: DirectoryIntegrationWhereUniqueInput
  }

  /**
   * DirectoryIntegration findFirst
   */
  export type DirectoryIntegrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectoryIntegration
     */
    select?: DirectoryIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectoryIntegration
     */
    omit?: DirectoryIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which DirectoryIntegration to fetch.
     */
    where?: DirectoryIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectoryIntegrations to fetch.
     */
    orderBy?: DirectoryIntegrationOrderByWithRelationInput | DirectoryIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DirectoryIntegrations.
     */
    cursor?: DirectoryIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectoryIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectoryIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DirectoryIntegrations.
     */
    distinct?: DirectoryIntegrationScalarFieldEnum | DirectoryIntegrationScalarFieldEnum[]
  }

  /**
   * DirectoryIntegration findFirstOrThrow
   */
  export type DirectoryIntegrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectoryIntegration
     */
    select?: DirectoryIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectoryIntegration
     */
    omit?: DirectoryIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which DirectoryIntegration to fetch.
     */
    where?: DirectoryIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectoryIntegrations to fetch.
     */
    orderBy?: DirectoryIntegrationOrderByWithRelationInput | DirectoryIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DirectoryIntegrations.
     */
    cursor?: DirectoryIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectoryIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectoryIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DirectoryIntegrations.
     */
    distinct?: DirectoryIntegrationScalarFieldEnum | DirectoryIntegrationScalarFieldEnum[]
  }

  /**
   * DirectoryIntegration findMany
   */
  export type DirectoryIntegrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectoryIntegration
     */
    select?: DirectoryIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectoryIntegration
     */
    omit?: DirectoryIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which DirectoryIntegrations to fetch.
     */
    where?: DirectoryIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectoryIntegrations to fetch.
     */
    orderBy?: DirectoryIntegrationOrderByWithRelationInput | DirectoryIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DirectoryIntegrations.
     */
    cursor?: DirectoryIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectoryIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectoryIntegrations.
     */
    skip?: number
    distinct?: DirectoryIntegrationScalarFieldEnum | DirectoryIntegrationScalarFieldEnum[]
  }

  /**
   * DirectoryIntegration create
   */
  export type DirectoryIntegrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectoryIntegration
     */
    select?: DirectoryIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectoryIntegration
     */
    omit?: DirectoryIntegrationOmit<ExtArgs> | null
    /**
     * The data needed to create a DirectoryIntegration.
     */
    data: XOR<DirectoryIntegrationCreateInput, DirectoryIntegrationUncheckedCreateInput>
  }

  /**
   * DirectoryIntegration createMany
   */
  export type DirectoryIntegrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DirectoryIntegrations.
     */
    data: DirectoryIntegrationCreateManyInput | DirectoryIntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DirectoryIntegration createManyAndReturn
   */
  export type DirectoryIntegrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectoryIntegration
     */
    select?: DirectoryIntegrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DirectoryIntegration
     */
    omit?: DirectoryIntegrationOmit<ExtArgs> | null
    /**
     * The data used to create many DirectoryIntegrations.
     */
    data: DirectoryIntegrationCreateManyInput | DirectoryIntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DirectoryIntegration update
   */
  export type DirectoryIntegrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectoryIntegration
     */
    select?: DirectoryIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectoryIntegration
     */
    omit?: DirectoryIntegrationOmit<ExtArgs> | null
    /**
     * The data needed to update a DirectoryIntegration.
     */
    data: XOR<DirectoryIntegrationUpdateInput, DirectoryIntegrationUncheckedUpdateInput>
    /**
     * Choose, which DirectoryIntegration to update.
     */
    where: DirectoryIntegrationWhereUniqueInput
  }

  /**
   * DirectoryIntegration updateMany
   */
  export type DirectoryIntegrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DirectoryIntegrations.
     */
    data: XOR<DirectoryIntegrationUpdateManyMutationInput, DirectoryIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which DirectoryIntegrations to update
     */
    where?: DirectoryIntegrationWhereInput
    /**
     * Limit how many DirectoryIntegrations to update.
     */
    limit?: number
  }

  /**
   * DirectoryIntegration updateManyAndReturn
   */
  export type DirectoryIntegrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectoryIntegration
     */
    select?: DirectoryIntegrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DirectoryIntegration
     */
    omit?: DirectoryIntegrationOmit<ExtArgs> | null
    /**
     * The data used to update DirectoryIntegrations.
     */
    data: XOR<DirectoryIntegrationUpdateManyMutationInput, DirectoryIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which DirectoryIntegrations to update
     */
    where?: DirectoryIntegrationWhereInput
    /**
     * Limit how many DirectoryIntegrations to update.
     */
    limit?: number
  }

  /**
   * DirectoryIntegration upsert
   */
  export type DirectoryIntegrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectoryIntegration
     */
    select?: DirectoryIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectoryIntegration
     */
    omit?: DirectoryIntegrationOmit<ExtArgs> | null
    /**
     * The filter to search for the DirectoryIntegration to update in case it exists.
     */
    where: DirectoryIntegrationWhereUniqueInput
    /**
     * In case the DirectoryIntegration found by the `where` argument doesn't exist, create a new DirectoryIntegration with this data.
     */
    create: XOR<DirectoryIntegrationCreateInput, DirectoryIntegrationUncheckedCreateInput>
    /**
     * In case the DirectoryIntegration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DirectoryIntegrationUpdateInput, DirectoryIntegrationUncheckedUpdateInput>
  }

  /**
   * DirectoryIntegration delete
   */
  export type DirectoryIntegrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectoryIntegration
     */
    select?: DirectoryIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectoryIntegration
     */
    omit?: DirectoryIntegrationOmit<ExtArgs> | null
    /**
     * Filter which DirectoryIntegration to delete.
     */
    where: DirectoryIntegrationWhereUniqueInput
  }

  /**
   * DirectoryIntegration deleteMany
   */
  export type DirectoryIntegrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DirectoryIntegrations to delete
     */
    where?: DirectoryIntegrationWhereInput
    /**
     * Limit how many DirectoryIntegrations to delete.
     */
    limit?: number
  }

  /**
   * DirectoryIntegration without action
   */
  export type DirectoryIntegrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectoryIntegration
     */
    select?: DirectoryIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectoryIntegration
     */
    omit?: DirectoryIntegrationOmit<ExtArgs> | null
  }


  /**
   * Model Asset
   */

  export type AggregateAsset = {
    _count: AssetCountAggregateOutputType | null
    _avg: AssetAvgAggregateOutputType | null
    _sum: AssetSumAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  export type AssetAvgAggregateOutputType = {
    id: number | null
    sizeBytes: number | null
  }

  export type AssetSumAggregateOutputType = {
    id: number | null
    sizeBytes: number | null
  }

  export type AssetMinAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    filename: string | null
    url: string | null
    sizeBytes: number | null
    mimeType: string | null
    uploadedAt: Date | null
  }

  export type AssetMaxAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    filename: string | null
    url: string | null
    sizeBytes: number | null
    mimeType: string | null
    uploadedAt: Date | null
  }

  export type AssetCountAggregateOutputType = {
    id: number
    name: number
    type: number
    filename: number
    url: number
    sizeBytes: number
    mimeType: number
    uploadedAt: number
    _all: number
  }


  export type AssetAvgAggregateInputType = {
    id?: true
    sizeBytes?: true
  }

  export type AssetSumAggregateInputType = {
    id?: true
    sizeBytes?: true
  }

  export type AssetMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    filename?: true
    url?: true
    sizeBytes?: true
    mimeType?: true
    uploadedAt?: true
  }

  export type AssetMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    filename?: true
    url?: true
    sizeBytes?: true
    mimeType?: true
    uploadedAt?: true
  }

  export type AssetCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    filename?: true
    url?: true
    sizeBytes?: true
    mimeType?: true
    uploadedAt?: true
    _all?: true
  }

  export type AssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Asset to aggregate.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assets
    **/
    _count?: true | AssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetMaxAggregateInputType
  }

  export type GetAssetAggregateType<T extends AssetAggregateArgs> = {
        [P in keyof T & keyof AggregateAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAsset[P]>
      : GetScalarType<T[P], AggregateAsset[P]>
  }




  export type AssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithAggregationInput | AssetOrderByWithAggregationInput[]
    by: AssetScalarFieldEnum[] | AssetScalarFieldEnum
    having?: AssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetCountAggregateInputType | true
    _avg?: AssetAvgAggregateInputType
    _sum?: AssetSumAggregateInputType
    _min?: AssetMinAggregateInputType
    _max?: AssetMaxAggregateInputType
  }

  export type AssetGroupByOutputType = {
    id: number
    name: string
    type: string
    filename: string
    url: string
    sizeBytes: number | null
    mimeType: string | null
    uploadedAt: Date
    _count: AssetCountAggregateOutputType | null
    _avg: AssetAvgAggregateOutputType | null
    _sum: AssetSumAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  type GetAssetGroupByPayload<T extends AssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetGroupByOutputType[P]>
            : GetScalarType<T[P], AssetGroupByOutputType[P]>
        }
      >
    >


  export type AssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    filename?: boolean
    url?: boolean
    sizeBytes?: boolean
    mimeType?: boolean
    uploadedAt?: boolean
  }, ExtArgs["result"]["asset"]>

  export type AssetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    filename?: boolean
    url?: boolean
    sizeBytes?: boolean
    mimeType?: boolean
    uploadedAt?: boolean
  }, ExtArgs["result"]["asset"]>

  export type AssetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    filename?: boolean
    url?: boolean
    sizeBytes?: boolean
    mimeType?: boolean
    uploadedAt?: boolean
  }, ExtArgs["result"]["asset"]>

  export type AssetSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    filename?: boolean
    url?: boolean
    sizeBytes?: boolean
    mimeType?: boolean
    uploadedAt?: boolean
  }

  export type AssetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "filename" | "url" | "sizeBytes" | "mimeType" | "uploadedAt", ExtArgs["result"]["asset"]>

  export type $AssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Asset"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      type: string
      filename: string
      url: string
      sizeBytes: number | null
      mimeType: string | null
      uploadedAt: Date
    }, ExtArgs["result"]["asset"]>
    composites: {}
  }

  type AssetGetPayload<S extends boolean | null | undefined | AssetDefaultArgs> = $Result.GetResult<Prisma.$AssetPayload, S>

  type AssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssetCountAggregateInputType | true
    }

  export interface AssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Asset'], meta: { name: 'Asset' } }
    /**
     * Find zero or one Asset that matches the filter.
     * @param {AssetFindUniqueArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetFindUniqueArgs>(args: SelectSubset<T, AssetFindUniqueArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Asset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssetFindUniqueOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetFindUniqueOrThrowArgs>(args: SelectSubset<T, AssetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Asset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetFindFirstArgs>(args?: SelectSubset<T, AssetFindFirstArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Asset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetFindFirstOrThrowArgs>(args?: SelectSubset<T, AssetFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assets
     * const assets = await prisma.asset.findMany()
     * 
     * // Get first 10 Assets
     * const assets = await prisma.asset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetWithIdOnly = await prisma.asset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssetFindManyArgs>(args?: SelectSubset<T, AssetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Asset.
     * @param {AssetCreateArgs} args - Arguments to create a Asset.
     * @example
     * // Create one Asset
     * const Asset = await prisma.asset.create({
     *   data: {
     *     // ... data to create a Asset
     *   }
     * })
     * 
     */
    create<T extends AssetCreateArgs>(args: SelectSubset<T, AssetCreateArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Assets.
     * @param {AssetCreateManyArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const asset = await prisma.asset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssetCreateManyArgs>(args?: SelectSubset<T, AssetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assets and returns the data saved in the database.
     * @param {AssetCreateManyAndReturnArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const asset = await prisma.asset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assets and only return the `id`
     * const assetWithIdOnly = await prisma.asset.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssetCreateManyAndReturnArgs>(args?: SelectSubset<T, AssetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Asset.
     * @param {AssetDeleteArgs} args - Arguments to delete one Asset.
     * @example
     * // Delete one Asset
     * const Asset = await prisma.asset.delete({
     *   where: {
     *     // ... filter to delete one Asset
     *   }
     * })
     * 
     */
    delete<T extends AssetDeleteArgs>(args: SelectSubset<T, AssetDeleteArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Asset.
     * @param {AssetUpdateArgs} args - Arguments to update one Asset.
     * @example
     * // Update one Asset
     * const asset = await prisma.asset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssetUpdateArgs>(args: SelectSubset<T, AssetUpdateArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Assets.
     * @param {AssetDeleteManyArgs} args - Arguments to filter Assets to delete.
     * @example
     * // Delete a few Assets
     * const { count } = await prisma.asset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssetDeleteManyArgs>(args?: SelectSubset<T, AssetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assets
     * const asset = await prisma.asset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssetUpdateManyArgs>(args: SelectSubset<T, AssetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assets and returns the data updated in the database.
     * @param {AssetUpdateManyAndReturnArgs} args - Arguments to update many Assets.
     * @example
     * // Update many Assets
     * const asset = await prisma.asset.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Assets and only return the `id`
     * const assetWithIdOnly = await prisma.asset.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssetUpdateManyAndReturnArgs>(args: SelectSubset<T, AssetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Asset.
     * @param {AssetUpsertArgs} args - Arguments to update or create a Asset.
     * @example
     * // Update or create a Asset
     * const asset = await prisma.asset.upsert({
     *   create: {
     *     // ... data to create a Asset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Asset we want to update
     *   }
     * })
     */
    upsert<T extends AssetUpsertArgs>(args: SelectSubset<T, AssetUpsertArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetCountArgs} args - Arguments to filter Assets to count.
     * @example
     * // Count the number of Assets
     * const count = await prisma.asset.count({
     *   where: {
     *     // ... the filter for the Assets we want to count
     *   }
     * })
    **/
    count<T extends AssetCountArgs>(
      args?: Subset<T, AssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetAggregateArgs>(args: Subset<T, AssetAggregateArgs>): Prisma.PrismaPromise<GetAssetAggregateType<T>>

    /**
     * Group by Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetGroupByArgs['orderBy'] }
        : { orderBy?: AssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Asset model
   */
  readonly fields: AssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Asset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Asset model
   */
  interface AssetFieldRefs {
    readonly id: FieldRef<"Asset", 'Int'>
    readonly name: FieldRef<"Asset", 'String'>
    readonly type: FieldRef<"Asset", 'String'>
    readonly filename: FieldRef<"Asset", 'String'>
    readonly url: FieldRef<"Asset", 'String'>
    readonly sizeBytes: FieldRef<"Asset", 'Int'>
    readonly mimeType: FieldRef<"Asset", 'String'>
    readonly uploadedAt: FieldRef<"Asset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Asset findUnique
   */
  export type AssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findUniqueOrThrow
   */
  export type AssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findFirst
   */
  export type AssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findFirstOrThrow
   */
  export type AssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findMany
   */
  export type AssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Filter, which Assets to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset create
   */
  export type AssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * The data needed to create a Asset.
     */
    data: XOR<AssetCreateInput, AssetUncheckedCreateInput>
  }

  /**
   * Asset createMany
   */
  export type AssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Asset createManyAndReturn
   */
  export type AssetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Asset update
   */
  export type AssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * The data needed to update a Asset.
     */
    data: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
    /**
     * Choose, which Asset to update.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset updateMany
   */
  export type AssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assets.
     */
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyInput>
    /**
     * Filter which Assets to update
     */
    where?: AssetWhereInput
    /**
     * Limit how many Assets to update.
     */
    limit?: number
  }

  /**
   * Asset updateManyAndReturn
   */
  export type AssetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * The data used to update Assets.
     */
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyInput>
    /**
     * Filter which Assets to update
     */
    where?: AssetWhereInput
    /**
     * Limit how many Assets to update.
     */
    limit?: number
  }

  /**
   * Asset upsert
   */
  export type AssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * The filter to search for the Asset to update in case it exists.
     */
    where: AssetWhereUniqueInput
    /**
     * In case the Asset found by the `where` argument doesn't exist, create a new Asset with this data.
     */
    create: XOR<AssetCreateInput, AssetUncheckedCreateInput>
    /**
     * In case the Asset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
  }

  /**
   * Asset delete
   */
  export type AssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Filter which Asset to delete.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset deleteMany
   */
  export type AssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assets to delete
     */
    where?: AssetWhereInput
    /**
     * Limit how many Assets to delete.
     */
    limit?: number
  }

  /**
   * Asset without action
   */
  export type AssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
  }


  /**
   * Model KioskActivation
   */

  export type AggregateKioskActivation = {
    _count: KioskActivationCountAggregateOutputType | null
    _min: KioskActivationMinAggregateOutputType | null
    _max: KioskActivationMaxAggregateOutputType | null
  }

  export type KioskActivationMinAggregateOutputType = {
    id: string | null
    code: string | null
    qrCode: string | null
    expiresAt: Date | null
    used: boolean | null
    usedAt: Date | null
    createdAt: Date | null
    kioskId: string | null
  }

  export type KioskActivationMaxAggregateOutputType = {
    id: string | null
    code: string | null
    qrCode: string | null
    expiresAt: Date | null
    used: boolean | null
    usedAt: Date | null
    createdAt: Date | null
    kioskId: string | null
  }

  export type KioskActivationCountAggregateOutputType = {
    id: number
    code: number
    qrCode: number
    expiresAt: number
    used: number
    usedAt: number
    createdAt: number
    kioskId: number
    _all: number
  }


  export type KioskActivationMinAggregateInputType = {
    id?: true
    code?: true
    qrCode?: true
    expiresAt?: true
    used?: true
    usedAt?: true
    createdAt?: true
    kioskId?: true
  }

  export type KioskActivationMaxAggregateInputType = {
    id?: true
    code?: true
    qrCode?: true
    expiresAt?: true
    used?: true
    usedAt?: true
    createdAt?: true
    kioskId?: true
  }

  export type KioskActivationCountAggregateInputType = {
    id?: true
    code?: true
    qrCode?: true
    expiresAt?: true
    used?: true
    usedAt?: true
    createdAt?: true
    kioskId?: true
    _all?: true
  }

  export type KioskActivationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KioskActivation to aggregate.
     */
    where?: KioskActivationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KioskActivations to fetch.
     */
    orderBy?: KioskActivationOrderByWithRelationInput | KioskActivationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KioskActivationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KioskActivations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KioskActivations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KioskActivations
    **/
    _count?: true | KioskActivationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KioskActivationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KioskActivationMaxAggregateInputType
  }

  export type GetKioskActivationAggregateType<T extends KioskActivationAggregateArgs> = {
        [P in keyof T & keyof AggregateKioskActivation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKioskActivation[P]>
      : GetScalarType<T[P], AggregateKioskActivation[P]>
  }




  export type KioskActivationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KioskActivationWhereInput
    orderBy?: KioskActivationOrderByWithAggregationInput | KioskActivationOrderByWithAggregationInput[]
    by: KioskActivationScalarFieldEnum[] | KioskActivationScalarFieldEnum
    having?: KioskActivationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KioskActivationCountAggregateInputType | true
    _min?: KioskActivationMinAggregateInputType
    _max?: KioskActivationMaxAggregateInputType
  }

  export type KioskActivationGroupByOutputType = {
    id: string
    code: string
    qrCode: string
    expiresAt: Date
    used: boolean
    usedAt: Date | null
    createdAt: Date
    kioskId: string | null
    _count: KioskActivationCountAggregateOutputType | null
    _min: KioskActivationMinAggregateOutputType | null
    _max: KioskActivationMaxAggregateOutputType | null
  }

  type GetKioskActivationGroupByPayload<T extends KioskActivationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KioskActivationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KioskActivationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KioskActivationGroupByOutputType[P]>
            : GetScalarType<T[P], KioskActivationGroupByOutputType[P]>
        }
      >
    >


  export type KioskActivationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    qrCode?: boolean
    expiresAt?: boolean
    used?: boolean
    usedAt?: boolean
    createdAt?: boolean
    kioskId?: boolean
    kiosk?: boolean | KioskActivation$kioskArgs<ExtArgs>
  }, ExtArgs["result"]["kioskActivation"]>

  export type KioskActivationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    qrCode?: boolean
    expiresAt?: boolean
    used?: boolean
    usedAt?: boolean
    createdAt?: boolean
    kioskId?: boolean
    kiosk?: boolean | KioskActivation$kioskArgs<ExtArgs>
  }, ExtArgs["result"]["kioskActivation"]>

  export type KioskActivationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    qrCode?: boolean
    expiresAt?: boolean
    used?: boolean
    usedAt?: boolean
    createdAt?: boolean
    kioskId?: boolean
    kiosk?: boolean | KioskActivation$kioskArgs<ExtArgs>
  }, ExtArgs["result"]["kioskActivation"]>

  export type KioskActivationSelectScalar = {
    id?: boolean
    code?: boolean
    qrCode?: boolean
    expiresAt?: boolean
    used?: boolean
    usedAt?: boolean
    createdAt?: boolean
    kioskId?: boolean
  }

  export type KioskActivationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "qrCode" | "expiresAt" | "used" | "usedAt" | "createdAt" | "kioskId", ExtArgs["result"]["kioskActivation"]>
  export type KioskActivationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kiosk?: boolean | KioskActivation$kioskArgs<ExtArgs>
  }
  export type KioskActivationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kiosk?: boolean | KioskActivation$kioskArgs<ExtArgs>
  }
  export type KioskActivationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kiosk?: boolean | KioskActivation$kioskArgs<ExtArgs>
  }

  export type $KioskActivationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KioskActivation"
    objects: {
      kiosk: Prisma.$KioskPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      qrCode: string
      expiresAt: Date
      used: boolean
      usedAt: Date | null
      createdAt: Date
      kioskId: string | null
    }, ExtArgs["result"]["kioskActivation"]>
    composites: {}
  }

  type KioskActivationGetPayload<S extends boolean | null | undefined | KioskActivationDefaultArgs> = $Result.GetResult<Prisma.$KioskActivationPayload, S>

  type KioskActivationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KioskActivationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KioskActivationCountAggregateInputType | true
    }

  export interface KioskActivationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KioskActivation'], meta: { name: 'KioskActivation' } }
    /**
     * Find zero or one KioskActivation that matches the filter.
     * @param {KioskActivationFindUniqueArgs} args - Arguments to find a KioskActivation
     * @example
     * // Get one KioskActivation
     * const kioskActivation = await prisma.kioskActivation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KioskActivationFindUniqueArgs>(args: SelectSubset<T, KioskActivationFindUniqueArgs<ExtArgs>>): Prisma__KioskActivationClient<$Result.GetResult<Prisma.$KioskActivationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KioskActivation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KioskActivationFindUniqueOrThrowArgs} args - Arguments to find a KioskActivation
     * @example
     * // Get one KioskActivation
     * const kioskActivation = await prisma.kioskActivation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KioskActivationFindUniqueOrThrowArgs>(args: SelectSubset<T, KioskActivationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KioskActivationClient<$Result.GetResult<Prisma.$KioskActivationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KioskActivation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskActivationFindFirstArgs} args - Arguments to find a KioskActivation
     * @example
     * // Get one KioskActivation
     * const kioskActivation = await prisma.kioskActivation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KioskActivationFindFirstArgs>(args?: SelectSubset<T, KioskActivationFindFirstArgs<ExtArgs>>): Prisma__KioskActivationClient<$Result.GetResult<Prisma.$KioskActivationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KioskActivation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskActivationFindFirstOrThrowArgs} args - Arguments to find a KioskActivation
     * @example
     * // Get one KioskActivation
     * const kioskActivation = await prisma.kioskActivation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KioskActivationFindFirstOrThrowArgs>(args?: SelectSubset<T, KioskActivationFindFirstOrThrowArgs<ExtArgs>>): Prisma__KioskActivationClient<$Result.GetResult<Prisma.$KioskActivationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KioskActivations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskActivationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KioskActivations
     * const kioskActivations = await prisma.kioskActivation.findMany()
     * 
     * // Get first 10 KioskActivations
     * const kioskActivations = await prisma.kioskActivation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kioskActivationWithIdOnly = await prisma.kioskActivation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KioskActivationFindManyArgs>(args?: SelectSubset<T, KioskActivationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KioskActivationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KioskActivation.
     * @param {KioskActivationCreateArgs} args - Arguments to create a KioskActivation.
     * @example
     * // Create one KioskActivation
     * const KioskActivation = await prisma.kioskActivation.create({
     *   data: {
     *     // ... data to create a KioskActivation
     *   }
     * })
     * 
     */
    create<T extends KioskActivationCreateArgs>(args: SelectSubset<T, KioskActivationCreateArgs<ExtArgs>>): Prisma__KioskActivationClient<$Result.GetResult<Prisma.$KioskActivationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KioskActivations.
     * @param {KioskActivationCreateManyArgs} args - Arguments to create many KioskActivations.
     * @example
     * // Create many KioskActivations
     * const kioskActivation = await prisma.kioskActivation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KioskActivationCreateManyArgs>(args?: SelectSubset<T, KioskActivationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KioskActivations and returns the data saved in the database.
     * @param {KioskActivationCreateManyAndReturnArgs} args - Arguments to create many KioskActivations.
     * @example
     * // Create many KioskActivations
     * const kioskActivation = await prisma.kioskActivation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KioskActivations and only return the `id`
     * const kioskActivationWithIdOnly = await prisma.kioskActivation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KioskActivationCreateManyAndReturnArgs>(args?: SelectSubset<T, KioskActivationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KioskActivationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KioskActivation.
     * @param {KioskActivationDeleteArgs} args - Arguments to delete one KioskActivation.
     * @example
     * // Delete one KioskActivation
     * const KioskActivation = await prisma.kioskActivation.delete({
     *   where: {
     *     // ... filter to delete one KioskActivation
     *   }
     * })
     * 
     */
    delete<T extends KioskActivationDeleteArgs>(args: SelectSubset<T, KioskActivationDeleteArgs<ExtArgs>>): Prisma__KioskActivationClient<$Result.GetResult<Prisma.$KioskActivationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KioskActivation.
     * @param {KioskActivationUpdateArgs} args - Arguments to update one KioskActivation.
     * @example
     * // Update one KioskActivation
     * const kioskActivation = await prisma.kioskActivation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KioskActivationUpdateArgs>(args: SelectSubset<T, KioskActivationUpdateArgs<ExtArgs>>): Prisma__KioskActivationClient<$Result.GetResult<Prisma.$KioskActivationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KioskActivations.
     * @param {KioskActivationDeleteManyArgs} args - Arguments to filter KioskActivations to delete.
     * @example
     * // Delete a few KioskActivations
     * const { count } = await prisma.kioskActivation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KioskActivationDeleteManyArgs>(args?: SelectSubset<T, KioskActivationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KioskActivations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskActivationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KioskActivations
     * const kioskActivation = await prisma.kioskActivation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KioskActivationUpdateManyArgs>(args: SelectSubset<T, KioskActivationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KioskActivations and returns the data updated in the database.
     * @param {KioskActivationUpdateManyAndReturnArgs} args - Arguments to update many KioskActivations.
     * @example
     * // Update many KioskActivations
     * const kioskActivation = await prisma.kioskActivation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KioskActivations and only return the `id`
     * const kioskActivationWithIdOnly = await prisma.kioskActivation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KioskActivationUpdateManyAndReturnArgs>(args: SelectSubset<T, KioskActivationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KioskActivationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KioskActivation.
     * @param {KioskActivationUpsertArgs} args - Arguments to update or create a KioskActivation.
     * @example
     * // Update or create a KioskActivation
     * const kioskActivation = await prisma.kioskActivation.upsert({
     *   create: {
     *     // ... data to create a KioskActivation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KioskActivation we want to update
     *   }
     * })
     */
    upsert<T extends KioskActivationUpsertArgs>(args: SelectSubset<T, KioskActivationUpsertArgs<ExtArgs>>): Prisma__KioskActivationClient<$Result.GetResult<Prisma.$KioskActivationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KioskActivations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskActivationCountArgs} args - Arguments to filter KioskActivations to count.
     * @example
     * // Count the number of KioskActivations
     * const count = await prisma.kioskActivation.count({
     *   where: {
     *     // ... the filter for the KioskActivations we want to count
     *   }
     * })
    **/
    count<T extends KioskActivationCountArgs>(
      args?: Subset<T, KioskActivationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KioskActivationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KioskActivation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskActivationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KioskActivationAggregateArgs>(args: Subset<T, KioskActivationAggregateArgs>): Prisma.PrismaPromise<GetKioskActivationAggregateType<T>>

    /**
     * Group by KioskActivation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskActivationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KioskActivationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KioskActivationGroupByArgs['orderBy'] }
        : { orderBy?: KioskActivationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KioskActivationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKioskActivationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KioskActivation model
   */
  readonly fields: KioskActivationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KioskActivation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KioskActivationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kiosk<T extends KioskActivation$kioskArgs<ExtArgs> = {}>(args?: Subset<T, KioskActivation$kioskArgs<ExtArgs>>): Prisma__KioskClient<$Result.GetResult<Prisma.$KioskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KioskActivation model
   */
  interface KioskActivationFieldRefs {
    readonly id: FieldRef<"KioskActivation", 'String'>
    readonly code: FieldRef<"KioskActivation", 'String'>
    readonly qrCode: FieldRef<"KioskActivation", 'String'>
    readonly expiresAt: FieldRef<"KioskActivation", 'DateTime'>
    readonly used: FieldRef<"KioskActivation", 'Boolean'>
    readonly usedAt: FieldRef<"KioskActivation", 'DateTime'>
    readonly createdAt: FieldRef<"KioskActivation", 'DateTime'>
    readonly kioskId: FieldRef<"KioskActivation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * KioskActivation findUnique
   */
  export type KioskActivationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskActivation
     */
    select?: KioskActivationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskActivation
     */
    omit?: KioskActivationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskActivationInclude<ExtArgs> | null
    /**
     * Filter, which KioskActivation to fetch.
     */
    where: KioskActivationWhereUniqueInput
  }

  /**
   * KioskActivation findUniqueOrThrow
   */
  export type KioskActivationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskActivation
     */
    select?: KioskActivationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskActivation
     */
    omit?: KioskActivationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskActivationInclude<ExtArgs> | null
    /**
     * Filter, which KioskActivation to fetch.
     */
    where: KioskActivationWhereUniqueInput
  }

  /**
   * KioskActivation findFirst
   */
  export type KioskActivationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskActivation
     */
    select?: KioskActivationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskActivation
     */
    omit?: KioskActivationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskActivationInclude<ExtArgs> | null
    /**
     * Filter, which KioskActivation to fetch.
     */
    where?: KioskActivationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KioskActivations to fetch.
     */
    orderBy?: KioskActivationOrderByWithRelationInput | KioskActivationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KioskActivations.
     */
    cursor?: KioskActivationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KioskActivations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KioskActivations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KioskActivations.
     */
    distinct?: KioskActivationScalarFieldEnum | KioskActivationScalarFieldEnum[]
  }

  /**
   * KioskActivation findFirstOrThrow
   */
  export type KioskActivationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskActivation
     */
    select?: KioskActivationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskActivation
     */
    omit?: KioskActivationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskActivationInclude<ExtArgs> | null
    /**
     * Filter, which KioskActivation to fetch.
     */
    where?: KioskActivationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KioskActivations to fetch.
     */
    orderBy?: KioskActivationOrderByWithRelationInput | KioskActivationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KioskActivations.
     */
    cursor?: KioskActivationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KioskActivations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KioskActivations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KioskActivations.
     */
    distinct?: KioskActivationScalarFieldEnum | KioskActivationScalarFieldEnum[]
  }

  /**
   * KioskActivation findMany
   */
  export type KioskActivationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskActivation
     */
    select?: KioskActivationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskActivation
     */
    omit?: KioskActivationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskActivationInclude<ExtArgs> | null
    /**
     * Filter, which KioskActivations to fetch.
     */
    where?: KioskActivationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KioskActivations to fetch.
     */
    orderBy?: KioskActivationOrderByWithRelationInput | KioskActivationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KioskActivations.
     */
    cursor?: KioskActivationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KioskActivations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KioskActivations.
     */
    skip?: number
    distinct?: KioskActivationScalarFieldEnum | KioskActivationScalarFieldEnum[]
  }

  /**
   * KioskActivation create
   */
  export type KioskActivationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskActivation
     */
    select?: KioskActivationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskActivation
     */
    omit?: KioskActivationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskActivationInclude<ExtArgs> | null
    /**
     * The data needed to create a KioskActivation.
     */
    data: XOR<KioskActivationCreateInput, KioskActivationUncheckedCreateInput>
  }

  /**
   * KioskActivation createMany
   */
  export type KioskActivationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KioskActivations.
     */
    data: KioskActivationCreateManyInput | KioskActivationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KioskActivation createManyAndReturn
   */
  export type KioskActivationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskActivation
     */
    select?: KioskActivationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KioskActivation
     */
    omit?: KioskActivationOmit<ExtArgs> | null
    /**
     * The data used to create many KioskActivations.
     */
    data: KioskActivationCreateManyInput | KioskActivationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskActivationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KioskActivation update
   */
  export type KioskActivationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskActivation
     */
    select?: KioskActivationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskActivation
     */
    omit?: KioskActivationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskActivationInclude<ExtArgs> | null
    /**
     * The data needed to update a KioskActivation.
     */
    data: XOR<KioskActivationUpdateInput, KioskActivationUncheckedUpdateInput>
    /**
     * Choose, which KioskActivation to update.
     */
    where: KioskActivationWhereUniqueInput
  }

  /**
   * KioskActivation updateMany
   */
  export type KioskActivationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KioskActivations.
     */
    data: XOR<KioskActivationUpdateManyMutationInput, KioskActivationUncheckedUpdateManyInput>
    /**
     * Filter which KioskActivations to update
     */
    where?: KioskActivationWhereInput
    /**
     * Limit how many KioskActivations to update.
     */
    limit?: number
  }

  /**
   * KioskActivation updateManyAndReturn
   */
  export type KioskActivationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskActivation
     */
    select?: KioskActivationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KioskActivation
     */
    omit?: KioskActivationOmit<ExtArgs> | null
    /**
     * The data used to update KioskActivations.
     */
    data: XOR<KioskActivationUpdateManyMutationInput, KioskActivationUncheckedUpdateManyInput>
    /**
     * Filter which KioskActivations to update
     */
    where?: KioskActivationWhereInput
    /**
     * Limit how many KioskActivations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskActivationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KioskActivation upsert
   */
  export type KioskActivationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskActivation
     */
    select?: KioskActivationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskActivation
     */
    omit?: KioskActivationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskActivationInclude<ExtArgs> | null
    /**
     * The filter to search for the KioskActivation to update in case it exists.
     */
    where: KioskActivationWhereUniqueInput
    /**
     * In case the KioskActivation found by the `where` argument doesn't exist, create a new KioskActivation with this data.
     */
    create: XOR<KioskActivationCreateInput, KioskActivationUncheckedCreateInput>
    /**
     * In case the KioskActivation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KioskActivationUpdateInput, KioskActivationUncheckedUpdateInput>
  }

  /**
   * KioskActivation delete
   */
  export type KioskActivationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskActivation
     */
    select?: KioskActivationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskActivation
     */
    omit?: KioskActivationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskActivationInclude<ExtArgs> | null
    /**
     * Filter which KioskActivation to delete.
     */
    where: KioskActivationWhereUniqueInput
  }

  /**
   * KioskActivation deleteMany
   */
  export type KioskActivationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KioskActivations to delete
     */
    where?: KioskActivationWhereInput
    /**
     * Limit how many KioskActivations to delete.
     */
    limit?: number
  }

  /**
   * KioskActivation.kiosk
   */
  export type KioskActivation$kioskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kiosk
     */
    select?: KioskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kiosk
     */
    omit?: KioskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskInclude<ExtArgs> | null
    where?: KioskWhereInput
  }

  /**
   * KioskActivation without action
   */
  export type KioskActivationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskActivation
     */
    select?: KioskActivationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskActivation
     */
    omit?: KioskActivationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskActivationInclude<ExtArgs> | null
  }


  /**
   * Model SsoConfiguration
   */

  export type AggregateSsoConfiguration = {
    _count: SsoConfigurationCountAggregateOutputType | null
    _avg: SsoConfigurationAvgAggregateOutputType | null
    _sum: SsoConfigurationSumAggregateOutputType | null
    _min: SsoConfigurationMinAggregateOutputType | null
    _max: SsoConfigurationMaxAggregateOutputType | null
  }

  export type SsoConfigurationAvgAggregateOutputType = {
    id: number | null
  }

  export type SsoConfigurationSumAggregateOutputType = {
    id: number | null
  }

  export type SsoConfigurationMinAggregateOutputType = {
    id: number | null
    provider: string | null
    enabled: boolean | null
    updatedAt: Date | null
  }

  export type SsoConfigurationMaxAggregateOutputType = {
    id: number | null
    provider: string | null
    enabled: boolean | null
    updatedAt: Date | null
  }

  export type SsoConfigurationCountAggregateOutputType = {
    id: number
    provider: number
    enabled: number
    configuration: number
    updatedAt: number
    _all: number
  }


  export type SsoConfigurationAvgAggregateInputType = {
    id?: true
  }

  export type SsoConfigurationSumAggregateInputType = {
    id?: true
  }

  export type SsoConfigurationMinAggregateInputType = {
    id?: true
    provider?: true
    enabled?: true
    updatedAt?: true
  }

  export type SsoConfigurationMaxAggregateInputType = {
    id?: true
    provider?: true
    enabled?: true
    updatedAt?: true
  }

  export type SsoConfigurationCountAggregateInputType = {
    id?: true
    provider?: true
    enabled?: true
    configuration?: true
    updatedAt?: true
    _all?: true
  }

  export type SsoConfigurationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SsoConfiguration to aggregate.
     */
    where?: SsoConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SsoConfigurations to fetch.
     */
    orderBy?: SsoConfigurationOrderByWithRelationInput | SsoConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SsoConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SsoConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SsoConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SsoConfigurations
    **/
    _count?: true | SsoConfigurationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SsoConfigurationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SsoConfigurationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SsoConfigurationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SsoConfigurationMaxAggregateInputType
  }

  export type GetSsoConfigurationAggregateType<T extends SsoConfigurationAggregateArgs> = {
        [P in keyof T & keyof AggregateSsoConfiguration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSsoConfiguration[P]>
      : GetScalarType<T[P], AggregateSsoConfiguration[P]>
  }




  export type SsoConfigurationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SsoConfigurationWhereInput
    orderBy?: SsoConfigurationOrderByWithAggregationInput | SsoConfigurationOrderByWithAggregationInput[]
    by: SsoConfigurationScalarFieldEnum[] | SsoConfigurationScalarFieldEnum
    having?: SsoConfigurationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SsoConfigurationCountAggregateInputType | true
    _avg?: SsoConfigurationAvgAggregateInputType
    _sum?: SsoConfigurationSumAggregateInputType
    _min?: SsoConfigurationMinAggregateInputType
    _max?: SsoConfigurationMaxAggregateInputType
  }

  export type SsoConfigurationGroupByOutputType = {
    id: number
    provider: string
    enabled: boolean
    configuration: JsonValue | null
    updatedAt: Date
    _count: SsoConfigurationCountAggregateOutputType | null
    _avg: SsoConfigurationAvgAggregateOutputType | null
    _sum: SsoConfigurationSumAggregateOutputType | null
    _min: SsoConfigurationMinAggregateOutputType | null
    _max: SsoConfigurationMaxAggregateOutputType | null
  }

  type GetSsoConfigurationGroupByPayload<T extends SsoConfigurationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SsoConfigurationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SsoConfigurationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SsoConfigurationGroupByOutputType[P]>
            : GetScalarType<T[P], SsoConfigurationGroupByOutputType[P]>
        }
      >
    >


  export type SsoConfigurationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    enabled?: boolean
    configuration?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["ssoConfiguration"]>

  export type SsoConfigurationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    enabled?: boolean
    configuration?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["ssoConfiguration"]>

  export type SsoConfigurationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    enabled?: boolean
    configuration?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["ssoConfiguration"]>

  export type SsoConfigurationSelectScalar = {
    id?: boolean
    provider?: boolean
    enabled?: boolean
    configuration?: boolean
    updatedAt?: boolean
  }

  export type SsoConfigurationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "provider" | "enabled" | "configuration" | "updatedAt", ExtArgs["result"]["ssoConfiguration"]>

  export type $SsoConfigurationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SsoConfiguration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      provider: string
      enabled: boolean
      configuration: Prisma.JsonValue | null
      updatedAt: Date
    }, ExtArgs["result"]["ssoConfiguration"]>
    composites: {}
  }

  type SsoConfigurationGetPayload<S extends boolean | null | undefined | SsoConfigurationDefaultArgs> = $Result.GetResult<Prisma.$SsoConfigurationPayload, S>

  type SsoConfigurationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SsoConfigurationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SsoConfigurationCountAggregateInputType | true
    }

  export interface SsoConfigurationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SsoConfiguration'], meta: { name: 'SsoConfiguration' } }
    /**
     * Find zero or one SsoConfiguration that matches the filter.
     * @param {SsoConfigurationFindUniqueArgs} args - Arguments to find a SsoConfiguration
     * @example
     * // Get one SsoConfiguration
     * const ssoConfiguration = await prisma.ssoConfiguration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SsoConfigurationFindUniqueArgs>(args: SelectSubset<T, SsoConfigurationFindUniqueArgs<ExtArgs>>): Prisma__SsoConfigurationClient<$Result.GetResult<Prisma.$SsoConfigurationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SsoConfiguration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SsoConfigurationFindUniqueOrThrowArgs} args - Arguments to find a SsoConfiguration
     * @example
     * // Get one SsoConfiguration
     * const ssoConfiguration = await prisma.ssoConfiguration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SsoConfigurationFindUniqueOrThrowArgs>(args: SelectSubset<T, SsoConfigurationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SsoConfigurationClient<$Result.GetResult<Prisma.$SsoConfigurationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SsoConfiguration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SsoConfigurationFindFirstArgs} args - Arguments to find a SsoConfiguration
     * @example
     * // Get one SsoConfiguration
     * const ssoConfiguration = await prisma.ssoConfiguration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SsoConfigurationFindFirstArgs>(args?: SelectSubset<T, SsoConfigurationFindFirstArgs<ExtArgs>>): Prisma__SsoConfigurationClient<$Result.GetResult<Prisma.$SsoConfigurationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SsoConfiguration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SsoConfigurationFindFirstOrThrowArgs} args - Arguments to find a SsoConfiguration
     * @example
     * // Get one SsoConfiguration
     * const ssoConfiguration = await prisma.ssoConfiguration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SsoConfigurationFindFirstOrThrowArgs>(args?: SelectSubset<T, SsoConfigurationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SsoConfigurationClient<$Result.GetResult<Prisma.$SsoConfigurationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SsoConfigurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SsoConfigurationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SsoConfigurations
     * const ssoConfigurations = await prisma.ssoConfiguration.findMany()
     * 
     * // Get first 10 SsoConfigurations
     * const ssoConfigurations = await prisma.ssoConfiguration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ssoConfigurationWithIdOnly = await prisma.ssoConfiguration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SsoConfigurationFindManyArgs>(args?: SelectSubset<T, SsoConfigurationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SsoConfigurationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SsoConfiguration.
     * @param {SsoConfigurationCreateArgs} args - Arguments to create a SsoConfiguration.
     * @example
     * // Create one SsoConfiguration
     * const SsoConfiguration = await prisma.ssoConfiguration.create({
     *   data: {
     *     // ... data to create a SsoConfiguration
     *   }
     * })
     * 
     */
    create<T extends SsoConfigurationCreateArgs>(args: SelectSubset<T, SsoConfigurationCreateArgs<ExtArgs>>): Prisma__SsoConfigurationClient<$Result.GetResult<Prisma.$SsoConfigurationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SsoConfigurations.
     * @param {SsoConfigurationCreateManyArgs} args - Arguments to create many SsoConfigurations.
     * @example
     * // Create many SsoConfigurations
     * const ssoConfiguration = await prisma.ssoConfiguration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SsoConfigurationCreateManyArgs>(args?: SelectSubset<T, SsoConfigurationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SsoConfigurations and returns the data saved in the database.
     * @param {SsoConfigurationCreateManyAndReturnArgs} args - Arguments to create many SsoConfigurations.
     * @example
     * // Create many SsoConfigurations
     * const ssoConfiguration = await prisma.ssoConfiguration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SsoConfigurations and only return the `id`
     * const ssoConfigurationWithIdOnly = await prisma.ssoConfiguration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SsoConfigurationCreateManyAndReturnArgs>(args?: SelectSubset<T, SsoConfigurationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SsoConfigurationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SsoConfiguration.
     * @param {SsoConfigurationDeleteArgs} args - Arguments to delete one SsoConfiguration.
     * @example
     * // Delete one SsoConfiguration
     * const SsoConfiguration = await prisma.ssoConfiguration.delete({
     *   where: {
     *     // ... filter to delete one SsoConfiguration
     *   }
     * })
     * 
     */
    delete<T extends SsoConfigurationDeleteArgs>(args: SelectSubset<T, SsoConfigurationDeleteArgs<ExtArgs>>): Prisma__SsoConfigurationClient<$Result.GetResult<Prisma.$SsoConfigurationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SsoConfiguration.
     * @param {SsoConfigurationUpdateArgs} args - Arguments to update one SsoConfiguration.
     * @example
     * // Update one SsoConfiguration
     * const ssoConfiguration = await prisma.ssoConfiguration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SsoConfigurationUpdateArgs>(args: SelectSubset<T, SsoConfigurationUpdateArgs<ExtArgs>>): Prisma__SsoConfigurationClient<$Result.GetResult<Prisma.$SsoConfigurationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SsoConfigurations.
     * @param {SsoConfigurationDeleteManyArgs} args - Arguments to filter SsoConfigurations to delete.
     * @example
     * // Delete a few SsoConfigurations
     * const { count } = await prisma.ssoConfiguration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SsoConfigurationDeleteManyArgs>(args?: SelectSubset<T, SsoConfigurationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SsoConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SsoConfigurationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SsoConfigurations
     * const ssoConfiguration = await prisma.ssoConfiguration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SsoConfigurationUpdateManyArgs>(args: SelectSubset<T, SsoConfigurationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SsoConfigurations and returns the data updated in the database.
     * @param {SsoConfigurationUpdateManyAndReturnArgs} args - Arguments to update many SsoConfigurations.
     * @example
     * // Update many SsoConfigurations
     * const ssoConfiguration = await prisma.ssoConfiguration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SsoConfigurations and only return the `id`
     * const ssoConfigurationWithIdOnly = await prisma.ssoConfiguration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SsoConfigurationUpdateManyAndReturnArgs>(args: SelectSubset<T, SsoConfigurationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SsoConfigurationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SsoConfiguration.
     * @param {SsoConfigurationUpsertArgs} args - Arguments to update or create a SsoConfiguration.
     * @example
     * // Update or create a SsoConfiguration
     * const ssoConfiguration = await prisma.ssoConfiguration.upsert({
     *   create: {
     *     // ... data to create a SsoConfiguration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SsoConfiguration we want to update
     *   }
     * })
     */
    upsert<T extends SsoConfigurationUpsertArgs>(args: SelectSubset<T, SsoConfigurationUpsertArgs<ExtArgs>>): Prisma__SsoConfigurationClient<$Result.GetResult<Prisma.$SsoConfigurationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SsoConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SsoConfigurationCountArgs} args - Arguments to filter SsoConfigurations to count.
     * @example
     * // Count the number of SsoConfigurations
     * const count = await prisma.ssoConfiguration.count({
     *   where: {
     *     // ... the filter for the SsoConfigurations we want to count
     *   }
     * })
    **/
    count<T extends SsoConfigurationCountArgs>(
      args?: Subset<T, SsoConfigurationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SsoConfigurationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SsoConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SsoConfigurationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SsoConfigurationAggregateArgs>(args: Subset<T, SsoConfigurationAggregateArgs>): Prisma.PrismaPromise<GetSsoConfigurationAggregateType<T>>

    /**
     * Group by SsoConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SsoConfigurationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SsoConfigurationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SsoConfigurationGroupByArgs['orderBy'] }
        : { orderBy?: SsoConfigurationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SsoConfigurationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSsoConfigurationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SsoConfiguration model
   */
  readonly fields: SsoConfigurationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SsoConfiguration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SsoConfigurationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SsoConfiguration model
   */
  interface SsoConfigurationFieldRefs {
    readonly id: FieldRef<"SsoConfiguration", 'Int'>
    readonly provider: FieldRef<"SsoConfiguration", 'String'>
    readonly enabled: FieldRef<"SsoConfiguration", 'Boolean'>
    readonly configuration: FieldRef<"SsoConfiguration", 'Json'>
    readonly updatedAt: FieldRef<"SsoConfiguration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SsoConfiguration findUnique
   */
  export type SsoConfigurationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SsoConfiguration
     */
    select?: SsoConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SsoConfiguration
     */
    omit?: SsoConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which SsoConfiguration to fetch.
     */
    where: SsoConfigurationWhereUniqueInput
  }

  /**
   * SsoConfiguration findUniqueOrThrow
   */
  export type SsoConfigurationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SsoConfiguration
     */
    select?: SsoConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SsoConfiguration
     */
    omit?: SsoConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which SsoConfiguration to fetch.
     */
    where: SsoConfigurationWhereUniqueInput
  }

  /**
   * SsoConfiguration findFirst
   */
  export type SsoConfigurationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SsoConfiguration
     */
    select?: SsoConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SsoConfiguration
     */
    omit?: SsoConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which SsoConfiguration to fetch.
     */
    where?: SsoConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SsoConfigurations to fetch.
     */
    orderBy?: SsoConfigurationOrderByWithRelationInput | SsoConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SsoConfigurations.
     */
    cursor?: SsoConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SsoConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SsoConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SsoConfigurations.
     */
    distinct?: SsoConfigurationScalarFieldEnum | SsoConfigurationScalarFieldEnum[]
  }

  /**
   * SsoConfiguration findFirstOrThrow
   */
  export type SsoConfigurationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SsoConfiguration
     */
    select?: SsoConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SsoConfiguration
     */
    omit?: SsoConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which SsoConfiguration to fetch.
     */
    where?: SsoConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SsoConfigurations to fetch.
     */
    orderBy?: SsoConfigurationOrderByWithRelationInput | SsoConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SsoConfigurations.
     */
    cursor?: SsoConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SsoConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SsoConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SsoConfigurations.
     */
    distinct?: SsoConfigurationScalarFieldEnum | SsoConfigurationScalarFieldEnum[]
  }

  /**
   * SsoConfiguration findMany
   */
  export type SsoConfigurationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SsoConfiguration
     */
    select?: SsoConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SsoConfiguration
     */
    omit?: SsoConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which SsoConfigurations to fetch.
     */
    where?: SsoConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SsoConfigurations to fetch.
     */
    orderBy?: SsoConfigurationOrderByWithRelationInput | SsoConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SsoConfigurations.
     */
    cursor?: SsoConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SsoConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SsoConfigurations.
     */
    skip?: number
    distinct?: SsoConfigurationScalarFieldEnum | SsoConfigurationScalarFieldEnum[]
  }

  /**
   * SsoConfiguration create
   */
  export type SsoConfigurationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SsoConfiguration
     */
    select?: SsoConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SsoConfiguration
     */
    omit?: SsoConfigurationOmit<ExtArgs> | null
    /**
     * The data needed to create a SsoConfiguration.
     */
    data: XOR<SsoConfigurationCreateInput, SsoConfigurationUncheckedCreateInput>
  }

  /**
   * SsoConfiguration createMany
   */
  export type SsoConfigurationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SsoConfigurations.
     */
    data: SsoConfigurationCreateManyInput | SsoConfigurationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SsoConfiguration createManyAndReturn
   */
  export type SsoConfigurationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SsoConfiguration
     */
    select?: SsoConfigurationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SsoConfiguration
     */
    omit?: SsoConfigurationOmit<ExtArgs> | null
    /**
     * The data used to create many SsoConfigurations.
     */
    data: SsoConfigurationCreateManyInput | SsoConfigurationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SsoConfiguration update
   */
  export type SsoConfigurationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SsoConfiguration
     */
    select?: SsoConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SsoConfiguration
     */
    omit?: SsoConfigurationOmit<ExtArgs> | null
    /**
     * The data needed to update a SsoConfiguration.
     */
    data: XOR<SsoConfigurationUpdateInput, SsoConfigurationUncheckedUpdateInput>
    /**
     * Choose, which SsoConfiguration to update.
     */
    where: SsoConfigurationWhereUniqueInput
  }

  /**
   * SsoConfiguration updateMany
   */
  export type SsoConfigurationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SsoConfigurations.
     */
    data: XOR<SsoConfigurationUpdateManyMutationInput, SsoConfigurationUncheckedUpdateManyInput>
    /**
     * Filter which SsoConfigurations to update
     */
    where?: SsoConfigurationWhereInput
    /**
     * Limit how many SsoConfigurations to update.
     */
    limit?: number
  }

  /**
   * SsoConfiguration updateManyAndReturn
   */
  export type SsoConfigurationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SsoConfiguration
     */
    select?: SsoConfigurationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SsoConfiguration
     */
    omit?: SsoConfigurationOmit<ExtArgs> | null
    /**
     * The data used to update SsoConfigurations.
     */
    data: XOR<SsoConfigurationUpdateManyMutationInput, SsoConfigurationUncheckedUpdateManyInput>
    /**
     * Filter which SsoConfigurations to update
     */
    where?: SsoConfigurationWhereInput
    /**
     * Limit how many SsoConfigurations to update.
     */
    limit?: number
  }

  /**
   * SsoConfiguration upsert
   */
  export type SsoConfigurationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SsoConfiguration
     */
    select?: SsoConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SsoConfiguration
     */
    omit?: SsoConfigurationOmit<ExtArgs> | null
    /**
     * The filter to search for the SsoConfiguration to update in case it exists.
     */
    where: SsoConfigurationWhereUniqueInput
    /**
     * In case the SsoConfiguration found by the `where` argument doesn't exist, create a new SsoConfiguration with this data.
     */
    create: XOR<SsoConfigurationCreateInput, SsoConfigurationUncheckedCreateInput>
    /**
     * In case the SsoConfiguration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SsoConfigurationUpdateInput, SsoConfigurationUncheckedUpdateInput>
  }

  /**
   * SsoConfiguration delete
   */
  export type SsoConfigurationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SsoConfiguration
     */
    select?: SsoConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SsoConfiguration
     */
    omit?: SsoConfigurationOmit<ExtArgs> | null
    /**
     * Filter which SsoConfiguration to delete.
     */
    where: SsoConfigurationWhereUniqueInput
  }

  /**
   * SsoConfiguration deleteMany
   */
  export type SsoConfigurationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SsoConfigurations to delete
     */
    where?: SsoConfigurationWhereInput
    /**
     * Limit how many SsoConfigurations to delete.
     */
    limit?: number
  }

  /**
   * SsoConfiguration without action
   */
  export type SsoConfigurationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SsoConfiguration
     */
    select?: SsoConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SsoConfiguration
     */
    omit?: SsoConfigurationOmit<ExtArgs> | null
  }


  /**
   * Model AdminPin
   */

  export type AggregateAdminPin = {
    _count: AdminPinCountAggregateOutputType | null
    _avg: AdminPinAvgAggregateOutputType | null
    _sum: AdminPinSumAggregateOutputType | null
    _min: AdminPinMinAggregateOutputType | null
    _max: AdminPinMaxAggregateOutputType | null
  }

  export type AdminPinAvgAggregateOutputType = {
    id: number | null
  }

  export type AdminPinSumAggregateOutputType = {
    id: number | null
  }

  export type AdminPinMinAggregateOutputType = {
    id: number | null
    globalPin: string | null
    updatedAt: Date | null
  }

  export type AdminPinMaxAggregateOutputType = {
    id: number | null
    globalPin: string | null
    updatedAt: Date | null
  }

  export type AdminPinCountAggregateOutputType = {
    id: number
    globalPin: number
    kioskPins: number
    updatedAt: number
    _all: number
  }


  export type AdminPinAvgAggregateInputType = {
    id?: true
  }

  export type AdminPinSumAggregateInputType = {
    id?: true
  }

  export type AdminPinMinAggregateInputType = {
    id?: true
    globalPin?: true
    updatedAt?: true
  }

  export type AdminPinMaxAggregateInputType = {
    id?: true
    globalPin?: true
    updatedAt?: true
  }

  export type AdminPinCountAggregateInputType = {
    id?: true
    globalPin?: true
    kioskPins?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminPinAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminPin to aggregate.
     */
    where?: AdminPinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminPins to fetch.
     */
    orderBy?: AdminPinOrderByWithRelationInput | AdminPinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminPinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminPins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminPins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminPins
    **/
    _count?: true | AdminPinCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminPinAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminPinSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminPinMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminPinMaxAggregateInputType
  }

  export type GetAdminPinAggregateType<T extends AdminPinAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminPin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminPin[P]>
      : GetScalarType<T[P], AggregateAdminPin[P]>
  }




  export type AdminPinGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminPinWhereInput
    orderBy?: AdminPinOrderByWithAggregationInput | AdminPinOrderByWithAggregationInput[]
    by: AdminPinScalarFieldEnum[] | AdminPinScalarFieldEnum
    having?: AdminPinScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminPinCountAggregateInputType | true
    _avg?: AdminPinAvgAggregateInputType
    _sum?: AdminPinSumAggregateInputType
    _min?: AdminPinMinAggregateInputType
    _max?: AdminPinMaxAggregateInputType
  }

  export type AdminPinGroupByOutputType = {
    id: number
    globalPin: string | null
    kioskPins: JsonValue | null
    updatedAt: Date
    _count: AdminPinCountAggregateOutputType | null
    _avg: AdminPinAvgAggregateOutputType | null
    _sum: AdminPinSumAggregateOutputType | null
    _min: AdminPinMinAggregateOutputType | null
    _max: AdminPinMaxAggregateOutputType | null
  }

  type GetAdminPinGroupByPayload<T extends AdminPinGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminPinGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminPinGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminPinGroupByOutputType[P]>
            : GetScalarType<T[P], AdminPinGroupByOutputType[P]>
        }
      >
    >


  export type AdminPinSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    globalPin?: boolean
    kioskPins?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["adminPin"]>

  export type AdminPinSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    globalPin?: boolean
    kioskPins?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["adminPin"]>

  export type AdminPinSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    globalPin?: boolean
    kioskPins?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["adminPin"]>

  export type AdminPinSelectScalar = {
    id?: boolean
    globalPin?: boolean
    kioskPins?: boolean
    updatedAt?: boolean
  }

  export type AdminPinOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "globalPin" | "kioskPins" | "updatedAt", ExtArgs["result"]["adminPin"]>

  export type $AdminPinPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminPin"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      globalPin: string | null
      kioskPins: Prisma.JsonValue | null
      updatedAt: Date
    }, ExtArgs["result"]["adminPin"]>
    composites: {}
  }

  type AdminPinGetPayload<S extends boolean | null | undefined | AdminPinDefaultArgs> = $Result.GetResult<Prisma.$AdminPinPayload, S>

  type AdminPinCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminPinFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminPinCountAggregateInputType | true
    }

  export interface AdminPinDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminPin'], meta: { name: 'AdminPin' } }
    /**
     * Find zero or one AdminPin that matches the filter.
     * @param {AdminPinFindUniqueArgs} args - Arguments to find a AdminPin
     * @example
     * // Get one AdminPin
     * const adminPin = await prisma.adminPin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminPinFindUniqueArgs>(args: SelectSubset<T, AdminPinFindUniqueArgs<ExtArgs>>): Prisma__AdminPinClient<$Result.GetResult<Prisma.$AdminPinPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminPin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminPinFindUniqueOrThrowArgs} args - Arguments to find a AdminPin
     * @example
     * // Get one AdminPin
     * const adminPin = await prisma.adminPin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminPinFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminPinFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminPinClient<$Result.GetResult<Prisma.$AdminPinPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminPin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPinFindFirstArgs} args - Arguments to find a AdminPin
     * @example
     * // Get one AdminPin
     * const adminPin = await prisma.adminPin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminPinFindFirstArgs>(args?: SelectSubset<T, AdminPinFindFirstArgs<ExtArgs>>): Prisma__AdminPinClient<$Result.GetResult<Prisma.$AdminPinPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminPin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPinFindFirstOrThrowArgs} args - Arguments to find a AdminPin
     * @example
     * // Get one AdminPin
     * const adminPin = await prisma.adminPin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminPinFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminPinFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminPinClient<$Result.GetResult<Prisma.$AdminPinPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminPins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPinFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminPins
     * const adminPins = await prisma.adminPin.findMany()
     * 
     * // Get first 10 AdminPins
     * const adminPins = await prisma.adminPin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminPinWithIdOnly = await prisma.adminPin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminPinFindManyArgs>(args?: SelectSubset<T, AdminPinFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminPin.
     * @param {AdminPinCreateArgs} args - Arguments to create a AdminPin.
     * @example
     * // Create one AdminPin
     * const AdminPin = await prisma.adminPin.create({
     *   data: {
     *     // ... data to create a AdminPin
     *   }
     * })
     * 
     */
    create<T extends AdminPinCreateArgs>(args: SelectSubset<T, AdminPinCreateArgs<ExtArgs>>): Prisma__AdminPinClient<$Result.GetResult<Prisma.$AdminPinPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminPins.
     * @param {AdminPinCreateManyArgs} args - Arguments to create many AdminPins.
     * @example
     * // Create many AdminPins
     * const adminPin = await prisma.adminPin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminPinCreateManyArgs>(args?: SelectSubset<T, AdminPinCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminPins and returns the data saved in the database.
     * @param {AdminPinCreateManyAndReturnArgs} args - Arguments to create many AdminPins.
     * @example
     * // Create many AdminPins
     * const adminPin = await prisma.adminPin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminPins and only return the `id`
     * const adminPinWithIdOnly = await prisma.adminPin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminPinCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminPinCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPinPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminPin.
     * @param {AdminPinDeleteArgs} args - Arguments to delete one AdminPin.
     * @example
     * // Delete one AdminPin
     * const AdminPin = await prisma.adminPin.delete({
     *   where: {
     *     // ... filter to delete one AdminPin
     *   }
     * })
     * 
     */
    delete<T extends AdminPinDeleteArgs>(args: SelectSubset<T, AdminPinDeleteArgs<ExtArgs>>): Prisma__AdminPinClient<$Result.GetResult<Prisma.$AdminPinPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminPin.
     * @param {AdminPinUpdateArgs} args - Arguments to update one AdminPin.
     * @example
     * // Update one AdminPin
     * const adminPin = await prisma.adminPin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminPinUpdateArgs>(args: SelectSubset<T, AdminPinUpdateArgs<ExtArgs>>): Prisma__AdminPinClient<$Result.GetResult<Prisma.$AdminPinPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminPins.
     * @param {AdminPinDeleteManyArgs} args - Arguments to filter AdminPins to delete.
     * @example
     * // Delete a few AdminPins
     * const { count } = await prisma.adminPin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminPinDeleteManyArgs>(args?: SelectSubset<T, AdminPinDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminPins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPinUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminPins
     * const adminPin = await prisma.adminPin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminPinUpdateManyArgs>(args: SelectSubset<T, AdminPinUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminPins and returns the data updated in the database.
     * @param {AdminPinUpdateManyAndReturnArgs} args - Arguments to update many AdminPins.
     * @example
     * // Update many AdminPins
     * const adminPin = await prisma.adminPin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminPins and only return the `id`
     * const adminPinWithIdOnly = await prisma.adminPin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminPinUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminPinUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPinPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminPin.
     * @param {AdminPinUpsertArgs} args - Arguments to update or create a AdminPin.
     * @example
     * // Update or create a AdminPin
     * const adminPin = await prisma.adminPin.upsert({
     *   create: {
     *     // ... data to create a AdminPin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminPin we want to update
     *   }
     * })
     */
    upsert<T extends AdminPinUpsertArgs>(args: SelectSubset<T, AdminPinUpsertArgs<ExtArgs>>): Prisma__AdminPinClient<$Result.GetResult<Prisma.$AdminPinPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminPins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPinCountArgs} args - Arguments to filter AdminPins to count.
     * @example
     * // Count the number of AdminPins
     * const count = await prisma.adminPin.count({
     *   where: {
     *     // ... the filter for the AdminPins we want to count
     *   }
     * })
    **/
    count<T extends AdminPinCountArgs>(
      args?: Subset<T, AdminPinCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminPinCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminPin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPinAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminPinAggregateArgs>(args: Subset<T, AdminPinAggregateArgs>): Prisma.PrismaPromise<GetAdminPinAggregateType<T>>

    /**
     * Group by AdminPin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminPinGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminPinGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminPinGroupByArgs['orderBy'] }
        : { orderBy?: AdminPinGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminPinGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminPinGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminPin model
   */
  readonly fields: AdminPinFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminPin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminPinClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminPin model
   */
  interface AdminPinFieldRefs {
    readonly id: FieldRef<"AdminPin", 'Int'>
    readonly globalPin: FieldRef<"AdminPin", 'String'>
    readonly kioskPins: FieldRef<"AdminPin", 'Json'>
    readonly updatedAt: FieldRef<"AdminPin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminPin findUnique
   */
  export type AdminPinFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPin
     */
    select?: AdminPinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPin
     */
    omit?: AdminPinOmit<ExtArgs> | null
    /**
     * Filter, which AdminPin to fetch.
     */
    where: AdminPinWhereUniqueInput
  }

  /**
   * AdminPin findUniqueOrThrow
   */
  export type AdminPinFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPin
     */
    select?: AdminPinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPin
     */
    omit?: AdminPinOmit<ExtArgs> | null
    /**
     * Filter, which AdminPin to fetch.
     */
    where: AdminPinWhereUniqueInput
  }

  /**
   * AdminPin findFirst
   */
  export type AdminPinFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPin
     */
    select?: AdminPinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPin
     */
    omit?: AdminPinOmit<ExtArgs> | null
    /**
     * Filter, which AdminPin to fetch.
     */
    where?: AdminPinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminPins to fetch.
     */
    orderBy?: AdminPinOrderByWithRelationInput | AdminPinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminPins.
     */
    cursor?: AdminPinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminPins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminPins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminPins.
     */
    distinct?: AdminPinScalarFieldEnum | AdminPinScalarFieldEnum[]
  }

  /**
   * AdminPin findFirstOrThrow
   */
  export type AdminPinFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPin
     */
    select?: AdminPinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPin
     */
    omit?: AdminPinOmit<ExtArgs> | null
    /**
     * Filter, which AdminPin to fetch.
     */
    where?: AdminPinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminPins to fetch.
     */
    orderBy?: AdminPinOrderByWithRelationInput | AdminPinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminPins.
     */
    cursor?: AdminPinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminPins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminPins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminPins.
     */
    distinct?: AdminPinScalarFieldEnum | AdminPinScalarFieldEnum[]
  }

  /**
   * AdminPin findMany
   */
  export type AdminPinFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPin
     */
    select?: AdminPinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPin
     */
    omit?: AdminPinOmit<ExtArgs> | null
    /**
     * Filter, which AdminPins to fetch.
     */
    where?: AdminPinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminPins to fetch.
     */
    orderBy?: AdminPinOrderByWithRelationInput | AdminPinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminPins.
     */
    cursor?: AdminPinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminPins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminPins.
     */
    skip?: number
    distinct?: AdminPinScalarFieldEnum | AdminPinScalarFieldEnum[]
  }

  /**
   * AdminPin create
   */
  export type AdminPinCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPin
     */
    select?: AdminPinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPin
     */
    omit?: AdminPinOmit<ExtArgs> | null
    /**
     * The data needed to create a AdminPin.
     */
    data?: XOR<AdminPinCreateInput, AdminPinUncheckedCreateInput>
  }

  /**
   * AdminPin createMany
   */
  export type AdminPinCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminPins.
     */
    data: AdminPinCreateManyInput | AdminPinCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminPin createManyAndReturn
   */
  export type AdminPinCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPin
     */
    select?: AdminPinSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPin
     */
    omit?: AdminPinOmit<ExtArgs> | null
    /**
     * The data used to create many AdminPins.
     */
    data: AdminPinCreateManyInput | AdminPinCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminPin update
   */
  export type AdminPinUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPin
     */
    select?: AdminPinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPin
     */
    omit?: AdminPinOmit<ExtArgs> | null
    /**
     * The data needed to update a AdminPin.
     */
    data: XOR<AdminPinUpdateInput, AdminPinUncheckedUpdateInput>
    /**
     * Choose, which AdminPin to update.
     */
    where: AdminPinWhereUniqueInput
  }

  /**
   * AdminPin updateMany
   */
  export type AdminPinUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminPins.
     */
    data: XOR<AdminPinUpdateManyMutationInput, AdminPinUncheckedUpdateManyInput>
    /**
     * Filter which AdminPins to update
     */
    where?: AdminPinWhereInput
    /**
     * Limit how many AdminPins to update.
     */
    limit?: number
  }

  /**
   * AdminPin updateManyAndReturn
   */
  export type AdminPinUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPin
     */
    select?: AdminPinSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPin
     */
    omit?: AdminPinOmit<ExtArgs> | null
    /**
     * The data used to update AdminPins.
     */
    data: XOR<AdminPinUpdateManyMutationInput, AdminPinUncheckedUpdateManyInput>
    /**
     * Filter which AdminPins to update
     */
    where?: AdminPinWhereInput
    /**
     * Limit how many AdminPins to update.
     */
    limit?: number
  }

  /**
   * AdminPin upsert
   */
  export type AdminPinUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPin
     */
    select?: AdminPinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPin
     */
    omit?: AdminPinOmit<ExtArgs> | null
    /**
     * The filter to search for the AdminPin to update in case it exists.
     */
    where: AdminPinWhereUniqueInput
    /**
     * In case the AdminPin found by the `where` argument doesn't exist, create a new AdminPin with this data.
     */
    create: XOR<AdminPinCreateInput, AdminPinUncheckedCreateInput>
    /**
     * In case the AdminPin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminPinUpdateInput, AdminPinUncheckedUpdateInput>
  }

  /**
   * AdminPin delete
   */
  export type AdminPinDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPin
     */
    select?: AdminPinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPin
     */
    omit?: AdminPinOmit<ExtArgs> | null
    /**
     * Filter which AdminPin to delete.
     */
    where: AdminPinWhereUniqueInput
  }

  /**
   * AdminPin deleteMany
   */
  export type AdminPinDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminPins to delete
     */
    where?: AdminPinWhereInput
    /**
     * Limit how many AdminPins to delete.
     */
    limit?: number
  }

  /**
   * AdminPin without action
   */
  export type AdminPinDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminPin
     */
    select?: AdminPinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminPin
     */
    omit?: AdminPinOmit<ExtArgs> | null
  }


  /**
   * Model KbArticle
   */

  export type AggregateKbArticle = {
    _count: KbArticleCountAggregateOutputType | null
    _avg: KbArticleAvgAggregateOutputType | null
    _sum: KbArticleSumAggregateOutputType | null
    _min: KbArticleMinAggregateOutputType | null
    _max: KbArticleMaxAggregateOutputType | null
  }

  export type KbArticleAvgAggregateOutputType = {
    id: number | null
    currentVersionId: number | null
  }

  export type KbArticleSumAggregateOutputType = {
    id: number | null
    currentVersionId: number | null
  }

  export type KbArticleMinAggregateOutputType = {
    id: number | null
    slug: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
    authorId: string | null
    currentVersionId: number | null
    isPublished: boolean | null
  }

  export type KbArticleMaxAggregateOutputType = {
    id: number | null
    slug: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
    authorId: string | null
    currentVersionId: number | null
    isPublished: boolean | null
  }

  export type KbArticleCountAggregateOutputType = {
    id: number
    slug: number
    title: number
    createdAt: number
    updatedAt: number
    authorId: number
    currentVersionId: number
    isPublished: number
    tags: number
    _all: number
  }


  export type KbArticleAvgAggregateInputType = {
    id?: true
    currentVersionId?: true
  }

  export type KbArticleSumAggregateInputType = {
    id?: true
    currentVersionId?: true
  }

  export type KbArticleMinAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
    currentVersionId?: true
    isPublished?: true
  }

  export type KbArticleMaxAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
    currentVersionId?: true
    isPublished?: true
  }

  export type KbArticleCountAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
    currentVersionId?: true
    isPublished?: true
    tags?: true
    _all?: true
  }

  export type KbArticleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KbArticle to aggregate.
     */
    where?: KbArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KbArticles to fetch.
     */
    orderBy?: KbArticleOrderByWithRelationInput | KbArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KbArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KbArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KbArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KbArticles
    **/
    _count?: true | KbArticleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KbArticleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KbArticleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KbArticleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KbArticleMaxAggregateInputType
  }

  export type GetKbArticleAggregateType<T extends KbArticleAggregateArgs> = {
        [P in keyof T & keyof AggregateKbArticle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKbArticle[P]>
      : GetScalarType<T[P], AggregateKbArticle[P]>
  }




  export type KbArticleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KbArticleWhereInput
    orderBy?: KbArticleOrderByWithAggregationInput | KbArticleOrderByWithAggregationInput[]
    by: KbArticleScalarFieldEnum[] | KbArticleScalarFieldEnum
    having?: KbArticleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KbArticleCountAggregateInputType | true
    _avg?: KbArticleAvgAggregateInputType
    _sum?: KbArticleSumAggregateInputType
    _min?: KbArticleMinAggregateInputType
    _max?: KbArticleMaxAggregateInputType
  }

  export type KbArticleGroupByOutputType = {
    id: number
    slug: string
    title: string
    createdAt: Date
    updatedAt: Date
    authorId: string | null
    currentVersionId: number | null
    isPublished: boolean
    tags: string[]
    _count: KbArticleCountAggregateOutputType | null
    _avg: KbArticleAvgAggregateOutputType | null
    _sum: KbArticleSumAggregateOutputType | null
    _min: KbArticleMinAggregateOutputType | null
    _max: KbArticleMaxAggregateOutputType | null
  }

  type GetKbArticleGroupByPayload<T extends KbArticleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KbArticleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KbArticleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KbArticleGroupByOutputType[P]>
            : GetScalarType<T[P], KbArticleGroupByOutputType[P]>
        }
      >
    >


  export type KbArticleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    currentVersionId?: boolean
    isPublished?: boolean
    tags?: boolean
    author?: boolean | KbArticle$authorArgs<ExtArgs>
    versions?: boolean | KbArticle$versionsArgs<ExtArgs>
    comments?: boolean | KbArticle$commentsArgs<ExtArgs>
    currentVersion?: boolean | KbArticle$currentVersionArgs<ExtArgs>
    _count?: boolean | KbArticleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kbArticle"]>

  export type KbArticleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    currentVersionId?: boolean
    isPublished?: boolean
    tags?: boolean
    author?: boolean | KbArticle$authorArgs<ExtArgs>
    currentVersion?: boolean | KbArticle$currentVersionArgs<ExtArgs>
  }, ExtArgs["result"]["kbArticle"]>

  export type KbArticleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    currentVersionId?: boolean
    isPublished?: boolean
    tags?: boolean
    author?: boolean | KbArticle$authorArgs<ExtArgs>
    currentVersion?: boolean | KbArticle$currentVersionArgs<ExtArgs>
  }, ExtArgs["result"]["kbArticle"]>

  export type KbArticleSelectScalar = {
    id?: boolean
    slug?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    currentVersionId?: boolean
    isPublished?: boolean
    tags?: boolean
  }

  export type KbArticleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "title" | "createdAt" | "updatedAt" | "authorId" | "currentVersionId" | "isPublished" | "tags", ExtArgs["result"]["kbArticle"]>
  export type KbArticleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | KbArticle$authorArgs<ExtArgs>
    versions?: boolean | KbArticle$versionsArgs<ExtArgs>
    comments?: boolean | KbArticle$commentsArgs<ExtArgs>
    currentVersion?: boolean | KbArticle$currentVersionArgs<ExtArgs>
    _count?: boolean | KbArticleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KbArticleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | KbArticle$authorArgs<ExtArgs>
    currentVersion?: boolean | KbArticle$currentVersionArgs<ExtArgs>
  }
  export type KbArticleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | KbArticle$authorArgs<ExtArgs>
    currentVersion?: boolean | KbArticle$currentVersionArgs<ExtArgs>
  }

  export type $KbArticlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KbArticle"
    objects: {
      author: Prisma.$UserPayload<ExtArgs> | null
      versions: Prisma.$KbArticleVersionPayload<ExtArgs>[]
      comments: Prisma.$KbArticleCommentPayload<ExtArgs>[]
      currentVersion: Prisma.$KbArticleVersionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      slug: string
      title: string
      createdAt: Date
      updatedAt: Date
      authorId: string | null
      currentVersionId: number | null
      isPublished: boolean
      tags: string[]
    }, ExtArgs["result"]["kbArticle"]>
    composites: {}
  }

  type KbArticleGetPayload<S extends boolean | null | undefined | KbArticleDefaultArgs> = $Result.GetResult<Prisma.$KbArticlePayload, S>

  type KbArticleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KbArticleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KbArticleCountAggregateInputType | true
    }

  export interface KbArticleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KbArticle'], meta: { name: 'KbArticle' } }
    /**
     * Find zero or one KbArticle that matches the filter.
     * @param {KbArticleFindUniqueArgs} args - Arguments to find a KbArticle
     * @example
     * // Get one KbArticle
     * const kbArticle = await prisma.kbArticle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KbArticleFindUniqueArgs>(args: SelectSubset<T, KbArticleFindUniqueArgs<ExtArgs>>): Prisma__KbArticleClient<$Result.GetResult<Prisma.$KbArticlePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KbArticle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KbArticleFindUniqueOrThrowArgs} args - Arguments to find a KbArticle
     * @example
     * // Get one KbArticle
     * const kbArticle = await prisma.kbArticle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KbArticleFindUniqueOrThrowArgs>(args: SelectSubset<T, KbArticleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KbArticleClient<$Result.GetResult<Prisma.$KbArticlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KbArticle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KbArticleFindFirstArgs} args - Arguments to find a KbArticle
     * @example
     * // Get one KbArticle
     * const kbArticle = await prisma.kbArticle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KbArticleFindFirstArgs>(args?: SelectSubset<T, KbArticleFindFirstArgs<ExtArgs>>): Prisma__KbArticleClient<$Result.GetResult<Prisma.$KbArticlePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KbArticle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KbArticleFindFirstOrThrowArgs} args - Arguments to find a KbArticle
     * @example
     * // Get one KbArticle
     * const kbArticle = await prisma.kbArticle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KbArticleFindFirstOrThrowArgs>(args?: SelectSubset<T, KbArticleFindFirstOrThrowArgs<ExtArgs>>): Prisma__KbArticleClient<$Result.GetResult<Prisma.$KbArticlePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KbArticles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KbArticleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KbArticles
     * const kbArticles = await prisma.kbArticle.findMany()
     * 
     * // Get first 10 KbArticles
     * const kbArticles = await prisma.kbArticle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kbArticleWithIdOnly = await prisma.kbArticle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KbArticleFindManyArgs>(args?: SelectSubset<T, KbArticleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KbArticlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KbArticle.
     * @param {KbArticleCreateArgs} args - Arguments to create a KbArticle.
     * @example
     * // Create one KbArticle
     * const KbArticle = await prisma.kbArticle.create({
     *   data: {
     *     // ... data to create a KbArticle
     *   }
     * })
     * 
     */
    create<T extends KbArticleCreateArgs>(args: SelectSubset<T, KbArticleCreateArgs<ExtArgs>>): Prisma__KbArticleClient<$Result.GetResult<Prisma.$KbArticlePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KbArticles.
     * @param {KbArticleCreateManyArgs} args - Arguments to create many KbArticles.
     * @example
     * // Create many KbArticles
     * const kbArticle = await prisma.kbArticle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KbArticleCreateManyArgs>(args?: SelectSubset<T, KbArticleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KbArticles and returns the data saved in the database.
     * @param {KbArticleCreateManyAndReturnArgs} args - Arguments to create many KbArticles.
     * @example
     * // Create many KbArticles
     * const kbArticle = await prisma.kbArticle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KbArticles and only return the `id`
     * const kbArticleWithIdOnly = await prisma.kbArticle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KbArticleCreateManyAndReturnArgs>(args?: SelectSubset<T, KbArticleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KbArticlePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KbArticle.
     * @param {KbArticleDeleteArgs} args - Arguments to delete one KbArticle.
     * @example
     * // Delete one KbArticle
     * const KbArticle = await prisma.kbArticle.delete({
     *   where: {
     *     // ... filter to delete one KbArticle
     *   }
     * })
     * 
     */
    delete<T extends KbArticleDeleteArgs>(args: SelectSubset<T, KbArticleDeleteArgs<ExtArgs>>): Prisma__KbArticleClient<$Result.GetResult<Prisma.$KbArticlePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KbArticle.
     * @param {KbArticleUpdateArgs} args - Arguments to update one KbArticle.
     * @example
     * // Update one KbArticle
     * const kbArticle = await prisma.kbArticle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KbArticleUpdateArgs>(args: SelectSubset<T, KbArticleUpdateArgs<ExtArgs>>): Prisma__KbArticleClient<$Result.GetResult<Prisma.$KbArticlePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KbArticles.
     * @param {KbArticleDeleteManyArgs} args - Arguments to filter KbArticles to delete.
     * @example
     * // Delete a few KbArticles
     * const { count } = await prisma.kbArticle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KbArticleDeleteManyArgs>(args?: SelectSubset<T, KbArticleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KbArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KbArticleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KbArticles
     * const kbArticle = await prisma.kbArticle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KbArticleUpdateManyArgs>(args: SelectSubset<T, KbArticleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KbArticles and returns the data updated in the database.
     * @param {KbArticleUpdateManyAndReturnArgs} args - Arguments to update many KbArticles.
     * @example
     * // Update many KbArticles
     * const kbArticle = await prisma.kbArticle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KbArticles and only return the `id`
     * const kbArticleWithIdOnly = await prisma.kbArticle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KbArticleUpdateManyAndReturnArgs>(args: SelectSubset<T, KbArticleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KbArticlePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KbArticle.
     * @param {KbArticleUpsertArgs} args - Arguments to update or create a KbArticle.
     * @example
     * // Update or create a KbArticle
     * const kbArticle = await prisma.kbArticle.upsert({
     *   create: {
     *     // ... data to create a KbArticle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KbArticle we want to update
     *   }
     * })
     */
    upsert<T extends KbArticleUpsertArgs>(args: SelectSubset<T, KbArticleUpsertArgs<ExtArgs>>): Prisma__KbArticleClient<$Result.GetResult<Prisma.$KbArticlePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KbArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KbArticleCountArgs} args - Arguments to filter KbArticles to count.
     * @example
     * // Count the number of KbArticles
     * const count = await prisma.kbArticle.count({
     *   where: {
     *     // ... the filter for the KbArticles we want to count
     *   }
     * })
    **/
    count<T extends KbArticleCountArgs>(
      args?: Subset<T, KbArticleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KbArticleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KbArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KbArticleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KbArticleAggregateArgs>(args: Subset<T, KbArticleAggregateArgs>): Prisma.PrismaPromise<GetKbArticleAggregateType<T>>

    /**
     * Group by KbArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KbArticleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KbArticleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KbArticleGroupByArgs['orderBy'] }
        : { orderBy?: KbArticleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KbArticleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKbArticleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KbArticle model
   */
  readonly fields: KbArticleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KbArticle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KbArticleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends KbArticle$authorArgs<ExtArgs> = {}>(args?: Subset<T, KbArticle$authorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    versions<T extends KbArticle$versionsArgs<ExtArgs> = {}>(args?: Subset<T, KbArticle$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KbArticleVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends KbArticle$commentsArgs<ExtArgs> = {}>(args?: Subset<T, KbArticle$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KbArticleCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    currentVersion<T extends KbArticle$currentVersionArgs<ExtArgs> = {}>(args?: Subset<T, KbArticle$currentVersionArgs<ExtArgs>>): Prisma__KbArticleVersionClient<$Result.GetResult<Prisma.$KbArticleVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KbArticle model
   */
  interface KbArticleFieldRefs {
    readonly id: FieldRef<"KbArticle", 'Int'>
    readonly slug: FieldRef<"KbArticle", 'String'>
    readonly title: FieldRef<"KbArticle", 'String'>
    readonly createdAt: FieldRef<"KbArticle", 'DateTime'>
    readonly updatedAt: FieldRef<"KbArticle", 'DateTime'>
    readonly authorId: FieldRef<"KbArticle", 'String'>
    readonly currentVersionId: FieldRef<"KbArticle", 'Int'>
    readonly isPublished: FieldRef<"KbArticle", 'Boolean'>
    readonly tags: FieldRef<"KbArticle", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * KbArticle findUnique
   */
  export type KbArticleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticle
     */
    select?: KbArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticle
     */
    omit?: KbArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleInclude<ExtArgs> | null
    /**
     * Filter, which KbArticle to fetch.
     */
    where: KbArticleWhereUniqueInput
  }

  /**
   * KbArticle findUniqueOrThrow
   */
  export type KbArticleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticle
     */
    select?: KbArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticle
     */
    omit?: KbArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleInclude<ExtArgs> | null
    /**
     * Filter, which KbArticle to fetch.
     */
    where: KbArticleWhereUniqueInput
  }

  /**
   * KbArticle findFirst
   */
  export type KbArticleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticle
     */
    select?: KbArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticle
     */
    omit?: KbArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleInclude<ExtArgs> | null
    /**
     * Filter, which KbArticle to fetch.
     */
    where?: KbArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KbArticles to fetch.
     */
    orderBy?: KbArticleOrderByWithRelationInput | KbArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KbArticles.
     */
    cursor?: KbArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KbArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KbArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KbArticles.
     */
    distinct?: KbArticleScalarFieldEnum | KbArticleScalarFieldEnum[]
  }

  /**
   * KbArticle findFirstOrThrow
   */
  export type KbArticleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticle
     */
    select?: KbArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticle
     */
    omit?: KbArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleInclude<ExtArgs> | null
    /**
     * Filter, which KbArticle to fetch.
     */
    where?: KbArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KbArticles to fetch.
     */
    orderBy?: KbArticleOrderByWithRelationInput | KbArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KbArticles.
     */
    cursor?: KbArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KbArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KbArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KbArticles.
     */
    distinct?: KbArticleScalarFieldEnum | KbArticleScalarFieldEnum[]
  }

  /**
   * KbArticle findMany
   */
  export type KbArticleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticle
     */
    select?: KbArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticle
     */
    omit?: KbArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleInclude<ExtArgs> | null
    /**
     * Filter, which KbArticles to fetch.
     */
    where?: KbArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KbArticles to fetch.
     */
    orderBy?: KbArticleOrderByWithRelationInput | KbArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KbArticles.
     */
    cursor?: KbArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KbArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KbArticles.
     */
    skip?: number
    distinct?: KbArticleScalarFieldEnum | KbArticleScalarFieldEnum[]
  }

  /**
   * KbArticle create
   */
  export type KbArticleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticle
     */
    select?: KbArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticle
     */
    omit?: KbArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleInclude<ExtArgs> | null
    /**
     * The data needed to create a KbArticle.
     */
    data: XOR<KbArticleCreateInput, KbArticleUncheckedCreateInput>
  }

  /**
   * KbArticle createMany
   */
  export type KbArticleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KbArticles.
     */
    data: KbArticleCreateManyInput | KbArticleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KbArticle createManyAndReturn
   */
  export type KbArticleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticle
     */
    select?: KbArticleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticle
     */
    omit?: KbArticleOmit<ExtArgs> | null
    /**
     * The data used to create many KbArticles.
     */
    data: KbArticleCreateManyInput | KbArticleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KbArticle update
   */
  export type KbArticleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticle
     */
    select?: KbArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticle
     */
    omit?: KbArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleInclude<ExtArgs> | null
    /**
     * The data needed to update a KbArticle.
     */
    data: XOR<KbArticleUpdateInput, KbArticleUncheckedUpdateInput>
    /**
     * Choose, which KbArticle to update.
     */
    where: KbArticleWhereUniqueInput
  }

  /**
   * KbArticle updateMany
   */
  export type KbArticleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KbArticles.
     */
    data: XOR<KbArticleUpdateManyMutationInput, KbArticleUncheckedUpdateManyInput>
    /**
     * Filter which KbArticles to update
     */
    where?: KbArticleWhereInput
    /**
     * Limit how many KbArticles to update.
     */
    limit?: number
  }

  /**
   * KbArticle updateManyAndReturn
   */
  export type KbArticleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticle
     */
    select?: KbArticleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticle
     */
    omit?: KbArticleOmit<ExtArgs> | null
    /**
     * The data used to update KbArticles.
     */
    data: XOR<KbArticleUpdateManyMutationInput, KbArticleUncheckedUpdateManyInput>
    /**
     * Filter which KbArticles to update
     */
    where?: KbArticleWhereInput
    /**
     * Limit how many KbArticles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KbArticle upsert
   */
  export type KbArticleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticle
     */
    select?: KbArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticle
     */
    omit?: KbArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleInclude<ExtArgs> | null
    /**
     * The filter to search for the KbArticle to update in case it exists.
     */
    where: KbArticleWhereUniqueInput
    /**
     * In case the KbArticle found by the `where` argument doesn't exist, create a new KbArticle with this data.
     */
    create: XOR<KbArticleCreateInput, KbArticleUncheckedCreateInput>
    /**
     * In case the KbArticle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KbArticleUpdateInput, KbArticleUncheckedUpdateInput>
  }

  /**
   * KbArticle delete
   */
  export type KbArticleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticle
     */
    select?: KbArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticle
     */
    omit?: KbArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleInclude<ExtArgs> | null
    /**
     * Filter which KbArticle to delete.
     */
    where: KbArticleWhereUniqueInput
  }

  /**
   * KbArticle deleteMany
   */
  export type KbArticleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KbArticles to delete
     */
    where?: KbArticleWhereInput
    /**
     * Limit how many KbArticles to delete.
     */
    limit?: number
  }

  /**
   * KbArticle.author
   */
  export type KbArticle$authorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * KbArticle.versions
   */
  export type KbArticle$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticleVersion
     */
    select?: KbArticleVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticleVersion
     */
    omit?: KbArticleVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleVersionInclude<ExtArgs> | null
    where?: KbArticleVersionWhereInput
    orderBy?: KbArticleVersionOrderByWithRelationInput | KbArticleVersionOrderByWithRelationInput[]
    cursor?: KbArticleVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KbArticleVersionScalarFieldEnum | KbArticleVersionScalarFieldEnum[]
  }

  /**
   * KbArticle.comments
   */
  export type KbArticle$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticleComment
     */
    select?: KbArticleCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticleComment
     */
    omit?: KbArticleCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleCommentInclude<ExtArgs> | null
    where?: KbArticleCommentWhereInput
    orderBy?: KbArticleCommentOrderByWithRelationInput | KbArticleCommentOrderByWithRelationInput[]
    cursor?: KbArticleCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KbArticleCommentScalarFieldEnum | KbArticleCommentScalarFieldEnum[]
  }

  /**
   * KbArticle.currentVersion
   */
  export type KbArticle$currentVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticleVersion
     */
    select?: KbArticleVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticleVersion
     */
    omit?: KbArticleVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleVersionInclude<ExtArgs> | null
    where?: KbArticleVersionWhereInput
  }

  /**
   * KbArticle without action
   */
  export type KbArticleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticle
     */
    select?: KbArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticle
     */
    omit?: KbArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleInclude<ExtArgs> | null
  }


  /**
   * Model KbArticleVersion
   */

  export type AggregateKbArticleVersion = {
    _count: KbArticleVersionCountAggregateOutputType | null
    _avg: KbArticleVersionAvgAggregateOutputType | null
    _sum: KbArticleVersionSumAggregateOutputType | null
    _min: KbArticleVersionMinAggregateOutputType | null
    _max: KbArticleVersionMaxAggregateOutputType | null
  }

  export type KbArticleVersionAvgAggregateOutputType = {
    id: number | null
    articleId: number | null
    version: number | null
  }

  export type KbArticleVersionSumAggregateOutputType = {
    id: number | null
    articleId: number | null
    version: number | null
  }

  export type KbArticleVersionMinAggregateOutputType = {
    id: number | null
    articleId: number | null
    content: string | null
    summary: string | null
    createdAt: Date | null
    updatedAt: Date | null
    authorId: string | null
    version: number | null
    isApproved: boolean | null
  }

  export type KbArticleVersionMaxAggregateOutputType = {
    id: number | null
    articleId: number | null
    content: string | null
    summary: string | null
    createdAt: Date | null
    updatedAt: Date | null
    authorId: string | null
    version: number | null
    isApproved: boolean | null
  }

  export type KbArticleVersionCountAggregateOutputType = {
    id: number
    articleId: number
    content: number
    summary: number
    createdAt: number
    updatedAt: number
    authorId: number
    version: number
    isApproved: number
    _all: number
  }


  export type KbArticleVersionAvgAggregateInputType = {
    id?: true
    articleId?: true
    version?: true
  }

  export type KbArticleVersionSumAggregateInputType = {
    id?: true
    articleId?: true
    version?: true
  }

  export type KbArticleVersionMinAggregateInputType = {
    id?: true
    articleId?: true
    content?: true
    summary?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
    version?: true
    isApproved?: true
  }

  export type KbArticleVersionMaxAggregateInputType = {
    id?: true
    articleId?: true
    content?: true
    summary?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
    version?: true
    isApproved?: true
  }

  export type KbArticleVersionCountAggregateInputType = {
    id?: true
    articleId?: true
    content?: true
    summary?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
    version?: true
    isApproved?: true
    _all?: true
  }

  export type KbArticleVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KbArticleVersion to aggregate.
     */
    where?: KbArticleVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KbArticleVersions to fetch.
     */
    orderBy?: KbArticleVersionOrderByWithRelationInput | KbArticleVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KbArticleVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KbArticleVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KbArticleVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KbArticleVersions
    **/
    _count?: true | KbArticleVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KbArticleVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KbArticleVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KbArticleVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KbArticleVersionMaxAggregateInputType
  }

  export type GetKbArticleVersionAggregateType<T extends KbArticleVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateKbArticleVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKbArticleVersion[P]>
      : GetScalarType<T[P], AggregateKbArticleVersion[P]>
  }




  export type KbArticleVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KbArticleVersionWhereInput
    orderBy?: KbArticleVersionOrderByWithAggregationInput | KbArticleVersionOrderByWithAggregationInput[]
    by: KbArticleVersionScalarFieldEnum[] | KbArticleVersionScalarFieldEnum
    having?: KbArticleVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KbArticleVersionCountAggregateInputType | true
    _avg?: KbArticleVersionAvgAggregateInputType
    _sum?: KbArticleVersionSumAggregateInputType
    _min?: KbArticleVersionMinAggregateInputType
    _max?: KbArticleVersionMaxAggregateInputType
  }

  export type KbArticleVersionGroupByOutputType = {
    id: number
    articleId: number
    content: string
    summary: string | null
    createdAt: Date
    updatedAt: Date
    authorId: string | null
    version: number
    isApproved: boolean
    _count: KbArticleVersionCountAggregateOutputType | null
    _avg: KbArticleVersionAvgAggregateOutputType | null
    _sum: KbArticleVersionSumAggregateOutputType | null
    _min: KbArticleVersionMinAggregateOutputType | null
    _max: KbArticleVersionMaxAggregateOutputType | null
  }

  type GetKbArticleVersionGroupByPayload<T extends KbArticleVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KbArticleVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KbArticleVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KbArticleVersionGroupByOutputType[P]>
            : GetScalarType<T[P], KbArticleVersionGroupByOutputType[P]>
        }
      >
    >


  export type KbArticleVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    articleId?: boolean
    content?: boolean
    summary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    version?: boolean
    isApproved?: boolean
    article?: boolean | KbArticleDefaultArgs<ExtArgs>
    author?: boolean | KbArticleVersion$authorArgs<ExtArgs>
    currentForArticle?: boolean | KbArticleVersion$currentForArticleArgs<ExtArgs>
    _count?: boolean | KbArticleVersionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kbArticleVersion"]>

  export type KbArticleVersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    articleId?: boolean
    content?: boolean
    summary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    version?: boolean
    isApproved?: boolean
    article?: boolean | KbArticleDefaultArgs<ExtArgs>
    author?: boolean | KbArticleVersion$authorArgs<ExtArgs>
  }, ExtArgs["result"]["kbArticleVersion"]>

  export type KbArticleVersionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    articleId?: boolean
    content?: boolean
    summary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    version?: boolean
    isApproved?: boolean
    article?: boolean | KbArticleDefaultArgs<ExtArgs>
    author?: boolean | KbArticleVersion$authorArgs<ExtArgs>
  }, ExtArgs["result"]["kbArticleVersion"]>

  export type KbArticleVersionSelectScalar = {
    id?: boolean
    articleId?: boolean
    content?: boolean
    summary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    version?: boolean
    isApproved?: boolean
  }

  export type KbArticleVersionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "articleId" | "content" | "summary" | "createdAt" | "updatedAt" | "authorId" | "version" | "isApproved", ExtArgs["result"]["kbArticleVersion"]>
  export type KbArticleVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | KbArticleDefaultArgs<ExtArgs>
    author?: boolean | KbArticleVersion$authorArgs<ExtArgs>
    currentForArticle?: boolean | KbArticleVersion$currentForArticleArgs<ExtArgs>
    _count?: boolean | KbArticleVersionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KbArticleVersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | KbArticleDefaultArgs<ExtArgs>
    author?: boolean | KbArticleVersion$authorArgs<ExtArgs>
  }
  export type KbArticleVersionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | KbArticleDefaultArgs<ExtArgs>
    author?: boolean | KbArticleVersion$authorArgs<ExtArgs>
  }

  export type $KbArticleVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KbArticleVersion"
    objects: {
      article: Prisma.$KbArticlePayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs> | null
      currentForArticle: Prisma.$KbArticlePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      articleId: number
      content: string
      summary: string | null
      createdAt: Date
      updatedAt: Date
      authorId: string | null
      version: number
      isApproved: boolean
    }, ExtArgs["result"]["kbArticleVersion"]>
    composites: {}
  }

  type KbArticleVersionGetPayload<S extends boolean | null | undefined | KbArticleVersionDefaultArgs> = $Result.GetResult<Prisma.$KbArticleVersionPayload, S>

  type KbArticleVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KbArticleVersionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KbArticleVersionCountAggregateInputType | true
    }

  export interface KbArticleVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KbArticleVersion'], meta: { name: 'KbArticleVersion' } }
    /**
     * Find zero or one KbArticleVersion that matches the filter.
     * @param {KbArticleVersionFindUniqueArgs} args - Arguments to find a KbArticleVersion
     * @example
     * // Get one KbArticleVersion
     * const kbArticleVersion = await prisma.kbArticleVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KbArticleVersionFindUniqueArgs>(args: SelectSubset<T, KbArticleVersionFindUniqueArgs<ExtArgs>>): Prisma__KbArticleVersionClient<$Result.GetResult<Prisma.$KbArticleVersionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KbArticleVersion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KbArticleVersionFindUniqueOrThrowArgs} args - Arguments to find a KbArticleVersion
     * @example
     * // Get one KbArticleVersion
     * const kbArticleVersion = await prisma.kbArticleVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KbArticleVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, KbArticleVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KbArticleVersionClient<$Result.GetResult<Prisma.$KbArticleVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KbArticleVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KbArticleVersionFindFirstArgs} args - Arguments to find a KbArticleVersion
     * @example
     * // Get one KbArticleVersion
     * const kbArticleVersion = await prisma.kbArticleVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KbArticleVersionFindFirstArgs>(args?: SelectSubset<T, KbArticleVersionFindFirstArgs<ExtArgs>>): Prisma__KbArticleVersionClient<$Result.GetResult<Prisma.$KbArticleVersionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KbArticleVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KbArticleVersionFindFirstOrThrowArgs} args - Arguments to find a KbArticleVersion
     * @example
     * // Get one KbArticleVersion
     * const kbArticleVersion = await prisma.kbArticleVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KbArticleVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, KbArticleVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__KbArticleVersionClient<$Result.GetResult<Prisma.$KbArticleVersionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KbArticleVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KbArticleVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KbArticleVersions
     * const kbArticleVersions = await prisma.kbArticleVersion.findMany()
     * 
     * // Get first 10 KbArticleVersions
     * const kbArticleVersions = await prisma.kbArticleVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kbArticleVersionWithIdOnly = await prisma.kbArticleVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KbArticleVersionFindManyArgs>(args?: SelectSubset<T, KbArticleVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KbArticleVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KbArticleVersion.
     * @param {KbArticleVersionCreateArgs} args - Arguments to create a KbArticleVersion.
     * @example
     * // Create one KbArticleVersion
     * const KbArticleVersion = await prisma.kbArticleVersion.create({
     *   data: {
     *     // ... data to create a KbArticleVersion
     *   }
     * })
     * 
     */
    create<T extends KbArticleVersionCreateArgs>(args: SelectSubset<T, KbArticleVersionCreateArgs<ExtArgs>>): Prisma__KbArticleVersionClient<$Result.GetResult<Prisma.$KbArticleVersionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KbArticleVersions.
     * @param {KbArticleVersionCreateManyArgs} args - Arguments to create many KbArticleVersions.
     * @example
     * // Create many KbArticleVersions
     * const kbArticleVersion = await prisma.kbArticleVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KbArticleVersionCreateManyArgs>(args?: SelectSubset<T, KbArticleVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KbArticleVersions and returns the data saved in the database.
     * @param {KbArticleVersionCreateManyAndReturnArgs} args - Arguments to create many KbArticleVersions.
     * @example
     * // Create many KbArticleVersions
     * const kbArticleVersion = await prisma.kbArticleVersion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KbArticleVersions and only return the `id`
     * const kbArticleVersionWithIdOnly = await prisma.kbArticleVersion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KbArticleVersionCreateManyAndReturnArgs>(args?: SelectSubset<T, KbArticleVersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KbArticleVersionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KbArticleVersion.
     * @param {KbArticleVersionDeleteArgs} args - Arguments to delete one KbArticleVersion.
     * @example
     * // Delete one KbArticleVersion
     * const KbArticleVersion = await prisma.kbArticleVersion.delete({
     *   where: {
     *     // ... filter to delete one KbArticleVersion
     *   }
     * })
     * 
     */
    delete<T extends KbArticleVersionDeleteArgs>(args: SelectSubset<T, KbArticleVersionDeleteArgs<ExtArgs>>): Prisma__KbArticleVersionClient<$Result.GetResult<Prisma.$KbArticleVersionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KbArticleVersion.
     * @param {KbArticleVersionUpdateArgs} args - Arguments to update one KbArticleVersion.
     * @example
     * // Update one KbArticleVersion
     * const kbArticleVersion = await prisma.kbArticleVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KbArticleVersionUpdateArgs>(args: SelectSubset<T, KbArticleVersionUpdateArgs<ExtArgs>>): Prisma__KbArticleVersionClient<$Result.GetResult<Prisma.$KbArticleVersionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KbArticleVersions.
     * @param {KbArticleVersionDeleteManyArgs} args - Arguments to filter KbArticleVersions to delete.
     * @example
     * // Delete a few KbArticleVersions
     * const { count } = await prisma.kbArticleVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KbArticleVersionDeleteManyArgs>(args?: SelectSubset<T, KbArticleVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KbArticleVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KbArticleVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KbArticleVersions
     * const kbArticleVersion = await prisma.kbArticleVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KbArticleVersionUpdateManyArgs>(args: SelectSubset<T, KbArticleVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KbArticleVersions and returns the data updated in the database.
     * @param {KbArticleVersionUpdateManyAndReturnArgs} args - Arguments to update many KbArticleVersions.
     * @example
     * // Update many KbArticleVersions
     * const kbArticleVersion = await prisma.kbArticleVersion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KbArticleVersions and only return the `id`
     * const kbArticleVersionWithIdOnly = await prisma.kbArticleVersion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KbArticleVersionUpdateManyAndReturnArgs>(args: SelectSubset<T, KbArticleVersionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KbArticleVersionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KbArticleVersion.
     * @param {KbArticleVersionUpsertArgs} args - Arguments to update or create a KbArticleVersion.
     * @example
     * // Update or create a KbArticleVersion
     * const kbArticleVersion = await prisma.kbArticleVersion.upsert({
     *   create: {
     *     // ... data to create a KbArticleVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KbArticleVersion we want to update
     *   }
     * })
     */
    upsert<T extends KbArticleVersionUpsertArgs>(args: SelectSubset<T, KbArticleVersionUpsertArgs<ExtArgs>>): Prisma__KbArticleVersionClient<$Result.GetResult<Prisma.$KbArticleVersionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KbArticleVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KbArticleVersionCountArgs} args - Arguments to filter KbArticleVersions to count.
     * @example
     * // Count the number of KbArticleVersions
     * const count = await prisma.kbArticleVersion.count({
     *   where: {
     *     // ... the filter for the KbArticleVersions we want to count
     *   }
     * })
    **/
    count<T extends KbArticleVersionCountArgs>(
      args?: Subset<T, KbArticleVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KbArticleVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KbArticleVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KbArticleVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KbArticleVersionAggregateArgs>(args: Subset<T, KbArticleVersionAggregateArgs>): Prisma.PrismaPromise<GetKbArticleVersionAggregateType<T>>

    /**
     * Group by KbArticleVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KbArticleVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KbArticleVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KbArticleVersionGroupByArgs['orderBy'] }
        : { orderBy?: KbArticleVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KbArticleVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKbArticleVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KbArticleVersion model
   */
  readonly fields: KbArticleVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KbArticleVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KbArticleVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    article<T extends KbArticleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KbArticleDefaultArgs<ExtArgs>>): Prisma__KbArticleClient<$Result.GetResult<Prisma.$KbArticlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends KbArticleVersion$authorArgs<ExtArgs> = {}>(args?: Subset<T, KbArticleVersion$authorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    currentForArticle<T extends KbArticleVersion$currentForArticleArgs<ExtArgs> = {}>(args?: Subset<T, KbArticleVersion$currentForArticleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KbArticlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KbArticleVersion model
   */
  interface KbArticleVersionFieldRefs {
    readonly id: FieldRef<"KbArticleVersion", 'Int'>
    readonly articleId: FieldRef<"KbArticleVersion", 'Int'>
    readonly content: FieldRef<"KbArticleVersion", 'String'>
    readonly summary: FieldRef<"KbArticleVersion", 'String'>
    readonly createdAt: FieldRef<"KbArticleVersion", 'DateTime'>
    readonly updatedAt: FieldRef<"KbArticleVersion", 'DateTime'>
    readonly authorId: FieldRef<"KbArticleVersion", 'String'>
    readonly version: FieldRef<"KbArticleVersion", 'Int'>
    readonly isApproved: FieldRef<"KbArticleVersion", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * KbArticleVersion findUnique
   */
  export type KbArticleVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticleVersion
     */
    select?: KbArticleVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticleVersion
     */
    omit?: KbArticleVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleVersionInclude<ExtArgs> | null
    /**
     * Filter, which KbArticleVersion to fetch.
     */
    where: KbArticleVersionWhereUniqueInput
  }

  /**
   * KbArticleVersion findUniqueOrThrow
   */
  export type KbArticleVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticleVersion
     */
    select?: KbArticleVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticleVersion
     */
    omit?: KbArticleVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleVersionInclude<ExtArgs> | null
    /**
     * Filter, which KbArticleVersion to fetch.
     */
    where: KbArticleVersionWhereUniqueInput
  }

  /**
   * KbArticleVersion findFirst
   */
  export type KbArticleVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticleVersion
     */
    select?: KbArticleVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticleVersion
     */
    omit?: KbArticleVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleVersionInclude<ExtArgs> | null
    /**
     * Filter, which KbArticleVersion to fetch.
     */
    where?: KbArticleVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KbArticleVersions to fetch.
     */
    orderBy?: KbArticleVersionOrderByWithRelationInput | KbArticleVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KbArticleVersions.
     */
    cursor?: KbArticleVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KbArticleVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KbArticleVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KbArticleVersions.
     */
    distinct?: KbArticleVersionScalarFieldEnum | KbArticleVersionScalarFieldEnum[]
  }

  /**
   * KbArticleVersion findFirstOrThrow
   */
  export type KbArticleVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticleVersion
     */
    select?: KbArticleVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticleVersion
     */
    omit?: KbArticleVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleVersionInclude<ExtArgs> | null
    /**
     * Filter, which KbArticleVersion to fetch.
     */
    where?: KbArticleVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KbArticleVersions to fetch.
     */
    orderBy?: KbArticleVersionOrderByWithRelationInput | KbArticleVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KbArticleVersions.
     */
    cursor?: KbArticleVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KbArticleVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KbArticleVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KbArticleVersions.
     */
    distinct?: KbArticleVersionScalarFieldEnum | KbArticleVersionScalarFieldEnum[]
  }

  /**
   * KbArticleVersion findMany
   */
  export type KbArticleVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticleVersion
     */
    select?: KbArticleVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticleVersion
     */
    omit?: KbArticleVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleVersionInclude<ExtArgs> | null
    /**
     * Filter, which KbArticleVersions to fetch.
     */
    where?: KbArticleVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KbArticleVersions to fetch.
     */
    orderBy?: KbArticleVersionOrderByWithRelationInput | KbArticleVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KbArticleVersions.
     */
    cursor?: KbArticleVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KbArticleVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KbArticleVersions.
     */
    skip?: number
    distinct?: KbArticleVersionScalarFieldEnum | KbArticleVersionScalarFieldEnum[]
  }

  /**
   * KbArticleVersion create
   */
  export type KbArticleVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticleVersion
     */
    select?: KbArticleVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticleVersion
     */
    omit?: KbArticleVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a KbArticleVersion.
     */
    data: XOR<KbArticleVersionCreateInput, KbArticleVersionUncheckedCreateInput>
  }

  /**
   * KbArticleVersion createMany
   */
  export type KbArticleVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KbArticleVersions.
     */
    data: KbArticleVersionCreateManyInput | KbArticleVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KbArticleVersion createManyAndReturn
   */
  export type KbArticleVersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticleVersion
     */
    select?: KbArticleVersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticleVersion
     */
    omit?: KbArticleVersionOmit<ExtArgs> | null
    /**
     * The data used to create many KbArticleVersions.
     */
    data: KbArticleVersionCreateManyInput | KbArticleVersionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleVersionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KbArticleVersion update
   */
  export type KbArticleVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticleVersion
     */
    select?: KbArticleVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticleVersion
     */
    omit?: KbArticleVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a KbArticleVersion.
     */
    data: XOR<KbArticleVersionUpdateInput, KbArticleVersionUncheckedUpdateInput>
    /**
     * Choose, which KbArticleVersion to update.
     */
    where: KbArticleVersionWhereUniqueInput
  }

  /**
   * KbArticleVersion updateMany
   */
  export type KbArticleVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KbArticleVersions.
     */
    data: XOR<KbArticleVersionUpdateManyMutationInput, KbArticleVersionUncheckedUpdateManyInput>
    /**
     * Filter which KbArticleVersions to update
     */
    where?: KbArticleVersionWhereInput
    /**
     * Limit how many KbArticleVersions to update.
     */
    limit?: number
  }

  /**
   * KbArticleVersion updateManyAndReturn
   */
  export type KbArticleVersionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticleVersion
     */
    select?: KbArticleVersionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticleVersion
     */
    omit?: KbArticleVersionOmit<ExtArgs> | null
    /**
     * The data used to update KbArticleVersions.
     */
    data: XOR<KbArticleVersionUpdateManyMutationInput, KbArticleVersionUncheckedUpdateManyInput>
    /**
     * Filter which KbArticleVersions to update
     */
    where?: KbArticleVersionWhereInput
    /**
     * Limit how many KbArticleVersions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleVersionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KbArticleVersion upsert
   */
  export type KbArticleVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticleVersion
     */
    select?: KbArticleVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticleVersion
     */
    omit?: KbArticleVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the KbArticleVersion to update in case it exists.
     */
    where: KbArticleVersionWhereUniqueInput
    /**
     * In case the KbArticleVersion found by the `where` argument doesn't exist, create a new KbArticleVersion with this data.
     */
    create: XOR<KbArticleVersionCreateInput, KbArticleVersionUncheckedCreateInput>
    /**
     * In case the KbArticleVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KbArticleVersionUpdateInput, KbArticleVersionUncheckedUpdateInput>
  }

  /**
   * KbArticleVersion delete
   */
  export type KbArticleVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticleVersion
     */
    select?: KbArticleVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticleVersion
     */
    omit?: KbArticleVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleVersionInclude<ExtArgs> | null
    /**
     * Filter which KbArticleVersion to delete.
     */
    where: KbArticleVersionWhereUniqueInput
  }

  /**
   * KbArticleVersion deleteMany
   */
  export type KbArticleVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KbArticleVersions to delete
     */
    where?: KbArticleVersionWhereInput
    /**
     * Limit how many KbArticleVersions to delete.
     */
    limit?: number
  }

  /**
   * KbArticleVersion.author
   */
  export type KbArticleVersion$authorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * KbArticleVersion.currentForArticle
   */
  export type KbArticleVersion$currentForArticleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticle
     */
    select?: KbArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticle
     */
    omit?: KbArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleInclude<ExtArgs> | null
    where?: KbArticleWhereInput
    orderBy?: KbArticleOrderByWithRelationInput | KbArticleOrderByWithRelationInput[]
    cursor?: KbArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KbArticleScalarFieldEnum | KbArticleScalarFieldEnum[]
  }

  /**
   * KbArticleVersion without action
   */
  export type KbArticleVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticleVersion
     */
    select?: KbArticleVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticleVersion
     */
    omit?: KbArticleVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleVersionInclude<ExtArgs> | null
  }


  /**
   * Model KbArticleComment
   */

  export type AggregateKbArticleComment = {
    _count: KbArticleCommentCountAggregateOutputType | null
    _avg: KbArticleCommentAvgAggregateOutputType | null
    _sum: KbArticleCommentSumAggregateOutputType | null
    _min: KbArticleCommentMinAggregateOutputType | null
    _max: KbArticleCommentMaxAggregateOutputType | null
  }

  export type KbArticleCommentAvgAggregateOutputType = {
    id: number | null
    articleId: number | null
  }

  export type KbArticleCommentSumAggregateOutputType = {
    id: number | null
    articleId: number | null
  }

  export type KbArticleCommentMinAggregateOutputType = {
    id: number | null
    articleId: number | null
    userId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
  }

  export type KbArticleCommentMaxAggregateOutputType = {
    id: number | null
    articleId: number | null
    userId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
  }

  export type KbArticleCommentCountAggregateOutputType = {
    id: number
    articleId: number
    userId: number
    content: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    _all: number
  }


  export type KbArticleCommentAvgAggregateInputType = {
    id?: true
    articleId?: true
  }

  export type KbArticleCommentSumAggregateInputType = {
    id?: true
    articleId?: true
  }

  export type KbArticleCommentMinAggregateInputType = {
    id?: true
    articleId?: true
    userId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
  }

  export type KbArticleCommentMaxAggregateInputType = {
    id?: true
    articleId?: true
    userId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
  }

  export type KbArticleCommentCountAggregateInputType = {
    id?: true
    articleId?: true
    userId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    _all?: true
  }

  export type KbArticleCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KbArticleComment to aggregate.
     */
    where?: KbArticleCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KbArticleComments to fetch.
     */
    orderBy?: KbArticleCommentOrderByWithRelationInput | KbArticleCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KbArticleCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KbArticleComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KbArticleComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KbArticleComments
    **/
    _count?: true | KbArticleCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KbArticleCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KbArticleCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KbArticleCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KbArticleCommentMaxAggregateInputType
  }

  export type GetKbArticleCommentAggregateType<T extends KbArticleCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateKbArticleComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKbArticleComment[P]>
      : GetScalarType<T[P], AggregateKbArticleComment[P]>
  }




  export type KbArticleCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KbArticleCommentWhereInput
    orderBy?: KbArticleCommentOrderByWithAggregationInput | KbArticleCommentOrderByWithAggregationInput[]
    by: KbArticleCommentScalarFieldEnum[] | KbArticleCommentScalarFieldEnum
    having?: KbArticleCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KbArticleCommentCountAggregateInputType | true
    _avg?: KbArticleCommentAvgAggregateInputType
    _sum?: KbArticleCommentSumAggregateInputType
    _min?: KbArticleCommentMinAggregateInputType
    _max?: KbArticleCommentMaxAggregateInputType
  }

  export type KbArticleCommentGroupByOutputType = {
    id: number
    articleId: number
    userId: string
    content: string
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    _count: KbArticleCommentCountAggregateOutputType | null
    _avg: KbArticleCommentAvgAggregateOutputType | null
    _sum: KbArticleCommentSumAggregateOutputType | null
    _min: KbArticleCommentMinAggregateOutputType | null
    _max: KbArticleCommentMaxAggregateOutputType | null
  }

  type GetKbArticleCommentGroupByPayload<T extends KbArticleCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KbArticleCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KbArticleCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KbArticleCommentGroupByOutputType[P]>
            : GetScalarType<T[P], KbArticleCommentGroupByOutputType[P]>
        }
      >
    >


  export type KbArticleCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    articleId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    article?: boolean | KbArticleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kbArticleComment"]>

  export type KbArticleCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    articleId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    article?: boolean | KbArticleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kbArticleComment"]>

  export type KbArticleCommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    articleId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    article?: boolean | KbArticleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kbArticleComment"]>

  export type KbArticleCommentSelectScalar = {
    id?: boolean
    articleId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
  }

  export type KbArticleCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "articleId" | "userId" | "content" | "createdAt" | "updatedAt" | "isDeleted", ExtArgs["result"]["kbArticleComment"]>
  export type KbArticleCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | KbArticleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type KbArticleCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | KbArticleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type KbArticleCommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | KbArticleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $KbArticleCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KbArticleComment"
    objects: {
      article: Prisma.$KbArticlePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      articleId: number
      userId: string
      content: string
      createdAt: Date
      updatedAt: Date
      isDeleted: boolean
    }, ExtArgs["result"]["kbArticleComment"]>
    composites: {}
  }

  type KbArticleCommentGetPayload<S extends boolean | null | undefined | KbArticleCommentDefaultArgs> = $Result.GetResult<Prisma.$KbArticleCommentPayload, S>

  type KbArticleCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KbArticleCommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KbArticleCommentCountAggregateInputType | true
    }

  export interface KbArticleCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KbArticleComment'], meta: { name: 'KbArticleComment' } }
    /**
     * Find zero or one KbArticleComment that matches the filter.
     * @param {KbArticleCommentFindUniqueArgs} args - Arguments to find a KbArticleComment
     * @example
     * // Get one KbArticleComment
     * const kbArticleComment = await prisma.kbArticleComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KbArticleCommentFindUniqueArgs>(args: SelectSubset<T, KbArticleCommentFindUniqueArgs<ExtArgs>>): Prisma__KbArticleCommentClient<$Result.GetResult<Prisma.$KbArticleCommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KbArticleComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KbArticleCommentFindUniqueOrThrowArgs} args - Arguments to find a KbArticleComment
     * @example
     * // Get one KbArticleComment
     * const kbArticleComment = await prisma.kbArticleComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KbArticleCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, KbArticleCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KbArticleCommentClient<$Result.GetResult<Prisma.$KbArticleCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KbArticleComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KbArticleCommentFindFirstArgs} args - Arguments to find a KbArticleComment
     * @example
     * // Get one KbArticleComment
     * const kbArticleComment = await prisma.kbArticleComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KbArticleCommentFindFirstArgs>(args?: SelectSubset<T, KbArticleCommentFindFirstArgs<ExtArgs>>): Prisma__KbArticleCommentClient<$Result.GetResult<Prisma.$KbArticleCommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KbArticleComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KbArticleCommentFindFirstOrThrowArgs} args - Arguments to find a KbArticleComment
     * @example
     * // Get one KbArticleComment
     * const kbArticleComment = await prisma.kbArticleComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KbArticleCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, KbArticleCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__KbArticleCommentClient<$Result.GetResult<Prisma.$KbArticleCommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KbArticleComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KbArticleCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KbArticleComments
     * const kbArticleComments = await prisma.kbArticleComment.findMany()
     * 
     * // Get first 10 KbArticleComments
     * const kbArticleComments = await prisma.kbArticleComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kbArticleCommentWithIdOnly = await prisma.kbArticleComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KbArticleCommentFindManyArgs>(args?: SelectSubset<T, KbArticleCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KbArticleCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KbArticleComment.
     * @param {KbArticleCommentCreateArgs} args - Arguments to create a KbArticleComment.
     * @example
     * // Create one KbArticleComment
     * const KbArticleComment = await prisma.kbArticleComment.create({
     *   data: {
     *     // ... data to create a KbArticleComment
     *   }
     * })
     * 
     */
    create<T extends KbArticleCommentCreateArgs>(args: SelectSubset<T, KbArticleCommentCreateArgs<ExtArgs>>): Prisma__KbArticleCommentClient<$Result.GetResult<Prisma.$KbArticleCommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KbArticleComments.
     * @param {KbArticleCommentCreateManyArgs} args - Arguments to create many KbArticleComments.
     * @example
     * // Create many KbArticleComments
     * const kbArticleComment = await prisma.kbArticleComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KbArticleCommentCreateManyArgs>(args?: SelectSubset<T, KbArticleCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KbArticleComments and returns the data saved in the database.
     * @param {KbArticleCommentCreateManyAndReturnArgs} args - Arguments to create many KbArticleComments.
     * @example
     * // Create many KbArticleComments
     * const kbArticleComment = await prisma.kbArticleComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KbArticleComments and only return the `id`
     * const kbArticleCommentWithIdOnly = await prisma.kbArticleComment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KbArticleCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, KbArticleCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KbArticleCommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KbArticleComment.
     * @param {KbArticleCommentDeleteArgs} args - Arguments to delete one KbArticleComment.
     * @example
     * // Delete one KbArticleComment
     * const KbArticleComment = await prisma.kbArticleComment.delete({
     *   where: {
     *     // ... filter to delete one KbArticleComment
     *   }
     * })
     * 
     */
    delete<T extends KbArticleCommentDeleteArgs>(args: SelectSubset<T, KbArticleCommentDeleteArgs<ExtArgs>>): Prisma__KbArticleCommentClient<$Result.GetResult<Prisma.$KbArticleCommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KbArticleComment.
     * @param {KbArticleCommentUpdateArgs} args - Arguments to update one KbArticleComment.
     * @example
     * // Update one KbArticleComment
     * const kbArticleComment = await prisma.kbArticleComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KbArticleCommentUpdateArgs>(args: SelectSubset<T, KbArticleCommentUpdateArgs<ExtArgs>>): Prisma__KbArticleCommentClient<$Result.GetResult<Prisma.$KbArticleCommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KbArticleComments.
     * @param {KbArticleCommentDeleteManyArgs} args - Arguments to filter KbArticleComments to delete.
     * @example
     * // Delete a few KbArticleComments
     * const { count } = await prisma.kbArticleComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KbArticleCommentDeleteManyArgs>(args?: SelectSubset<T, KbArticleCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KbArticleComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KbArticleCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KbArticleComments
     * const kbArticleComment = await prisma.kbArticleComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KbArticleCommentUpdateManyArgs>(args: SelectSubset<T, KbArticleCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KbArticleComments and returns the data updated in the database.
     * @param {KbArticleCommentUpdateManyAndReturnArgs} args - Arguments to update many KbArticleComments.
     * @example
     * // Update many KbArticleComments
     * const kbArticleComment = await prisma.kbArticleComment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KbArticleComments and only return the `id`
     * const kbArticleCommentWithIdOnly = await prisma.kbArticleComment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KbArticleCommentUpdateManyAndReturnArgs>(args: SelectSubset<T, KbArticleCommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KbArticleCommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KbArticleComment.
     * @param {KbArticleCommentUpsertArgs} args - Arguments to update or create a KbArticleComment.
     * @example
     * // Update or create a KbArticleComment
     * const kbArticleComment = await prisma.kbArticleComment.upsert({
     *   create: {
     *     // ... data to create a KbArticleComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KbArticleComment we want to update
     *   }
     * })
     */
    upsert<T extends KbArticleCommentUpsertArgs>(args: SelectSubset<T, KbArticleCommentUpsertArgs<ExtArgs>>): Prisma__KbArticleCommentClient<$Result.GetResult<Prisma.$KbArticleCommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KbArticleComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KbArticleCommentCountArgs} args - Arguments to filter KbArticleComments to count.
     * @example
     * // Count the number of KbArticleComments
     * const count = await prisma.kbArticleComment.count({
     *   where: {
     *     // ... the filter for the KbArticleComments we want to count
     *   }
     * })
    **/
    count<T extends KbArticleCommentCountArgs>(
      args?: Subset<T, KbArticleCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KbArticleCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KbArticleComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KbArticleCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KbArticleCommentAggregateArgs>(args: Subset<T, KbArticleCommentAggregateArgs>): Prisma.PrismaPromise<GetKbArticleCommentAggregateType<T>>

    /**
     * Group by KbArticleComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KbArticleCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KbArticleCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KbArticleCommentGroupByArgs['orderBy'] }
        : { orderBy?: KbArticleCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KbArticleCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKbArticleCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KbArticleComment model
   */
  readonly fields: KbArticleCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KbArticleComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KbArticleCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    article<T extends KbArticleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KbArticleDefaultArgs<ExtArgs>>): Prisma__KbArticleClient<$Result.GetResult<Prisma.$KbArticlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KbArticleComment model
   */
  interface KbArticleCommentFieldRefs {
    readonly id: FieldRef<"KbArticleComment", 'Int'>
    readonly articleId: FieldRef<"KbArticleComment", 'Int'>
    readonly userId: FieldRef<"KbArticleComment", 'String'>
    readonly content: FieldRef<"KbArticleComment", 'String'>
    readonly createdAt: FieldRef<"KbArticleComment", 'DateTime'>
    readonly updatedAt: FieldRef<"KbArticleComment", 'DateTime'>
    readonly isDeleted: FieldRef<"KbArticleComment", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * KbArticleComment findUnique
   */
  export type KbArticleCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticleComment
     */
    select?: KbArticleCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticleComment
     */
    omit?: KbArticleCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleCommentInclude<ExtArgs> | null
    /**
     * Filter, which KbArticleComment to fetch.
     */
    where: KbArticleCommentWhereUniqueInput
  }

  /**
   * KbArticleComment findUniqueOrThrow
   */
  export type KbArticleCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticleComment
     */
    select?: KbArticleCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticleComment
     */
    omit?: KbArticleCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleCommentInclude<ExtArgs> | null
    /**
     * Filter, which KbArticleComment to fetch.
     */
    where: KbArticleCommentWhereUniqueInput
  }

  /**
   * KbArticleComment findFirst
   */
  export type KbArticleCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticleComment
     */
    select?: KbArticleCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticleComment
     */
    omit?: KbArticleCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleCommentInclude<ExtArgs> | null
    /**
     * Filter, which KbArticleComment to fetch.
     */
    where?: KbArticleCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KbArticleComments to fetch.
     */
    orderBy?: KbArticleCommentOrderByWithRelationInput | KbArticleCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KbArticleComments.
     */
    cursor?: KbArticleCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KbArticleComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KbArticleComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KbArticleComments.
     */
    distinct?: KbArticleCommentScalarFieldEnum | KbArticleCommentScalarFieldEnum[]
  }

  /**
   * KbArticleComment findFirstOrThrow
   */
  export type KbArticleCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticleComment
     */
    select?: KbArticleCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticleComment
     */
    omit?: KbArticleCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleCommentInclude<ExtArgs> | null
    /**
     * Filter, which KbArticleComment to fetch.
     */
    where?: KbArticleCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KbArticleComments to fetch.
     */
    orderBy?: KbArticleCommentOrderByWithRelationInput | KbArticleCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KbArticleComments.
     */
    cursor?: KbArticleCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KbArticleComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KbArticleComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KbArticleComments.
     */
    distinct?: KbArticleCommentScalarFieldEnum | KbArticleCommentScalarFieldEnum[]
  }

  /**
   * KbArticleComment findMany
   */
  export type KbArticleCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticleComment
     */
    select?: KbArticleCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticleComment
     */
    omit?: KbArticleCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleCommentInclude<ExtArgs> | null
    /**
     * Filter, which KbArticleComments to fetch.
     */
    where?: KbArticleCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KbArticleComments to fetch.
     */
    orderBy?: KbArticleCommentOrderByWithRelationInput | KbArticleCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KbArticleComments.
     */
    cursor?: KbArticleCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KbArticleComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KbArticleComments.
     */
    skip?: number
    distinct?: KbArticleCommentScalarFieldEnum | KbArticleCommentScalarFieldEnum[]
  }

  /**
   * KbArticleComment create
   */
  export type KbArticleCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticleComment
     */
    select?: KbArticleCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticleComment
     */
    omit?: KbArticleCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a KbArticleComment.
     */
    data: XOR<KbArticleCommentCreateInput, KbArticleCommentUncheckedCreateInput>
  }

  /**
   * KbArticleComment createMany
   */
  export type KbArticleCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KbArticleComments.
     */
    data: KbArticleCommentCreateManyInput | KbArticleCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KbArticleComment createManyAndReturn
   */
  export type KbArticleCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticleComment
     */
    select?: KbArticleCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticleComment
     */
    omit?: KbArticleCommentOmit<ExtArgs> | null
    /**
     * The data used to create many KbArticleComments.
     */
    data: KbArticleCommentCreateManyInput | KbArticleCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KbArticleComment update
   */
  export type KbArticleCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticleComment
     */
    select?: KbArticleCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticleComment
     */
    omit?: KbArticleCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a KbArticleComment.
     */
    data: XOR<KbArticleCommentUpdateInput, KbArticleCommentUncheckedUpdateInput>
    /**
     * Choose, which KbArticleComment to update.
     */
    where: KbArticleCommentWhereUniqueInput
  }

  /**
   * KbArticleComment updateMany
   */
  export type KbArticleCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KbArticleComments.
     */
    data: XOR<KbArticleCommentUpdateManyMutationInput, KbArticleCommentUncheckedUpdateManyInput>
    /**
     * Filter which KbArticleComments to update
     */
    where?: KbArticleCommentWhereInput
    /**
     * Limit how many KbArticleComments to update.
     */
    limit?: number
  }

  /**
   * KbArticleComment updateManyAndReturn
   */
  export type KbArticleCommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticleComment
     */
    select?: KbArticleCommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticleComment
     */
    omit?: KbArticleCommentOmit<ExtArgs> | null
    /**
     * The data used to update KbArticleComments.
     */
    data: XOR<KbArticleCommentUpdateManyMutationInput, KbArticleCommentUncheckedUpdateManyInput>
    /**
     * Filter which KbArticleComments to update
     */
    where?: KbArticleCommentWhereInput
    /**
     * Limit how many KbArticleComments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleCommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KbArticleComment upsert
   */
  export type KbArticleCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticleComment
     */
    select?: KbArticleCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticleComment
     */
    omit?: KbArticleCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the KbArticleComment to update in case it exists.
     */
    where: KbArticleCommentWhereUniqueInput
    /**
     * In case the KbArticleComment found by the `where` argument doesn't exist, create a new KbArticleComment with this data.
     */
    create: XOR<KbArticleCommentCreateInput, KbArticleCommentUncheckedCreateInput>
    /**
     * In case the KbArticleComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KbArticleCommentUpdateInput, KbArticleCommentUncheckedUpdateInput>
  }

  /**
   * KbArticleComment delete
   */
  export type KbArticleCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticleComment
     */
    select?: KbArticleCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticleComment
     */
    omit?: KbArticleCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleCommentInclude<ExtArgs> | null
    /**
     * Filter which KbArticleComment to delete.
     */
    where: KbArticleCommentWhereUniqueInput
  }

  /**
   * KbArticleComment deleteMany
   */
  export type KbArticleCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KbArticleComments to delete
     */
    where?: KbArticleCommentWhereInput
    /**
     * Limit how many KbArticleComments to delete.
     */
    limit?: number
  }

  /**
   * KbArticleComment without action
   */
  export type KbArticleCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KbArticleComment
     */
    select?: KbArticleCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KbArticleComment
     */
    omit?: KbArticleCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KbArticleCommentInclude<ExtArgs> | null
  }


  /**
   * Model SupportTicket
   */

  export type AggregateSupportTicket = {
    _count: SupportTicketCountAggregateOutputType | null
    _avg: SupportTicketAvgAggregateOutputType | null
    _sum: SupportTicketSumAggregateOutputType | null
    _min: SupportTicketMinAggregateOutputType | null
    _max: SupportTicketMaxAggregateOutputType | null
  }

  export type SupportTicketAvgAggregateOutputType = {
    id: number | null
    vipPriorityScore: number | null
  }

  export type SupportTicketSumAggregateOutputType = {
    id: number | null
    vipPriorityScore: number | null
  }

  export type SupportTicketMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    assigneeId: string | null
    vipPriorityScore: number | null
    vipTriggerSource: string | null
  }

  export type SupportTicketMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    assigneeId: string | null
    vipPriorityScore: number | null
    vipTriggerSource: string | null
  }

  export type SupportTicketCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    createdAt: number
    updatedAt: number
    userId: number
    assigneeId: number
    vipPriorityScore: number
    vipTriggerSource: number
    _all: number
  }


  export type SupportTicketAvgAggregateInputType = {
    id?: true
    vipPriorityScore?: true
  }

  export type SupportTicketSumAggregateInputType = {
    id?: true
    vipPriorityScore?: true
  }

  export type SupportTicketMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    assigneeId?: true
    vipPriorityScore?: true
    vipTriggerSource?: true
  }

  export type SupportTicketMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    assigneeId?: true
    vipPriorityScore?: true
    vipTriggerSource?: true
  }

  export type SupportTicketCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    assigneeId?: true
    vipPriorityScore?: true
    vipTriggerSource?: true
    _all?: true
  }

  export type SupportTicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportTicket to aggregate.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupportTickets
    **/
    _count?: true | SupportTicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupportTicketAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupportTicketSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupportTicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupportTicketMaxAggregateInputType
  }

  export type GetSupportTicketAggregateType<T extends SupportTicketAggregateArgs> = {
        [P in keyof T & keyof AggregateSupportTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupportTicket[P]>
      : GetScalarType<T[P], AggregateSupportTicket[P]>
  }




  export type SupportTicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithAggregationInput | SupportTicketOrderByWithAggregationInput[]
    by: SupportTicketScalarFieldEnum[] | SupportTicketScalarFieldEnum
    having?: SupportTicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupportTicketCountAggregateInputType | true
    _avg?: SupportTicketAvgAggregateInputType
    _sum?: SupportTicketSumAggregateInputType
    _min?: SupportTicketMinAggregateInputType
    _max?: SupportTicketMaxAggregateInputType
  }

  export type SupportTicketGroupByOutputType = {
    id: number
    title: string
    description: string
    status: string
    createdAt: Date
    updatedAt: Date
    userId: string | null
    assigneeId: string | null
    vipPriorityScore: number | null
    vipTriggerSource: string | null
    _count: SupportTicketCountAggregateOutputType | null
    _avg: SupportTicketAvgAggregateOutputType | null
    _sum: SupportTicketSumAggregateOutputType | null
    _min: SupportTicketMinAggregateOutputType | null
    _max: SupportTicketMaxAggregateOutputType | null
  }

  type GetSupportTicketGroupByPayload<T extends SupportTicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupportTicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupportTicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupportTicketGroupByOutputType[P]>
            : GetScalarType<T[P], SupportTicketGroupByOutputType[P]>
        }
      >
    >


  export type SupportTicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    assigneeId?: boolean
    vipPriorityScore?: boolean
    vipTriggerSource?: boolean
    users_support_tickets_assigneeIdTousers?: boolean | SupportTicket$users_support_tickets_assigneeIdTousersArgs<ExtArgs>
    users_support_tickets_userIdTousers?: boolean | SupportTicket$users_support_tickets_userIdTousersArgs<ExtArgs>
    mailroomPackages?: boolean | SupportTicket$mailroomPackagesArgs<ExtArgs>
    assetHistory?: boolean | SupportTicket$assetHistoryArgs<ExtArgs>
    ritms?: boolean | SupportTicket$ritmsArgs<ExtArgs>
    _count?: boolean | SupportTicketCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicket"]>

  export type SupportTicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    assigneeId?: boolean
    vipPriorityScore?: boolean
    vipTriggerSource?: boolean
    users_support_tickets_assigneeIdTousers?: boolean | SupportTicket$users_support_tickets_assigneeIdTousersArgs<ExtArgs>
    users_support_tickets_userIdTousers?: boolean | SupportTicket$users_support_tickets_userIdTousersArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicket"]>

  export type SupportTicketSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    assigneeId?: boolean
    vipPriorityScore?: boolean
    vipTriggerSource?: boolean
    users_support_tickets_assigneeIdTousers?: boolean | SupportTicket$users_support_tickets_assigneeIdTousersArgs<ExtArgs>
    users_support_tickets_userIdTousers?: boolean | SupportTicket$users_support_tickets_userIdTousersArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicket"]>

  export type SupportTicketSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    assigneeId?: boolean
    vipPriorityScore?: boolean
    vipTriggerSource?: boolean
  }

  export type SupportTicketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "status" | "createdAt" | "updatedAt" | "userId" | "assigneeId" | "vipPriorityScore" | "vipTriggerSource", ExtArgs["result"]["supportTicket"]>
  export type SupportTicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_support_tickets_assigneeIdTousers?: boolean | SupportTicket$users_support_tickets_assigneeIdTousersArgs<ExtArgs>
    users_support_tickets_userIdTousers?: boolean | SupportTicket$users_support_tickets_userIdTousersArgs<ExtArgs>
    mailroomPackages?: boolean | SupportTicket$mailroomPackagesArgs<ExtArgs>
    assetHistory?: boolean | SupportTicket$assetHistoryArgs<ExtArgs>
    ritms?: boolean | SupportTicket$ritmsArgs<ExtArgs>
    _count?: boolean | SupportTicketCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SupportTicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_support_tickets_assigneeIdTousers?: boolean | SupportTicket$users_support_tickets_assigneeIdTousersArgs<ExtArgs>
    users_support_tickets_userIdTousers?: boolean | SupportTicket$users_support_tickets_userIdTousersArgs<ExtArgs>
  }
  export type SupportTicketIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_support_tickets_assigneeIdTousers?: boolean | SupportTicket$users_support_tickets_assigneeIdTousersArgs<ExtArgs>
    users_support_tickets_userIdTousers?: boolean | SupportTicket$users_support_tickets_userIdTousersArgs<ExtArgs>
  }

  export type $SupportTicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupportTicket"
    objects: {
      users_support_tickets_assigneeIdTousers: Prisma.$UserPayload<ExtArgs> | null
      users_support_tickets_userIdTousers: Prisma.$UserPayload<ExtArgs> | null
      mailroomPackages: Prisma.$MailroomPackagePayload<ExtArgs>[]
      assetHistory: Prisma.$AssetTicketHistoryPayload<ExtArgs>[]
      ritms: Prisma.$RITMPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string
      status: string
      createdAt: Date
      updatedAt: Date
      userId: string | null
      assigneeId: string | null
      vipPriorityScore: number | null
      vipTriggerSource: string | null
    }, ExtArgs["result"]["supportTicket"]>
    composites: {}
  }

  type SupportTicketGetPayload<S extends boolean | null | undefined | SupportTicketDefaultArgs> = $Result.GetResult<Prisma.$SupportTicketPayload, S>

  type SupportTicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupportTicketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupportTicketCountAggregateInputType | true
    }

  export interface SupportTicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupportTicket'], meta: { name: 'SupportTicket' } }
    /**
     * Find zero or one SupportTicket that matches the filter.
     * @param {SupportTicketFindUniqueArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupportTicketFindUniqueArgs>(args: SelectSubset<T, SupportTicketFindUniqueArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SupportTicket that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupportTicketFindUniqueOrThrowArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupportTicketFindUniqueOrThrowArgs>(args: SelectSubset<T, SupportTicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupportTicket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindFirstArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupportTicketFindFirstArgs>(args?: SelectSubset<T, SupportTicketFindFirstArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupportTicket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindFirstOrThrowArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupportTicketFindFirstOrThrowArgs>(args?: SelectSubset<T, SupportTicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SupportTickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupportTickets
     * const supportTickets = await prisma.supportTicket.findMany()
     * 
     * // Get first 10 SupportTickets
     * const supportTickets = await prisma.supportTicket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupportTicketFindManyArgs>(args?: SelectSubset<T, SupportTicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SupportTicket.
     * @param {SupportTicketCreateArgs} args - Arguments to create a SupportTicket.
     * @example
     * // Create one SupportTicket
     * const SupportTicket = await prisma.supportTicket.create({
     *   data: {
     *     // ... data to create a SupportTicket
     *   }
     * })
     * 
     */
    create<T extends SupportTicketCreateArgs>(args: SelectSubset<T, SupportTicketCreateArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SupportTickets.
     * @param {SupportTicketCreateManyArgs} args - Arguments to create many SupportTickets.
     * @example
     * // Create many SupportTickets
     * const supportTicket = await prisma.supportTicket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupportTicketCreateManyArgs>(args?: SelectSubset<T, SupportTicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupportTickets and returns the data saved in the database.
     * @param {SupportTicketCreateManyAndReturnArgs} args - Arguments to create many SupportTickets.
     * @example
     * // Create many SupportTickets
     * const supportTicket = await prisma.supportTicket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupportTickets and only return the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupportTicketCreateManyAndReturnArgs>(args?: SelectSubset<T, SupportTicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SupportTicket.
     * @param {SupportTicketDeleteArgs} args - Arguments to delete one SupportTicket.
     * @example
     * // Delete one SupportTicket
     * const SupportTicket = await prisma.supportTicket.delete({
     *   where: {
     *     // ... filter to delete one SupportTicket
     *   }
     * })
     * 
     */
    delete<T extends SupportTicketDeleteArgs>(args: SelectSubset<T, SupportTicketDeleteArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SupportTicket.
     * @param {SupportTicketUpdateArgs} args - Arguments to update one SupportTicket.
     * @example
     * // Update one SupportTicket
     * const supportTicket = await prisma.supportTicket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupportTicketUpdateArgs>(args: SelectSubset<T, SupportTicketUpdateArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SupportTickets.
     * @param {SupportTicketDeleteManyArgs} args - Arguments to filter SupportTickets to delete.
     * @example
     * // Delete a few SupportTickets
     * const { count } = await prisma.supportTicket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupportTicketDeleteManyArgs>(args?: SelectSubset<T, SupportTicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupportTickets
     * const supportTicket = await prisma.supportTicket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupportTicketUpdateManyArgs>(args: SelectSubset<T, SupportTicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportTickets and returns the data updated in the database.
     * @param {SupportTicketUpdateManyAndReturnArgs} args - Arguments to update many SupportTickets.
     * @example
     * // Update many SupportTickets
     * const supportTicket = await prisma.supportTicket.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SupportTickets and only return the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupportTicketUpdateManyAndReturnArgs>(args: SelectSubset<T, SupportTicketUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SupportTicket.
     * @param {SupportTicketUpsertArgs} args - Arguments to update or create a SupportTicket.
     * @example
     * // Update or create a SupportTicket
     * const supportTicket = await prisma.supportTicket.upsert({
     *   create: {
     *     // ... data to create a SupportTicket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupportTicket we want to update
     *   }
     * })
     */
    upsert<T extends SupportTicketUpsertArgs>(args: SelectSubset<T, SupportTicketUpsertArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SupportTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketCountArgs} args - Arguments to filter SupportTickets to count.
     * @example
     * // Count the number of SupportTickets
     * const count = await prisma.supportTicket.count({
     *   where: {
     *     // ... the filter for the SupportTickets we want to count
     *   }
     * })
    **/
    count<T extends SupportTicketCountArgs>(
      args?: Subset<T, SupportTicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupportTicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupportTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupportTicketAggregateArgs>(args: Subset<T, SupportTicketAggregateArgs>): Prisma.PrismaPromise<GetSupportTicketAggregateType<T>>

    /**
     * Group by SupportTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupportTicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupportTicketGroupByArgs['orderBy'] }
        : { orderBy?: SupportTicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupportTicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupportTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupportTicket model
   */
  readonly fields: SupportTicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupportTicket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupportTicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_support_tickets_assigneeIdTousers<T extends SupportTicket$users_support_tickets_assigneeIdTousersArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicket$users_support_tickets_assigneeIdTousersArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users_support_tickets_userIdTousers<T extends SupportTicket$users_support_tickets_userIdTousersArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicket$users_support_tickets_userIdTousersArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    mailroomPackages<T extends SupportTicket$mailroomPackagesArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicket$mailroomPackagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MailroomPackagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assetHistory<T extends SupportTicket$assetHistoryArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicket$assetHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetTicketHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ritms<T extends SupportTicket$ritmsArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicket$ritmsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RITMPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupportTicket model
   */
  interface SupportTicketFieldRefs {
    readonly id: FieldRef<"SupportTicket", 'Int'>
    readonly title: FieldRef<"SupportTicket", 'String'>
    readonly description: FieldRef<"SupportTicket", 'String'>
    readonly status: FieldRef<"SupportTicket", 'String'>
    readonly createdAt: FieldRef<"SupportTicket", 'DateTime'>
    readonly updatedAt: FieldRef<"SupportTicket", 'DateTime'>
    readonly userId: FieldRef<"SupportTicket", 'String'>
    readonly assigneeId: FieldRef<"SupportTicket", 'String'>
    readonly vipPriorityScore: FieldRef<"SupportTicket", 'Int'>
    readonly vipTriggerSource: FieldRef<"SupportTicket", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SupportTicket findUnique
   */
  export type SupportTicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket findUniqueOrThrow
   */
  export type SupportTicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket findFirst
   */
  export type SupportTicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportTickets.
     */
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket findFirstOrThrow
   */
  export type SupportTicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportTickets.
     */
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket findMany
   */
  export type SupportTicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTickets to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket create
   */
  export type SupportTicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The data needed to create a SupportTicket.
     */
    data: XOR<SupportTicketCreateInput, SupportTicketUncheckedCreateInput>
  }

  /**
   * SupportTicket createMany
   */
  export type SupportTicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupportTickets.
     */
    data: SupportTicketCreateManyInput | SupportTicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupportTicket createManyAndReturn
   */
  export type SupportTicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * The data used to create many SupportTickets.
     */
    data: SupportTicketCreateManyInput | SupportTicketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupportTicket update
   */
  export type SupportTicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The data needed to update a SupportTicket.
     */
    data: XOR<SupportTicketUpdateInput, SupportTicketUncheckedUpdateInput>
    /**
     * Choose, which SupportTicket to update.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket updateMany
   */
  export type SupportTicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupportTickets.
     */
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyInput>
    /**
     * Filter which SupportTickets to update
     */
    where?: SupportTicketWhereInput
    /**
     * Limit how many SupportTickets to update.
     */
    limit?: number
  }

  /**
   * SupportTicket updateManyAndReturn
   */
  export type SupportTicketUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * The data used to update SupportTickets.
     */
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyInput>
    /**
     * Filter which SupportTickets to update
     */
    where?: SupportTicketWhereInput
    /**
     * Limit how many SupportTickets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupportTicket upsert
   */
  export type SupportTicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The filter to search for the SupportTicket to update in case it exists.
     */
    where: SupportTicketWhereUniqueInput
    /**
     * In case the SupportTicket found by the `where` argument doesn't exist, create a new SupportTicket with this data.
     */
    create: XOR<SupportTicketCreateInput, SupportTicketUncheckedCreateInput>
    /**
     * In case the SupportTicket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupportTicketUpdateInput, SupportTicketUncheckedUpdateInput>
  }

  /**
   * SupportTicket delete
   */
  export type SupportTicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter which SupportTicket to delete.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket deleteMany
   */
  export type SupportTicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportTickets to delete
     */
    where?: SupportTicketWhereInput
    /**
     * Limit how many SupportTickets to delete.
     */
    limit?: number
  }

  /**
   * SupportTicket.users_support_tickets_assigneeIdTousers
   */
  export type SupportTicket$users_support_tickets_assigneeIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SupportTicket.users_support_tickets_userIdTousers
   */
  export type SupportTicket$users_support_tickets_userIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SupportTicket.mailroomPackages
   */
  export type SupportTicket$mailroomPackagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailroomPackage
     */
    select?: MailroomPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MailroomPackage
     */
    omit?: MailroomPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailroomPackageInclude<ExtArgs> | null
    where?: MailroomPackageWhereInput
    orderBy?: MailroomPackageOrderByWithRelationInput | MailroomPackageOrderByWithRelationInput[]
    cursor?: MailroomPackageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MailroomPackageScalarFieldEnum | MailroomPackageScalarFieldEnum[]
  }

  /**
   * SupportTicket.assetHistory
   */
  export type SupportTicket$assetHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetTicketHistory
     */
    select?: AssetTicketHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetTicketHistory
     */
    omit?: AssetTicketHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetTicketHistoryInclude<ExtArgs> | null
    where?: AssetTicketHistoryWhereInput
    orderBy?: AssetTicketHistoryOrderByWithRelationInput | AssetTicketHistoryOrderByWithRelationInput[]
    cursor?: AssetTicketHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetTicketHistoryScalarFieldEnum | AssetTicketHistoryScalarFieldEnum[]
  }

  /**
   * SupportTicket.ritms
   */
  export type SupportTicket$ritmsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RITM
     */
    select?: RITMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RITM
     */
    omit?: RITMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RITMInclude<ExtArgs> | null
    where?: RITMWhereInput
    orderBy?: RITMOrderByWithRelationInput | RITMOrderByWithRelationInput[]
    cursor?: RITMWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RITMScalarFieldEnum | RITMScalarFieldEnum[]
  }

  /**
   * SupportTicket without action
   */
  export type SupportTicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
  }


  /**
   * Model InventoryAsset
   */

  export type AggregateInventoryAsset = {
    _count: InventoryAssetCountAggregateOutputType | null
    _avg: InventoryAssetAvgAggregateOutputType | null
    _sum: InventoryAssetSumAggregateOutputType | null
    _min: InventoryAssetMinAggregateOutputType | null
    _max: InventoryAssetMaxAggregateOutputType | null
  }

  export type InventoryAssetAvgAggregateOutputType = {
    id: number | null
    typeId: number | null
    vendorId: number | null
    assignedToOrgId: number | null
    assignedToCustomerId: number | null
    locationId: number | null
    warrantyAlertDays: number | null
  }

  export type InventoryAssetSumAggregateOutputType = {
    id: number | null
    typeId: number | null
    vendorId: number | null
    assignedToOrgId: number | null
    assignedToCustomerId: number | null
    locationId: number | null
    warrantyAlertDays: number | null
  }

  export type InventoryAssetMinAggregateOutputType = {
    id: number | null
    assetTag: string | null
    typeId: number | null
    serialNumber: string | null
    model: string | null
    vendorId: number | null
    purchaseDate: Date | null
    warrantyExpiry: Date | null
    assignedToUserId: string | null
    assignedToOrgId: number | null
    assignedToCustomerId: number | null
    department: string | null
    status: string | null
    locationId: number | null
    kioskId: string | null
    notes: string | null
    createdBy: string | null
    updatedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    serialNumberEnc: string | null
    warrantyInfoEnc: string | null
    purchaseInfoEnc: string | null
    maintenanceNotesEnc: string | null
    warrantyAlertDays: number | null
    warrantyAlertEnabled: boolean | null
    lastWarrantyAlertSent: Date | null
    importBatchId: string | null
    importSource: string | null
    importValidated: boolean | null
    validationErrors: string | null
  }

  export type InventoryAssetMaxAggregateOutputType = {
    id: number | null
    assetTag: string | null
    typeId: number | null
    serialNumber: string | null
    model: string | null
    vendorId: number | null
    purchaseDate: Date | null
    warrantyExpiry: Date | null
    assignedToUserId: string | null
    assignedToOrgId: number | null
    assignedToCustomerId: number | null
    department: string | null
    status: string | null
    locationId: number | null
    kioskId: string | null
    notes: string | null
    createdBy: string | null
    updatedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    serialNumberEnc: string | null
    warrantyInfoEnc: string | null
    purchaseInfoEnc: string | null
    maintenanceNotesEnc: string | null
    warrantyAlertDays: number | null
    warrantyAlertEnabled: boolean | null
    lastWarrantyAlertSent: Date | null
    importBatchId: string | null
    importSource: string | null
    importValidated: boolean | null
    validationErrors: string | null
  }

  export type InventoryAssetCountAggregateOutputType = {
    id: number
    assetTag: number
    typeId: number
    serialNumber: number
    model: number
    vendorId: number
    purchaseDate: number
    warrantyExpiry: number
    assignedToUserId: number
    assignedToOrgId: number
    assignedToCustomerId: number
    department: number
    status: number
    locationId: number
    kioskId: number
    customFields: number
    notes: number
    createdBy: number
    updatedBy: number
    createdAt: number
    updatedAt: number
    serialNumberEnc: number
    warrantyInfoEnc: number
    purchaseInfoEnc: number
    maintenanceNotesEnc: number
    warrantyAlertDays: number
    warrantyAlertEnabled: number
    lastWarrantyAlertSent: number
    importBatchId: number
    importSource: number
    importValidated: number
    validationErrors: number
    _all: number
  }


  export type InventoryAssetAvgAggregateInputType = {
    id?: true
    typeId?: true
    vendorId?: true
    assignedToOrgId?: true
    assignedToCustomerId?: true
    locationId?: true
    warrantyAlertDays?: true
  }

  export type InventoryAssetSumAggregateInputType = {
    id?: true
    typeId?: true
    vendorId?: true
    assignedToOrgId?: true
    assignedToCustomerId?: true
    locationId?: true
    warrantyAlertDays?: true
  }

  export type InventoryAssetMinAggregateInputType = {
    id?: true
    assetTag?: true
    typeId?: true
    serialNumber?: true
    model?: true
    vendorId?: true
    purchaseDate?: true
    warrantyExpiry?: true
    assignedToUserId?: true
    assignedToOrgId?: true
    assignedToCustomerId?: true
    department?: true
    status?: true
    locationId?: true
    kioskId?: true
    notes?: true
    createdBy?: true
    updatedBy?: true
    createdAt?: true
    updatedAt?: true
    serialNumberEnc?: true
    warrantyInfoEnc?: true
    purchaseInfoEnc?: true
    maintenanceNotesEnc?: true
    warrantyAlertDays?: true
    warrantyAlertEnabled?: true
    lastWarrantyAlertSent?: true
    importBatchId?: true
    importSource?: true
    importValidated?: true
    validationErrors?: true
  }

  export type InventoryAssetMaxAggregateInputType = {
    id?: true
    assetTag?: true
    typeId?: true
    serialNumber?: true
    model?: true
    vendorId?: true
    purchaseDate?: true
    warrantyExpiry?: true
    assignedToUserId?: true
    assignedToOrgId?: true
    assignedToCustomerId?: true
    department?: true
    status?: true
    locationId?: true
    kioskId?: true
    notes?: true
    createdBy?: true
    updatedBy?: true
    createdAt?: true
    updatedAt?: true
    serialNumberEnc?: true
    warrantyInfoEnc?: true
    purchaseInfoEnc?: true
    maintenanceNotesEnc?: true
    warrantyAlertDays?: true
    warrantyAlertEnabled?: true
    lastWarrantyAlertSent?: true
    importBatchId?: true
    importSource?: true
    importValidated?: true
    validationErrors?: true
  }

  export type InventoryAssetCountAggregateInputType = {
    id?: true
    assetTag?: true
    typeId?: true
    serialNumber?: true
    model?: true
    vendorId?: true
    purchaseDate?: true
    warrantyExpiry?: true
    assignedToUserId?: true
    assignedToOrgId?: true
    assignedToCustomerId?: true
    department?: true
    status?: true
    locationId?: true
    kioskId?: true
    customFields?: true
    notes?: true
    createdBy?: true
    updatedBy?: true
    createdAt?: true
    updatedAt?: true
    serialNumberEnc?: true
    warrantyInfoEnc?: true
    purchaseInfoEnc?: true
    maintenanceNotesEnc?: true
    warrantyAlertDays?: true
    warrantyAlertEnabled?: true
    lastWarrantyAlertSent?: true
    importBatchId?: true
    importSource?: true
    importValidated?: true
    validationErrors?: true
    _all?: true
  }

  export type InventoryAssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryAsset to aggregate.
     */
    where?: InventoryAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryAssets to fetch.
     */
    orderBy?: InventoryAssetOrderByWithRelationInput | InventoryAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryAssets
    **/
    _count?: true | InventoryAssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryAssetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryAssetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryAssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryAssetMaxAggregateInputType
  }

  export type GetInventoryAssetAggregateType<T extends InventoryAssetAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryAsset[P]>
      : GetScalarType<T[P], AggregateInventoryAsset[P]>
  }




  export type InventoryAssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryAssetWhereInput
    orderBy?: InventoryAssetOrderByWithAggregationInput | InventoryAssetOrderByWithAggregationInput[]
    by: InventoryAssetScalarFieldEnum[] | InventoryAssetScalarFieldEnum
    having?: InventoryAssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryAssetCountAggregateInputType | true
    _avg?: InventoryAssetAvgAggregateInputType
    _sum?: InventoryAssetSumAggregateInputType
    _min?: InventoryAssetMinAggregateInputType
    _max?: InventoryAssetMaxAggregateInputType
  }

  export type InventoryAssetGroupByOutputType = {
    id: number
    assetTag: string
    typeId: number | null
    serialNumber: string | null
    model: string | null
    vendorId: number | null
    purchaseDate: Date | null
    warrantyExpiry: Date | null
    assignedToUserId: string | null
    assignedToOrgId: number | null
    assignedToCustomerId: number | null
    department: string | null
    status: string | null
    locationId: number | null
    kioskId: string | null
    customFields: JsonValue | null
    notes: string | null
    createdBy: string | null
    updatedBy: string | null
    createdAt: Date
    updatedAt: Date
    serialNumberEnc: string | null
    warrantyInfoEnc: string | null
    purchaseInfoEnc: string | null
    maintenanceNotesEnc: string | null
    warrantyAlertDays: number | null
    warrantyAlertEnabled: boolean
    lastWarrantyAlertSent: Date | null
    importBatchId: string | null
    importSource: string | null
    importValidated: boolean
    validationErrors: string | null
    _count: InventoryAssetCountAggregateOutputType | null
    _avg: InventoryAssetAvgAggregateOutputType | null
    _sum: InventoryAssetSumAggregateOutputType | null
    _min: InventoryAssetMinAggregateOutputType | null
    _max: InventoryAssetMaxAggregateOutputType | null
  }

  type GetInventoryAssetGroupByPayload<T extends InventoryAssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryAssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryAssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryAssetGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryAssetGroupByOutputType[P]>
        }
      >
    >


  export type InventoryAssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetTag?: boolean
    typeId?: boolean
    serialNumber?: boolean
    model?: boolean
    vendorId?: boolean
    purchaseDate?: boolean
    warrantyExpiry?: boolean
    assignedToUserId?: boolean
    assignedToOrgId?: boolean
    assignedToCustomerId?: boolean
    department?: boolean
    status?: boolean
    locationId?: boolean
    kioskId?: boolean
    customFields?: boolean
    notes?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serialNumberEnc?: boolean
    warrantyInfoEnc?: boolean
    purchaseInfoEnc?: boolean
    maintenanceNotesEnc?: boolean
    warrantyAlertDays?: boolean
    warrantyAlertEnabled?: boolean
    lastWarrantyAlertSent?: boolean
    importBatchId?: boolean
    importSource?: boolean
    importValidated?: boolean
    validationErrors?: boolean
    statusLogs?: boolean | InventoryAsset$statusLogsArgs<ExtArgs>
    assignments?: boolean | InventoryAsset$assignmentsArgs<ExtArgs>
    mailroomPackages?: boolean | InventoryAsset$mailroomPackagesArgs<ExtArgs>
    ticketHistory?: boolean | InventoryAsset$ticketHistoryArgs<ExtArgs>
    warrantyAlerts?: boolean | InventoryAsset$warrantyAlertsArgs<ExtArgs>
    kioskRegistrations?: boolean | InventoryAsset$kioskRegistrationsArgs<ExtArgs>
    validationLogs?: boolean | InventoryAsset$validationLogsArgs<ExtArgs>
    syncFailures?: boolean | InventoryAsset$syncFailuresArgs<ExtArgs>
    importBatch?: boolean | InventoryAsset$importBatchArgs<ExtArgs>
    _count?: boolean | InventoryAssetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryAsset"]>

  export type InventoryAssetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetTag?: boolean
    typeId?: boolean
    serialNumber?: boolean
    model?: boolean
    vendorId?: boolean
    purchaseDate?: boolean
    warrantyExpiry?: boolean
    assignedToUserId?: boolean
    assignedToOrgId?: boolean
    assignedToCustomerId?: boolean
    department?: boolean
    status?: boolean
    locationId?: boolean
    kioskId?: boolean
    customFields?: boolean
    notes?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serialNumberEnc?: boolean
    warrantyInfoEnc?: boolean
    purchaseInfoEnc?: boolean
    maintenanceNotesEnc?: boolean
    warrantyAlertDays?: boolean
    warrantyAlertEnabled?: boolean
    lastWarrantyAlertSent?: boolean
    importBatchId?: boolean
    importSource?: boolean
    importValidated?: boolean
    validationErrors?: boolean
    importBatch?: boolean | InventoryAsset$importBatchArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryAsset"]>

  export type InventoryAssetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetTag?: boolean
    typeId?: boolean
    serialNumber?: boolean
    model?: boolean
    vendorId?: boolean
    purchaseDate?: boolean
    warrantyExpiry?: boolean
    assignedToUserId?: boolean
    assignedToOrgId?: boolean
    assignedToCustomerId?: boolean
    department?: boolean
    status?: boolean
    locationId?: boolean
    kioskId?: boolean
    customFields?: boolean
    notes?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serialNumberEnc?: boolean
    warrantyInfoEnc?: boolean
    purchaseInfoEnc?: boolean
    maintenanceNotesEnc?: boolean
    warrantyAlertDays?: boolean
    warrantyAlertEnabled?: boolean
    lastWarrantyAlertSent?: boolean
    importBatchId?: boolean
    importSource?: boolean
    importValidated?: boolean
    validationErrors?: boolean
    importBatch?: boolean | InventoryAsset$importBatchArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryAsset"]>

  export type InventoryAssetSelectScalar = {
    id?: boolean
    assetTag?: boolean
    typeId?: boolean
    serialNumber?: boolean
    model?: boolean
    vendorId?: boolean
    purchaseDate?: boolean
    warrantyExpiry?: boolean
    assignedToUserId?: boolean
    assignedToOrgId?: boolean
    assignedToCustomerId?: boolean
    department?: boolean
    status?: boolean
    locationId?: boolean
    kioskId?: boolean
    customFields?: boolean
    notes?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serialNumberEnc?: boolean
    warrantyInfoEnc?: boolean
    purchaseInfoEnc?: boolean
    maintenanceNotesEnc?: boolean
    warrantyAlertDays?: boolean
    warrantyAlertEnabled?: boolean
    lastWarrantyAlertSent?: boolean
    importBatchId?: boolean
    importSource?: boolean
    importValidated?: boolean
    validationErrors?: boolean
  }

  export type InventoryAssetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "assetTag" | "typeId" | "serialNumber" | "model" | "vendorId" | "purchaseDate" | "warrantyExpiry" | "assignedToUserId" | "assignedToOrgId" | "assignedToCustomerId" | "department" | "status" | "locationId" | "kioskId" | "customFields" | "notes" | "createdBy" | "updatedBy" | "createdAt" | "updatedAt" | "serialNumberEnc" | "warrantyInfoEnc" | "purchaseInfoEnc" | "maintenanceNotesEnc" | "warrantyAlertDays" | "warrantyAlertEnabled" | "lastWarrantyAlertSent" | "importBatchId" | "importSource" | "importValidated" | "validationErrors", ExtArgs["result"]["inventoryAsset"]>
  export type InventoryAssetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    statusLogs?: boolean | InventoryAsset$statusLogsArgs<ExtArgs>
    assignments?: boolean | InventoryAsset$assignmentsArgs<ExtArgs>
    mailroomPackages?: boolean | InventoryAsset$mailroomPackagesArgs<ExtArgs>
    ticketHistory?: boolean | InventoryAsset$ticketHistoryArgs<ExtArgs>
    warrantyAlerts?: boolean | InventoryAsset$warrantyAlertsArgs<ExtArgs>
    kioskRegistrations?: boolean | InventoryAsset$kioskRegistrationsArgs<ExtArgs>
    validationLogs?: boolean | InventoryAsset$validationLogsArgs<ExtArgs>
    syncFailures?: boolean | InventoryAsset$syncFailuresArgs<ExtArgs>
    importBatch?: boolean | InventoryAsset$importBatchArgs<ExtArgs>
    _count?: boolean | InventoryAssetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InventoryAssetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    importBatch?: boolean | InventoryAsset$importBatchArgs<ExtArgs>
  }
  export type InventoryAssetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    importBatch?: boolean | InventoryAsset$importBatchArgs<ExtArgs>
  }

  export type $InventoryAssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryAsset"
    objects: {
      statusLogs: Prisma.$AssetStatusLogPayload<ExtArgs>[]
      assignments: Prisma.$AssetAssignmentPayload<ExtArgs>[]
      mailroomPackages: Prisma.$MailroomPackagePayload<ExtArgs>[]
      ticketHistory: Prisma.$AssetTicketHistoryPayload<ExtArgs>[]
      warrantyAlerts: Prisma.$AssetWarrantyAlertPayload<ExtArgs>[]
      kioskRegistrations: Prisma.$KioskAssetRegistryPayload<ExtArgs>[]
      validationLogs: Prisma.$AssetValidationLogPayload<ExtArgs>[]
      syncFailures: Prisma.$HelixSyncFailurePayload<ExtArgs>[]
      importBatch: Prisma.$AssetImportBatchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      assetTag: string
      typeId: number | null
      serialNumber: string | null
      model: string | null
      vendorId: number | null
      purchaseDate: Date | null
      warrantyExpiry: Date | null
      assignedToUserId: string | null
      assignedToOrgId: number | null
      assignedToCustomerId: number | null
      department: string | null
      status: string | null
      locationId: number | null
      kioskId: string | null
      customFields: Prisma.JsonValue | null
      notes: string | null
      createdBy: string | null
      updatedBy: string | null
      createdAt: Date
      updatedAt: Date
      serialNumberEnc: string | null
      warrantyInfoEnc: string | null
      purchaseInfoEnc: string | null
      maintenanceNotesEnc: string | null
      warrantyAlertDays: number | null
      warrantyAlertEnabled: boolean
      lastWarrantyAlertSent: Date | null
      importBatchId: string | null
      importSource: string | null
      importValidated: boolean
      validationErrors: string | null
    }, ExtArgs["result"]["inventoryAsset"]>
    composites: {}
  }

  type InventoryAssetGetPayload<S extends boolean | null | undefined | InventoryAssetDefaultArgs> = $Result.GetResult<Prisma.$InventoryAssetPayload, S>

  type InventoryAssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryAssetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryAssetCountAggregateInputType | true
    }

  export interface InventoryAssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryAsset'], meta: { name: 'InventoryAsset' } }
    /**
     * Find zero or one InventoryAsset that matches the filter.
     * @param {InventoryAssetFindUniqueArgs} args - Arguments to find a InventoryAsset
     * @example
     * // Get one InventoryAsset
     * const inventoryAsset = await prisma.inventoryAsset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryAssetFindUniqueArgs>(args: SelectSubset<T, InventoryAssetFindUniqueArgs<ExtArgs>>): Prisma__InventoryAssetClient<$Result.GetResult<Prisma.$InventoryAssetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryAsset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryAssetFindUniqueOrThrowArgs} args - Arguments to find a InventoryAsset
     * @example
     * // Get one InventoryAsset
     * const inventoryAsset = await prisma.inventoryAsset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryAssetFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryAssetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryAssetClient<$Result.GetResult<Prisma.$InventoryAssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryAsset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAssetFindFirstArgs} args - Arguments to find a InventoryAsset
     * @example
     * // Get one InventoryAsset
     * const inventoryAsset = await prisma.inventoryAsset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryAssetFindFirstArgs>(args?: SelectSubset<T, InventoryAssetFindFirstArgs<ExtArgs>>): Prisma__InventoryAssetClient<$Result.GetResult<Prisma.$InventoryAssetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryAsset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAssetFindFirstOrThrowArgs} args - Arguments to find a InventoryAsset
     * @example
     * // Get one InventoryAsset
     * const inventoryAsset = await prisma.inventoryAsset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryAssetFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryAssetFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryAssetClient<$Result.GetResult<Prisma.$InventoryAssetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryAssets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryAssets
     * const inventoryAssets = await prisma.inventoryAsset.findMany()
     * 
     * // Get first 10 InventoryAssets
     * const inventoryAssets = await prisma.inventoryAsset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryAssetWithIdOnly = await prisma.inventoryAsset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryAssetFindManyArgs>(args?: SelectSubset<T, InventoryAssetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryAssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryAsset.
     * @param {InventoryAssetCreateArgs} args - Arguments to create a InventoryAsset.
     * @example
     * // Create one InventoryAsset
     * const InventoryAsset = await prisma.inventoryAsset.create({
     *   data: {
     *     // ... data to create a InventoryAsset
     *   }
     * })
     * 
     */
    create<T extends InventoryAssetCreateArgs>(args: SelectSubset<T, InventoryAssetCreateArgs<ExtArgs>>): Prisma__InventoryAssetClient<$Result.GetResult<Prisma.$InventoryAssetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryAssets.
     * @param {InventoryAssetCreateManyArgs} args - Arguments to create many InventoryAssets.
     * @example
     * // Create many InventoryAssets
     * const inventoryAsset = await prisma.inventoryAsset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryAssetCreateManyArgs>(args?: SelectSubset<T, InventoryAssetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryAssets and returns the data saved in the database.
     * @param {InventoryAssetCreateManyAndReturnArgs} args - Arguments to create many InventoryAssets.
     * @example
     * // Create many InventoryAssets
     * const inventoryAsset = await prisma.inventoryAsset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryAssets and only return the `id`
     * const inventoryAssetWithIdOnly = await prisma.inventoryAsset.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryAssetCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryAssetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryAssetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryAsset.
     * @param {InventoryAssetDeleteArgs} args - Arguments to delete one InventoryAsset.
     * @example
     * // Delete one InventoryAsset
     * const InventoryAsset = await prisma.inventoryAsset.delete({
     *   where: {
     *     // ... filter to delete one InventoryAsset
     *   }
     * })
     * 
     */
    delete<T extends InventoryAssetDeleteArgs>(args: SelectSubset<T, InventoryAssetDeleteArgs<ExtArgs>>): Prisma__InventoryAssetClient<$Result.GetResult<Prisma.$InventoryAssetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryAsset.
     * @param {InventoryAssetUpdateArgs} args - Arguments to update one InventoryAsset.
     * @example
     * // Update one InventoryAsset
     * const inventoryAsset = await prisma.inventoryAsset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryAssetUpdateArgs>(args: SelectSubset<T, InventoryAssetUpdateArgs<ExtArgs>>): Prisma__InventoryAssetClient<$Result.GetResult<Prisma.$InventoryAssetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryAssets.
     * @param {InventoryAssetDeleteManyArgs} args - Arguments to filter InventoryAssets to delete.
     * @example
     * // Delete a few InventoryAssets
     * const { count } = await prisma.inventoryAsset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryAssetDeleteManyArgs>(args?: SelectSubset<T, InventoryAssetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryAssets
     * const inventoryAsset = await prisma.inventoryAsset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryAssetUpdateManyArgs>(args: SelectSubset<T, InventoryAssetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryAssets and returns the data updated in the database.
     * @param {InventoryAssetUpdateManyAndReturnArgs} args - Arguments to update many InventoryAssets.
     * @example
     * // Update many InventoryAssets
     * const inventoryAsset = await prisma.inventoryAsset.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryAssets and only return the `id`
     * const inventoryAssetWithIdOnly = await prisma.inventoryAsset.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryAssetUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryAssetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryAssetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryAsset.
     * @param {InventoryAssetUpsertArgs} args - Arguments to update or create a InventoryAsset.
     * @example
     * // Update or create a InventoryAsset
     * const inventoryAsset = await prisma.inventoryAsset.upsert({
     *   create: {
     *     // ... data to create a InventoryAsset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryAsset we want to update
     *   }
     * })
     */
    upsert<T extends InventoryAssetUpsertArgs>(args: SelectSubset<T, InventoryAssetUpsertArgs<ExtArgs>>): Prisma__InventoryAssetClient<$Result.GetResult<Prisma.$InventoryAssetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAssetCountArgs} args - Arguments to filter InventoryAssets to count.
     * @example
     * // Count the number of InventoryAssets
     * const count = await prisma.inventoryAsset.count({
     *   where: {
     *     // ... the filter for the InventoryAssets we want to count
     *   }
     * })
    **/
    count<T extends InventoryAssetCountArgs>(
      args?: Subset<T, InventoryAssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryAssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAssetAggregateArgs>(args: Subset<T, InventoryAssetAggregateArgs>): Prisma.PrismaPromise<GetInventoryAssetAggregateType<T>>

    /**
     * Group by InventoryAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryAssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryAssetGroupByArgs['orderBy'] }
        : { orderBy?: InventoryAssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryAssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryAsset model
   */
  readonly fields: InventoryAssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryAsset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryAssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    statusLogs<T extends InventoryAsset$statusLogsArgs<ExtArgs> = {}>(args?: Subset<T, InventoryAsset$statusLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetStatusLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignments<T extends InventoryAsset$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, InventoryAsset$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mailroomPackages<T extends InventoryAsset$mailroomPackagesArgs<ExtArgs> = {}>(args?: Subset<T, InventoryAsset$mailroomPackagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MailroomPackagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ticketHistory<T extends InventoryAsset$ticketHistoryArgs<ExtArgs> = {}>(args?: Subset<T, InventoryAsset$ticketHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetTicketHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    warrantyAlerts<T extends InventoryAsset$warrantyAlertsArgs<ExtArgs> = {}>(args?: Subset<T, InventoryAsset$warrantyAlertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetWarrantyAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    kioskRegistrations<T extends InventoryAsset$kioskRegistrationsArgs<ExtArgs> = {}>(args?: Subset<T, InventoryAsset$kioskRegistrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KioskAssetRegistryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    validationLogs<T extends InventoryAsset$validationLogsArgs<ExtArgs> = {}>(args?: Subset<T, InventoryAsset$validationLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetValidationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    syncFailures<T extends InventoryAsset$syncFailuresArgs<ExtArgs> = {}>(args?: Subset<T, InventoryAsset$syncFailuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelixSyncFailurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    importBatch<T extends InventoryAsset$importBatchArgs<ExtArgs> = {}>(args?: Subset<T, InventoryAsset$importBatchArgs<ExtArgs>>): Prisma__AssetImportBatchClient<$Result.GetResult<Prisma.$AssetImportBatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryAsset model
   */
  interface InventoryAssetFieldRefs {
    readonly id: FieldRef<"InventoryAsset", 'Int'>
    readonly assetTag: FieldRef<"InventoryAsset", 'String'>
    readonly typeId: FieldRef<"InventoryAsset", 'Int'>
    readonly serialNumber: FieldRef<"InventoryAsset", 'String'>
    readonly model: FieldRef<"InventoryAsset", 'String'>
    readonly vendorId: FieldRef<"InventoryAsset", 'Int'>
    readonly purchaseDate: FieldRef<"InventoryAsset", 'DateTime'>
    readonly warrantyExpiry: FieldRef<"InventoryAsset", 'DateTime'>
    readonly assignedToUserId: FieldRef<"InventoryAsset", 'String'>
    readonly assignedToOrgId: FieldRef<"InventoryAsset", 'Int'>
    readonly assignedToCustomerId: FieldRef<"InventoryAsset", 'Int'>
    readonly department: FieldRef<"InventoryAsset", 'String'>
    readonly status: FieldRef<"InventoryAsset", 'String'>
    readonly locationId: FieldRef<"InventoryAsset", 'Int'>
    readonly kioskId: FieldRef<"InventoryAsset", 'String'>
    readonly customFields: FieldRef<"InventoryAsset", 'Json'>
    readonly notes: FieldRef<"InventoryAsset", 'String'>
    readonly createdBy: FieldRef<"InventoryAsset", 'String'>
    readonly updatedBy: FieldRef<"InventoryAsset", 'String'>
    readonly createdAt: FieldRef<"InventoryAsset", 'DateTime'>
    readonly updatedAt: FieldRef<"InventoryAsset", 'DateTime'>
    readonly serialNumberEnc: FieldRef<"InventoryAsset", 'String'>
    readonly warrantyInfoEnc: FieldRef<"InventoryAsset", 'String'>
    readonly purchaseInfoEnc: FieldRef<"InventoryAsset", 'String'>
    readonly maintenanceNotesEnc: FieldRef<"InventoryAsset", 'String'>
    readonly warrantyAlertDays: FieldRef<"InventoryAsset", 'Int'>
    readonly warrantyAlertEnabled: FieldRef<"InventoryAsset", 'Boolean'>
    readonly lastWarrantyAlertSent: FieldRef<"InventoryAsset", 'DateTime'>
    readonly importBatchId: FieldRef<"InventoryAsset", 'String'>
    readonly importSource: FieldRef<"InventoryAsset", 'String'>
    readonly importValidated: FieldRef<"InventoryAsset", 'Boolean'>
    readonly validationErrors: FieldRef<"InventoryAsset", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InventoryAsset findUnique
   */
  export type InventoryAssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAsset
     */
    select?: InventoryAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAsset
     */
    omit?: InventoryAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAssetInclude<ExtArgs> | null
    /**
     * Filter, which InventoryAsset to fetch.
     */
    where: InventoryAssetWhereUniqueInput
  }

  /**
   * InventoryAsset findUniqueOrThrow
   */
  export type InventoryAssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAsset
     */
    select?: InventoryAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAsset
     */
    omit?: InventoryAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAssetInclude<ExtArgs> | null
    /**
     * Filter, which InventoryAsset to fetch.
     */
    where: InventoryAssetWhereUniqueInput
  }

  /**
   * InventoryAsset findFirst
   */
  export type InventoryAssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAsset
     */
    select?: InventoryAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAsset
     */
    omit?: InventoryAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAssetInclude<ExtArgs> | null
    /**
     * Filter, which InventoryAsset to fetch.
     */
    where?: InventoryAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryAssets to fetch.
     */
    orderBy?: InventoryAssetOrderByWithRelationInput | InventoryAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryAssets.
     */
    cursor?: InventoryAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryAssets.
     */
    distinct?: InventoryAssetScalarFieldEnum | InventoryAssetScalarFieldEnum[]
  }

  /**
   * InventoryAsset findFirstOrThrow
   */
  export type InventoryAssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAsset
     */
    select?: InventoryAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAsset
     */
    omit?: InventoryAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAssetInclude<ExtArgs> | null
    /**
     * Filter, which InventoryAsset to fetch.
     */
    where?: InventoryAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryAssets to fetch.
     */
    orderBy?: InventoryAssetOrderByWithRelationInput | InventoryAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryAssets.
     */
    cursor?: InventoryAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryAssets.
     */
    distinct?: InventoryAssetScalarFieldEnum | InventoryAssetScalarFieldEnum[]
  }

  /**
   * InventoryAsset findMany
   */
  export type InventoryAssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAsset
     */
    select?: InventoryAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAsset
     */
    omit?: InventoryAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAssetInclude<ExtArgs> | null
    /**
     * Filter, which InventoryAssets to fetch.
     */
    where?: InventoryAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryAssets to fetch.
     */
    orderBy?: InventoryAssetOrderByWithRelationInput | InventoryAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryAssets.
     */
    cursor?: InventoryAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryAssets.
     */
    skip?: number
    distinct?: InventoryAssetScalarFieldEnum | InventoryAssetScalarFieldEnum[]
  }

  /**
   * InventoryAsset create
   */
  export type InventoryAssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAsset
     */
    select?: InventoryAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAsset
     */
    omit?: InventoryAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAssetInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryAsset.
     */
    data: XOR<InventoryAssetCreateInput, InventoryAssetUncheckedCreateInput>
  }

  /**
   * InventoryAsset createMany
   */
  export type InventoryAssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryAssets.
     */
    data: InventoryAssetCreateManyInput | InventoryAssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryAsset createManyAndReturn
   */
  export type InventoryAssetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAsset
     */
    select?: InventoryAssetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAsset
     */
    omit?: InventoryAssetOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryAssets.
     */
    data: InventoryAssetCreateManyInput | InventoryAssetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAssetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryAsset update
   */
  export type InventoryAssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAsset
     */
    select?: InventoryAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAsset
     */
    omit?: InventoryAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAssetInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryAsset.
     */
    data: XOR<InventoryAssetUpdateInput, InventoryAssetUncheckedUpdateInput>
    /**
     * Choose, which InventoryAsset to update.
     */
    where: InventoryAssetWhereUniqueInput
  }

  /**
   * InventoryAsset updateMany
   */
  export type InventoryAssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryAssets.
     */
    data: XOR<InventoryAssetUpdateManyMutationInput, InventoryAssetUncheckedUpdateManyInput>
    /**
     * Filter which InventoryAssets to update
     */
    where?: InventoryAssetWhereInput
    /**
     * Limit how many InventoryAssets to update.
     */
    limit?: number
  }

  /**
   * InventoryAsset updateManyAndReturn
   */
  export type InventoryAssetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAsset
     */
    select?: InventoryAssetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAsset
     */
    omit?: InventoryAssetOmit<ExtArgs> | null
    /**
     * The data used to update InventoryAssets.
     */
    data: XOR<InventoryAssetUpdateManyMutationInput, InventoryAssetUncheckedUpdateManyInput>
    /**
     * Filter which InventoryAssets to update
     */
    where?: InventoryAssetWhereInput
    /**
     * Limit how many InventoryAssets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAssetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryAsset upsert
   */
  export type InventoryAssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAsset
     */
    select?: InventoryAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAsset
     */
    omit?: InventoryAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAssetInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryAsset to update in case it exists.
     */
    where: InventoryAssetWhereUniqueInput
    /**
     * In case the InventoryAsset found by the `where` argument doesn't exist, create a new InventoryAsset with this data.
     */
    create: XOR<InventoryAssetCreateInput, InventoryAssetUncheckedCreateInput>
    /**
     * In case the InventoryAsset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryAssetUpdateInput, InventoryAssetUncheckedUpdateInput>
  }

  /**
   * InventoryAsset delete
   */
  export type InventoryAssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAsset
     */
    select?: InventoryAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAsset
     */
    omit?: InventoryAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAssetInclude<ExtArgs> | null
    /**
     * Filter which InventoryAsset to delete.
     */
    where: InventoryAssetWhereUniqueInput
  }

  /**
   * InventoryAsset deleteMany
   */
  export type InventoryAssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryAssets to delete
     */
    where?: InventoryAssetWhereInput
    /**
     * Limit how many InventoryAssets to delete.
     */
    limit?: number
  }

  /**
   * InventoryAsset.statusLogs
   */
  export type InventoryAsset$statusLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetStatusLog
     */
    select?: AssetStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetStatusLog
     */
    omit?: AssetStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetStatusLogInclude<ExtArgs> | null
    where?: AssetStatusLogWhereInput
    orderBy?: AssetStatusLogOrderByWithRelationInput | AssetStatusLogOrderByWithRelationInput[]
    cursor?: AssetStatusLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetStatusLogScalarFieldEnum | AssetStatusLogScalarFieldEnum[]
  }

  /**
   * InventoryAsset.assignments
   */
  export type InventoryAsset$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAssignment
     */
    select?: AssetAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetAssignment
     */
    omit?: AssetAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAssignmentInclude<ExtArgs> | null
    where?: AssetAssignmentWhereInput
    orderBy?: AssetAssignmentOrderByWithRelationInput | AssetAssignmentOrderByWithRelationInput[]
    cursor?: AssetAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetAssignmentScalarFieldEnum | AssetAssignmentScalarFieldEnum[]
  }

  /**
   * InventoryAsset.mailroomPackages
   */
  export type InventoryAsset$mailroomPackagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailroomPackage
     */
    select?: MailroomPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MailroomPackage
     */
    omit?: MailroomPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailroomPackageInclude<ExtArgs> | null
    where?: MailroomPackageWhereInput
    orderBy?: MailroomPackageOrderByWithRelationInput | MailroomPackageOrderByWithRelationInput[]
    cursor?: MailroomPackageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MailroomPackageScalarFieldEnum | MailroomPackageScalarFieldEnum[]
  }

  /**
   * InventoryAsset.ticketHistory
   */
  export type InventoryAsset$ticketHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetTicketHistory
     */
    select?: AssetTicketHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetTicketHistory
     */
    omit?: AssetTicketHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetTicketHistoryInclude<ExtArgs> | null
    where?: AssetTicketHistoryWhereInput
    orderBy?: AssetTicketHistoryOrderByWithRelationInput | AssetTicketHistoryOrderByWithRelationInput[]
    cursor?: AssetTicketHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetTicketHistoryScalarFieldEnum | AssetTicketHistoryScalarFieldEnum[]
  }

  /**
   * InventoryAsset.warrantyAlerts
   */
  export type InventoryAsset$warrantyAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetWarrantyAlert
     */
    select?: AssetWarrantyAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetWarrantyAlert
     */
    omit?: AssetWarrantyAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetWarrantyAlertInclude<ExtArgs> | null
    where?: AssetWarrantyAlertWhereInput
    orderBy?: AssetWarrantyAlertOrderByWithRelationInput | AssetWarrantyAlertOrderByWithRelationInput[]
    cursor?: AssetWarrantyAlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetWarrantyAlertScalarFieldEnum | AssetWarrantyAlertScalarFieldEnum[]
  }

  /**
   * InventoryAsset.kioskRegistrations
   */
  export type InventoryAsset$kioskRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskAssetRegistry
     */
    select?: KioskAssetRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskAssetRegistry
     */
    omit?: KioskAssetRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskAssetRegistryInclude<ExtArgs> | null
    where?: KioskAssetRegistryWhereInput
    orderBy?: KioskAssetRegistryOrderByWithRelationInput | KioskAssetRegistryOrderByWithRelationInput[]
    cursor?: KioskAssetRegistryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KioskAssetRegistryScalarFieldEnum | KioskAssetRegistryScalarFieldEnum[]
  }

  /**
   * InventoryAsset.validationLogs
   */
  export type InventoryAsset$validationLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetValidationLog
     */
    select?: AssetValidationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetValidationLog
     */
    omit?: AssetValidationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetValidationLogInclude<ExtArgs> | null
    where?: AssetValidationLogWhereInput
    orderBy?: AssetValidationLogOrderByWithRelationInput | AssetValidationLogOrderByWithRelationInput[]
    cursor?: AssetValidationLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetValidationLogScalarFieldEnum | AssetValidationLogScalarFieldEnum[]
  }

  /**
   * InventoryAsset.syncFailures
   */
  export type InventoryAsset$syncFailuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelixSyncFailure
     */
    select?: HelixSyncFailureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelixSyncFailure
     */
    omit?: HelixSyncFailureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelixSyncFailureInclude<ExtArgs> | null
    where?: HelixSyncFailureWhereInput
    orderBy?: HelixSyncFailureOrderByWithRelationInput | HelixSyncFailureOrderByWithRelationInput[]
    cursor?: HelixSyncFailureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HelixSyncFailureScalarFieldEnum | HelixSyncFailureScalarFieldEnum[]
  }

  /**
   * InventoryAsset.importBatch
   */
  export type InventoryAsset$importBatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetImportBatch
     */
    select?: AssetImportBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetImportBatch
     */
    omit?: AssetImportBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetImportBatchInclude<ExtArgs> | null
    where?: AssetImportBatchWhereInput
  }

  /**
   * InventoryAsset without action
   */
  export type InventoryAssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAsset
     */
    select?: InventoryAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAsset
     */
    omit?: InventoryAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAssetInclude<ExtArgs> | null
  }


  /**
   * Model AssetStatusLog
   */

  export type AggregateAssetStatusLog = {
    _count: AssetStatusLogCountAggregateOutputType | null
    _avg: AssetStatusLogAvgAggregateOutputType | null
    _sum: AssetStatusLogSumAggregateOutputType | null
    _min: AssetStatusLogMinAggregateOutputType | null
    _max: AssetStatusLogMaxAggregateOutputType | null
  }

  export type AssetStatusLogAvgAggregateOutputType = {
    id: number | null
    assetId: number | null
  }

  export type AssetStatusLogSumAggregateOutputType = {
    id: number | null
    assetId: number | null
  }

  export type AssetStatusLogMinAggregateOutputType = {
    id: number | null
    assetId: number | null
    previousStatus: string | null
    newStatus: string | null
    changedByUserId: string | null
    notes: string | null
    timestamp: Date | null
  }

  export type AssetStatusLogMaxAggregateOutputType = {
    id: number | null
    assetId: number | null
    previousStatus: string | null
    newStatus: string | null
    changedByUserId: string | null
    notes: string | null
    timestamp: Date | null
  }

  export type AssetStatusLogCountAggregateOutputType = {
    id: number
    assetId: number
    previousStatus: number
    newStatus: number
    changedByUserId: number
    notes: number
    timestamp: number
    _all: number
  }


  export type AssetStatusLogAvgAggregateInputType = {
    id?: true
    assetId?: true
  }

  export type AssetStatusLogSumAggregateInputType = {
    id?: true
    assetId?: true
  }

  export type AssetStatusLogMinAggregateInputType = {
    id?: true
    assetId?: true
    previousStatus?: true
    newStatus?: true
    changedByUserId?: true
    notes?: true
    timestamp?: true
  }

  export type AssetStatusLogMaxAggregateInputType = {
    id?: true
    assetId?: true
    previousStatus?: true
    newStatus?: true
    changedByUserId?: true
    notes?: true
    timestamp?: true
  }

  export type AssetStatusLogCountAggregateInputType = {
    id?: true
    assetId?: true
    previousStatus?: true
    newStatus?: true
    changedByUserId?: true
    notes?: true
    timestamp?: true
    _all?: true
  }

  export type AssetStatusLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetStatusLog to aggregate.
     */
    where?: AssetStatusLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetStatusLogs to fetch.
     */
    orderBy?: AssetStatusLogOrderByWithRelationInput | AssetStatusLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetStatusLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetStatusLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetStatusLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssetStatusLogs
    **/
    _count?: true | AssetStatusLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssetStatusLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssetStatusLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetStatusLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetStatusLogMaxAggregateInputType
  }

  export type GetAssetStatusLogAggregateType<T extends AssetStatusLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAssetStatusLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssetStatusLog[P]>
      : GetScalarType<T[P], AggregateAssetStatusLog[P]>
  }




  export type AssetStatusLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetStatusLogWhereInput
    orderBy?: AssetStatusLogOrderByWithAggregationInput | AssetStatusLogOrderByWithAggregationInput[]
    by: AssetStatusLogScalarFieldEnum[] | AssetStatusLogScalarFieldEnum
    having?: AssetStatusLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetStatusLogCountAggregateInputType | true
    _avg?: AssetStatusLogAvgAggregateInputType
    _sum?: AssetStatusLogSumAggregateInputType
    _min?: AssetStatusLogMinAggregateInputType
    _max?: AssetStatusLogMaxAggregateInputType
  }

  export type AssetStatusLogGroupByOutputType = {
    id: number
    assetId: number
    previousStatus: string | null
    newStatus: string
    changedByUserId: string | null
    notes: string | null
    timestamp: Date
    _count: AssetStatusLogCountAggregateOutputType | null
    _avg: AssetStatusLogAvgAggregateOutputType | null
    _sum: AssetStatusLogSumAggregateOutputType | null
    _min: AssetStatusLogMinAggregateOutputType | null
    _max: AssetStatusLogMaxAggregateOutputType | null
  }

  type GetAssetStatusLogGroupByPayload<T extends AssetStatusLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetStatusLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetStatusLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetStatusLogGroupByOutputType[P]>
            : GetScalarType<T[P], AssetStatusLogGroupByOutputType[P]>
        }
      >
    >


  export type AssetStatusLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetId?: boolean
    previousStatus?: boolean
    newStatus?: boolean
    changedByUserId?: boolean
    notes?: boolean
    timestamp?: boolean
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assetStatusLog"]>

  export type AssetStatusLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetId?: boolean
    previousStatus?: boolean
    newStatus?: boolean
    changedByUserId?: boolean
    notes?: boolean
    timestamp?: boolean
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assetStatusLog"]>

  export type AssetStatusLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetId?: boolean
    previousStatus?: boolean
    newStatus?: boolean
    changedByUserId?: boolean
    notes?: boolean
    timestamp?: boolean
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assetStatusLog"]>

  export type AssetStatusLogSelectScalar = {
    id?: boolean
    assetId?: boolean
    previousStatus?: boolean
    newStatus?: boolean
    changedByUserId?: boolean
    notes?: boolean
    timestamp?: boolean
  }

  export type AssetStatusLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "assetId" | "previousStatus" | "newStatus" | "changedByUserId" | "notes" | "timestamp", ExtArgs["result"]["assetStatusLog"]>
  export type AssetStatusLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
  }
  export type AssetStatusLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
  }
  export type AssetStatusLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
  }

  export type $AssetStatusLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssetStatusLog"
    objects: {
      asset: Prisma.$InventoryAssetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      assetId: number
      previousStatus: string | null
      newStatus: string
      changedByUserId: string | null
      notes: string | null
      timestamp: Date
    }, ExtArgs["result"]["assetStatusLog"]>
    composites: {}
  }

  type AssetStatusLogGetPayload<S extends boolean | null | undefined | AssetStatusLogDefaultArgs> = $Result.GetResult<Prisma.$AssetStatusLogPayload, S>

  type AssetStatusLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssetStatusLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssetStatusLogCountAggregateInputType | true
    }

  export interface AssetStatusLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssetStatusLog'], meta: { name: 'AssetStatusLog' } }
    /**
     * Find zero or one AssetStatusLog that matches the filter.
     * @param {AssetStatusLogFindUniqueArgs} args - Arguments to find a AssetStatusLog
     * @example
     * // Get one AssetStatusLog
     * const assetStatusLog = await prisma.assetStatusLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetStatusLogFindUniqueArgs>(args: SelectSubset<T, AssetStatusLogFindUniqueArgs<ExtArgs>>): Prisma__AssetStatusLogClient<$Result.GetResult<Prisma.$AssetStatusLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AssetStatusLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssetStatusLogFindUniqueOrThrowArgs} args - Arguments to find a AssetStatusLog
     * @example
     * // Get one AssetStatusLog
     * const assetStatusLog = await prisma.assetStatusLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetStatusLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AssetStatusLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssetStatusLogClient<$Result.GetResult<Prisma.$AssetStatusLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssetStatusLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetStatusLogFindFirstArgs} args - Arguments to find a AssetStatusLog
     * @example
     * // Get one AssetStatusLog
     * const assetStatusLog = await prisma.assetStatusLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetStatusLogFindFirstArgs>(args?: SelectSubset<T, AssetStatusLogFindFirstArgs<ExtArgs>>): Prisma__AssetStatusLogClient<$Result.GetResult<Prisma.$AssetStatusLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssetStatusLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetStatusLogFindFirstOrThrowArgs} args - Arguments to find a AssetStatusLog
     * @example
     * // Get one AssetStatusLog
     * const assetStatusLog = await prisma.assetStatusLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetStatusLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AssetStatusLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssetStatusLogClient<$Result.GetResult<Prisma.$AssetStatusLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AssetStatusLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetStatusLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssetStatusLogs
     * const assetStatusLogs = await prisma.assetStatusLog.findMany()
     * 
     * // Get first 10 AssetStatusLogs
     * const assetStatusLogs = await prisma.assetStatusLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetStatusLogWithIdOnly = await prisma.assetStatusLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssetStatusLogFindManyArgs>(args?: SelectSubset<T, AssetStatusLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetStatusLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AssetStatusLog.
     * @param {AssetStatusLogCreateArgs} args - Arguments to create a AssetStatusLog.
     * @example
     * // Create one AssetStatusLog
     * const AssetStatusLog = await prisma.assetStatusLog.create({
     *   data: {
     *     // ... data to create a AssetStatusLog
     *   }
     * })
     * 
     */
    create<T extends AssetStatusLogCreateArgs>(args: SelectSubset<T, AssetStatusLogCreateArgs<ExtArgs>>): Prisma__AssetStatusLogClient<$Result.GetResult<Prisma.$AssetStatusLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AssetStatusLogs.
     * @param {AssetStatusLogCreateManyArgs} args - Arguments to create many AssetStatusLogs.
     * @example
     * // Create many AssetStatusLogs
     * const assetStatusLog = await prisma.assetStatusLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssetStatusLogCreateManyArgs>(args?: SelectSubset<T, AssetStatusLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssetStatusLogs and returns the data saved in the database.
     * @param {AssetStatusLogCreateManyAndReturnArgs} args - Arguments to create many AssetStatusLogs.
     * @example
     * // Create many AssetStatusLogs
     * const assetStatusLog = await prisma.assetStatusLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssetStatusLogs and only return the `id`
     * const assetStatusLogWithIdOnly = await prisma.assetStatusLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssetStatusLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AssetStatusLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetStatusLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AssetStatusLog.
     * @param {AssetStatusLogDeleteArgs} args - Arguments to delete one AssetStatusLog.
     * @example
     * // Delete one AssetStatusLog
     * const AssetStatusLog = await prisma.assetStatusLog.delete({
     *   where: {
     *     // ... filter to delete one AssetStatusLog
     *   }
     * })
     * 
     */
    delete<T extends AssetStatusLogDeleteArgs>(args: SelectSubset<T, AssetStatusLogDeleteArgs<ExtArgs>>): Prisma__AssetStatusLogClient<$Result.GetResult<Prisma.$AssetStatusLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AssetStatusLog.
     * @param {AssetStatusLogUpdateArgs} args - Arguments to update one AssetStatusLog.
     * @example
     * // Update one AssetStatusLog
     * const assetStatusLog = await prisma.assetStatusLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssetStatusLogUpdateArgs>(args: SelectSubset<T, AssetStatusLogUpdateArgs<ExtArgs>>): Prisma__AssetStatusLogClient<$Result.GetResult<Prisma.$AssetStatusLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AssetStatusLogs.
     * @param {AssetStatusLogDeleteManyArgs} args - Arguments to filter AssetStatusLogs to delete.
     * @example
     * // Delete a few AssetStatusLogs
     * const { count } = await prisma.assetStatusLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssetStatusLogDeleteManyArgs>(args?: SelectSubset<T, AssetStatusLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssetStatusLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetStatusLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssetStatusLogs
     * const assetStatusLog = await prisma.assetStatusLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssetStatusLogUpdateManyArgs>(args: SelectSubset<T, AssetStatusLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssetStatusLogs and returns the data updated in the database.
     * @param {AssetStatusLogUpdateManyAndReturnArgs} args - Arguments to update many AssetStatusLogs.
     * @example
     * // Update many AssetStatusLogs
     * const assetStatusLog = await prisma.assetStatusLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AssetStatusLogs and only return the `id`
     * const assetStatusLogWithIdOnly = await prisma.assetStatusLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssetStatusLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AssetStatusLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetStatusLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AssetStatusLog.
     * @param {AssetStatusLogUpsertArgs} args - Arguments to update or create a AssetStatusLog.
     * @example
     * // Update or create a AssetStatusLog
     * const assetStatusLog = await prisma.assetStatusLog.upsert({
     *   create: {
     *     // ... data to create a AssetStatusLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssetStatusLog we want to update
     *   }
     * })
     */
    upsert<T extends AssetStatusLogUpsertArgs>(args: SelectSubset<T, AssetStatusLogUpsertArgs<ExtArgs>>): Prisma__AssetStatusLogClient<$Result.GetResult<Prisma.$AssetStatusLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AssetStatusLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetStatusLogCountArgs} args - Arguments to filter AssetStatusLogs to count.
     * @example
     * // Count the number of AssetStatusLogs
     * const count = await prisma.assetStatusLog.count({
     *   where: {
     *     // ... the filter for the AssetStatusLogs we want to count
     *   }
     * })
    **/
    count<T extends AssetStatusLogCountArgs>(
      args?: Subset<T, AssetStatusLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetStatusLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssetStatusLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetStatusLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetStatusLogAggregateArgs>(args: Subset<T, AssetStatusLogAggregateArgs>): Prisma.PrismaPromise<GetAssetStatusLogAggregateType<T>>

    /**
     * Group by AssetStatusLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetStatusLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetStatusLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetStatusLogGroupByArgs['orderBy'] }
        : { orderBy?: AssetStatusLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetStatusLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetStatusLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssetStatusLog model
   */
  readonly fields: AssetStatusLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssetStatusLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetStatusLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    asset<T extends InventoryAssetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryAssetDefaultArgs<ExtArgs>>): Prisma__InventoryAssetClient<$Result.GetResult<Prisma.$InventoryAssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssetStatusLog model
   */
  interface AssetStatusLogFieldRefs {
    readonly id: FieldRef<"AssetStatusLog", 'Int'>
    readonly assetId: FieldRef<"AssetStatusLog", 'Int'>
    readonly previousStatus: FieldRef<"AssetStatusLog", 'String'>
    readonly newStatus: FieldRef<"AssetStatusLog", 'String'>
    readonly changedByUserId: FieldRef<"AssetStatusLog", 'String'>
    readonly notes: FieldRef<"AssetStatusLog", 'String'>
    readonly timestamp: FieldRef<"AssetStatusLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AssetStatusLog findUnique
   */
  export type AssetStatusLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetStatusLog
     */
    select?: AssetStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetStatusLog
     */
    omit?: AssetStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetStatusLogInclude<ExtArgs> | null
    /**
     * Filter, which AssetStatusLog to fetch.
     */
    where: AssetStatusLogWhereUniqueInput
  }

  /**
   * AssetStatusLog findUniqueOrThrow
   */
  export type AssetStatusLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetStatusLog
     */
    select?: AssetStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetStatusLog
     */
    omit?: AssetStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetStatusLogInclude<ExtArgs> | null
    /**
     * Filter, which AssetStatusLog to fetch.
     */
    where: AssetStatusLogWhereUniqueInput
  }

  /**
   * AssetStatusLog findFirst
   */
  export type AssetStatusLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetStatusLog
     */
    select?: AssetStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetStatusLog
     */
    omit?: AssetStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetStatusLogInclude<ExtArgs> | null
    /**
     * Filter, which AssetStatusLog to fetch.
     */
    where?: AssetStatusLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetStatusLogs to fetch.
     */
    orderBy?: AssetStatusLogOrderByWithRelationInput | AssetStatusLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetStatusLogs.
     */
    cursor?: AssetStatusLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetStatusLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetStatusLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetStatusLogs.
     */
    distinct?: AssetStatusLogScalarFieldEnum | AssetStatusLogScalarFieldEnum[]
  }

  /**
   * AssetStatusLog findFirstOrThrow
   */
  export type AssetStatusLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetStatusLog
     */
    select?: AssetStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetStatusLog
     */
    omit?: AssetStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetStatusLogInclude<ExtArgs> | null
    /**
     * Filter, which AssetStatusLog to fetch.
     */
    where?: AssetStatusLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetStatusLogs to fetch.
     */
    orderBy?: AssetStatusLogOrderByWithRelationInput | AssetStatusLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetStatusLogs.
     */
    cursor?: AssetStatusLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetStatusLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetStatusLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetStatusLogs.
     */
    distinct?: AssetStatusLogScalarFieldEnum | AssetStatusLogScalarFieldEnum[]
  }

  /**
   * AssetStatusLog findMany
   */
  export type AssetStatusLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetStatusLog
     */
    select?: AssetStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetStatusLog
     */
    omit?: AssetStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetStatusLogInclude<ExtArgs> | null
    /**
     * Filter, which AssetStatusLogs to fetch.
     */
    where?: AssetStatusLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetStatusLogs to fetch.
     */
    orderBy?: AssetStatusLogOrderByWithRelationInput | AssetStatusLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssetStatusLogs.
     */
    cursor?: AssetStatusLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetStatusLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetStatusLogs.
     */
    skip?: number
    distinct?: AssetStatusLogScalarFieldEnum | AssetStatusLogScalarFieldEnum[]
  }

  /**
   * AssetStatusLog create
   */
  export type AssetStatusLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetStatusLog
     */
    select?: AssetStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetStatusLog
     */
    omit?: AssetStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetStatusLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AssetStatusLog.
     */
    data: XOR<AssetStatusLogCreateInput, AssetStatusLogUncheckedCreateInput>
  }

  /**
   * AssetStatusLog createMany
   */
  export type AssetStatusLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssetStatusLogs.
     */
    data: AssetStatusLogCreateManyInput | AssetStatusLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssetStatusLog createManyAndReturn
   */
  export type AssetStatusLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetStatusLog
     */
    select?: AssetStatusLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssetStatusLog
     */
    omit?: AssetStatusLogOmit<ExtArgs> | null
    /**
     * The data used to create many AssetStatusLogs.
     */
    data: AssetStatusLogCreateManyInput | AssetStatusLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetStatusLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssetStatusLog update
   */
  export type AssetStatusLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetStatusLog
     */
    select?: AssetStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetStatusLog
     */
    omit?: AssetStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetStatusLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AssetStatusLog.
     */
    data: XOR<AssetStatusLogUpdateInput, AssetStatusLogUncheckedUpdateInput>
    /**
     * Choose, which AssetStatusLog to update.
     */
    where: AssetStatusLogWhereUniqueInput
  }

  /**
   * AssetStatusLog updateMany
   */
  export type AssetStatusLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssetStatusLogs.
     */
    data: XOR<AssetStatusLogUpdateManyMutationInput, AssetStatusLogUncheckedUpdateManyInput>
    /**
     * Filter which AssetStatusLogs to update
     */
    where?: AssetStatusLogWhereInput
    /**
     * Limit how many AssetStatusLogs to update.
     */
    limit?: number
  }

  /**
   * AssetStatusLog updateManyAndReturn
   */
  export type AssetStatusLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetStatusLog
     */
    select?: AssetStatusLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssetStatusLog
     */
    omit?: AssetStatusLogOmit<ExtArgs> | null
    /**
     * The data used to update AssetStatusLogs.
     */
    data: XOR<AssetStatusLogUpdateManyMutationInput, AssetStatusLogUncheckedUpdateManyInput>
    /**
     * Filter which AssetStatusLogs to update
     */
    where?: AssetStatusLogWhereInput
    /**
     * Limit how many AssetStatusLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetStatusLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssetStatusLog upsert
   */
  export type AssetStatusLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetStatusLog
     */
    select?: AssetStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetStatusLog
     */
    omit?: AssetStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetStatusLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AssetStatusLog to update in case it exists.
     */
    where: AssetStatusLogWhereUniqueInput
    /**
     * In case the AssetStatusLog found by the `where` argument doesn't exist, create a new AssetStatusLog with this data.
     */
    create: XOR<AssetStatusLogCreateInput, AssetStatusLogUncheckedCreateInput>
    /**
     * In case the AssetStatusLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetStatusLogUpdateInput, AssetStatusLogUncheckedUpdateInput>
  }

  /**
   * AssetStatusLog delete
   */
  export type AssetStatusLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetStatusLog
     */
    select?: AssetStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetStatusLog
     */
    omit?: AssetStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetStatusLogInclude<ExtArgs> | null
    /**
     * Filter which AssetStatusLog to delete.
     */
    where: AssetStatusLogWhereUniqueInput
  }

  /**
   * AssetStatusLog deleteMany
   */
  export type AssetStatusLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetStatusLogs to delete
     */
    where?: AssetStatusLogWhereInput
    /**
     * Limit how many AssetStatusLogs to delete.
     */
    limit?: number
  }

  /**
   * AssetStatusLog without action
   */
  export type AssetStatusLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetStatusLog
     */
    select?: AssetStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetStatusLog
     */
    omit?: AssetStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetStatusLogInclude<ExtArgs> | null
  }


  /**
   * Model AssetAssignment
   */

  export type AggregateAssetAssignment = {
    _count: AssetAssignmentCountAggregateOutputType | null
    _avg: AssetAssignmentAvgAggregateOutputType | null
    _sum: AssetAssignmentSumAggregateOutputType | null
    _min: AssetAssignmentMinAggregateOutputType | null
    _max: AssetAssignmentMaxAggregateOutputType | null
  }

  export type AssetAssignmentAvgAggregateOutputType = {
    id: number | null
    assetId: number | null
    orgId: number | null
    customerId: number | null
  }

  export type AssetAssignmentSumAggregateOutputType = {
    id: number | null
    assetId: number | null
    orgId: number | null
    customerId: number | null
  }

  export type AssetAssignmentMinAggregateOutputType = {
    id: number | null
    assetId: number | null
    userId: string | null
    orgId: number | null
    customerId: number | null
    assignedBy: string | null
    assignedDate: Date | null
    expectedReturn: Date | null
    returnDate: Date | null
    managerId: string | null
  }

  export type AssetAssignmentMaxAggregateOutputType = {
    id: number | null
    assetId: number | null
    userId: string | null
    orgId: number | null
    customerId: number | null
    assignedBy: string | null
    assignedDate: Date | null
    expectedReturn: Date | null
    returnDate: Date | null
    managerId: string | null
  }

  export type AssetAssignmentCountAggregateOutputType = {
    id: number
    assetId: number
    userId: number
    orgId: number
    customerId: number
    assignedBy: number
    assignedDate: number
    expectedReturn: number
    returnDate: number
    managerId: number
    _all: number
  }


  export type AssetAssignmentAvgAggregateInputType = {
    id?: true
    assetId?: true
    orgId?: true
    customerId?: true
  }

  export type AssetAssignmentSumAggregateInputType = {
    id?: true
    assetId?: true
    orgId?: true
    customerId?: true
  }

  export type AssetAssignmentMinAggregateInputType = {
    id?: true
    assetId?: true
    userId?: true
    orgId?: true
    customerId?: true
    assignedBy?: true
    assignedDate?: true
    expectedReturn?: true
    returnDate?: true
    managerId?: true
  }

  export type AssetAssignmentMaxAggregateInputType = {
    id?: true
    assetId?: true
    userId?: true
    orgId?: true
    customerId?: true
    assignedBy?: true
    assignedDate?: true
    expectedReturn?: true
    returnDate?: true
    managerId?: true
  }

  export type AssetAssignmentCountAggregateInputType = {
    id?: true
    assetId?: true
    userId?: true
    orgId?: true
    customerId?: true
    assignedBy?: true
    assignedDate?: true
    expectedReturn?: true
    returnDate?: true
    managerId?: true
    _all?: true
  }

  export type AssetAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetAssignment to aggregate.
     */
    where?: AssetAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetAssignments to fetch.
     */
    orderBy?: AssetAssignmentOrderByWithRelationInput | AssetAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssetAssignments
    **/
    _count?: true | AssetAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssetAssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssetAssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetAssignmentMaxAggregateInputType
  }

  export type GetAssetAssignmentAggregateType<T extends AssetAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAssetAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssetAssignment[P]>
      : GetScalarType<T[P], AggregateAssetAssignment[P]>
  }




  export type AssetAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetAssignmentWhereInput
    orderBy?: AssetAssignmentOrderByWithAggregationInput | AssetAssignmentOrderByWithAggregationInput[]
    by: AssetAssignmentScalarFieldEnum[] | AssetAssignmentScalarFieldEnum
    having?: AssetAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetAssignmentCountAggregateInputType | true
    _avg?: AssetAssignmentAvgAggregateInputType
    _sum?: AssetAssignmentSumAggregateInputType
    _min?: AssetAssignmentMinAggregateInputType
    _max?: AssetAssignmentMaxAggregateInputType
  }

  export type AssetAssignmentGroupByOutputType = {
    id: number
    assetId: number
    userId: string | null
    orgId: number | null
    customerId: number | null
    assignedBy: string | null
    assignedDate: Date
    expectedReturn: Date | null
    returnDate: Date | null
    managerId: string | null
    _count: AssetAssignmentCountAggregateOutputType | null
    _avg: AssetAssignmentAvgAggregateOutputType | null
    _sum: AssetAssignmentSumAggregateOutputType | null
    _min: AssetAssignmentMinAggregateOutputType | null
    _max: AssetAssignmentMaxAggregateOutputType | null
  }

  type GetAssetAssignmentGroupByPayload<T extends AssetAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], AssetAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type AssetAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetId?: boolean
    userId?: boolean
    orgId?: boolean
    customerId?: boolean
    assignedBy?: boolean
    assignedDate?: boolean
    expectedReturn?: boolean
    returnDate?: boolean
    managerId?: boolean
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assetAssignment"]>

  export type AssetAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetId?: boolean
    userId?: boolean
    orgId?: boolean
    customerId?: boolean
    assignedBy?: boolean
    assignedDate?: boolean
    expectedReturn?: boolean
    returnDate?: boolean
    managerId?: boolean
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assetAssignment"]>

  export type AssetAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetId?: boolean
    userId?: boolean
    orgId?: boolean
    customerId?: boolean
    assignedBy?: boolean
    assignedDate?: boolean
    expectedReturn?: boolean
    returnDate?: boolean
    managerId?: boolean
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assetAssignment"]>

  export type AssetAssignmentSelectScalar = {
    id?: boolean
    assetId?: boolean
    userId?: boolean
    orgId?: boolean
    customerId?: boolean
    assignedBy?: boolean
    assignedDate?: boolean
    expectedReturn?: boolean
    returnDate?: boolean
    managerId?: boolean
  }

  export type AssetAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "assetId" | "userId" | "orgId" | "customerId" | "assignedBy" | "assignedDate" | "expectedReturn" | "returnDate" | "managerId", ExtArgs["result"]["assetAssignment"]>
  export type AssetAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
  }
  export type AssetAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
  }
  export type AssetAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
  }

  export type $AssetAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssetAssignment"
    objects: {
      asset: Prisma.$InventoryAssetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      assetId: number
      userId: string | null
      orgId: number | null
      customerId: number | null
      assignedBy: string | null
      assignedDate: Date
      expectedReturn: Date | null
      returnDate: Date | null
      managerId: string | null
    }, ExtArgs["result"]["assetAssignment"]>
    composites: {}
  }

  type AssetAssignmentGetPayload<S extends boolean | null | undefined | AssetAssignmentDefaultArgs> = $Result.GetResult<Prisma.$AssetAssignmentPayload, S>

  type AssetAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssetAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssetAssignmentCountAggregateInputType | true
    }

  export interface AssetAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssetAssignment'], meta: { name: 'AssetAssignment' } }
    /**
     * Find zero or one AssetAssignment that matches the filter.
     * @param {AssetAssignmentFindUniqueArgs} args - Arguments to find a AssetAssignment
     * @example
     * // Get one AssetAssignment
     * const assetAssignment = await prisma.assetAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetAssignmentFindUniqueArgs>(args: SelectSubset<T, AssetAssignmentFindUniqueArgs<ExtArgs>>): Prisma__AssetAssignmentClient<$Result.GetResult<Prisma.$AssetAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AssetAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssetAssignmentFindUniqueOrThrowArgs} args - Arguments to find a AssetAssignment
     * @example
     * // Get one AssetAssignment
     * const assetAssignment = await prisma.assetAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AssetAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssetAssignmentClient<$Result.GetResult<Prisma.$AssetAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssetAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAssignmentFindFirstArgs} args - Arguments to find a AssetAssignment
     * @example
     * // Get one AssetAssignment
     * const assetAssignment = await prisma.assetAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetAssignmentFindFirstArgs>(args?: SelectSubset<T, AssetAssignmentFindFirstArgs<ExtArgs>>): Prisma__AssetAssignmentClient<$Result.GetResult<Prisma.$AssetAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssetAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAssignmentFindFirstOrThrowArgs} args - Arguments to find a AssetAssignment
     * @example
     * // Get one AssetAssignment
     * const assetAssignment = await prisma.assetAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AssetAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssetAssignmentClient<$Result.GetResult<Prisma.$AssetAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AssetAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssetAssignments
     * const assetAssignments = await prisma.assetAssignment.findMany()
     * 
     * // Get first 10 AssetAssignments
     * const assetAssignments = await prisma.assetAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetAssignmentWithIdOnly = await prisma.assetAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssetAssignmentFindManyArgs>(args?: SelectSubset<T, AssetAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AssetAssignment.
     * @param {AssetAssignmentCreateArgs} args - Arguments to create a AssetAssignment.
     * @example
     * // Create one AssetAssignment
     * const AssetAssignment = await prisma.assetAssignment.create({
     *   data: {
     *     // ... data to create a AssetAssignment
     *   }
     * })
     * 
     */
    create<T extends AssetAssignmentCreateArgs>(args: SelectSubset<T, AssetAssignmentCreateArgs<ExtArgs>>): Prisma__AssetAssignmentClient<$Result.GetResult<Prisma.$AssetAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AssetAssignments.
     * @param {AssetAssignmentCreateManyArgs} args - Arguments to create many AssetAssignments.
     * @example
     * // Create many AssetAssignments
     * const assetAssignment = await prisma.assetAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssetAssignmentCreateManyArgs>(args?: SelectSubset<T, AssetAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssetAssignments and returns the data saved in the database.
     * @param {AssetAssignmentCreateManyAndReturnArgs} args - Arguments to create many AssetAssignments.
     * @example
     * // Create many AssetAssignments
     * const assetAssignment = await prisma.assetAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssetAssignments and only return the `id`
     * const assetAssignmentWithIdOnly = await prisma.assetAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssetAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AssetAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AssetAssignment.
     * @param {AssetAssignmentDeleteArgs} args - Arguments to delete one AssetAssignment.
     * @example
     * // Delete one AssetAssignment
     * const AssetAssignment = await prisma.assetAssignment.delete({
     *   where: {
     *     // ... filter to delete one AssetAssignment
     *   }
     * })
     * 
     */
    delete<T extends AssetAssignmentDeleteArgs>(args: SelectSubset<T, AssetAssignmentDeleteArgs<ExtArgs>>): Prisma__AssetAssignmentClient<$Result.GetResult<Prisma.$AssetAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AssetAssignment.
     * @param {AssetAssignmentUpdateArgs} args - Arguments to update one AssetAssignment.
     * @example
     * // Update one AssetAssignment
     * const assetAssignment = await prisma.assetAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssetAssignmentUpdateArgs>(args: SelectSubset<T, AssetAssignmentUpdateArgs<ExtArgs>>): Prisma__AssetAssignmentClient<$Result.GetResult<Prisma.$AssetAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AssetAssignments.
     * @param {AssetAssignmentDeleteManyArgs} args - Arguments to filter AssetAssignments to delete.
     * @example
     * // Delete a few AssetAssignments
     * const { count } = await prisma.assetAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssetAssignmentDeleteManyArgs>(args?: SelectSubset<T, AssetAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssetAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssetAssignments
     * const assetAssignment = await prisma.assetAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssetAssignmentUpdateManyArgs>(args: SelectSubset<T, AssetAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssetAssignments and returns the data updated in the database.
     * @param {AssetAssignmentUpdateManyAndReturnArgs} args - Arguments to update many AssetAssignments.
     * @example
     * // Update many AssetAssignments
     * const assetAssignment = await prisma.assetAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AssetAssignments and only return the `id`
     * const assetAssignmentWithIdOnly = await prisma.assetAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssetAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AssetAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AssetAssignment.
     * @param {AssetAssignmentUpsertArgs} args - Arguments to update or create a AssetAssignment.
     * @example
     * // Update or create a AssetAssignment
     * const assetAssignment = await prisma.assetAssignment.upsert({
     *   create: {
     *     // ... data to create a AssetAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssetAssignment we want to update
     *   }
     * })
     */
    upsert<T extends AssetAssignmentUpsertArgs>(args: SelectSubset<T, AssetAssignmentUpsertArgs<ExtArgs>>): Prisma__AssetAssignmentClient<$Result.GetResult<Prisma.$AssetAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AssetAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAssignmentCountArgs} args - Arguments to filter AssetAssignments to count.
     * @example
     * // Count the number of AssetAssignments
     * const count = await prisma.assetAssignment.count({
     *   where: {
     *     // ... the filter for the AssetAssignments we want to count
     *   }
     * })
    **/
    count<T extends AssetAssignmentCountArgs>(
      args?: Subset<T, AssetAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssetAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetAssignmentAggregateArgs>(args: Subset<T, AssetAssignmentAggregateArgs>): Prisma.PrismaPromise<GetAssetAssignmentAggregateType<T>>

    /**
     * Group by AssetAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: AssetAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssetAssignment model
   */
  readonly fields: AssetAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssetAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    asset<T extends InventoryAssetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryAssetDefaultArgs<ExtArgs>>): Prisma__InventoryAssetClient<$Result.GetResult<Prisma.$InventoryAssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssetAssignment model
   */
  interface AssetAssignmentFieldRefs {
    readonly id: FieldRef<"AssetAssignment", 'Int'>
    readonly assetId: FieldRef<"AssetAssignment", 'Int'>
    readonly userId: FieldRef<"AssetAssignment", 'String'>
    readonly orgId: FieldRef<"AssetAssignment", 'Int'>
    readonly customerId: FieldRef<"AssetAssignment", 'Int'>
    readonly assignedBy: FieldRef<"AssetAssignment", 'String'>
    readonly assignedDate: FieldRef<"AssetAssignment", 'DateTime'>
    readonly expectedReturn: FieldRef<"AssetAssignment", 'DateTime'>
    readonly returnDate: FieldRef<"AssetAssignment", 'DateTime'>
    readonly managerId: FieldRef<"AssetAssignment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AssetAssignment findUnique
   */
  export type AssetAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAssignment
     */
    select?: AssetAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetAssignment
     */
    omit?: AssetAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which AssetAssignment to fetch.
     */
    where: AssetAssignmentWhereUniqueInput
  }

  /**
   * AssetAssignment findUniqueOrThrow
   */
  export type AssetAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAssignment
     */
    select?: AssetAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetAssignment
     */
    omit?: AssetAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which AssetAssignment to fetch.
     */
    where: AssetAssignmentWhereUniqueInput
  }

  /**
   * AssetAssignment findFirst
   */
  export type AssetAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAssignment
     */
    select?: AssetAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetAssignment
     */
    omit?: AssetAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which AssetAssignment to fetch.
     */
    where?: AssetAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetAssignments to fetch.
     */
    orderBy?: AssetAssignmentOrderByWithRelationInput | AssetAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetAssignments.
     */
    cursor?: AssetAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetAssignments.
     */
    distinct?: AssetAssignmentScalarFieldEnum | AssetAssignmentScalarFieldEnum[]
  }

  /**
   * AssetAssignment findFirstOrThrow
   */
  export type AssetAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAssignment
     */
    select?: AssetAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetAssignment
     */
    omit?: AssetAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which AssetAssignment to fetch.
     */
    where?: AssetAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetAssignments to fetch.
     */
    orderBy?: AssetAssignmentOrderByWithRelationInput | AssetAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetAssignments.
     */
    cursor?: AssetAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetAssignments.
     */
    distinct?: AssetAssignmentScalarFieldEnum | AssetAssignmentScalarFieldEnum[]
  }

  /**
   * AssetAssignment findMany
   */
  export type AssetAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAssignment
     */
    select?: AssetAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetAssignment
     */
    omit?: AssetAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which AssetAssignments to fetch.
     */
    where?: AssetAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetAssignments to fetch.
     */
    orderBy?: AssetAssignmentOrderByWithRelationInput | AssetAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssetAssignments.
     */
    cursor?: AssetAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetAssignments.
     */
    skip?: number
    distinct?: AssetAssignmentScalarFieldEnum | AssetAssignmentScalarFieldEnum[]
  }

  /**
   * AssetAssignment create
   */
  export type AssetAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAssignment
     */
    select?: AssetAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetAssignment
     */
    omit?: AssetAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a AssetAssignment.
     */
    data: XOR<AssetAssignmentCreateInput, AssetAssignmentUncheckedCreateInput>
  }

  /**
   * AssetAssignment createMany
   */
  export type AssetAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssetAssignments.
     */
    data: AssetAssignmentCreateManyInput | AssetAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssetAssignment createManyAndReturn
   */
  export type AssetAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAssignment
     */
    select?: AssetAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssetAssignment
     */
    omit?: AssetAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many AssetAssignments.
     */
    data: AssetAssignmentCreateManyInput | AssetAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssetAssignment update
   */
  export type AssetAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAssignment
     */
    select?: AssetAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetAssignment
     */
    omit?: AssetAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a AssetAssignment.
     */
    data: XOR<AssetAssignmentUpdateInput, AssetAssignmentUncheckedUpdateInput>
    /**
     * Choose, which AssetAssignment to update.
     */
    where: AssetAssignmentWhereUniqueInput
  }

  /**
   * AssetAssignment updateMany
   */
  export type AssetAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssetAssignments.
     */
    data: XOR<AssetAssignmentUpdateManyMutationInput, AssetAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which AssetAssignments to update
     */
    where?: AssetAssignmentWhereInput
    /**
     * Limit how many AssetAssignments to update.
     */
    limit?: number
  }

  /**
   * AssetAssignment updateManyAndReturn
   */
  export type AssetAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAssignment
     */
    select?: AssetAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssetAssignment
     */
    omit?: AssetAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update AssetAssignments.
     */
    data: XOR<AssetAssignmentUpdateManyMutationInput, AssetAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which AssetAssignments to update
     */
    where?: AssetAssignmentWhereInput
    /**
     * Limit how many AssetAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssetAssignment upsert
   */
  export type AssetAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAssignment
     */
    select?: AssetAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetAssignment
     */
    omit?: AssetAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the AssetAssignment to update in case it exists.
     */
    where: AssetAssignmentWhereUniqueInput
    /**
     * In case the AssetAssignment found by the `where` argument doesn't exist, create a new AssetAssignment with this data.
     */
    create: XOR<AssetAssignmentCreateInput, AssetAssignmentUncheckedCreateInput>
    /**
     * In case the AssetAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetAssignmentUpdateInput, AssetAssignmentUncheckedUpdateInput>
  }

  /**
   * AssetAssignment delete
   */
  export type AssetAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAssignment
     */
    select?: AssetAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetAssignment
     */
    omit?: AssetAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAssignmentInclude<ExtArgs> | null
    /**
     * Filter which AssetAssignment to delete.
     */
    where: AssetAssignmentWhereUniqueInput
  }

  /**
   * AssetAssignment deleteMany
   */
  export type AssetAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetAssignments to delete
     */
    where?: AssetAssignmentWhereInput
    /**
     * Limit how many AssetAssignments to delete.
     */
    limit?: number
  }

  /**
   * AssetAssignment without action
   */
  export type AssetAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetAssignment
     */
    select?: AssetAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetAssignment
     */
    omit?: AssetAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model AssetTicketHistory
   */

  export type AggregateAssetTicketHistory = {
    _count: AssetTicketHistoryCountAggregateOutputType | null
    _avg: AssetTicketHistoryAvgAggregateOutputType | null
    _sum: AssetTicketHistorySumAggregateOutputType | null
    _min: AssetTicketHistoryMinAggregateOutputType | null
    _max: AssetTicketHistoryMaxAggregateOutputType | null
  }

  export type AssetTicketHistoryAvgAggregateOutputType = {
    id: number | null
    assetId: number | null
    ticketId: number | null
  }

  export type AssetTicketHistorySumAggregateOutputType = {
    id: number | null
    assetId: number | null
    ticketId: number | null
  }

  export type AssetTicketHistoryMinAggregateOutputType = {
    id: number | null
    assetId: number | null
    ticketId: number | null
    relationshipType: string | null
    createdAt: Date | null
    endedAt: Date | null
    createdBy: string | null
    notes: string | null
  }

  export type AssetTicketHistoryMaxAggregateOutputType = {
    id: number | null
    assetId: number | null
    ticketId: number | null
    relationshipType: string | null
    createdAt: Date | null
    endedAt: Date | null
    createdBy: string | null
    notes: string | null
  }

  export type AssetTicketHistoryCountAggregateOutputType = {
    id: number
    assetId: number
    ticketId: number
    relationshipType: number
    createdAt: number
    endedAt: number
    createdBy: number
    notes: number
    _all: number
  }


  export type AssetTicketHistoryAvgAggregateInputType = {
    id?: true
    assetId?: true
    ticketId?: true
  }

  export type AssetTicketHistorySumAggregateInputType = {
    id?: true
    assetId?: true
    ticketId?: true
  }

  export type AssetTicketHistoryMinAggregateInputType = {
    id?: true
    assetId?: true
    ticketId?: true
    relationshipType?: true
    createdAt?: true
    endedAt?: true
    createdBy?: true
    notes?: true
  }

  export type AssetTicketHistoryMaxAggregateInputType = {
    id?: true
    assetId?: true
    ticketId?: true
    relationshipType?: true
    createdAt?: true
    endedAt?: true
    createdBy?: true
    notes?: true
  }

  export type AssetTicketHistoryCountAggregateInputType = {
    id?: true
    assetId?: true
    ticketId?: true
    relationshipType?: true
    createdAt?: true
    endedAt?: true
    createdBy?: true
    notes?: true
    _all?: true
  }

  export type AssetTicketHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetTicketHistory to aggregate.
     */
    where?: AssetTicketHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetTicketHistories to fetch.
     */
    orderBy?: AssetTicketHistoryOrderByWithRelationInput | AssetTicketHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetTicketHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetTicketHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetTicketHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssetTicketHistories
    **/
    _count?: true | AssetTicketHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssetTicketHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssetTicketHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetTicketHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetTicketHistoryMaxAggregateInputType
  }

  export type GetAssetTicketHistoryAggregateType<T extends AssetTicketHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateAssetTicketHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssetTicketHistory[P]>
      : GetScalarType<T[P], AggregateAssetTicketHistory[P]>
  }




  export type AssetTicketHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetTicketHistoryWhereInput
    orderBy?: AssetTicketHistoryOrderByWithAggregationInput | AssetTicketHistoryOrderByWithAggregationInput[]
    by: AssetTicketHistoryScalarFieldEnum[] | AssetTicketHistoryScalarFieldEnum
    having?: AssetTicketHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetTicketHistoryCountAggregateInputType | true
    _avg?: AssetTicketHistoryAvgAggregateInputType
    _sum?: AssetTicketHistorySumAggregateInputType
    _min?: AssetTicketHistoryMinAggregateInputType
    _max?: AssetTicketHistoryMaxAggregateInputType
  }

  export type AssetTicketHistoryGroupByOutputType = {
    id: number
    assetId: number
    ticketId: number
    relationshipType: string
    createdAt: Date
    endedAt: Date | null
    createdBy: string | null
    notes: string | null
    _count: AssetTicketHistoryCountAggregateOutputType | null
    _avg: AssetTicketHistoryAvgAggregateOutputType | null
    _sum: AssetTicketHistorySumAggregateOutputType | null
    _min: AssetTicketHistoryMinAggregateOutputType | null
    _max: AssetTicketHistoryMaxAggregateOutputType | null
  }

  type GetAssetTicketHistoryGroupByPayload<T extends AssetTicketHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetTicketHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetTicketHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetTicketHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], AssetTicketHistoryGroupByOutputType[P]>
        }
      >
    >


  export type AssetTicketHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetId?: boolean
    ticketId?: boolean
    relationshipType?: boolean
    createdAt?: boolean
    endedAt?: boolean
    createdBy?: boolean
    notes?: boolean
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assetTicketHistory"]>

  export type AssetTicketHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetId?: boolean
    ticketId?: boolean
    relationshipType?: boolean
    createdAt?: boolean
    endedAt?: boolean
    createdBy?: boolean
    notes?: boolean
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assetTicketHistory"]>

  export type AssetTicketHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetId?: boolean
    ticketId?: boolean
    relationshipType?: boolean
    createdAt?: boolean
    endedAt?: boolean
    createdBy?: boolean
    notes?: boolean
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assetTicketHistory"]>

  export type AssetTicketHistorySelectScalar = {
    id?: boolean
    assetId?: boolean
    ticketId?: boolean
    relationshipType?: boolean
    createdAt?: boolean
    endedAt?: boolean
    createdBy?: boolean
    notes?: boolean
  }

  export type AssetTicketHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "assetId" | "ticketId" | "relationshipType" | "createdAt" | "endedAt" | "createdBy" | "notes", ExtArgs["result"]["assetTicketHistory"]>
  export type AssetTicketHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
  }
  export type AssetTicketHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
  }
  export type AssetTicketHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
  }

  export type $AssetTicketHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssetTicketHistory"
    objects: {
      asset: Prisma.$InventoryAssetPayload<ExtArgs>
      ticket: Prisma.$SupportTicketPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      assetId: number
      ticketId: number
      relationshipType: string
      createdAt: Date
      endedAt: Date | null
      createdBy: string | null
      notes: string | null
    }, ExtArgs["result"]["assetTicketHistory"]>
    composites: {}
  }

  type AssetTicketHistoryGetPayload<S extends boolean | null | undefined | AssetTicketHistoryDefaultArgs> = $Result.GetResult<Prisma.$AssetTicketHistoryPayload, S>

  type AssetTicketHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssetTicketHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssetTicketHistoryCountAggregateInputType | true
    }

  export interface AssetTicketHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssetTicketHistory'], meta: { name: 'AssetTicketHistory' } }
    /**
     * Find zero or one AssetTicketHistory that matches the filter.
     * @param {AssetTicketHistoryFindUniqueArgs} args - Arguments to find a AssetTicketHistory
     * @example
     * // Get one AssetTicketHistory
     * const assetTicketHistory = await prisma.assetTicketHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetTicketHistoryFindUniqueArgs>(args: SelectSubset<T, AssetTicketHistoryFindUniqueArgs<ExtArgs>>): Prisma__AssetTicketHistoryClient<$Result.GetResult<Prisma.$AssetTicketHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AssetTicketHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssetTicketHistoryFindUniqueOrThrowArgs} args - Arguments to find a AssetTicketHistory
     * @example
     * // Get one AssetTicketHistory
     * const assetTicketHistory = await prisma.assetTicketHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetTicketHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, AssetTicketHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssetTicketHistoryClient<$Result.GetResult<Prisma.$AssetTicketHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssetTicketHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetTicketHistoryFindFirstArgs} args - Arguments to find a AssetTicketHistory
     * @example
     * // Get one AssetTicketHistory
     * const assetTicketHistory = await prisma.assetTicketHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetTicketHistoryFindFirstArgs>(args?: SelectSubset<T, AssetTicketHistoryFindFirstArgs<ExtArgs>>): Prisma__AssetTicketHistoryClient<$Result.GetResult<Prisma.$AssetTicketHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssetTicketHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetTicketHistoryFindFirstOrThrowArgs} args - Arguments to find a AssetTicketHistory
     * @example
     * // Get one AssetTicketHistory
     * const assetTicketHistory = await prisma.assetTicketHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetTicketHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, AssetTicketHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssetTicketHistoryClient<$Result.GetResult<Prisma.$AssetTicketHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AssetTicketHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetTicketHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssetTicketHistories
     * const assetTicketHistories = await prisma.assetTicketHistory.findMany()
     * 
     * // Get first 10 AssetTicketHistories
     * const assetTicketHistories = await prisma.assetTicketHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetTicketHistoryWithIdOnly = await prisma.assetTicketHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssetTicketHistoryFindManyArgs>(args?: SelectSubset<T, AssetTicketHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetTicketHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AssetTicketHistory.
     * @param {AssetTicketHistoryCreateArgs} args - Arguments to create a AssetTicketHistory.
     * @example
     * // Create one AssetTicketHistory
     * const AssetTicketHistory = await prisma.assetTicketHistory.create({
     *   data: {
     *     // ... data to create a AssetTicketHistory
     *   }
     * })
     * 
     */
    create<T extends AssetTicketHistoryCreateArgs>(args: SelectSubset<T, AssetTicketHistoryCreateArgs<ExtArgs>>): Prisma__AssetTicketHistoryClient<$Result.GetResult<Prisma.$AssetTicketHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AssetTicketHistories.
     * @param {AssetTicketHistoryCreateManyArgs} args - Arguments to create many AssetTicketHistories.
     * @example
     * // Create many AssetTicketHistories
     * const assetTicketHistory = await prisma.assetTicketHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssetTicketHistoryCreateManyArgs>(args?: SelectSubset<T, AssetTicketHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssetTicketHistories and returns the data saved in the database.
     * @param {AssetTicketHistoryCreateManyAndReturnArgs} args - Arguments to create many AssetTicketHistories.
     * @example
     * // Create many AssetTicketHistories
     * const assetTicketHistory = await prisma.assetTicketHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssetTicketHistories and only return the `id`
     * const assetTicketHistoryWithIdOnly = await prisma.assetTicketHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssetTicketHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, AssetTicketHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetTicketHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AssetTicketHistory.
     * @param {AssetTicketHistoryDeleteArgs} args - Arguments to delete one AssetTicketHistory.
     * @example
     * // Delete one AssetTicketHistory
     * const AssetTicketHistory = await prisma.assetTicketHistory.delete({
     *   where: {
     *     // ... filter to delete one AssetTicketHistory
     *   }
     * })
     * 
     */
    delete<T extends AssetTicketHistoryDeleteArgs>(args: SelectSubset<T, AssetTicketHistoryDeleteArgs<ExtArgs>>): Prisma__AssetTicketHistoryClient<$Result.GetResult<Prisma.$AssetTicketHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AssetTicketHistory.
     * @param {AssetTicketHistoryUpdateArgs} args - Arguments to update one AssetTicketHistory.
     * @example
     * // Update one AssetTicketHistory
     * const assetTicketHistory = await prisma.assetTicketHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssetTicketHistoryUpdateArgs>(args: SelectSubset<T, AssetTicketHistoryUpdateArgs<ExtArgs>>): Prisma__AssetTicketHistoryClient<$Result.GetResult<Prisma.$AssetTicketHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AssetTicketHistories.
     * @param {AssetTicketHistoryDeleteManyArgs} args - Arguments to filter AssetTicketHistories to delete.
     * @example
     * // Delete a few AssetTicketHistories
     * const { count } = await prisma.assetTicketHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssetTicketHistoryDeleteManyArgs>(args?: SelectSubset<T, AssetTicketHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssetTicketHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetTicketHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssetTicketHistories
     * const assetTicketHistory = await prisma.assetTicketHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssetTicketHistoryUpdateManyArgs>(args: SelectSubset<T, AssetTicketHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssetTicketHistories and returns the data updated in the database.
     * @param {AssetTicketHistoryUpdateManyAndReturnArgs} args - Arguments to update many AssetTicketHistories.
     * @example
     * // Update many AssetTicketHistories
     * const assetTicketHistory = await prisma.assetTicketHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AssetTicketHistories and only return the `id`
     * const assetTicketHistoryWithIdOnly = await prisma.assetTicketHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssetTicketHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, AssetTicketHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetTicketHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AssetTicketHistory.
     * @param {AssetTicketHistoryUpsertArgs} args - Arguments to update or create a AssetTicketHistory.
     * @example
     * // Update or create a AssetTicketHistory
     * const assetTicketHistory = await prisma.assetTicketHistory.upsert({
     *   create: {
     *     // ... data to create a AssetTicketHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssetTicketHistory we want to update
     *   }
     * })
     */
    upsert<T extends AssetTicketHistoryUpsertArgs>(args: SelectSubset<T, AssetTicketHistoryUpsertArgs<ExtArgs>>): Prisma__AssetTicketHistoryClient<$Result.GetResult<Prisma.$AssetTicketHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AssetTicketHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetTicketHistoryCountArgs} args - Arguments to filter AssetTicketHistories to count.
     * @example
     * // Count the number of AssetTicketHistories
     * const count = await prisma.assetTicketHistory.count({
     *   where: {
     *     // ... the filter for the AssetTicketHistories we want to count
     *   }
     * })
    **/
    count<T extends AssetTicketHistoryCountArgs>(
      args?: Subset<T, AssetTicketHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetTicketHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssetTicketHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetTicketHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetTicketHistoryAggregateArgs>(args: Subset<T, AssetTicketHistoryAggregateArgs>): Prisma.PrismaPromise<GetAssetTicketHistoryAggregateType<T>>

    /**
     * Group by AssetTicketHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetTicketHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetTicketHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetTicketHistoryGroupByArgs['orderBy'] }
        : { orderBy?: AssetTicketHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetTicketHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetTicketHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssetTicketHistory model
   */
  readonly fields: AssetTicketHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssetTicketHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetTicketHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    asset<T extends InventoryAssetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryAssetDefaultArgs<ExtArgs>>): Prisma__InventoryAssetClient<$Result.GetResult<Prisma.$InventoryAssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ticket<T extends SupportTicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicketDefaultArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssetTicketHistory model
   */
  interface AssetTicketHistoryFieldRefs {
    readonly id: FieldRef<"AssetTicketHistory", 'Int'>
    readonly assetId: FieldRef<"AssetTicketHistory", 'Int'>
    readonly ticketId: FieldRef<"AssetTicketHistory", 'Int'>
    readonly relationshipType: FieldRef<"AssetTicketHistory", 'String'>
    readonly createdAt: FieldRef<"AssetTicketHistory", 'DateTime'>
    readonly endedAt: FieldRef<"AssetTicketHistory", 'DateTime'>
    readonly createdBy: FieldRef<"AssetTicketHistory", 'String'>
    readonly notes: FieldRef<"AssetTicketHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AssetTicketHistory findUnique
   */
  export type AssetTicketHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetTicketHistory
     */
    select?: AssetTicketHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetTicketHistory
     */
    omit?: AssetTicketHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetTicketHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AssetTicketHistory to fetch.
     */
    where: AssetTicketHistoryWhereUniqueInput
  }

  /**
   * AssetTicketHistory findUniqueOrThrow
   */
  export type AssetTicketHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetTicketHistory
     */
    select?: AssetTicketHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetTicketHistory
     */
    omit?: AssetTicketHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetTicketHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AssetTicketHistory to fetch.
     */
    where: AssetTicketHistoryWhereUniqueInput
  }

  /**
   * AssetTicketHistory findFirst
   */
  export type AssetTicketHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetTicketHistory
     */
    select?: AssetTicketHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetTicketHistory
     */
    omit?: AssetTicketHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetTicketHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AssetTicketHistory to fetch.
     */
    where?: AssetTicketHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetTicketHistories to fetch.
     */
    orderBy?: AssetTicketHistoryOrderByWithRelationInput | AssetTicketHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetTicketHistories.
     */
    cursor?: AssetTicketHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetTicketHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetTicketHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetTicketHistories.
     */
    distinct?: AssetTicketHistoryScalarFieldEnum | AssetTicketHistoryScalarFieldEnum[]
  }

  /**
   * AssetTicketHistory findFirstOrThrow
   */
  export type AssetTicketHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetTicketHistory
     */
    select?: AssetTicketHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetTicketHistory
     */
    omit?: AssetTicketHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetTicketHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AssetTicketHistory to fetch.
     */
    where?: AssetTicketHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetTicketHistories to fetch.
     */
    orderBy?: AssetTicketHistoryOrderByWithRelationInput | AssetTicketHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetTicketHistories.
     */
    cursor?: AssetTicketHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetTicketHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetTicketHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetTicketHistories.
     */
    distinct?: AssetTicketHistoryScalarFieldEnum | AssetTicketHistoryScalarFieldEnum[]
  }

  /**
   * AssetTicketHistory findMany
   */
  export type AssetTicketHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetTicketHistory
     */
    select?: AssetTicketHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetTicketHistory
     */
    omit?: AssetTicketHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetTicketHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AssetTicketHistories to fetch.
     */
    where?: AssetTicketHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetTicketHistories to fetch.
     */
    orderBy?: AssetTicketHistoryOrderByWithRelationInput | AssetTicketHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssetTicketHistories.
     */
    cursor?: AssetTicketHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetTicketHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetTicketHistories.
     */
    skip?: number
    distinct?: AssetTicketHistoryScalarFieldEnum | AssetTicketHistoryScalarFieldEnum[]
  }

  /**
   * AssetTicketHistory create
   */
  export type AssetTicketHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetTicketHistory
     */
    select?: AssetTicketHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetTicketHistory
     */
    omit?: AssetTicketHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetTicketHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a AssetTicketHistory.
     */
    data: XOR<AssetTicketHistoryCreateInput, AssetTicketHistoryUncheckedCreateInput>
  }

  /**
   * AssetTicketHistory createMany
   */
  export type AssetTicketHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssetTicketHistories.
     */
    data: AssetTicketHistoryCreateManyInput | AssetTicketHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssetTicketHistory createManyAndReturn
   */
  export type AssetTicketHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetTicketHistory
     */
    select?: AssetTicketHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssetTicketHistory
     */
    omit?: AssetTicketHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many AssetTicketHistories.
     */
    data: AssetTicketHistoryCreateManyInput | AssetTicketHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetTicketHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssetTicketHistory update
   */
  export type AssetTicketHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetTicketHistory
     */
    select?: AssetTicketHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetTicketHistory
     */
    omit?: AssetTicketHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetTicketHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a AssetTicketHistory.
     */
    data: XOR<AssetTicketHistoryUpdateInput, AssetTicketHistoryUncheckedUpdateInput>
    /**
     * Choose, which AssetTicketHistory to update.
     */
    where: AssetTicketHistoryWhereUniqueInput
  }

  /**
   * AssetTicketHistory updateMany
   */
  export type AssetTicketHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssetTicketHistories.
     */
    data: XOR<AssetTicketHistoryUpdateManyMutationInput, AssetTicketHistoryUncheckedUpdateManyInput>
    /**
     * Filter which AssetTicketHistories to update
     */
    where?: AssetTicketHistoryWhereInput
    /**
     * Limit how many AssetTicketHistories to update.
     */
    limit?: number
  }

  /**
   * AssetTicketHistory updateManyAndReturn
   */
  export type AssetTicketHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetTicketHistory
     */
    select?: AssetTicketHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssetTicketHistory
     */
    omit?: AssetTicketHistoryOmit<ExtArgs> | null
    /**
     * The data used to update AssetTicketHistories.
     */
    data: XOR<AssetTicketHistoryUpdateManyMutationInput, AssetTicketHistoryUncheckedUpdateManyInput>
    /**
     * Filter which AssetTicketHistories to update
     */
    where?: AssetTicketHistoryWhereInput
    /**
     * Limit how many AssetTicketHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetTicketHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssetTicketHistory upsert
   */
  export type AssetTicketHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetTicketHistory
     */
    select?: AssetTicketHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetTicketHistory
     */
    omit?: AssetTicketHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetTicketHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the AssetTicketHistory to update in case it exists.
     */
    where: AssetTicketHistoryWhereUniqueInput
    /**
     * In case the AssetTicketHistory found by the `where` argument doesn't exist, create a new AssetTicketHistory with this data.
     */
    create: XOR<AssetTicketHistoryCreateInput, AssetTicketHistoryUncheckedCreateInput>
    /**
     * In case the AssetTicketHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetTicketHistoryUpdateInput, AssetTicketHistoryUncheckedUpdateInput>
  }

  /**
   * AssetTicketHistory delete
   */
  export type AssetTicketHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetTicketHistory
     */
    select?: AssetTicketHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetTicketHistory
     */
    omit?: AssetTicketHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetTicketHistoryInclude<ExtArgs> | null
    /**
     * Filter which AssetTicketHistory to delete.
     */
    where: AssetTicketHistoryWhereUniqueInput
  }

  /**
   * AssetTicketHistory deleteMany
   */
  export type AssetTicketHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetTicketHistories to delete
     */
    where?: AssetTicketHistoryWhereInput
    /**
     * Limit how many AssetTicketHistories to delete.
     */
    limit?: number
  }

  /**
   * AssetTicketHistory without action
   */
  export type AssetTicketHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetTicketHistory
     */
    select?: AssetTicketHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetTicketHistory
     */
    omit?: AssetTicketHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetTicketHistoryInclude<ExtArgs> | null
  }


  /**
   * Model AssetWarrantyAlert
   */

  export type AggregateAssetWarrantyAlert = {
    _count: AssetWarrantyAlertCountAggregateOutputType | null
    _avg: AssetWarrantyAlertAvgAggregateOutputType | null
    _sum: AssetWarrantyAlertSumAggregateOutputType | null
    _min: AssetWarrantyAlertMinAggregateOutputType | null
    _max: AssetWarrantyAlertMaxAggregateOutputType | null
  }

  export type AssetWarrantyAlertAvgAggregateOutputType = {
    id: number | null
    assetId: number | null
    daysRemaining: number | null
  }

  export type AssetWarrantyAlertSumAggregateOutputType = {
    id: number | null
    assetId: number | null
    daysRemaining: number | null
  }

  export type AssetWarrantyAlertMinAggregateOutputType = {
    id: number | null
    assetId: number | null
    alertType: string | null
    alertDate: Date | null
    expiryDate: Date | null
    daysRemaining: number | null
    notificationSent: boolean | null
    notificationSentAt: Date | null
    dismissed: boolean | null
    dismissedBy: string | null
    dismissedAt: Date | null
  }

  export type AssetWarrantyAlertMaxAggregateOutputType = {
    id: number | null
    assetId: number | null
    alertType: string | null
    alertDate: Date | null
    expiryDate: Date | null
    daysRemaining: number | null
    notificationSent: boolean | null
    notificationSentAt: Date | null
    dismissed: boolean | null
    dismissedBy: string | null
    dismissedAt: Date | null
  }

  export type AssetWarrantyAlertCountAggregateOutputType = {
    id: number
    assetId: number
    alertType: number
    alertDate: number
    expiryDate: number
    daysRemaining: number
    notificationSent: number
    notificationSentAt: number
    dismissed: number
    dismissedBy: number
    dismissedAt: number
    _all: number
  }


  export type AssetWarrantyAlertAvgAggregateInputType = {
    id?: true
    assetId?: true
    daysRemaining?: true
  }

  export type AssetWarrantyAlertSumAggregateInputType = {
    id?: true
    assetId?: true
    daysRemaining?: true
  }

  export type AssetWarrantyAlertMinAggregateInputType = {
    id?: true
    assetId?: true
    alertType?: true
    alertDate?: true
    expiryDate?: true
    daysRemaining?: true
    notificationSent?: true
    notificationSentAt?: true
    dismissed?: true
    dismissedBy?: true
    dismissedAt?: true
  }

  export type AssetWarrantyAlertMaxAggregateInputType = {
    id?: true
    assetId?: true
    alertType?: true
    alertDate?: true
    expiryDate?: true
    daysRemaining?: true
    notificationSent?: true
    notificationSentAt?: true
    dismissed?: true
    dismissedBy?: true
    dismissedAt?: true
  }

  export type AssetWarrantyAlertCountAggregateInputType = {
    id?: true
    assetId?: true
    alertType?: true
    alertDate?: true
    expiryDate?: true
    daysRemaining?: true
    notificationSent?: true
    notificationSentAt?: true
    dismissed?: true
    dismissedBy?: true
    dismissedAt?: true
    _all?: true
  }

  export type AssetWarrantyAlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetWarrantyAlert to aggregate.
     */
    where?: AssetWarrantyAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetWarrantyAlerts to fetch.
     */
    orderBy?: AssetWarrantyAlertOrderByWithRelationInput | AssetWarrantyAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetWarrantyAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetWarrantyAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetWarrantyAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssetWarrantyAlerts
    **/
    _count?: true | AssetWarrantyAlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssetWarrantyAlertAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssetWarrantyAlertSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetWarrantyAlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetWarrantyAlertMaxAggregateInputType
  }

  export type GetAssetWarrantyAlertAggregateType<T extends AssetWarrantyAlertAggregateArgs> = {
        [P in keyof T & keyof AggregateAssetWarrantyAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssetWarrantyAlert[P]>
      : GetScalarType<T[P], AggregateAssetWarrantyAlert[P]>
  }




  export type AssetWarrantyAlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWarrantyAlertWhereInput
    orderBy?: AssetWarrantyAlertOrderByWithAggregationInput | AssetWarrantyAlertOrderByWithAggregationInput[]
    by: AssetWarrantyAlertScalarFieldEnum[] | AssetWarrantyAlertScalarFieldEnum
    having?: AssetWarrantyAlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetWarrantyAlertCountAggregateInputType | true
    _avg?: AssetWarrantyAlertAvgAggregateInputType
    _sum?: AssetWarrantyAlertSumAggregateInputType
    _min?: AssetWarrantyAlertMinAggregateInputType
    _max?: AssetWarrantyAlertMaxAggregateInputType
  }

  export type AssetWarrantyAlertGroupByOutputType = {
    id: number
    assetId: number
    alertType: string
    alertDate: Date
    expiryDate: Date
    daysRemaining: number
    notificationSent: boolean
    notificationSentAt: Date | null
    dismissed: boolean
    dismissedBy: string | null
    dismissedAt: Date | null
    _count: AssetWarrantyAlertCountAggregateOutputType | null
    _avg: AssetWarrantyAlertAvgAggregateOutputType | null
    _sum: AssetWarrantyAlertSumAggregateOutputType | null
    _min: AssetWarrantyAlertMinAggregateOutputType | null
    _max: AssetWarrantyAlertMaxAggregateOutputType | null
  }

  type GetAssetWarrantyAlertGroupByPayload<T extends AssetWarrantyAlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetWarrantyAlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetWarrantyAlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetWarrantyAlertGroupByOutputType[P]>
            : GetScalarType<T[P], AssetWarrantyAlertGroupByOutputType[P]>
        }
      >
    >


  export type AssetWarrantyAlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetId?: boolean
    alertType?: boolean
    alertDate?: boolean
    expiryDate?: boolean
    daysRemaining?: boolean
    notificationSent?: boolean
    notificationSentAt?: boolean
    dismissed?: boolean
    dismissedBy?: boolean
    dismissedAt?: boolean
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assetWarrantyAlert"]>

  export type AssetWarrantyAlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetId?: boolean
    alertType?: boolean
    alertDate?: boolean
    expiryDate?: boolean
    daysRemaining?: boolean
    notificationSent?: boolean
    notificationSentAt?: boolean
    dismissed?: boolean
    dismissedBy?: boolean
    dismissedAt?: boolean
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assetWarrantyAlert"]>

  export type AssetWarrantyAlertSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetId?: boolean
    alertType?: boolean
    alertDate?: boolean
    expiryDate?: boolean
    daysRemaining?: boolean
    notificationSent?: boolean
    notificationSentAt?: boolean
    dismissed?: boolean
    dismissedBy?: boolean
    dismissedAt?: boolean
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assetWarrantyAlert"]>

  export type AssetWarrantyAlertSelectScalar = {
    id?: boolean
    assetId?: boolean
    alertType?: boolean
    alertDate?: boolean
    expiryDate?: boolean
    daysRemaining?: boolean
    notificationSent?: boolean
    notificationSentAt?: boolean
    dismissed?: boolean
    dismissedBy?: boolean
    dismissedAt?: boolean
  }

  export type AssetWarrantyAlertOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "assetId" | "alertType" | "alertDate" | "expiryDate" | "daysRemaining" | "notificationSent" | "notificationSentAt" | "dismissed" | "dismissedBy" | "dismissedAt", ExtArgs["result"]["assetWarrantyAlert"]>
  export type AssetWarrantyAlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
  }
  export type AssetWarrantyAlertIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
  }
  export type AssetWarrantyAlertIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
  }

  export type $AssetWarrantyAlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssetWarrantyAlert"
    objects: {
      asset: Prisma.$InventoryAssetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      assetId: number
      alertType: string
      alertDate: Date
      expiryDate: Date
      daysRemaining: number
      notificationSent: boolean
      notificationSentAt: Date | null
      dismissed: boolean
      dismissedBy: string | null
      dismissedAt: Date | null
    }, ExtArgs["result"]["assetWarrantyAlert"]>
    composites: {}
  }

  type AssetWarrantyAlertGetPayload<S extends boolean | null | undefined | AssetWarrantyAlertDefaultArgs> = $Result.GetResult<Prisma.$AssetWarrantyAlertPayload, S>

  type AssetWarrantyAlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssetWarrantyAlertFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssetWarrantyAlertCountAggregateInputType | true
    }

  export interface AssetWarrantyAlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssetWarrantyAlert'], meta: { name: 'AssetWarrantyAlert' } }
    /**
     * Find zero or one AssetWarrantyAlert that matches the filter.
     * @param {AssetWarrantyAlertFindUniqueArgs} args - Arguments to find a AssetWarrantyAlert
     * @example
     * // Get one AssetWarrantyAlert
     * const assetWarrantyAlert = await prisma.assetWarrantyAlert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetWarrantyAlertFindUniqueArgs>(args: SelectSubset<T, AssetWarrantyAlertFindUniqueArgs<ExtArgs>>): Prisma__AssetWarrantyAlertClient<$Result.GetResult<Prisma.$AssetWarrantyAlertPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AssetWarrantyAlert that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssetWarrantyAlertFindUniqueOrThrowArgs} args - Arguments to find a AssetWarrantyAlert
     * @example
     * // Get one AssetWarrantyAlert
     * const assetWarrantyAlert = await prisma.assetWarrantyAlert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetWarrantyAlertFindUniqueOrThrowArgs>(args: SelectSubset<T, AssetWarrantyAlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssetWarrantyAlertClient<$Result.GetResult<Prisma.$AssetWarrantyAlertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssetWarrantyAlert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetWarrantyAlertFindFirstArgs} args - Arguments to find a AssetWarrantyAlert
     * @example
     * // Get one AssetWarrantyAlert
     * const assetWarrantyAlert = await prisma.assetWarrantyAlert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetWarrantyAlertFindFirstArgs>(args?: SelectSubset<T, AssetWarrantyAlertFindFirstArgs<ExtArgs>>): Prisma__AssetWarrantyAlertClient<$Result.GetResult<Prisma.$AssetWarrantyAlertPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssetWarrantyAlert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetWarrantyAlertFindFirstOrThrowArgs} args - Arguments to find a AssetWarrantyAlert
     * @example
     * // Get one AssetWarrantyAlert
     * const assetWarrantyAlert = await prisma.assetWarrantyAlert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetWarrantyAlertFindFirstOrThrowArgs>(args?: SelectSubset<T, AssetWarrantyAlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssetWarrantyAlertClient<$Result.GetResult<Prisma.$AssetWarrantyAlertPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AssetWarrantyAlerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetWarrantyAlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssetWarrantyAlerts
     * const assetWarrantyAlerts = await prisma.assetWarrantyAlert.findMany()
     * 
     * // Get first 10 AssetWarrantyAlerts
     * const assetWarrantyAlerts = await prisma.assetWarrantyAlert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetWarrantyAlertWithIdOnly = await prisma.assetWarrantyAlert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssetWarrantyAlertFindManyArgs>(args?: SelectSubset<T, AssetWarrantyAlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetWarrantyAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AssetWarrantyAlert.
     * @param {AssetWarrantyAlertCreateArgs} args - Arguments to create a AssetWarrantyAlert.
     * @example
     * // Create one AssetWarrantyAlert
     * const AssetWarrantyAlert = await prisma.assetWarrantyAlert.create({
     *   data: {
     *     // ... data to create a AssetWarrantyAlert
     *   }
     * })
     * 
     */
    create<T extends AssetWarrantyAlertCreateArgs>(args: SelectSubset<T, AssetWarrantyAlertCreateArgs<ExtArgs>>): Prisma__AssetWarrantyAlertClient<$Result.GetResult<Prisma.$AssetWarrantyAlertPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AssetWarrantyAlerts.
     * @param {AssetWarrantyAlertCreateManyArgs} args - Arguments to create many AssetWarrantyAlerts.
     * @example
     * // Create many AssetWarrantyAlerts
     * const assetWarrantyAlert = await prisma.assetWarrantyAlert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssetWarrantyAlertCreateManyArgs>(args?: SelectSubset<T, AssetWarrantyAlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssetWarrantyAlerts and returns the data saved in the database.
     * @param {AssetWarrantyAlertCreateManyAndReturnArgs} args - Arguments to create many AssetWarrantyAlerts.
     * @example
     * // Create many AssetWarrantyAlerts
     * const assetWarrantyAlert = await prisma.assetWarrantyAlert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssetWarrantyAlerts and only return the `id`
     * const assetWarrantyAlertWithIdOnly = await prisma.assetWarrantyAlert.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssetWarrantyAlertCreateManyAndReturnArgs>(args?: SelectSubset<T, AssetWarrantyAlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetWarrantyAlertPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AssetWarrantyAlert.
     * @param {AssetWarrantyAlertDeleteArgs} args - Arguments to delete one AssetWarrantyAlert.
     * @example
     * // Delete one AssetWarrantyAlert
     * const AssetWarrantyAlert = await prisma.assetWarrantyAlert.delete({
     *   where: {
     *     // ... filter to delete one AssetWarrantyAlert
     *   }
     * })
     * 
     */
    delete<T extends AssetWarrantyAlertDeleteArgs>(args: SelectSubset<T, AssetWarrantyAlertDeleteArgs<ExtArgs>>): Prisma__AssetWarrantyAlertClient<$Result.GetResult<Prisma.$AssetWarrantyAlertPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AssetWarrantyAlert.
     * @param {AssetWarrantyAlertUpdateArgs} args - Arguments to update one AssetWarrantyAlert.
     * @example
     * // Update one AssetWarrantyAlert
     * const assetWarrantyAlert = await prisma.assetWarrantyAlert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssetWarrantyAlertUpdateArgs>(args: SelectSubset<T, AssetWarrantyAlertUpdateArgs<ExtArgs>>): Prisma__AssetWarrantyAlertClient<$Result.GetResult<Prisma.$AssetWarrantyAlertPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AssetWarrantyAlerts.
     * @param {AssetWarrantyAlertDeleteManyArgs} args - Arguments to filter AssetWarrantyAlerts to delete.
     * @example
     * // Delete a few AssetWarrantyAlerts
     * const { count } = await prisma.assetWarrantyAlert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssetWarrantyAlertDeleteManyArgs>(args?: SelectSubset<T, AssetWarrantyAlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssetWarrantyAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetWarrantyAlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssetWarrantyAlerts
     * const assetWarrantyAlert = await prisma.assetWarrantyAlert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssetWarrantyAlertUpdateManyArgs>(args: SelectSubset<T, AssetWarrantyAlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssetWarrantyAlerts and returns the data updated in the database.
     * @param {AssetWarrantyAlertUpdateManyAndReturnArgs} args - Arguments to update many AssetWarrantyAlerts.
     * @example
     * // Update many AssetWarrantyAlerts
     * const assetWarrantyAlert = await prisma.assetWarrantyAlert.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AssetWarrantyAlerts and only return the `id`
     * const assetWarrantyAlertWithIdOnly = await prisma.assetWarrantyAlert.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssetWarrantyAlertUpdateManyAndReturnArgs>(args: SelectSubset<T, AssetWarrantyAlertUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetWarrantyAlertPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AssetWarrantyAlert.
     * @param {AssetWarrantyAlertUpsertArgs} args - Arguments to update or create a AssetWarrantyAlert.
     * @example
     * // Update or create a AssetWarrantyAlert
     * const assetWarrantyAlert = await prisma.assetWarrantyAlert.upsert({
     *   create: {
     *     // ... data to create a AssetWarrantyAlert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssetWarrantyAlert we want to update
     *   }
     * })
     */
    upsert<T extends AssetWarrantyAlertUpsertArgs>(args: SelectSubset<T, AssetWarrantyAlertUpsertArgs<ExtArgs>>): Prisma__AssetWarrantyAlertClient<$Result.GetResult<Prisma.$AssetWarrantyAlertPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AssetWarrantyAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetWarrantyAlertCountArgs} args - Arguments to filter AssetWarrantyAlerts to count.
     * @example
     * // Count the number of AssetWarrantyAlerts
     * const count = await prisma.assetWarrantyAlert.count({
     *   where: {
     *     // ... the filter for the AssetWarrantyAlerts we want to count
     *   }
     * })
    **/
    count<T extends AssetWarrantyAlertCountArgs>(
      args?: Subset<T, AssetWarrantyAlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetWarrantyAlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssetWarrantyAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetWarrantyAlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetWarrantyAlertAggregateArgs>(args: Subset<T, AssetWarrantyAlertAggregateArgs>): Prisma.PrismaPromise<GetAssetWarrantyAlertAggregateType<T>>

    /**
     * Group by AssetWarrantyAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetWarrantyAlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetWarrantyAlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetWarrantyAlertGroupByArgs['orderBy'] }
        : { orderBy?: AssetWarrantyAlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetWarrantyAlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetWarrantyAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssetWarrantyAlert model
   */
  readonly fields: AssetWarrantyAlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssetWarrantyAlert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetWarrantyAlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    asset<T extends InventoryAssetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryAssetDefaultArgs<ExtArgs>>): Prisma__InventoryAssetClient<$Result.GetResult<Prisma.$InventoryAssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssetWarrantyAlert model
   */
  interface AssetWarrantyAlertFieldRefs {
    readonly id: FieldRef<"AssetWarrantyAlert", 'Int'>
    readonly assetId: FieldRef<"AssetWarrantyAlert", 'Int'>
    readonly alertType: FieldRef<"AssetWarrantyAlert", 'String'>
    readonly alertDate: FieldRef<"AssetWarrantyAlert", 'DateTime'>
    readonly expiryDate: FieldRef<"AssetWarrantyAlert", 'DateTime'>
    readonly daysRemaining: FieldRef<"AssetWarrantyAlert", 'Int'>
    readonly notificationSent: FieldRef<"AssetWarrantyAlert", 'Boolean'>
    readonly notificationSentAt: FieldRef<"AssetWarrantyAlert", 'DateTime'>
    readonly dismissed: FieldRef<"AssetWarrantyAlert", 'Boolean'>
    readonly dismissedBy: FieldRef<"AssetWarrantyAlert", 'String'>
    readonly dismissedAt: FieldRef<"AssetWarrantyAlert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AssetWarrantyAlert findUnique
   */
  export type AssetWarrantyAlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetWarrantyAlert
     */
    select?: AssetWarrantyAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetWarrantyAlert
     */
    omit?: AssetWarrantyAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetWarrantyAlertInclude<ExtArgs> | null
    /**
     * Filter, which AssetWarrantyAlert to fetch.
     */
    where: AssetWarrantyAlertWhereUniqueInput
  }

  /**
   * AssetWarrantyAlert findUniqueOrThrow
   */
  export type AssetWarrantyAlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetWarrantyAlert
     */
    select?: AssetWarrantyAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetWarrantyAlert
     */
    omit?: AssetWarrantyAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetWarrantyAlertInclude<ExtArgs> | null
    /**
     * Filter, which AssetWarrantyAlert to fetch.
     */
    where: AssetWarrantyAlertWhereUniqueInput
  }

  /**
   * AssetWarrantyAlert findFirst
   */
  export type AssetWarrantyAlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetWarrantyAlert
     */
    select?: AssetWarrantyAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetWarrantyAlert
     */
    omit?: AssetWarrantyAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetWarrantyAlertInclude<ExtArgs> | null
    /**
     * Filter, which AssetWarrantyAlert to fetch.
     */
    where?: AssetWarrantyAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetWarrantyAlerts to fetch.
     */
    orderBy?: AssetWarrantyAlertOrderByWithRelationInput | AssetWarrantyAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetWarrantyAlerts.
     */
    cursor?: AssetWarrantyAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetWarrantyAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetWarrantyAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetWarrantyAlerts.
     */
    distinct?: AssetWarrantyAlertScalarFieldEnum | AssetWarrantyAlertScalarFieldEnum[]
  }

  /**
   * AssetWarrantyAlert findFirstOrThrow
   */
  export type AssetWarrantyAlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetWarrantyAlert
     */
    select?: AssetWarrantyAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetWarrantyAlert
     */
    omit?: AssetWarrantyAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetWarrantyAlertInclude<ExtArgs> | null
    /**
     * Filter, which AssetWarrantyAlert to fetch.
     */
    where?: AssetWarrantyAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetWarrantyAlerts to fetch.
     */
    orderBy?: AssetWarrantyAlertOrderByWithRelationInput | AssetWarrantyAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetWarrantyAlerts.
     */
    cursor?: AssetWarrantyAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetWarrantyAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetWarrantyAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetWarrantyAlerts.
     */
    distinct?: AssetWarrantyAlertScalarFieldEnum | AssetWarrantyAlertScalarFieldEnum[]
  }

  /**
   * AssetWarrantyAlert findMany
   */
  export type AssetWarrantyAlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetWarrantyAlert
     */
    select?: AssetWarrantyAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetWarrantyAlert
     */
    omit?: AssetWarrantyAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetWarrantyAlertInclude<ExtArgs> | null
    /**
     * Filter, which AssetWarrantyAlerts to fetch.
     */
    where?: AssetWarrantyAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetWarrantyAlerts to fetch.
     */
    orderBy?: AssetWarrantyAlertOrderByWithRelationInput | AssetWarrantyAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssetWarrantyAlerts.
     */
    cursor?: AssetWarrantyAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetWarrantyAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetWarrantyAlerts.
     */
    skip?: number
    distinct?: AssetWarrantyAlertScalarFieldEnum | AssetWarrantyAlertScalarFieldEnum[]
  }

  /**
   * AssetWarrantyAlert create
   */
  export type AssetWarrantyAlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetWarrantyAlert
     */
    select?: AssetWarrantyAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetWarrantyAlert
     */
    omit?: AssetWarrantyAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetWarrantyAlertInclude<ExtArgs> | null
    /**
     * The data needed to create a AssetWarrantyAlert.
     */
    data: XOR<AssetWarrantyAlertCreateInput, AssetWarrantyAlertUncheckedCreateInput>
  }

  /**
   * AssetWarrantyAlert createMany
   */
  export type AssetWarrantyAlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssetWarrantyAlerts.
     */
    data: AssetWarrantyAlertCreateManyInput | AssetWarrantyAlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssetWarrantyAlert createManyAndReturn
   */
  export type AssetWarrantyAlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetWarrantyAlert
     */
    select?: AssetWarrantyAlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssetWarrantyAlert
     */
    omit?: AssetWarrantyAlertOmit<ExtArgs> | null
    /**
     * The data used to create many AssetWarrantyAlerts.
     */
    data: AssetWarrantyAlertCreateManyInput | AssetWarrantyAlertCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetWarrantyAlertIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssetWarrantyAlert update
   */
  export type AssetWarrantyAlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetWarrantyAlert
     */
    select?: AssetWarrantyAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetWarrantyAlert
     */
    omit?: AssetWarrantyAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetWarrantyAlertInclude<ExtArgs> | null
    /**
     * The data needed to update a AssetWarrantyAlert.
     */
    data: XOR<AssetWarrantyAlertUpdateInput, AssetWarrantyAlertUncheckedUpdateInput>
    /**
     * Choose, which AssetWarrantyAlert to update.
     */
    where: AssetWarrantyAlertWhereUniqueInput
  }

  /**
   * AssetWarrantyAlert updateMany
   */
  export type AssetWarrantyAlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssetWarrantyAlerts.
     */
    data: XOR<AssetWarrantyAlertUpdateManyMutationInput, AssetWarrantyAlertUncheckedUpdateManyInput>
    /**
     * Filter which AssetWarrantyAlerts to update
     */
    where?: AssetWarrantyAlertWhereInput
    /**
     * Limit how many AssetWarrantyAlerts to update.
     */
    limit?: number
  }

  /**
   * AssetWarrantyAlert updateManyAndReturn
   */
  export type AssetWarrantyAlertUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetWarrantyAlert
     */
    select?: AssetWarrantyAlertSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssetWarrantyAlert
     */
    omit?: AssetWarrantyAlertOmit<ExtArgs> | null
    /**
     * The data used to update AssetWarrantyAlerts.
     */
    data: XOR<AssetWarrantyAlertUpdateManyMutationInput, AssetWarrantyAlertUncheckedUpdateManyInput>
    /**
     * Filter which AssetWarrantyAlerts to update
     */
    where?: AssetWarrantyAlertWhereInput
    /**
     * Limit how many AssetWarrantyAlerts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetWarrantyAlertIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssetWarrantyAlert upsert
   */
  export type AssetWarrantyAlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetWarrantyAlert
     */
    select?: AssetWarrantyAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetWarrantyAlert
     */
    omit?: AssetWarrantyAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetWarrantyAlertInclude<ExtArgs> | null
    /**
     * The filter to search for the AssetWarrantyAlert to update in case it exists.
     */
    where: AssetWarrantyAlertWhereUniqueInput
    /**
     * In case the AssetWarrantyAlert found by the `where` argument doesn't exist, create a new AssetWarrantyAlert with this data.
     */
    create: XOR<AssetWarrantyAlertCreateInput, AssetWarrantyAlertUncheckedCreateInput>
    /**
     * In case the AssetWarrantyAlert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetWarrantyAlertUpdateInput, AssetWarrantyAlertUncheckedUpdateInput>
  }

  /**
   * AssetWarrantyAlert delete
   */
  export type AssetWarrantyAlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetWarrantyAlert
     */
    select?: AssetWarrantyAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetWarrantyAlert
     */
    omit?: AssetWarrantyAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetWarrantyAlertInclude<ExtArgs> | null
    /**
     * Filter which AssetWarrantyAlert to delete.
     */
    where: AssetWarrantyAlertWhereUniqueInput
  }

  /**
   * AssetWarrantyAlert deleteMany
   */
  export type AssetWarrantyAlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetWarrantyAlerts to delete
     */
    where?: AssetWarrantyAlertWhereInput
    /**
     * Limit how many AssetWarrantyAlerts to delete.
     */
    limit?: number
  }

  /**
   * AssetWarrantyAlert without action
   */
  export type AssetWarrantyAlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetWarrantyAlert
     */
    select?: AssetWarrantyAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetWarrantyAlert
     */
    omit?: AssetWarrantyAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetWarrantyAlertInclude<ExtArgs> | null
  }


  /**
   * Model AssetImportBatch
   */

  export type AggregateAssetImportBatch = {
    _count: AssetImportBatchCountAggregateOutputType | null
    _avg: AssetImportBatchAvgAggregateOutputType | null
    _sum: AssetImportBatchSumAggregateOutputType | null
    _min: AssetImportBatchMinAggregateOutputType | null
    _max: AssetImportBatchMaxAggregateOutputType | null
  }

  export type AssetImportBatchAvgAggregateOutputType = {
    totalRecords: number | null
    successfulRecords: number | null
    failedRecords: number | null
  }

  export type AssetImportBatchSumAggregateOutputType = {
    totalRecords: number | null
    successfulRecords: number | null
    failedRecords: number | null
  }

  export type AssetImportBatchMinAggregateOutputType = {
    id: string | null
    filename: string | null
    importedBy: string | null
    importDate: Date | null
    totalRecords: number | null
    successfulRecords: number | null
    failedRecords: number | null
    validationStatus: string | null
    validationErrors: string | null
    rollbackDate: Date | null
    rollbackBy: string | null
  }

  export type AssetImportBatchMaxAggregateOutputType = {
    id: string | null
    filename: string | null
    importedBy: string | null
    importDate: Date | null
    totalRecords: number | null
    successfulRecords: number | null
    failedRecords: number | null
    validationStatus: string | null
    validationErrors: string | null
    rollbackDate: Date | null
    rollbackBy: string | null
  }

  export type AssetImportBatchCountAggregateOutputType = {
    id: number
    filename: number
    importedBy: number
    importDate: number
    totalRecords: number
    successfulRecords: number
    failedRecords: number
    validationStatus: number
    validationErrors: number
    rollbackDate: number
    rollbackBy: number
    _all: number
  }


  export type AssetImportBatchAvgAggregateInputType = {
    totalRecords?: true
    successfulRecords?: true
    failedRecords?: true
  }

  export type AssetImportBatchSumAggregateInputType = {
    totalRecords?: true
    successfulRecords?: true
    failedRecords?: true
  }

  export type AssetImportBatchMinAggregateInputType = {
    id?: true
    filename?: true
    importedBy?: true
    importDate?: true
    totalRecords?: true
    successfulRecords?: true
    failedRecords?: true
    validationStatus?: true
    validationErrors?: true
    rollbackDate?: true
    rollbackBy?: true
  }

  export type AssetImportBatchMaxAggregateInputType = {
    id?: true
    filename?: true
    importedBy?: true
    importDate?: true
    totalRecords?: true
    successfulRecords?: true
    failedRecords?: true
    validationStatus?: true
    validationErrors?: true
    rollbackDate?: true
    rollbackBy?: true
  }

  export type AssetImportBatchCountAggregateInputType = {
    id?: true
    filename?: true
    importedBy?: true
    importDate?: true
    totalRecords?: true
    successfulRecords?: true
    failedRecords?: true
    validationStatus?: true
    validationErrors?: true
    rollbackDate?: true
    rollbackBy?: true
    _all?: true
  }

  export type AssetImportBatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetImportBatch to aggregate.
     */
    where?: AssetImportBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetImportBatches to fetch.
     */
    orderBy?: AssetImportBatchOrderByWithRelationInput | AssetImportBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetImportBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetImportBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetImportBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssetImportBatches
    **/
    _count?: true | AssetImportBatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssetImportBatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssetImportBatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetImportBatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetImportBatchMaxAggregateInputType
  }

  export type GetAssetImportBatchAggregateType<T extends AssetImportBatchAggregateArgs> = {
        [P in keyof T & keyof AggregateAssetImportBatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssetImportBatch[P]>
      : GetScalarType<T[P], AggregateAssetImportBatch[P]>
  }




  export type AssetImportBatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetImportBatchWhereInput
    orderBy?: AssetImportBatchOrderByWithAggregationInput | AssetImportBatchOrderByWithAggregationInput[]
    by: AssetImportBatchScalarFieldEnum[] | AssetImportBatchScalarFieldEnum
    having?: AssetImportBatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetImportBatchCountAggregateInputType | true
    _avg?: AssetImportBatchAvgAggregateInputType
    _sum?: AssetImportBatchSumAggregateInputType
    _min?: AssetImportBatchMinAggregateInputType
    _max?: AssetImportBatchMaxAggregateInputType
  }

  export type AssetImportBatchGroupByOutputType = {
    id: string
    filename: string
    importedBy: string
    importDate: Date
    totalRecords: number
    successfulRecords: number
    failedRecords: number
    validationStatus: string
    validationErrors: string | null
    rollbackDate: Date | null
    rollbackBy: string | null
    _count: AssetImportBatchCountAggregateOutputType | null
    _avg: AssetImportBatchAvgAggregateOutputType | null
    _sum: AssetImportBatchSumAggregateOutputType | null
    _min: AssetImportBatchMinAggregateOutputType | null
    _max: AssetImportBatchMaxAggregateOutputType | null
  }

  type GetAssetImportBatchGroupByPayload<T extends AssetImportBatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetImportBatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetImportBatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetImportBatchGroupByOutputType[P]>
            : GetScalarType<T[P], AssetImportBatchGroupByOutputType[P]>
        }
      >
    >


  export type AssetImportBatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    importedBy?: boolean
    importDate?: boolean
    totalRecords?: boolean
    successfulRecords?: boolean
    failedRecords?: boolean
    validationStatus?: boolean
    validationErrors?: boolean
    rollbackDate?: boolean
    rollbackBy?: boolean
    assets?: boolean | AssetImportBatch$assetsArgs<ExtArgs>
    validationLogs?: boolean | AssetImportBatch$validationLogsArgs<ExtArgs>
    _count?: boolean | AssetImportBatchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assetImportBatch"]>

  export type AssetImportBatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    importedBy?: boolean
    importDate?: boolean
    totalRecords?: boolean
    successfulRecords?: boolean
    failedRecords?: boolean
    validationStatus?: boolean
    validationErrors?: boolean
    rollbackDate?: boolean
    rollbackBy?: boolean
  }, ExtArgs["result"]["assetImportBatch"]>

  export type AssetImportBatchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    importedBy?: boolean
    importDate?: boolean
    totalRecords?: boolean
    successfulRecords?: boolean
    failedRecords?: boolean
    validationStatus?: boolean
    validationErrors?: boolean
    rollbackDate?: boolean
    rollbackBy?: boolean
  }, ExtArgs["result"]["assetImportBatch"]>

  export type AssetImportBatchSelectScalar = {
    id?: boolean
    filename?: boolean
    importedBy?: boolean
    importDate?: boolean
    totalRecords?: boolean
    successfulRecords?: boolean
    failedRecords?: boolean
    validationStatus?: boolean
    validationErrors?: boolean
    rollbackDate?: boolean
    rollbackBy?: boolean
  }

  export type AssetImportBatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "filename" | "importedBy" | "importDate" | "totalRecords" | "successfulRecords" | "failedRecords" | "validationStatus" | "validationErrors" | "rollbackDate" | "rollbackBy", ExtArgs["result"]["assetImportBatch"]>
  export type AssetImportBatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assets?: boolean | AssetImportBatch$assetsArgs<ExtArgs>
    validationLogs?: boolean | AssetImportBatch$validationLogsArgs<ExtArgs>
    _count?: boolean | AssetImportBatchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AssetImportBatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AssetImportBatchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AssetImportBatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssetImportBatch"
    objects: {
      assets: Prisma.$InventoryAssetPayload<ExtArgs>[]
      validationLogs: Prisma.$AssetValidationLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      filename: string
      importedBy: string
      importDate: Date
      totalRecords: number
      successfulRecords: number
      failedRecords: number
      validationStatus: string
      validationErrors: string | null
      rollbackDate: Date | null
      rollbackBy: string | null
    }, ExtArgs["result"]["assetImportBatch"]>
    composites: {}
  }

  type AssetImportBatchGetPayload<S extends boolean | null | undefined | AssetImportBatchDefaultArgs> = $Result.GetResult<Prisma.$AssetImportBatchPayload, S>

  type AssetImportBatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssetImportBatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssetImportBatchCountAggregateInputType | true
    }

  export interface AssetImportBatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssetImportBatch'], meta: { name: 'AssetImportBatch' } }
    /**
     * Find zero or one AssetImportBatch that matches the filter.
     * @param {AssetImportBatchFindUniqueArgs} args - Arguments to find a AssetImportBatch
     * @example
     * // Get one AssetImportBatch
     * const assetImportBatch = await prisma.assetImportBatch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetImportBatchFindUniqueArgs>(args: SelectSubset<T, AssetImportBatchFindUniqueArgs<ExtArgs>>): Prisma__AssetImportBatchClient<$Result.GetResult<Prisma.$AssetImportBatchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AssetImportBatch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssetImportBatchFindUniqueOrThrowArgs} args - Arguments to find a AssetImportBatch
     * @example
     * // Get one AssetImportBatch
     * const assetImportBatch = await prisma.assetImportBatch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetImportBatchFindUniqueOrThrowArgs>(args: SelectSubset<T, AssetImportBatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssetImportBatchClient<$Result.GetResult<Prisma.$AssetImportBatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssetImportBatch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetImportBatchFindFirstArgs} args - Arguments to find a AssetImportBatch
     * @example
     * // Get one AssetImportBatch
     * const assetImportBatch = await prisma.assetImportBatch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetImportBatchFindFirstArgs>(args?: SelectSubset<T, AssetImportBatchFindFirstArgs<ExtArgs>>): Prisma__AssetImportBatchClient<$Result.GetResult<Prisma.$AssetImportBatchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssetImportBatch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetImportBatchFindFirstOrThrowArgs} args - Arguments to find a AssetImportBatch
     * @example
     * // Get one AssetImportBatch
     * const assetImportBatch = await prisma.assetImportBatch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetImportBatchFindFirstOrThrowArgs>(args?: SelectSubset<T, AssetImportBatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssetImportBatchClient<$Result.GetResult<Prisma.$AssetImportBatchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AssetImportBatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetImportBatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssetImportBatches
     * const assetImportBatches = await prisma.assetImportBatch.findMany()
     * 
     * // Get first 10 AssetImportBatches
     * const assetImportBatches = await prisma.assetImportBatch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetImportBatchWithIdOnly = await prisma.assetImportBatch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssetImportBatchFindManyArgs>(args?: SelectSubset<T, AssetImportBatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetImportBatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AssetImportBatch.
     * @param {AssetImportBatchCreateArgs} args - Arguments to create a AssetImportBatch.
     * @example
     * // Create one AssetImportBatch
     * const AssetImportBatch = await prisma.assetImportBatch.create({
     *   data: {
     *     // ... data to create a AssetImportBatch
     *   }
     * })
     * 
     */
    create<T extends AssetImportBatchCreateArgs>(args: SelectSubset<T, AssetImportBatchCreateArgs<ExtArgs>>): Prisma__AssetImportBatchClient<$Result.GetResult<Prisma.$AssetImportBatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AssetImportBatches.
     * @param {AssetImportBatchCreateManyArgs} args - Arguments to create many AssetImportBatches.
     * @example
     * // Create many AssetImportBatches
     * const assetImportBatch = await prisma.assetImportBatch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssetImportBatchCreateManyArgs>(args?: SelectSubset<T, AssetImportBatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssetImportBatches and returns the data saved in the database.
     * @param {AssetImportBatchCreateManyAndReturnArgs} args - Arguments to create many AssetImportBatches.
     * @example
     * // Create many AssetImportBatches
     * const assetImportBatch = await prisma.assetImportBatch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssetImportBatches and only return the `id`
     * const assetImportBatchWithIdOnly = await prisma.assetImportBatch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssetImportBatchCreateManyAndReturnArgs>(args?: SelectSubset<T, AssetImportBatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetImportBatchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AssetImportBatch.
     * @param {AssetImportBatchDeleteArgs} args - Arguments to delete one AssetImportBatch.
     * @example
     * // Delete one AssetImportBatch
     * const AssetImportBatch = await prisma.assetImportBatch.delete({
     *   where: {
     *     // ... filter to delete one AssetImportBatch
     *   }
     * })
     * 
     */
    delete<T extends AssetImportBatchDeleteArgs>(args: SelectSubset<T, AssetImportBatchDeleteArgs<ExtArgs>>): Prisma__AssetImportBatchClient<$Result.GetResult<Prisma.$AssetImportBatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AssetImportBatch.
     * @param {AssetImportBatchUpdateArgs} args - Arguments to update one AssetImportBatch.
     * @example
     * // Update one AssetImportBatch
     * const assetImportBatch = await prisma.assetImportBatch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssetImportBatchUpdateArgs>(args: SelectSubset<T, AssetImportBatchUpdateArgs<ExtArgs>>): Prisma__AssetImportBatchClient<$Result.GetResult<Prisma.$AssetImportBatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AssetImportBatches.
     * @param {AssetImportBatchDeleteManyArgs} args - Arguments to filter AssetImportBatches to delete.
     * @example
     * // Delete a few AssetImportBatches
     * const { count } = await prisma.assetImportBatch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssetImportBatchDeleteManyArgs>(args?: SelectSubset<T, AssetImportBatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssetImportBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetImportBatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssetImportBatches
     * const assetImportBatch = await prisma.assetImportBatch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssetImportBatchUpdateManyArgs>(args: SelectSubset<T, AssetImportBatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssetImportBatches and returns the data updated in the database.
     * @param {AssetImportBatchUpdateManyAndReturnArgs} args - Arguments to update many AssetImportBatches.
     * @example
     * // Update many AssetImportBatches
     * const assetImportBatch = await prisma.assetImportBatch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AssetImportBatches and only return the `id`
     * const assetImportBatchWithIdOnly = await prisma.assetImportBatch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssetImportBatchUpdateManyAndReturnArgs>(args: SelectSubset<T, AssetImportBatchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetImportBatchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AssetImportBatch.
     * @param {AssetImportBatchUpsertArgs} args - Arguments to update or create a AssetImportBatch.
     * @example
     * // Update or create a AssetImportBatch
     * const assetImportBatch = await prisma.assetImportBatch.upsert({
     *   create: {
     *     // ... data to create a AssetImportBatch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssetImportBatch we want to update
     *   }
     * })
     */
    upsert<T extends AssetImportBatchUpsertArgs>(args: SelectSubset<T, AssetImportBatchUpsertArgs<ExtArgs>>): Prisma__AssetImportBatchClient<$Result.GetResult<Prisma.$AssetImportBatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AssetImportBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetImportBatchCountArgs} args - Arguments to filter AssetImportBatches to count.
     * @example
     * // Count the number of AssetImportBatches
     * const count = await prisma.assetImportBatch.count({
     *   where: {
     *     // ... the filter for the AssetImportBatches we want to count
     *   }
     * })
    **/
    count<T extends AssetImportBatchCountArgs>(
      args?: Subset<T, AssetImportBatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetImportBatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssetImportBatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetImportBatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetImportBatchAggregateArgs>(args: Subset<T, AssetImportBatchAggregateArgs>): Prisma.PrismaPromise<GetAssetImportBatchAggregateType<T>>

    /**
     * Group by AssetImportBatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetImportBatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetImportBatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetImportBatchGroupByArgs['orderBy'] }
        : { orderBy?: AssetImportBatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetImportBatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetImportBatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssetImportBatch model
   */
  readonly fields: AssetImportBatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssetImportBatch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetImportBatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assets<T extends AssetImportBatch$assetsArgs<ExtArgs> = {}>(args?: Subset<T, AssetImportBatch$assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryAssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    validationLogs<T extends AssetImportBatch$validationLogsArgs<ExtArgs> = {}>(args?: Subset<T, AssetImportBatch$validationLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetValidationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssetImportBatch model
   */
  interface AssetImportBatchFieldRefs {
    readonly id: FieldRef<"AssetImportBatch", 'String'>
    readonly filename: FieldRef<"AssetImportBatch", 'String'>
    readonly importedBy: FieldRef<"AssetImportBatch", 'String'>
    readonly importDate: FieldRef<"AssetImportBatch", 'DateTime'>
    readonly totalRecords: FieldRef<"AssetImportBatch", 'Int'>
    readonly successfulRecords: FieldRef<"AssetImportBatch", 'Int'>
    readonly failedRecords: FieldRef<"AssetImportBatch", 'Int'>
    readonly validationStatus: FieldRef<"AssetImportBatch", 'String'>
    readonly validationErrors: FieldRef<"AssetImportBatch", 'String'>
    readonly rollbackDate: FieldRef<"AssetImportBatch", 'DateTime'>
    readonly rollbackBy: FieldRef<"AssetImportBatch", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AssetImportBatch findUnique
   */
  export type AssetImportBatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetImportBatch
     */
    select?: AssetImportBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetImportBatch
     */
    omit?: AssetImportBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetImportBatchInclude<ExtArgs> | null
    /**
     * Filter, which AssetImportBatch to fetch.
     */
    where: AssetImportBatchWhereUniqueInput
  }

  /**
   * AssetImportBatch findUniqueOrThrow
   */
  export type AssetImportBatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetImportBatch
     */
    select?: AssetImportBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetImportBatch
     */
    omit?: AssetImportBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetImportBatchInclude<ExtArgs> | null
    /**
     * Filter, which AssetImportBatch to fetch.
     */
    where: AssetImportBatchWhereUniqueInput
  }

  /**
   * AssetImportBatch findFirst
   */
  export type AssetImportBatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetImportBatch
     */
    select?: AssetImportBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetImportBatch
     */
    omit?: AssetImportBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetImportBatchInclude<ExtArgs> | null
    /**
     * Filter, which AssetImportBatch to fetch.
     */
    where?: AssetImportBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetImportBatches to fetch.
     */
    orderBy?: AssetImportBatchOrderByWithRelationInput | AssetImportBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetImportBatches.
     */
    cursor?: AssetImportBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetImportBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetImportBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetImportBatches.
     */
    distinct?: AssetImportBatchScalarFieldEnum | AssetImportBatchScalarFieldEnum[]
  }

  /**
   * AssetImportBatch findFirstOrThrow
   */
  export type AssetImportBatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetImportBatch
     */
    select?: AssetImportBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetImportBatch
     */
    omit?: AssetImportBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetImportBatchInclude<ExtArgs> | null
    /**
     * Filter, which AssetImportBatch to fetch.
     */
    where?: AssetImportBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetImportBatches to fetch.
     */
    orderBy?: AssetImportBatchOrderByWithRelationInput | AssetImportBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetImportBatches.
     */
    cursor?: AssetImportBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetImportBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetImportBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetImportBatches.
     */
    distinct?: AssetImportBatchScalarFieldEnum | AssetImportBatchScalarFieldEnum[]
  }

  /**
   * AssetImportBatch findMany
   */
  export type AssetImportBatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetImportBatch
     */
    select?: AssetImportBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetImportBatch
     */
    omit?: AssetImportBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetImportBatchInclude<ExtArgs> | null
    /**
     * Filter, which AssetImportBatches to fetch.
     */
    where?: AssetImportBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetImportBatches to fetch.
     */
    orderBy?: AssetImportBatchOrderByWithRelationInput | AssetImportBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssetImportBatches.
     */
    cursor?: AssetImportBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetImportBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetImportBatches.
     */
    skip?: number
    distinct?: AssetImportBatchScalarFieldEnum | AssetImportBatchScalarFieldEnum[]
  }

  /**
   * AssetImportBatch create
   */
  export type AssetImportBatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetImportBatch
     */
    select?: AssetImportBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetImportBatch
     */
    omit?: AssetImportBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetImportBatchInclude<ExtArgs> | null
    /**
     * The data needed to create a AssetImportBatch.
     */
    data: XOR<AssetImportBatchCreateInput, AssetImportBatchUncheckedCreateInput>
  }

  /**
   * AssetImportBatch createMany
   */
  export type AssetImportBatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssetImportBatches.
     */
    data: AssetImportBatchCreateManyInput | AssetImportBatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssetImportBatch createManyAndReturn
   */
  export type AssetImportBatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetImportBatch
     */
    select?: AssetImportBatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssetImportBatch
     */
    omit?: AssetImportBatchOmit<ExtArgs> | null
    /**
     * The data used to create many AssetImportBatches.
     */
    data: AssetImportBatchCreateManyInput | AssetImportBatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssetImportBatch update
   */
  export type AssetImportBatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetImportBatch
     */
    select?: AssetImportBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetImportBatch
     */
    omit?: AssetImportBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetImportBatchInclude<ExtArgs> | null
    /**
     * The data needed to update a AssetImportBatch.
     */
    data: XOR<AssetImportBatchUpdateInput, AssetImportBatchUncheckedUpdateInput>
    /**
     * Choose, which AssetImportBatch to update.
     */
    where: AssetImportBatchWhereUniqueInput
  }

  /**
   * AssetImportBatch updateMany
   */
  export type AssetImportBatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssetImportBatches.
     */
    data: XOR<AssetImportBatchUpdateManyMutationInput, AssetImportBatchUncheckedUpdateManyInput>
    /**
     * Filter which AssetImportBatches to update
     */
    where?: AssetImportBatchWhereInput
    /**
     * Limit how many AssetImportBatches to update.
     */
    limit?: number
  }

  /**
   * AssetImportBatch updateManyAndReturn
   */
  export type AssetImportBatchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetImportBatch
     */
    select?: AssetImportBatchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssetImportBatch
     */
    omit?: AssetImportBatchOmit<ExtArgs> | null
    /**
     * The data used to update AssetImportBatches.
     */
    data: XOR<AssetImportBatchUpdateManyMutationInput, AssetImportBatchUncheckedUpdateManyInput>
    /**
     * Filter which AssetImportBatches to update
     */
    where?: AssetImportBatchWhereInput
    /**
     * Limit how many AssetImportBatches to update.
     */
    limit?: number
  }

  /**
   * AssetImportBatch upsert
   */
  export type AssetImportBatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetImportBatch
     */
    select?: AssetImportBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetImportBatch
     */
    omit?: AssetImportBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetImportBatchInclude<ExtArgs> | null
    /**
     * The filter to search for the AssetImportBatch to update in case it exists.
     */
    where: AssetImportBatchWhereUniqueInput
    /**
     * In case the AssetImportBatch found by the `where` argument doesn't exist, create a new AssetImportBatch with this data.
     */
    create: XOR<AssetImportBatchCreateInput, AssetImportBatchUncheckedCreateInput>
    /**
     * In case the AssetImportBatch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetImportBatchUpdateInput, AssetImportBatchUncheckedUpdateInput>
  }

  /**
   * AssetImportBatch delete
   */
  export type AssetImportBatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetImportBatch
     */
    select?: AssetImportBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetImportBatch
     */
    omit?: AssetImportBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetImportBatchInclude<ExtArgs> | null
    /**
     * Filter which AssetImportBatch to delete.
     */
    where: AssetImportBatchWhereUniqueInput
  }

  /**
   * AssetImportBatch deleteMany
   */
  export type AssetImportBatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetImportBatches to delete
     */
    where?: AssetImportBatchWhereInput
    /**
     * Limit how many AssetImportBatches to delete.
     */
    limit?: number
  }

  /**
   * AssetImportBatch.assets
   */
  export type AssetImportBatch$assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAsset
     */
    select?: InventoryAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAsset
     */
    omit?: InventoryAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAssetInclude<ExtArgs> | null
    where?: InventoryAssetWhereInput
    orderBy?: InventoryAssetOrderByWithRelationInput | InventoryAssetOrderByWithRelationInput[]
    cursor?: InventoryAssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryAssetScalarFieldEnum | InventoryAssetScalarFieldEnum[]
  }

  /**
   * AssetImportBatch.validationLogs
   */
  export type AssetImportBatch$validationLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetValidationLog
     */
    select?: AssetValidationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetValidationLog
     */
    omit?: AssetValidationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetValidationLogInclude<ExtArgs> | null
    where?: AssetValidationLogWhereInput
    orderBy?: AssetValidationLogOrderByWithRelationInput | AssetValidationLogOrderByWithRelationInput[]
    cursor?: AssetValidationLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetValidationLogScalarFieldEnum | AssetValidationLogScalarFieldEnum[]
  }

  /**
   * AssetImportBatch without action
   */
  export type AssetImportBatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetImportBatch
     */
    select?: AssetImportBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetImportBatch
     */
    omit?: AssetImportBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetImportBatchInclude<ExtArgs> | null
  }


  /**
   * Model AssetValidationLog
   */

  export type AggregateAssetValidationLog = {
    _count: AssetValidationLogCountAggregateOutputType | null
    _avg: AssetValidationLogAvgAggregateOutputType | null
    _sum: AssetValidationLogSumAggregateOutputType | null
    _min: AssetValidationLogMinAggregateOutputType | null
    _max: AssetValidationLogMaxAggregateOutputType | null
  }

  export type AssetValidationLogAvgAggregateOutputType = {
    id: number | null
    assetId: number | null
    rowNumber: number | null
  }

  export type AssetValidationLogSumAggregateOutputType = {
    id: number | null
    assetId: number | null
    rowNumber: number | null
  }

  export type AssetValidationLogMinAggregateOutputType = {
    id: number | null
    batchId: string | null
    assetId: number | null
    rowNumber: number | null
    validationLevel: string | null
    fieldName: string | null
    message: string | null
    createdAt: Date | null
  }

  export type AssetValidationLogMaxAggregateOutputType = {
    id: number | null
    batchId: string | null
    assetId: number | null
    rowNumber: number | null
    validationLevel: string | null
    fieldName: string | null
    message: string | null
    createdAt: Date | null
  }

  export type AssetValidationLogCountAggregateOutputType = {
    id: number
    batchId: number
    assetId: number
    rowNumber: number
    validationLevel: number
    fieldName: number
    message: number
    rawData: number
    createdAt: number
    _all: number
  }


  export type AssetValidationLogAvgAggregateInputType = {
    id?: true
    assetId?: true
    rowNumber?: true
  }

  export type AssetValidationLogSumAggregateInputType = {
    id?: true
    assetId?: true
    rowNumber?: true
  }

  export type AssetValidationLogMinAggregateInputType = {
    id?: true
    batchId?: true
    assetId?: true
    rowNumber?: true
    validationLevel?: true
    fieldName?: true
    message?: true
    createdAt?: true
  }

  export type AssetValidationLogMaxAggregateInputType = {
    id?: true
    batchId?: true
    assetId?: true
    rowNumber?: true
    validationLevel?: true
    fieldName?: true
    message?: true
    createdAt?: true
  }

  export type AssetValidationLogCountAggregateInputType = {
    id?: true
    batchId?: true
    assetId?: true
    rowNumber?: true
    validationLevel?: true
    fieldName?: true
    message?: true
    rawData?: true
    createdAt?: true
    _all?: true
  }

  export type AssetValidationLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetValidationLog to aggregate.
     */
    where?: AssetValidationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetValidationLogs to fetch.
     */
    orderBy?: AssetValidationLogOrderByWithRelationInput | AssetValidationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetValidationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetValidationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetValidationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssetValidationLogs
    **/
    _count?: true | AssetValidationLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssetValidationLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssetValidationLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetValidationLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetValidationLogMaxAggregateInputType
  }

  export type GetAssetValidationLogAggregateType<T extends AssetValidationLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAssetValidationLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssetValidationLog[P]>
      : GetScalarType<T[P], AggregateAssetValidationLog[P]>
  }




  export type AssetValidationLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetValidationLogWhereInput
    orderBy?: AssetValidationLogOrderByWithAggregationInput | AssetValidationLogOrderByWithAggregationInput[]
    by: AssetValidationLogScalarFieldEnum[] | AssetValidationLogScalarFieldEnum
    having?: AssetValidationLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetValidationLogCountAggregateInputType | true
    _avg?: AssetValidationLogAvgAggregateInputType
    _sum?: AssetValidationLogSumAggregateInputType
    _min?: AssetValidationLogMinAggregateInputType
    _max?: AssetValidationLogMaxAggregateInputType
  }

  export type AssetValidationLogGroupByOutputType = {
    id: number
    batchId: string
    assetId: number | null
    rowNumber: number
    validationLevel: string
    fieldName: string | null
    message: string
    rawData: JsonValue | null
    createdAt: Date
    _count: AssetValidationLogCountAggregateOutputType | null
    _avg: AssetValidationLogAvgAggregateOutputType | null
    _sum: AssetValidationLogSumAggregateOutputType | null
    _min: AssetValidationLogMinAggregateOutputType | null
    _max: AssetValidationLogMaxAggregateOutputType | null
  }

  type GetAssetValidationLogGroupByPayload<T extends AssetValidationLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetValidationLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetValidationLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetValidationLogGroupByOutputType[P]>
            : GetScalarType<T[P], AssetValidationLogGroupByOutputType[P]>
        }
      >
    >


  export type AssetValidationLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchId?: boolean
    assetId?: boolean
    rowNumber?: boolean
    validationLevel?: boolean
    fieldName?: boolean
    message?: boolean
    rawData?: boolean
    createdAt?: boolean
    batch?: boolean | AssetImportBatchDefaultArgs<ExtArgs>
    asset?: boolean | AssetValidationLog$assetArgs<ExtArgs>
  }, ExtArgs["result"]["assetValidationLog"]>

  export type AssetValidationLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchId?: boolean
    assetId?: boolean
    rowNumber?: boolean
    validationLevel?: boolean
    fieldName?: boolean
    message?: boolean
    rawData?: boolean
    createdAt?: boolean
    batch?: boolean | AssetImportBatchDefaultArgs<ExtArgs>
    asset?: boolean | AssetValidationLog$assetArgs<ExtArgs>
  }, ExtArgs["result"]["assetValidationLog"]>

  export type AssetValidationLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchId?: boolean
    assetId?: boolean
    rowNumber?: boolean
    validationLevel?: boolean
    fieldName?: boolean
    message?: boolean
    rawData?: boolean
    createdAt?: boolean
    batch?: boolean | AssetImportBatchDefaultArgs<ExtArgs>
    asset?: boolean | AssetValidationLog$assetArgs<ExtArgs>
  }, ExtArgs["result"]["assetValidationLog"]>

  export type AssetValidationLogSelectScalar = {
    id?: boolean
    batchId?: boolean
    assetId?: boolean
    rowNumber?: boolean
    validationLevel?: boolean
    fieldName?: boolean
    message?: boolean
    rawData?: boolean
    createdAt?: boolean
  }

  export type AssetValidationLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "batchId" | "assetId" | "rowNumber" | "validationLevel" | "fieldName" | "message" | "rawData" | "createdAt", ExtArgs["result"]["assetValidationLog"]>
  export type AssetValidationLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | AssetImportBatchDefaultArgs<ExtArgs>
    asset?: boolean | AssetValidationLog$assetArgs<ExtArgs>
  }
  export type AssetValidationLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | AssetImportBatchDefaultArgs<ExtArgs>
    asset?: boolean | AssetValidationLog$assetArgs<ExtArgs>
  }
  export type AssetValidationLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | AssetImportBatchDefaultArgs<ExtArgs>
    asset?: boolean | AssetValidationLog$assetArgs<ExtArgs>
  }

  export type $AssetValidationLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssetValidationLog"
    objects: {
      batch: Prisma.$AssetImportBatchPayload<ExtArgs>
      asset: Prisma.$InventoryAssetPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      batchId: string
      assetId: number | null
      rowNumber: number
      validationLevel: string
      fieldName: string | null
      message: string
      rawData: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["assetValidationLog"]>
    composites: {}
  }

  type AssetValidationLogGetPayload<S extends boolean | null | undefined | AssetValidationLogDefaultArgs> = $Result.GetResult<Prisma.$AssetValidationLogPayload, S>

  type AssetValidationLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssetValidationLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssetValidationLogCountAggregateInputType | true
    }

  export interface AssetValidationLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssetValidationLog'], meta: { name: 'AssetValidationLog' } }
    /**
     * Find zero or one AssetValidationLog that matches the filter.
     * @param {AssetValidationLogFindUniqueArgs} args - Arguments to find a AssetValidationLog
     * @example
     * // Get one AssetValidationLog
     * const assetValidationLog = await prisma.assetValidationLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetValidationLogFindUniqueArgs>(args: SelectSubset<T, AssetValidationLogFindUniqueArgs<ExtArgs>>): Prisma__AssetValidationLogClient<$Result.GetResult<Prisma.$AssetValidationLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AssetValidationLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssetValidationLogFindUniqueOrThrowArgs} args - Arguments to find a AssetValidationLog
     * @example
     * // Get one AssetValidationLog
     * const assetValidationLog = await prisma.assetValidationLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetValidationLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AssetValidationLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssetValidationLogClient<$Result.GetResult<Prisma.$AssetValidationLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssetValidationLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetValidationLogFindFirstArgs} args - Arguments to find a AssetValidationLog
     * @example
     * // Get one AssetValidationLog
     * const assetValidationLog = await prisma.assetValidationLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetValidationLogFindFirstArgs>(args?: SelectSubset<T, AssetValidationLogFindFirstArgs<ExtArgs>>): Prisma__AssetValidationLogClient<$Result.GetResult<Prisma.$AssetValidationLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssetValidationLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetValidationLogFindFirstOrThrowArgs} args - Arguments to find a AssetValidationLog
     * @example
     * // Get one AssetValidationLog
     * const assetValidationLog = await prisma.assetValidationLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetValidationLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AssetValidationLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssetValidationLogClient<$Result.GetResult<Prisma.$AssetValidationLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AssetValidationLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetValidationLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssetValidationLogs
     * const assetValidationLogs = await prisma.assetValidationLog.findMany()
     * 
     * // Get first 10 AssetValidationLogs
     * const assetValidationLogs = await prisma.assetValidationLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetValidationLogWithIdOnly = await prisma.assetValidationLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssetValidationLogFindManyArgs>(args?: SelectSubset<T, AssetValidationLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetValidationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AssetValidationLog.
     * @param {AssetValidationLogCreateArgs} args - Arguments to create a AssetValidationLog.
     * @example
     * // Create one AssetValidationLog
     * const AssetValidationLog = await prisma.assetValidationLog.create({
     *   data: {
     *     // ... data to create a AssetValidationLog
     *   }
     * })
     * 
     */
    create<T extends AssetValidationLogCreateArgs>(args: SelectSubset<T, AssetValidationLogCreateArgs<ExtArgs>>): Prisma__AssetValidationLogClient<$Result.GetResult<Prisma.$AssetValidationLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AssetValidationLogs.
     * @param {AssetValidationLogCreateManyArgs} args - Arguments to create many AssetValidationLogs.
     * @example
     * // Create many AssetValidationLogs
     * const assetValidationLog = await prisma.assetValidationLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssetValidationLogCreateManyArgs>(args?: SelectSubset<T, AssetValidationLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssetValidationLogs and returns the data saved in the database.
     * @param {AssetValidationLogCreateManyAndReturnArgs} args - Arguments to create many AssetValidationLogs.
     * @example
     * // Create many AssetValidationLogs
     * const assetValidationLog = await prisma.assetValidationLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssetValidationLogs and only return the `id`
     * const assetValidationLogWithIdOnly = await prisma.assetValidationLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssetValidationLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AssetValidationLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetValidationLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AssetValidationLog.
     * @param {AssetValidationLogDeleteArgs} args - Arguments to delete one AssetValidationLog.
     * @example
     * // Delete one AssetValidationLog
     * const AssetValidationLog = await prisma.assetValidationLog.delete({
     *   where: {
     *     // ... filter to delete one AssetValidationLog
     *   }
     * })
     * 
     */
    delete<T extends AssetValidationLogDeleteArgs>(args: SelectSubset<T, AssetValidationLogDeleteArgs<ExtArgs>>): Prisma__AssetValidationLogClient<$Result.GetResult<Prisma.$AssetValidationLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AssetValidationLog.
     * @param {AssetValidationLogUpdateArgs} args - Arguments to update one AssetValidationLog.
     * @example
     * // Update one AssetValidationLog
     * const assetValidationLog = await prisma.assetValidationLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssetValidationLogUpdateArgs>(args: SelectSubset<T, AssetValidationLogUpdateArgs<ExtArgs>>): Prisma__AssetValidationLogClient<$Result.GetResult<Prisma.$AssetValidationLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AssetValidationLogs.
     * @param {AssetValidationLogDeleteManyArgs} args - Arguments to filter AssetValidationLogs to delete.
     * @example
     * // Delete a few AssetValidationLogs
     * const { count } = await prisma.assetValidationLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssetValidationLogDeleteManyArgs>(args?: SelectSubset<T, AssetValidationLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssetValidationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetValidationLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssetValidationLogs
     * const assetValidationLog = await prisma.assetValidationLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssetValidationLogUpdateManyArgs>(args: SelectSubset<T, AssetValidationLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssetValidationLogs and returns the data updated in the database.
     * @param {AssetValidationLogUpdateManyAndReturnArgs} args - Arguments to update many AssetValidationLogs.
     * @example
     * // Update many AssetValidationLogs
     * const assetValidationLog = await prisma.assetValidationLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AssetValidationLogs and only return the `id`
     * const assetValidationLogWithIdOnly = await prisma.assetValidationLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssetValidationLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AssetValidationLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetValidationLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AssetValidationLog.
     * @param {AssetValidationLogUpsertArgs} args - Arguments to update or create a AssetValidationLog.
     * @example
     * // Update or create a AssetValidationLog
     * const assetValidationLog = await prisma.assetValidationLog.upsert({
     *   create: {
     *     // ... data to create a AssetValidationLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssetValidationLog we want to update
     *   }
     * })
     */
    upsert<T extends AssetValidationLogUpsertArgs>(args: SelectSubset<T, AssetValidationLogUpsertArgs<ExtArgs>>): Prisma__AssetValidationLogClient<$Result.GetResult<Prisma.$AssetValidationLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AssetValidationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetValidationLogCountArgs} args - Arguments to filter AssetValidationLogs to count.
     * @example
     * // Count the number of AssetValidationLogs
     * const count = await prisma.assetValidationLog.count({
     *   where: {
     *     // ... the filter for the AssetValidationLogs we want to count
     *   }
     * })
    **/
    count<T extends AssetValidationLogCountArgs>(
      args?: Subset<T, AssetValidationLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetValidationLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssetValidationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetValidationLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetValidationLogAggregateArgs>(args: Subset<T, AssetValidationLogAggregateArgs>): Prisma.PrismaPromise<GetAssetValidationLogAggregateType<T>>

    /**
     * Group by AssetValidationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetValidationLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetValidationLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetValidationLogGroupByArgs['orderBy'] }
        : { orderBy?: AssetValidationLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetValidationLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetValidationLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssetValidationLog model
   */
  readonly fields: AssetValidationLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssetValidationLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetValidationLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    batch<T extends AssetImportBatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssetImportBatchDefaultArgs<ExtArgs>>): Prisma__AssetImportBatchClient<$Result.GetResult<Prisma.$AssetImportBatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    asset<T extends AssetValidationLog$assetArgs<ExtArgs> = {}>(args?: Subset<T, AssetValidationLog$assetArgs<ExtArgs>>): Prisma__InventoryAssetClient<$Result.GetResult<Prisma.$InventoryAssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssetValidationLog model
   */
  interface AssetValidationLogFieldRefs {
    readonly id: FieldRef<"AssetValidationLog", 'Int'>
    readonly batchId: FieldRef<"AssetValidationLog", 'String'>
    readonly assetId: FieldRef<"AssetValidationLog", 'Int'>
    readonly rowNumber: FieldRef<"AssetValidationLog", 'Int'>
    readonly validationLevel: FieldRef<"AssetValidationLog", 'String'>
    readonly fieldName: FieldRef<"AssetValidationLog", 'String'>
    readonly message: FieldRef<"AssetValidationLog", 'String'>
    readonly rawData: FieldRef<"AssetValidationLog", 'Json'>
    readonly createdAt: FieldRef<"AssetValidationLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AssetValidationLog findUnique
   */
  export type AssetValidationLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetValidationLog
     */
    select?: AssetValidationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetValidationLog
     */
    omit?: AssetValidationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetValidationLogInclude<ExtArgs> | null
    /**
     * Filter, which AssetValidationLog to fetch.
     */
    where: AssetValidationLogWhereUniqueInput
  }

  /**
   * AssetValidationLog findUniqueOrThrow
   */
  export type AssetValidationLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetValidationLog
     */
    select?: AssetValidationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetValidationLog
     */
    omit?: AssetValidationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetValidationLogInclude<ExtArgs> | null
    /**
     * Filter, which AssetValidationLog to fetch.
     */
    where: AssetValidationLogWhereUniqueInput
  }

  /**
   * AssetValidationLog findFirst
   */
  export type AssetValidationLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetValidationLog
     */
    select?: AssetValidationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetValidationLog
     */
    omit?: AssetValidationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetValidationLogInclude<ExtArgs> | null
    /**
     * Filter, which AssetValidationLog to fetch.
     */
    where?: AssetValidationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetValidationLogs to fetch.
     */
    orderBy?: AssetValidationLogOrderByWithRelationInput | AssetValidationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetValidationLogs.
     */
    cursor?: AssetValidationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetValidationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetValidationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetValidationLogs.
     */
    distinct?: AssetValidationLogScalarFieldEnum | AssetValidationLogScalarFieldEnum[]
  }

  /**
   * AssetValidationLog findFirstOrThrow
   */
  export type AssetValidationLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetValidationLog
     */
    select?: AssetValidationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetValidationLog
     */
    omit?: AssetValidationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetValidationLogInclude<ExtArgs> | null
    /**
     * Filter, which AssetValidationLog to fetch.
     */
    where?: AssetValidationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetValidationLogs to fetch.
     */
    orderBy?: AssetValidationLogOrderByWithRelationInput | AssetValidationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetValidationLogs.
     */
    cursor?: AssetValidationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetValidationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetValidationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetValidationLogs.
     */
    distinct?: AssetValidationLogScalarFieldEnum | AssetValidationLogScalarFieldEnum[]
  }

  /**
   * AssetValidationLog findMany
   */
  export type AssetValidationLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetValidationLog
     */
    select?: AssetValidationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetValidationLog
     */
    omit?: AssetValidationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetValidationLogInclude<ExtArgs> | null
    /**
     * Filter, which AssetValidationLogs to fetch.
     */
    where?: AssetValidationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetValidationLogs to fetch.
     */
    orderBy?: AssetValidationLogOrderByWithRelationInput | AssetValidationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssetValidationLogs.
     */
    cursor?: AssetValidationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetValidationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetValidationLogs.
     */
    skip?: number
    distinct?: AssetValidationLogScalarFieldEnum | AssetValidationLogScalarFieldEnum[]
  }

  /**
   * AssetValidationLog create
   */
  export type AssetValidationLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetValidationLog
     */
    select?: AssetValidationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetValidationLog
     */
    omit?: AssetValidationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetValidationLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AssetValidationLog.
     */
    data: XOR<AssetValidationLogCreateInput, AssetValidationLogUncheckedCreateInput>
  }

  /**
   * AssetValidationLog createMany
   */
  export type AssetValidationLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssetValidationLogs.
     */
    data: AssetValidationLogCreateManyInput | AssetValidationLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssetValidationLog createManyAndReturn
   */
  export type AssetValidationLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetValidationLog
     */
    select?: AssetValidationLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssetValidationLog
     */
    omit?: AssetValidationLogOmit<ExtArgs> | null
    /**
     * The data used to create many AssetValidationLogs.
     */
    data: AssetValidationLogCreateManyInput | AssetValidationLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetValidationLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssetValidationLog update
   */
  export type AssetValidationLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetValidationLog
     */
    select?: AssetValidationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetValidationLog
     */
    omit?: AssetValidationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetValidationLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AssetValidationLog.
     */
    data: XOR<AssetValidationLogUpdateInput, AssetValidationLogUncheckedUpdateInput>
    /**
     * Choose, which AssetValidationLog to update.
     */
    where: AssetValidationLogWhereUniqueInput
  }

  /**
   * AssetValidationLog updateMany
   */
  export type AssetValidationLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssetValidationLogs.
     */
    data: XOR<AssetValidationLogUpdateManyMutationInput, AssetValidationLogUncheckedUpdateManyInput>
    /**
     * Filter which AssetValidationLogs to update
     */
    where?: AssetValidationLogWhereInput
    /**
     * Limit how many AssetValidationLogs to update.
     */
    limit?: number
  }

  /**
   * AssetValidationLog updateManyAndReturn
   */
  export type AssetValidationLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetValidationLog
     */
    select?: AssetValidationLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssetValidationLog
     */
    omit?: AssetValidationLogOmit<ExtArgs> | null
    /**
     * The data used to update AssetValidationLogs.
     */
    data: XOR<AssetValidationLogUpdateManyMutationInput, AssetValidationLogUncheckedUpdateManyInput>
    /**
     * Filter which AssetValidationLogs to update
     */
    where?: AssetValidationLogWhereInput
    /**
     * Limit how many AssetValidationLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetValidationLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssetValidationLog upsert
   */
  export type AssetValidationLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetValidationLog
     */
    select?: AssetValidationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetValidationLog
     */
    omit?: AssetValidationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetValidationLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AssetValidationLog to update in case it exists.
     */
    where: AssetValidationLogWhereUniqueInput
    /**
     * In case the AssetValidationLog found by the `where` argument doesn't exist, create a new AssetValidationLog with this data.
     */
    create: XOR<AssetValidationLogCreateInput, AssetValidationLogUncheckedCreateInput>
    /**
     * In case the AssetValidationLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetValidationLogUpdateInput, AssetValidationLogUncheckedUpdateInput>
  }

  /**
   * AssetValidationLog delete
   */
  export type AssetValidationLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetValidationLog
     */
    select?: AssetValidationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetValidationLog
     */
    omit?: AssetValidationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetValidationLogInclude<ExtArgs> | null
    /**
     * Filter which AssetValidationLog to delete.
     */
    where: AssetValidationLogWhereUniqueInput
  }

  /**
   * AssetValidationLog deleteMany
   */
  export type AssetValidationLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetValidationLogs to delete
     */
    where?: AssetValidationLogWhereInput
    /**
     * Limit how many AssetValidationLogs to delete.
     */
    limit?: number
  }

  /**
   * AssetValidationLog.asset
   */
  export type AssetValidationLog$assetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAsset
     */
    select?: InventoryAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAsset
     */
    omit?: InventoryAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAssetInclude<ExtArgs> | null
    where?: InventoryAssetWhereInput
  }

  /**
   * AssetValidationLog without action
   */
  export type AssetValidationLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetValidationLog
     */
    select?: AssetValidationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetValidationLog
     */
    omit?: AssetValidationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetValidationLogInclude<ExtArgs> | null
  }


  /**
   * Model KioskAssetRegistry
   */

  export type AggregateKioskAssetRegistry = {
    _count: KioskAssetRegistryCountAggregateOutputType | null
    _avg: KioskAssetRegistryAvgAggregateOutputType | null
    _sum: KioskAssetRegistrySumAggregateOutputType | null
    _min: KioskAssetRegistryMinAggregateOutputType | null
    _max: KioskAssetRegistryMaxAggregateOutputType | null
  }

  export type KioskAssetRegistryAvgAggregateOutputType = {
    id: number | null
    assetId: number | null
  }

  export type KioskAssetRegistrySumAggregateOutputType = {
    id: number | null
    assetId: number | null
  }

  export type KioskAssetRegistryMinAggregateOutputType = {
    id: number | null
    kioskId: string | null
    assetId: number | null
    registrationDate: Date | null
    lastCheckIn: Date | null
    status: string | null
    helixSyncStatus: string | null
    helixLastSync: Date | null
    helixErrorMessage: string | null
    encryptedMetadata: string | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type KioskAssetRegistryMaxAggregateOutputType = {
    id: number | null
    kioskId: string | null
    assetId: number | null
    registrationDate: Date | null
    lastCheckIn: Date | null
    status: string | null
    helixSyncStatus: string | null
    helixLastSync: Date | null
    helixErrorMessage: string | null
    encryptedMetadata: string | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type KioskAssetRegistryCountAggregateOutputType = {
    id: number
    kioskId: number
    assetId: number
    registrationDate: number
    lastCheckIn: number
    status: number
    helixSyncStatus: number
    helixLastSync: number
    helixErrorMessage: number
    encryptedMetadata: number
    createdBy: number
    updatedBy: number
    _all: number
  }


  export type KioskAssetRegistryAvgAggregateInputType = {
    id?: true
    assetId?: true
  }

  export type KioskAssetRegistrySumAggregateInputType = {
    id?: true
    assetId?: true
  }

  export type KioskAssetRegistryMinAggregateInputType = {
    id?: true
    kioskId?: true
    assetId?: true
    registrationDate?: true
    lastCheckIn?: true
    status?: true
    helixSyncStatus?: true
    helixLastSync?: true
    helixErrorMessage?: true
    encryptedMetadata?: true
    createdBy?: true
    updatedBy?: true
  }

  export type KioskAssetRegistryMaxAggregateInputType = {
    id?: true
    kioskId?: true
    assetId?: true
    registrationDate?: true
    lastCheckIn?: true
    status?: true
    helixSyncStatus?: true
    helixLastSync?: true
    helixErrorMessage?: true
    encryptedMetadata?: true
    createdBy?: true
    updatedBy?: true
  }

  export type KioskAssetRegistryCountAggregateInputType = {
    id?: true
    kioskId?: true
    assetId?: true
    registrationDate?: true
    lastCheckIn?: true
    status?: true
    helixSyncStatus?: true
    helixLastSync?: true
    helixErrorMessage?: true
    encryptedMetadata?: true
    createdBy?: true
    updatedBy?: true
    _all?: true
  }

  export type KioskAssetRegistryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KioskAssetRegistry to aggregate.
     */
    where?: KioskAssetRegistryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KioskAssetRegistries to fetch.
     */
    orderBy?: KioskAssetRegistryOrderByWithRelationInput | KioskAssetRegistryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KioskAssetRegistryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KioskAssetRegistries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KioskAssetRegistries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KioskAssetRegistries
    **/
    _count?: true | KioskAssetRegistryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KioskAssetRegistryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KioskAssetRegistrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KioskAssetRegistryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KioskAssetRegistryMaxAggregateInputType
  }

  export type GetKioskAssetRegistryAggregateType<T extends KioskAssetRegistryAggregateArgs> = {
        [P in keyof T & keyof AggregateKioskAssetRegistry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKioskAssetRegistry[P]>
      : GetScalarType<T[P], AggregateKioskAssetRegistry[P]>
  }




  export type KioskAssetRegistryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KioskAssetRegistryWhereInput
    orderBy?: KioskAssetRegistryOrderByWithAggregationInput | KioskAssetRegistryOrderByWithAggregationInput[]
    by: KioskAssetRegistryScalarFieldEnum[] | KioskAssetRegistryScalarFieldEnum
    having?: KioskAssetRegistryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KioskAssetRegistryCountAggregateInputType | true
    _avg?: KioskAssetRegistryAvgAggregateInputType
    _sum?: KioskAssetRegistrySumAggregateInputType
    _min?: KioskAssetRegistryMinAggregateInputType
    _max?: KioskAssetRegistryMaxAggregateInputType
  }

  export type KioskAssetRegistryGroupByOutputType = {
    id: number
    kioskId: string
    assetId: number
    registrationDate: Date
    lastCheckIn: Date | null
    status: string
    helixSyncStatus: string
    helixLastSync: Date | null
    helixErrorMessage: string | null
    encryptedMetadata: string | null
    createdBy: string | null
    updatedBy: string | null
    _count: KioskAssetRegistryCountAggregateOutputType | null
    _avg: KioskAssetRegistryAvgAggregateOutputType | null
    _sum: KioskAssetRegistrySumAggregateOutputType | null
    _min: KioskAssetRegistryMinAggregateOutputType | null
    _max: KioskAssetRegistryMaxAggregateOutputType | null
  }

  type GetKioskAssetRegistryGroupByPayload<T extends KioskAssetRegistryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KioskAssetRegistryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KioskAssetRegistryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KioskAssetRegistryGroupByOutputType[P]>
            : GetScalarType<T[P], KioskAssetRegistryGroupByOutputType[P]>
        }
      >
    >


  export type KioskAssetRegistrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kioskId?: boolean
    assetId?: boolean
    registrationDate?: boolean
    lastCheckIn?: boolean
    status?: boolean
    helixSyncStatus?: boolean
    helixLastSync?: boolean
    helixErrorMessage?: boolean
    encryptedMetadata?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    kiosk?: boolean | KioskDefaultArgs<ExtArgs>
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kioskAssetRegistry"]>

  export type KioskAssetRegistrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kioskId?: boolean
    assetId?: boolean
    registrationDate?: boolean
    lastCheckIn?: boolean
    status?: boolean
    helixSyncStatus?: boolean
    helixLastSync?: boolean
    helixErrorMessage?: boolean
    encryptedMetadata?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    kiosk?: boolean | KioskDefaultArgs<ExtArgs>
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kioskAssetRegistry"]>

  export type KioskAssetRegistrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kioskId?: boolean
    assetId?: boolean
    registrationDate?: boolean
    lastCheckIn?: boolean
    status?: boolean
    helixSyncStatus?: boolean
    helixLastSync?: boolean
    helixErrorMessage?: boolean
    encryptedMetadata?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    kiosk?: boolean | KioskDefaultArgs<ExtArgs>
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kioskAssetRegistry"]>

  export type KioskAssetRegistrySelectScalar = {
    id?: boolean
    kioskId?: boolean
    assetId?: boolean
    registrationDate?: boolean
    lastCheckIn?: boolean
    status?: boolean
    helixSyncStatus?: boolean
    helixLastSync?: boolean
    helixErrorMessage?: boolean
    encryptedMetadata?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }

  export type KioskAssetRegistryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "kioskId" | "assetId" | "registrationDate" | "lastCheckIn" | "status" | "helixSyncStatus" | "helixLastSync" | "helixErrorMessage" | "encryptedMetadata" | "createdBy" | "updatedBy", ExtArgs["result"]["kioskAssetRegistry"]>
  export type KioskAssetRegistryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kiosk?: boolean | KioskDefaultArgs<ExtArgs>
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
  }
  export type KioskAssetRegistryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kiosk?: boolean | KioskDefaultArgs<ExtArgs>
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
  }
  export type KioskAssetRegistryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kiosk?: boolean | KioskDefaultArgs<ExtArgs>
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
  }

  export type $KioskAssetRegistryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KioskAssetRegistry"
    objects: {
      kiosk: Prisma.$KioskPayload<ExtArgs>
      asset: Prisma.$InventoryAssetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      kioskId: string
      assetId: number
      registrationDate: Date
      lastCheckIn: Date | null
      status: string
      helixSyncStatus: string
      helixLastSync: Date | null
      helixErrorMessage: string | null
      encryptedMetadata: string | null
      createdBy: string | null
      updatedBy: string | null
    }, ExtArgs["result"]["kioskAssetRegistry"]>
    composites: {}
  }

  type KioskAssetRegistryGetPayload<S extends boolean | null | undefined | KioskAssetRegistryDefaultArgs> = $Result.GetResult<Prisma.$KioskAssetRegistryPayload, S>

  type KioskAssetRegistryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KioskAssetRegistryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KioskAssetRegistryCountAggregateInputType | true
    }

  export interface KioskAssetRegistryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KioskAssetRegistry'], meta: { name: 'KioskAssetRegistry' } }
    /**
     * Find zero or one KioskAssetRegistry that matches the filter.
     * @param {KioskAssetRegistryFindUniqueArgs} args - Arguments to find a KioskAssetRegistry
     * @example
     * // Get one KioskAssetRegistry
     * const kioskAssetRegistry = await prisma.kioskAssetRegistry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KioskAssetRegistryFindUniqueArgs>(args: SelectSubset<T, KioskAssetRegistryFindUniqueArgs<ExtArgs>>): Prisma__KioskAssetRegistryClient<$Result.GetResult<Prisma.$KioskAssetRegistryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KioskAssetRegistry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KioskAssetRegistryFindUniqueOrThrowArgs} args - Arguments to find a KioskAssetRegistry
     * @example
     * // Get one KioskAssetRegistry
     * const kioskAssetRegistry = await prisma.kioskAssetRegistry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KioskAssetRegistryFindUniqueOrThrowArgs>(args: SelectSubset<T, KioskAssetRegistryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KioskAssetRegistryClient<$Result.GetResult<Prisma.$KioskAssetRegistryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KioskAssetRegistry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskAssetRegistryFindFirstArgs} args - Arguments to find a KioskAssetRegistry
     * @example
     * // Get one KioskAssetRegistry
     * const kioskAssetRegistry = await prisma.kioskAssetRegistry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KioskAssetRegistryFindFirstArgs>(args?: SelectSubset<T, KioskAssetRegistryFindFirstArgs<ExtArgs>>): Prisma__KioskAssetRegistryClient<$Result.GetResult<Prisma.$KioskAssetRegistryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KioskAssetRegistry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskAssetRegistryFindFirstOrThrowArgs} args - Arguments to find a KioskAssetRegistry
     * @example
     * // Get one KioskAssetRegistry
     * const kioskAssetRegistry = await prisma.kioskAssetRegistry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KioskAssetRegistryFindFirstOrThrowArgs>(args?: SelectSubset<T, KioskAssetRegistryFindFirstOrThrowArgs<ExtArgs>>): Prisma__KioskAssetRegistryClient<$Result.GetResult<Prisma.$KioskAssetRegistryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KioskAssetRegistries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskAssetRegistryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KioskAssetRegistries
     * const kioskAssetRegistries = await prisma.kioskAssetRegistry.findMany()
     * 
     * // Get first 10 KioskAssetRegistries
     * const kioskAssetRegistries = await prisma.kioskAssetRegistry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kioskAssetRegistryWithIdOnly = await prisma.kioskAssetRegistry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KioskAssetRegistryFindManyArgs>(args?: SelectSubset<T, KioskAssetRegistryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KioskAssetRegistryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KioskAssetRegistry.
     * @param {KioskAssetRegistryCreateArgs} args - Arguments to create a KioskAssetRegistry.
     * @example
     * // Create one KioskAssetRegistry
     * const KioskAssetRegistry = await prisma.kioskAssetRegistry.create({
     *   data: {
     *     // ... data to create a KioskAssetRegistry
     *   }
     * })
     * 
     */
    create<T extends KioskAssetRegistryCreateArgs>(args: SelectSubset<T, KioskAssetRegistryCreateArgs<ExtArgs>>): Prisma__KioskAssetRegistryClient<$Result.GetResult<Prisma.$KioskAssetRegistryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KioskAssetRegistries.
     * @param {KioskAssetRegistryCreateManyArgs} args - Arguments to create many KioskAssetRegistries.
     * @example
     * // Create many KioskAssetRegistries
     * const kioskAssetRegistry = await prisma.kioskAssetRegistry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KioskAssetRegistryCreateManyArgs>(args?: SelectSubset<T, KioskAssetRegistryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KioskAssetRegistries and returns the data saved in the database.
     * @param {KioskAssetRegistryCreateManyAndReturnArgs} args - Arguments to create many KioskAssetRegistries.
     * @example
     * // Create many KioskAssetRegistries
     * const kioskAssetRegistry = await prisma.kioskAssetRegistry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KioskAssetRegistries and only return the `id`
     * const kioskAssetRegistryWithIdOnly = await prisma.kioskAssetRegistry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KioskAssetRegistryCreateManyAndReturnArgs>(args?: SelectSubset<T, KioskAssetRegistryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KioskAssetRegistryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KioskAssetRegistry.
     * @param {KioskAssetRegistryDeleteArgs} args - Arguments to delete one KioskAssetRegistry.
     * @example
     * // Delete one KioskAssetRegistry
     * const KioskAssetRegistry = await prisma.kioskAssetRegistry.delete({
     *   where: {
     *     // ... filter to delete one KioskAssetRegistry
     *   }
     * })
     * 
     */
    delete<T extends KioskAssetRegistryDeleteArgs>(args: SelectSubset<T, KioskAssetRegistryDeleteArgs<ExtArgs>>): Prisma__KioskAssetRegistryClient<$Result.GetResult<Prisma.$KioskAssetRegistryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KioskAssetRegistry.
     * @param {KioskAssetRegistryUpdateArgs} args - Arguments to update one KioskAssetRegistry.
     * @example
     * // Update one KioskAssetRegistry
     * const kioskAssetRegistry = await prisma.kioskAssetRegistry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KioskAssetRegistryUpdateArgs>(args: SelectSubset<T, KioskAssetRegistryUpdateArgs<ExtArgs>>): Prisma__KioskAssetRegistryClient<$Result.GetResult<Prisma.$KioskAssetRegistryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KioskAssetRegistries.
     * @param {KioskAssetRegistryDeleteManyArgs} args - Arguments to filter KioskAssetRegistries to delete.
     * @example
     * // Delete a few KioskAssetRegistries
     * const { count } = await prisma.kioskAssetRegistry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KioskAssetRegistryDeleteManyArgs>(args?: SelectSubset<T, KioskAssetRegistryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KioskAssetRegistries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskAssetRegistryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KioskAssetRegistries
     * const kioskAssetRegistry = await prisma.kioskAssetRegistry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KioskAssetRegistryUpdateManyArgs>(args: SelectSubset<T, KioskAssetRegistryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KioskAssetRegistries and returns the data updated in the database.
     * @param {KioskAssetRegistryUpdateManyAndReturnArgs} args - Arguments to update many KioskAssetRegistries.
     * @example
     * // Update many KioskAssetRegistries
     * const kioskAssetRegistry = await prisma.kioskAssetRegistry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KioskAssetRegistries and only return the `id`
     * const kioskAssetRegistryWithIdOnly = await prisma.kioskAssetRegistry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KioskAssetRegistryUpdateManyAndReturnArgs>(args: SelectSubset<T, KioskAssetRegistryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KioskAssetRegistryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KioskAssetRegistry.
     * @param {KioskAssetRegistryUpsertArgs} args - Arguments to update or create a KioskAssetRegistry.
     * @example
     * // Update or create a KioskAssetRegistry
     * const kioskAssetRegistry = await prisma.kioskAssetRegistry.upsert({
     *   create: {
     *     // ... data to create a KioskAssetRegistry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KioskAssetRegistry we want to update
     *   }
     * })
     */
    upsert<T extends KioskAssetRegistryUpsertArgs>(args: SelectSubset<T, KioskAssetRegistryUpsertArgs<ExtArgs>>): Prisma__KioskAssetRegistryClient<$Result.GetResult<Prisma.$KioskAssetRegistryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KioskAssetRegistries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskAssetRegistryCountArgs} args - Arguments to filter KioskAssetRegistries to count.
     * @example
     * // Count the number of KioskAssetRegistries
     * const count = await prisma.kioskAssetRegistry.count({
     *   where: {
     *     // ... the filter for the KioskAssetRegistries we want to count
     *   }
     * })
    **/
    count<T extends KioskAssetRegistryCountArgs>(
      args?: Subset<T, KioskAssetRegistryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KioskAssetRegistryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KioskAssetRegistry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskAssetRegistryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KioskAssetRegistryAggregateArgs>(args: Subset<T, KioskAssetRegistryAggregateArgs>): Prisma.PrismaPromise<GetKioskAssetRegistryAggregateType<T>>

    /**
     * Group by KioskAssetRegistry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskAssetRegistryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KioskAssetRegistryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KioskAssetRegistryGroupByArgs['orderBy'] }
        : { orderBy?: KioskAssetRegistryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KioskAssetRegistryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKioskAssetRegistryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KioskAssetRegistry model
   */
  readonly fields: KioskAssetRegistryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KioskAssetRegistry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KioskAssetRegistryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kiosk<T extends KioskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KioskDefaultArgs<ExtArgs>>): Prisma__KioskClient<$Result.GetResult<Prisma.$KioskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    asset<T extends InventoryAssetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryAssetDefaultArgs<ExtArgs>>): Prisma__InventoryAssetClient<$Result.GetResult<Prisma.$InventoryAssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KioskAssetRegistry model
   */
  interface KioskAssetRegistryFieldRefs {
    readonly id: FieldRef<"KioskAssetRegistry", 'Int'>
    readonly kioskId: FieldRef<"KioskAssetRegistry", 'String'>
    readonly assetId: FieldRef<"KioskAssetRegistry", 'Int'>
    readonly registrationDate: FieldRef<"KioskAssetRegistry", 'DateTime'>
    readonly lastCheckIn: FieldRef<"KioskAssetRegistry", 'DateTime'>
    readonly status: FieldRef<"KioskAssetRegistry", 'String'>
    readonly helixSyncStatus: FieldRef<"KioskAssetRegistry", 'String'>
    readonly helixLastSync: FieldRef<"KioskAssetRegistry", 'DateTime'>
    readonly helixErrorMessage: FieldRef<"KioskAssetRegistry", 'String'>
    readonly encryptedMetadata: FieldRef<"KioskAssetRegistry", 'String'>
    readonly createdBy: FieldRef<"KioskAssetRegistry", 'String'>
    readonly updatedBy: FieldRef<"KioskAssetRegistry", 'String'>
  }
    

  // Custom InputTypes
  /**
   * KioskAssetRegistry findUnique
   */
  export type KioskAssetRegistryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskAssetRegistry
     */
    select?: KioskAssetRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskAssetRegistry
     */
    omit?: KioskAssetRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskAssetRegistryInclude<ExtArgs> | null
    /**
     * Filter, which KioskAssetRegistry to fetch.
     */
    where: KioskAssetRegistryWhereUniqueInput
  }

  /**
   * KioskAssetRegistry findUniqueOrThrow
   */
  export type KioskAssetRegistryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskAssetRegistry
     */
    select?: KioskAssetRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskAssetRegistry
     */
    omit?: KioskAssetRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskAssetRegistryInclude<ExtArgs> | null
    /**
     * Filter, which KioskAssetRegistry to fetch.
     */
    where: KioskAssetRegistryWhereUniqueInput
  }

  /**
   * KioskAssetRegistry findFirst
   */
  export type KioskAssetRegistryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskAssetRegistry
     */
    select?: KioskAssetRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskAssetRegistry
     */
    omit?: KioskAssetRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskAssetRegistryInclude<ExtArgs> | null
    /**
     * Filter, which KioskAssetRegistry to fetch.
     */
    where?: KioskAssetRegistryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KioskAssetRegistries to fetch.
     */
    orderBy?: KioskAssetRegistryOrderByWithRelationInput | KioskAssetRegistryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KioskAssetRegistries.
     */
    cursor?: KioskAssetRegistryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KioskAssetRegistries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KioskAssetRegistries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KioskAssetRegistries.
     */
    distinct?: KioskAssetRegistryScalarFieldEnum | KioskAssetRegistryScalarFieldEnum[]
  }

  /**
   * KioskAssetRegistry findFirstOrThrow
   */
  export type KioskAssetRegistryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskAssetRegistry
     */
    select?: KioskAssetRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskAssetRegistry
     */
    omit?: KioskAssetRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskAssetRegistryInclude<ExtArgs> | null
    /**
     * Filter, which KioskAssetRegistry to fetch.
     */
    where?: KioskAssetRegistryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KioskAssetRegistries to fetch.
     */
    orderBy?: KioskAssetRegistryOrderByWithRelationInput | KioskAssetRegistryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KioskAssetRegistries.
     */
    cursor?: KioskAssetRegistryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KioskAssetRegistries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KioskAssetRegistries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KioskAssetRegistries.
     */
    distinct?: KioskAssetRegistryScalarFieldEnum | KioskAssetRegistryScalarFieldEnum[]
  }

  /**
   * KioskAssetRegistry findMany
   */
  export type KioskAssetRegistryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskAssetRegistry
     */
    select?: KioskAssetRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskAssetRegistry
     */
    omit?: KioskAssetRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskAssetRegistryInclude<ExtArgs> | null
    /**
     * Filter, which KioskAssetRegistries to fetch.
     */
    where?: KioskAssetRegistryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KioskAssetRegistries to fetch.
     */
    orderBy?: KioskAssetRegistryOrderByWithRelationInput | KioskAssetRegistryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KioskAssetRegistries.
     */
    cursor?: KioskAssetRegistryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KioskAssetRegistries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KioskAssetRegistries.
     */
    skip?: number
    distinct?: KioskAssetRegistryScalarFieldEnum | KioskAssetRegistryScalarFieldEnum[]
  }

  /**
   * KioskAssetRegistry create
   */
  export type KioskAssetRegistryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskAssetRegistry
     */
    select?: KioskAssetRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskAssetRegistry
     */
    omit?: KioskAssetRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskAssetRegistryInclude<ExtArgs> | null
    /**
     * The data needed to create a KioskAssetRegistry.
     */
    data: XOR<KioskAssetRegistryCreateInput, KioskAssetRegistryUncheckedCreateInput>
  }

  /**
   * KioskAssetRegistry createMany
   */
  export type KioskAssetRegistryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KioskAssetRegistries.
     */
    data: KioskAssetRegistryCreateManyInput | KioskAssetRegistryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KioskAssetRegistry createManyAndReturn
   */
  export type KioskAssetRegistryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskAssetRegistry
     */
    select?: KioskAssetRegistrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KioskAssetRegistry
     */
    omit?: KioskAssetRegistryOmit<ExtArgs> | null
    /**
     * The data used to create many KioskAssetRegistries.
     */
    data: KioskAssetRegistryCreateManyInput | KioskAssetRegistryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskAssetRegistryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KioskAssetRegistry update
   */
  export type KioskAssetRegistryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskAssetRegistry
     */
    select?: KioskAssetRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskAssetRegistry
     */
    omit?: KioskAssetRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskAssetRegistryInclude<ExtArgs> | null
    /**
     * The data needed to update a KioskAssetRegistry.
     */
    data: XOR<KioskAssetRegistryUpdateInput, KioskAssetRegistryUncheckedUpdateInput>
    /**
     * Choose, which KioskAssetRegistry to update.
     */
    where: KioskAssetRegistryWhereUniqueInput
  }

  /**
   * KioskAssetRegistry updateMany
   */
  export type KioskAssetRegistryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KioskAssetRegistries.
     */
    data: XOR<KioskAssetRegistryUpdateManyMutationInput, KioskAssetRegistryUncheckedUpdateManyInput>
    /**
     * Filter which KioskAssetRegistries to update
     */
    where?: KioskAssetRegistryWhereInput
    /**
     * Limit how many KioskAssetRegistries to update.
     */
    limit?: number
  }

  /**
   * KioskAssetRegistry updateManyAndReturn
   */
  export type KioskAssetRegistryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskAssetRegistry
     */
    select?: KioskAssetRegistrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KioskAssetRegistry
     */
    omit?: KioskAssetRegistryOmit<ExtArgs> | null
    /**
     * The data used to update KioskAssetRegistries.
     */
    data: XOR<KioskAssetRegistryUpdateManyMutationInput, KioskAssetRegistryUncheckedUpdateManyInput>
    /**
     * Filter which KioskAssetRegistries to update
     */
    where?: KioskAssetRegistryWhereInput
    /**
     * Limit how many KioskAssetRegistries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskAssetRegistryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KioskAssetRegistry upsert
   */
  export type KioskAssetRegistryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskAssetRegistry
     */
    select?: KioskAssetRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskAssetRegistry
     */
    omit?: KioskAssetRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskAssetRegistryInclude<ExtArgs> | null
    /**
     * The filter to search for the KioskAssetRegistry to update in case it exists.
     */
    where: KioskAssetRegistryWhereUniqueInput
    /**
     * In case the KioskAssetRegistry found by the `where` argument doesn't exist, create a new KioskAssetRegistry with this data.
     */
    create: XOR<KioskAssetRegistryCreateInput, KioskAssetRegistryUncheckedCreateInput>
    /**
     * In case the KioskAssetRegistry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KioskAssetRegistryUpdateInput, KioskAssetRegistryUncheckedUpdateInput>
  }

  /**
   * KioskAssetRegistry delete
   */
  export type KioskAssetRegistryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskAssetRegistry
     */
    select?: KioskAssetRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskAssetRegistry
     */
    omit?: KioskAssetRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskAssetRegistryInclude<ExtArgs> | null
    /**
     * Filter which KioskAssetRegistry to delete.
     */
    where: KioskAssetRegistryWhereUniqueInput
  }

  /**
   * KioskAssetRegistry deleteMany
   */
  export type KioskAssetRegistryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KioskAssetRegistries to delete
     */
    where?: KioskAssetRegistryWhereInput
    /**
     * Limit how many KioskAssetRegistries to delete.
     */
    limit?: number
  }

  /**
   * KioskAssetRegistry without action
   */
  export type KioskAssetRegistryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskAssetRegistry
     */
    select?: KioskAssetRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskAssetRegistry
     */
    omit?: KioskAssetRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskAssetRegistryInclude<ExtArgs> | null
  }


  /**
   * Model HelixSyncFailure
   */

  export type AggregateHelixSyncFailure = {
    _count: HelixSyncFailureCountAggregateOutputType | null
    _avg: HelixSyncFailureAvgAggregateOutputType | null
    _sum: HelixSyncFailureSumAggregateOutputType | null
    _min: HelixSyncFailureMinAggregateOutputType | null
    _max: HelixSyncFailureMaxAggregateOutputType | null
  }

  export type HelixSyncFailureAvgAggregateOutputType = {
    id: number | null
    assetId: number | null
    retryCount: number | null
  }

  export type HelixSyncFailureSumAggregateOutputType = {
    id: number | null
    assetId: number | null
    retryCount: number | null
  }

  export type HelixSyncFailureMinAggregateOutputType = {
    id: number | null
    kioskId: string | null
    assetId: number | null
    errorMessage: string | null
    retryCount: number | null
    nextRetryAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HelixSyncFailureMaxAggregateOutputType = {
    id: number | null
    kioskId: string | null
    assetId: number | null
    errorMessage: string | null
    retryCount: number | null
    nextRetryAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HelixSyncFailureCountAggregateOutputType = {
    id: number
    kioskId: number
    assetId: number
    errorMessage: number
    metadata: number
    retryCount: number
    nextRetryAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HelixSyncFailureAvgAggregateInputType = {
    id?: true
    assetId?: true
    retryCount?: true
  }

  export type HelixSyncFailureSumAggregateInputType = {
    id?: true
    assetId?: true
    retryCount?: true
  }

  export type HelixSyncFailureMinAggregateInputType = {
    id?: true
    kioskId?: true
    assetId?: true
    errorMessage?: true
    retryCount?: true
    nextRetryAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HelixSyncFailureMaxAggregateInputType = {
    id?: true
    kioskId?: true
    assetId?: true
    errorMessage?: true
    retryCount?: true
    nextRetryAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HelixSyncFailureCountAggregateInputType = {
    id?: true
    kioskId?: true
    assetId?: true
    errorMessage?: true
    metadata?: true
    retryCount?: true
    nextRetryAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HelixSyncFailureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HelixSyncFailure to aggregate.
     */
    where?: HelixSyncFailureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelixSyncFailures to fetch.
     */
    orderBy?: HelixSyncFailureOrderByWithRelationInput | HelixSyncFailureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HelixSyncFailureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelixSyncFailures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelixSyncFailures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HelixSyncFailures
    **/
    _count?: true | HelixSyncFailureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HelixSyncFailureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HelixSyncFailureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HelixSyncFailureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HelixSyncFailureMaxAggregateInputType
  }

  export type GetHelixSyncFailureAggregateType<T extends HelixSyncFailureAggregateArgs> = {
        [P in keyof T & keyof AggregateHelixSyncFailure]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHelixSyncFailure[P]>
      : GetScalarType<T[P], AggregateHelixSyncFailure[P]>
  }




  export type HelixSyncFailureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelixSyncFailureWhereInput
    orderBy?: HelixSyncFailureOrderByWithAggregationInput | HelixSyncFailureOrderByWithAggregationInput[]
    by: HelixSyncFailureScalarFieldEnum[] | HelixSyncFailureScalarFieldEnum
    having?: HelixSyncFailureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HelixSyncFailureCountAggregateInputType | true
    _avg?: HelixSyncFailureAvgAggregateInputType
    _sum?: HelixSyncFailureSumAggregateInputType
    _min?: HelixSyncFailureMinAggregateInputType
    _max?: HelixSyncFailureMaxAggregateInputType
  }

  export type HelixSyncFailureGroupByOutputType = {
    id: number
    kioskId: string
    assetId: number
    errorMessage: string
    metadata: JsonValue | null
    retryCount: number
    nextRetryAt: Date
    createdAt: Date
    updatedAt: Date
    _count: HelixSyncFailureCountAggregateOutputType | null
    _avg: HelixSyncFailureAvgAggregateOutputType | null
    _sum: HelixSyncFailureSumAggregateOutputType | null
    _min: HelixSyncFailureMinAggregateOutputType | null
    _max: HelixSyncFailureMaxAggregateOutputType | null
  }

  type GetHelixSyncFailureGroupByPayload<T extends HelixSyncFailureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HelixSyncFailureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HelixSyncFailureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HelixSyncFailureGroupByOutputType[P]>
            : GetScalarType<T[P], HelixSyncFailureGroupByOutputType[P]>
        }
      >
    >


  export type HelixSyncFailureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kioskId?: boolean
    assetId?: boolean
    errorMessage?: boolean
    metadata?: boolean
    retryCount?: boolean
    nextRetryAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kiosk?: boolean | KioskDefaultArgs<ExtArgs>
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helixSyncFailure"]>

  export type HelixSyncFailureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kioskId?: boolean
    assetId?: boolean
    errorMessage?: boolean
    metadata?: boolean
    retryCount?: boolean
    nextRetryAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kiosk?: boolean | KioskDefaultArgs<ExtArgs>
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helixSyncFailure"]>

  export type HelixSyncFailureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kioskId?: boolean
    assetId?: boolean
    errorMessage?: boolean
    metadata?: boolean
    retryCount?: boolean
    nextRetryAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kiosk?: boolean | KioskDefaultArgs<ExtArgs>
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helixSyncFailure"]>

  export type HelixSyncFailureSelectScalar = {
    id?: boolean
    kioskId?: boolean
    assetId?: boolean
    errorMessage?: boolean
    metadata?: boolean
    retryCount?: boolean
    nextRetryAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HelixSyncFailureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "kioskId" | "assetId" | "errorMessage" | "metadata" | "retryCount" | "nextRetryAt" | "createdAt" | "updatedAt", ExtArgs["result"]["helixSyncFailure"]>
  export type HelixSyncFailureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kiosk?: boolean | KioskDefaultArgs<ExtArgs>
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
  }
  export type HelixSyncFailureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kiosk?: boolean | KioskDefaultArgs<ExtArgs>
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
  }
  export type HelixSyncFailureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kiosk?: boolean | KioskDefaultArgs<ExtArgs>
    asset?: boolean | InventoryAssetDefaultArgs<ExtArgs>
  }

  export type $HelixSyncFailurePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HelixSyncFailure"
    objects: {
      kiosk: Prisma.$KioskPayload<ExtArgs>
      asset: Prisma.$InventoryAssetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      kioskId: string
      assetId: number
      errorMessage: string
      metadata: Prisma.JsonValue | null
      retryCount: number
      nextRetryAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["helixSyncFailure"]>
    composites: {}
  }

  type HelixSyncFailureGetPayload<S extends boolean | null | undefined | HelixSyncFailureDefaultArgs> = $Result.GetResult<Prisma.$HelixSyncFailurePayload, S>

  type HelixSyncFailureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HelixSyncFailureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HelixSyncFailureCountAggregateInputType | true
    }

  export interface HelixSyncFailureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HelixSyncFailure'], meta: { name: 'HelixSyncFailure' } }
    /**
     * Find zero or one HelixSyncFailure that matches the filter.
     * @param {HelixSyncFailureFindUniqueArgs} args - Arguments to find a HelixSyncFailure
     * @example
     * // Get one HelixSyncFailure
     * const helixSyncFailure = await prisma.helixSyncFailure.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HelixSyncFailureFindUniqueArgs>(args: SelectSubset<T, HelixSyncFailureFindUniqueArgs<ExtArgs>>): Prisma__HelixSyncFailureClient<$Result.GetResult<Prisma.$HelixSyncFailurePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HelixSyncFailure that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HelixSyncFailureFindUniqueOrThrowArgs} args - Arguments to find a HelixSyncFailure
     * @example
     * // Get one HelixSyncFailure
     * const helixSyncFailure = await prisma.helixSyncFailure.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HelixSyncFailureFindUniqueOrThrowArgs>(args: SelectSubset<T, HelixSyncFailureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HelixSyncFailureClient<$Result.GetResult<Prisma.$HelixSyncFailurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HelixSyncFailure that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelixSyncFailureFindFirstArgs} args - Arguments to find a HelixSyncFailure
     * @example
     * // Get one HelixSyncFailure
     * const helixSyncFailure = await prisma.helixSyncFailure.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HelixSyncFailureFindFirstArgs>(args?: SelectSubset<T, HelixSyncFailureFindFirstArgs<ExtArgs>>): Prisma__HelixSyncFailureClient<$Result.GetResult<Prisma.$HelixSyncFailurePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HelixSyncFailure that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelixSyncFailureFindFirstOrThrowArgs} args - Arguments to find a HelixSyncFailure
     * @example
     * // Get one HelixSyncFailure
     * const helixSyncFailure = await prisma.helixSyncFailure.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HelixSyncFailureFindFirstOrThrowArgs>(args?: SelectSubset<T, HelixSyncFailureFindFirstOrThrowArgs<ExtArgs>>): Prisma__HelixSyncFailureClient<$Result.GetResult<Prisma.$HelixSyncFailurePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HelixSyncFailures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelixSyncFailureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HelixSyncFailures
     * const helixSyncFailures = await prisma.helixSyncFailure.findMany()
     * 
     * // Get first 10 HelixSyncFailures
     * const helixSyncFailures = await prisma.helixSyncFailure.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const helixSyncFailureWithIdOnly = await prisma.helixSyncFailure.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HelixSyncFailureFindManyArgs>(args?: SelectSubset<T, HelixSyncFailureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelixSyncFailurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HelixSyncFailure.
     * @param {HelixSyncFailureCreateArgs} args - Arguments to create a HelixSyncFailure.
     * @example
     * // Create one HelixSyncFailure
     * const HelixSyncFailure = await prisma.helixSyncFailure.create({
     *   data: {
     *     // ... data to create a HelixSyncFailure
     *   }
     * })
     * 
     */
    create<T extends HelixSyncFailureCreateArgs>(args: SelectSubset<T, HelixSyncFailureCreateArgs<ExtArgs>>): Prisma__HelixSyncFailureClient<$Result.GetResult<Prisma.$HelixSyncFailurePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HelixSyncFailures.
     * @param {HelixSyncFailureCreateManyArgs} args - Arguments to create many HelixSyncFailures.
     * @example
     * // Create many HelixSyncFailures
     * const helixSyncFailure = await prisma.helixSyncFailure.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HelixSyncFailureCreateManyArgs>(args?: SelectSubset<T, HelixSyncFailureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HelixSyncFailures and returns the data saved in the database.
     * @param {HelixSyncFailureCreateManyAndReturnArgs} args - Arguments to create many HelixSyncFailures.
     * @example
     * // Create many HelixSyncFailures
     * const helixSyncFailure = await prisma.helixSyncFailure.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HelixSyncFailures and only return the `id`
     * const helixSyncFailureWithIdOnly = await prisma.helixSyncFailure.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HelixSyncFailureCreateManyAndReturnArgs>(args?: SelectSubset<T, HelixSyncFailureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelixSyncFailurePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HelixSyncFailure.
     * @param {HelixSyncFailureDeleteArgs} args - Arguments to delete one HelixSyncFailure.
     * @example
     * // Delete one HelixSyncFailure
     * const HelixSyncFailure = await prisma.helixSyncFailure.delete({
     *   where: {
     *     // ... filter to delete one HelixSyncFailure
     *   }
     * })
     * 
     */
    delete<T extends HelixSyncFailureDeleteArgs>(args: SelectSubset<T, HelixSyncFailureDeleteArgs<ExtArgs>>): Prisma__HelixSyncFailureClient<$Result.GetResult<Prisma.$HelixSyncFailurePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HelixSyncFailure.
     * @param {HelixSyncFailureUpdateArgs} args - Arguments to update one HelixSyncFailure.
     * @example
     * // Update one HelixSyncFailure
     * const helixSyncFailure = await prisma.helixSyncFailure.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HelixSyncFailureUpdateArgs>(args: SelectSubset<T, HelixSyncFailureUpdateArgs<ExtArgs>>): Prisma__HelixSyncFailureClient<$Result.GetResult<Prisma.$HelixSyncFailurePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HelixSyncFailures.
     * @param {HelixSyncFailureDeleteManyArgs} args - Arguments to filter HelixSyncFailures to delete.
     * @example
     * // Delete a few HelixSyncFailures
     * const { count } = await prisma.helixSyncFailure.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HelixSyncFailureDeleteManyArgs>(args?: SelectSubset<T, HelixSyncFailureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HelixSyncFailures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelixSyncFailureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HelixSyncFailures
     * const helixSyncFailure = await prisma.helixSyncFailure.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HelixSyncFailureUpdateManyArgs>(args: SelectSubset<T, HelixSyncFailureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HelixSyncFailures and returns the data updated in the database.
     * @param {HelixSyncFailureUpdateManyAndReturnArgs} args - Arguments to update many HelixSyncFailures.
     * @example
     * // Update many HelixSyncFailures
     * const helixSyncFailure = await prisma.helixSyncFailure.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HelixSyncFailures and only return the `id`
     * const helixSyncFailureWithIdOnly = await prisma.helixSyncFailure.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HelixSyncFailureUpdateManyAndReturnArgs>(args: SelectSubset<T, HelixSyncFailureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelixSyncFailurePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HelixSyncFailure.
     * @param {HelixSyncFailureUpsertArgs} args - Arguments to update or create a HelixSyncFailure.
     * @example
     * // Update or create a HelixSyncFailure
     * const helixSyncFailure = await prisma.helixSyncFailure.upsert({
     *   create: {
     *     // ... data to create a HelixSyncFailure
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HelixSyncFailure we want to update
     *   }
     * })
     */
    upsert<T extends HelixSyncFailureUpsertArgs>(args: SelectSubset<T, HelixSyncFailureUpsertArgs<ExtArgs>>): Prisma__HelixSyncFailureClient<$Result.GetResult<Prisma.$HelixSyncFailurePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HelixSyncFailures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelixSyncFailureCountArgs} args - Arguments to filter HelixSyncFailures to count.
     * @example
     * // Count the number of HelixSyncFailures
     * const count = await prisma.helixSyncFailure.count({
     *   where: {
     *     // ... the filter for the HelixSyncFailures we want to count
     *   }
     * })
    **/
    count<T extends HelixSyncFailureCountArgs>(
      args?: Subset<T, HelixSyncFailureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HelixSyncFailureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HelixSyncFailure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelixSyncFailureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HelixSyncFailureAggregateArgs>(args: Subset<T, HelixSyncFailureAggregateArgs>): Prisma.PrismaPromise<GetHelixSyncFailureAggregateType<T>>

    /**
     * Group by HelixSyncFailure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelixSyncFailureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HelixSyncFailureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HelixSyncFailureGroupByArgs['orderBy'] }
        : { orderBy?: HelixSyncFailureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HelixSyncFailureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHelixSyncFailureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HelixSyncFailure model
   */
  readonly fields: HelixSyncFailureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HelixSyncFailure.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HelixSyncFailureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kiosk<T extends KioskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KioskDefaultArgs<ExtArgs>>): Prisma__KioskClient<$Result.GetResult<Prisma.$KioskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    asset<T extends InventoryAssetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryAssetDefaultArgs<ExtArgs>>): Prisma__InventoryAssetClient<$Result.GetResult<Prisma.$InventoryAssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HelixSyncFailure model
   */
  interface HelixSyncFailureFieldRefs {
    readonly id: FieldRef<"HelixSyncFailure", 'Int'>
    readonly kioskId: FieldRef<"HelixSyncFailure", 'String'>
    readonly assetId: FieldRef<"HelixSyncFailure", 'Int'>
    readonly errorMessage: FieldRef<"HelixSyncFailure", 'String'>
    readonly metadata: FieldRef<"HelixSyncFailure", 'Json'>
    readonly retryCount: FieldRef<"HelixSyncFailure", 'Int'>
    readonly nextRetryAt: FieldRef<"HelixSyncFailure", 'DateTime'>
    readonly createdAt: FieldRef<"HelixSyncFailure", 'DateTime'>
    readonly updatedAt: FieldRef<"HelixSyncFailure", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HelixSyncFailure findUnique
   */
  export type HelixSyncFailureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelixSyncFailure
     */
    select?: HelixSyncFailureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelixSyncFailure
     */
    omit?: HelixSyncFailureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelixSyncFailureInclude<ExtArgs> | null
    /**
     * Filter, which HelixSyncFailure to fetch.
     */
    where: HelixSyncFailureWhereUniqueInput
  }

  /**
   * HelixSyncFailure findUniqueOrThrow
   */
  export type HelixSyncFailureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelixSyncFailure
     */
    select?: HelixSyncFailureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelixSyncFailure
     */
    omit?: HelixSyncFailureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelixSyncFailureInclude<ExtArgs> | null
    /**
     * Filter, which HelixSyncFailure to fetch.
     */
    where: HelixSyncFailureWhereUniqueInput
  }

  /**
   * HelixSyncFailure findFirst
   */
  export type HelixSyncFailureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelixSyncFailure
     */
    select?: HelixSyncFailureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelixSyncFailure
     */
    omit?: HelixSyncFailureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelixSyncFailureInclude<ExtArgs> | null
    /**
     * Filter, which HelixSyncFailure to fetch.
     */
    where?: HelixSyncFailureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelixSyncFailures to fetch.
     */
    orderBy?: HelixSyncFailureOrderByWithRelationInput | HelixSyncFailureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HelixSyncFailures.
     */
    cursor?: HelixSyncFailureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelixSyncFailures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelixSyncFailures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HelixSyncFailures.
     */
    distinct?: HelixSyncFailureScalarFieldEnum | HelixSyncFailureScalarFieldEnum[]
  }

  /**
   * HelixSyncFailure findFirstOrThrow
   */
  export type HelixSyncFailureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelixSyncFailure
     */
    select?: HelixSyncFailureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelixSyncFailure
     */
    omit?: HelixSyncFailureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelixSyncFailureInclude<ExtArgs> | null
    /**
     * Filter, which HelixSyncFailure to fetch.
     */
    where?: HelixSyncFailureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelixSyncFailures to fetch.
     */
    orderBy?: HelixSyncFailureOrderByWithRelationInput | HelixSyncFailureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HelixSyncFailures.
     */
    cursor?: HelixSyncFailureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelixSyncFailures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelixSyncFailures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HelixSyncFailures.
     */
    distinct?: HelixSyncFailureScalarFieldEnum | HelixSyncFailureScalarFieldEnum[]
  }

  /**
   * HelixSyncFailure findMany
   */
  export type HelixSyncFailureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelixSyncFailure
     */
    select?: HelixSyncFailureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelixSyncFailure
     */
    omit?: HelixSyncFailureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelixSyncFailureInclude<ExtArgs> | null
    /**
     * Filter, which HelixSyncFailures to fetch.
     */
    where?: HelixSyncFailureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelixSyncFailures to fetch.
     */
    orderBy?: HelixSyncFailureOrderByWithRelationInput | HelixSyncFailureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HelixSyncFailures.
     */
    cursor?: HelixSyncFailureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelixSyncFailures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelixSyncFailures.
     */
    skip?: number
    distinct?: HelixSyncFailureScalarFieldEnum | HelixSyncFailureScalarFieldEnum[]
  }

  /**
   * HelixSyncFailure create
   */
  export type HelixSyncFailureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelixSyncFailure
     */
    select?: HelixSyncFailureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelixSyncFailure
     */
    omit?: HelixSyncFailureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelixSyncFailureInclude<ExtArgs> | null
    /**
     * The data needed to create a HelixSyncFailure.
     */
    data: XOR<HelixSyncFailureCreateInput, HelixSyncFailureUncheckedCreateInput>
  }

  /**
   * HelixSyncFailure createMany
   */
  export type HelixSyncFailureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HelixSyncFailures.
     */
    data: HelixSyncFailureCreateManyInput | HelixSyncFailureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HelixSyncFailure createManyAndReturn
   */
  export type HelixSyncFailureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelixSyncFailure
     */
    select?: HelixSyncFailureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HelixSyncFailure
     */
    omit?: HelixSyncFailureOmit<ExtArgs> | null
    /**
     * The data used to create many HelixSyncFailures.
     */
    data: HelixSyncFailureCreateManyInput | HelixSyncFailureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelixSyncFailureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HelixSyncFailure update
   */
  export type HelixSyncFailureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelixSyncFailure
     */
    select?: HelixSyncFailureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelixSyncFailure
     */
    omit?: HelixSyncFailureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelixSyncFailureInclude<ExtArgs> | null
    /**
     * The data needed to update a HelixSyncFailure.
     */
    data: XOR<HelixSyncFailureUpdateInput, HelixSyncFailureUncheckedUpdateInput>
    /**
     * Choose, which HelixSyncFailure to update.
     */
    where: HelixSyncFailureWhereUniqueInput
  }

  /**
   * HelixSyncFailure updateMany
   */
  export type HelixSyncFailureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HelixSyncFailures.
     */
    data: XOR<HelixSyncFailureUpdateManyMutationInput, HelixSyncFailureUncheckedUpdateManyInput>
    /**
     * Filter which HelixSyncFailures to update
     */
    where?: HelixSyncFailureWhereInput
    /**
     * Limit how many HelixSyncFailures to update.
     */
    limit?: number
  }

  /**
   * HelixSyncFailure updateManyAndReturn
   */
  export type HelixSyncFailureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelixSyncFailure
     */
    select?: HelixSyncFailureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HelixSyncFailure
     */
    omit?: HelixSyncFailureOmit<ExtArgs> | null
    /**
     * The data used to update HelixSyncFailures.
     */
    data: XOR<HelixSyncFailureUpdateManyMutationInput, HelixSyncFailureUncheckedUpdateManyInput>
    /**
     * Filter which HelixSyncFailures to update
     */
    where?: HelixSyncFailureWhereInput
    /**
     * Limit how many HelixSyncFailures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelixSyncFailureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HelixSyncFailure upsert
   */
  export type HelixSyncFailureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelixSyncFailure
     */
    select?: HelixSyncFailureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelixSyncFailure
     */
    omit?: HelixSyncFailureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelixSyncFailureInclude<ExtArgs> | null
    /**
     * The filter to search for the HelixSyncFailure to update in case it exists.
     */
    where: HelixSyncFailureWhereUniqueInput
    /**
     * In case the HelixSyncFailure found by the `where` argument doesn't exist, create a new HelixSyncFailure with this data.
     */
    create: XOR<HelixSyncFailureCreateInput, HelixSyncFailureUncheckedCreateInput>
    /**
     * In case the HelixSyncFailure was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HelixSyncFailureUpdateInput, HelixSyncFailureUncheckedUpdateInput>
  }

  /**
   * HelixSyncFailure delete
   */
  export type HelixSyncFailureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelixSyncFailure
     */
    select?: HelixSyncFailureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelixSyncFailure
     */
    omit?: HelixSyncFailureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelixSyncFailureInclude<ExtArgs> | null
    /**
     * Filter which HelixSyncFailure to delete.
     */
    where: HelixSyncFailureWhereUniqueInput
  }

  /**
   * HelixSyncFailure deleteMany
   */
  export type HelixSyncFailureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HelixSyncFailures to delete
     */
    where?: HelixSyncFailureWhereInput
    /**
     * Limit how many HelixSyncFailures to delete.
     */
    limit?: number
  }

  /**
   * HelixSyncFailure without action
   */
  export type HelixSyncFailureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelixSyncFailure
     */
    select?: HelixSyncFailureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelixSyncFailure
     */
    omit?: HelixSyncFailureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelixSyncFailureInclude<ExtArgs> | null
  }


  /**
   * Model KioskOrganizationAssignment
   */

  export type AggregateKioskOrganizationAssignment = {
    _count: KioskOrganizationAssignmentCountAggregateOutputType | null
    _avg: KioskOrganizationAssignmentAvgAggregateOutputType | null
    _sum: KioskOrganizationAssignmentSumAggregateOutputType | null
    _min: KioskOrganizationAssignmentMinAggregateOutputType | null
    _max: KioskOrganizationAssignmentMaxAggregateOutputType | null
  }

  export type KioskOrganizationAssignmentAvgAggregateOutputType = {
    id: number | null
    organizationId: number | null
  }

  export type KioskOrganizationAssignmentSumAggregateOutputType = {
    id: number | null
    organizationId: number | null
  }

  export type KioskOrganizationAssignmentMinAggregateOutputType = {
    id: number | null
    kioskId: string | null
    organizationId: number | null
    department: string | null
    floor: string | null
    room: string | null
    building: string | null
    assignedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KioskOrganizationAssignmentMaxAggregateOutputType = {
    id: number | null
    kioskId: string | null
    organizationId: number | null
    department: string | null
    floor: string | null
    room: string | null
    building: string | null
    assignedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KioskOrganizationAssignmentCountAggregateOutputType = {
    id: number
    kioskId: number
    organizationId: number
    department: number
    floor: number
    room: number
    building: number
    assignedBy: number
    assignmentMetadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KioskOrganizationAssignmentAvgAggregateInputType = {
    id?: true
    organizationId?: true
  }

  export type KioskOrganizationAssignmentSumAggregateInputType = {
    id?: true
    organizationId?: true
  }

  export type KioskOrganizationAssignmentMinAggregateInputType = {
    id?: true
    kioskId?: true
    organizationId?: true
    department?: true
    floor?: true
    room?: true
    building?: true
    assignedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KioskOrganizationAssignmentMaxAggregateInputType = {
    id?: true
    kioskId?: true
    organizationId?: true
    department?: true
    floor?: true
    room?: true
    building?: true
    assignedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KioskOrganizationAssignmentCountAggregateInputType = {
    id?: true
    kioskId?: true
    organizationId?: true
    department?: true
    floor?: true
    room?: true
    building?: true
    assignedBy?: true
    assignmentMetadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KioskOrganizationAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KioskOrganizationAssignment to aggregate.
     */
    where?: KioskOrganizationAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KioskOrganizationAssignments to fetch.
     */
    orderBy?: KioskOrganizationAssignmentOrderByWithRelationInput | KioskOrganizationAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KioskOrganizationAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KioskOrganizationAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KioskOrganizationAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KioskOrganizationAssignments
    **/
    _count?: true | KioskOrganizationAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KioskOrganizationAssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KioskOrganizationAssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KioskOrganizationAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KioskOrganizationAssignmentMaxAggregateInputType
  }

  export type GetKioskOrganizationAssignmentAggregateType<T extends KioskOrganizationAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateKioskOrganizationAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKioskOrganizationAssignment[P]>
      : GetScalarType<T[P], AggregateKioskOrganizationAssignment[P]>
  }




  export type KioskOrganizationAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KioskOrganizationAssignmentWhereInput
    orderBy?: KioskOrganizationAssignmentOrderByWithAggregationInput | KioskOrganizationAssignmentOrderByWithAggregationInput[]
    by: KioskOrganizationAssignmentScalarFieldEnum[] | KioskOrganizationAssignmentScalarFieldEnum
    having?: KioskOrganizationAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KioskOrganizationAssignmentCountAggregateInputType | true
    _avg?: KioskOrganizationAssignmentAvgAggregateInputType
    _sum?: KioskOrganizationAssignmentSumAggregateInputType
    _min?: KioskOrganizationAssignmentMinAggregateInputType
    _max?: KioskOrganizationAssignmentMaxAggregateInputType
  }

  export type KioskOrganizationAssignmentGroupByOutputType = {
    id: number
    kioskId: string
    organizationId: number
    department: string | null
    floor: string | null
    room: string | null
    building: string | null
    assignedBy: string | null
    assignmentMetadata: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: KioskOrganizationAssignmentCountAggregateOutputType | null
    _avg: KioskOrganizationAssignmentAvgAggregateOutputType | null
    _sum: KioskOrganizationAssignmentSumAggregateOutputType | null
    _min: KioskOrganizationAssignmentMinAggregateOutputType | null
    _max: KioskOrganizationAssignmentMaxAggregateOutputType | null
  }

  type GetKioskOrganizationAssignmentGroupByPayload<T extends KioskOrganizationAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KioskOrganizationAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KioskOrganizationAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KioskOrganizationAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], KioskOrganizationAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type KioskOrganizationAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kioskId?: boolean
    organizationId?: boolean
    department?: boolean
    floor?: boolean
    room?: boolean
    building?: boolean
    assignedBy?: boolean
    assignmentMetadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kiosk?: boolean | KioskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kioskOrganizationAssignment"]>

  export type KioskOrganizationAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kioskId?: boolean
    organizationId?: boolean
    department?: boolean
    floor?: boolean
    room?: boolean
    building?: boolean
    assignedBy?: boolean
    assignmentMetadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kiosk?: boolean | KioskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kioskOrganizationAssignment"]>

  export type KioskOrganizationAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kioskId?: boolean
    organizationId?: boolean
    department?: boolean
    floor?: boolean
    room?: boolean
    building?: boolean
    assignedBy?: boolean
    assignmentMetadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kiosk?: boolean | KioskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kioskOrganizationAssignment"]>

  export type KioskOrganizationAssignmentSelectScalar = {
    id?: boolean
    kioskId?: boolean
    organizationId?: boolean
    department?: boolean
    floor?: boolean
    room?: boolean
    building?: boolean
    assignedBy?: boolean
    assignmentMetadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KioskOrganizationAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "kioskId" | "organizationId" | "department" | "floor" | "room" | "building" | "assignedBy" | "assignmentMetadata" | "createdAt" | "updatedAt", ExtArgs["result"]["kioskOrganizationAssignment"]>
  export type KioskOrganizationAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kiosk?: boolean | KioskDefaultArgs<ExtArgs>
  }
  export type KioskOrganizationAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kiosk?: boolean | KioskDefaultArgs<ExtArgs>
  }
  export type KioskOrganizationAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kiosk?: boolean | KioskDefaultArgs<ExtArgs>
  }

  export type $KioskOrganizationAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KioskOrganizationAssignment"
    objects: {
      kiosk: Prisma.$KioskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      kioskId: string
      organizationId: number
      department: string | null
      floor: string | null
      room: string | null
      building: string | null
      assignedBy: string | null
      assignmentMetadata: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["kioskOrganizationAssignment"]>
    composites: {}
  }

  type KioskOrganizationAssignmentGetPayload<S extends boolean | null | undefined | KioskOrganizationAssignmentDefaultArgs> = $Result.GetResult<Prisma.$KioskOrganizationAssignmentPayload, S>

  type KioskOrganizationAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KioskOrganizationAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KioskOrganizationAssignmentCountAggregateInputType | true
    }

  export interface KioskOrganizationAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KioskOrganizationAssignment'], meta: { name: 'KioskOrganizationAssignment' } }
    /**
     * Find zero or one KioskOrganizationAssignment that matches the filter.
     * @param {KioskOrganizationAssignmentFindUniqueArgs} args - Arguments to find a KioskOrganizationAssignment
     * @example
     * // Get one KioskOrganizationAssignment
     * const kioskOrganizationAssignment = await prisma.kioskOrganizationAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KioskOrganizationAssignmentFindUniqueArgs>(args: SelectSubset<T, KioskOrganizationAssignmentFindUniqueArgs<ExtArgs>>): Prisma__KioskOrganizationAssignmentClient<$Result.GetResult<Prisma.$KioskOrganizationAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KioskOrganizationAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KioskOrganizationAssignmentFindUniqueOrThrowArgs} args - Arguments to find a KioskOrganizationAssignment
     * @example
     * // Get one KioskOrganizationAssignment
     * const kioskOrganizationAssignment = await prisma.kioskOrganizationAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KioskOrganizationAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, KioskOrganizationAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KioskOrganizationAssignmentClient<$Result.GetResult<Prisma.$KioskOrganizationAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KioskOrganizationAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskOrganizationAssignmentFindFirstArgs} args - Arguments to find a KioskOrganizationAssignment
     * @example
     * // Get one KioskOrganizationAssignment
     * const kioskOrganizationAssignment = await prisma.kioskOrganizationAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KioskOrganizationAssignmentFindFirstArgs>(args?: SelectSubset<T, KioskOrganizationAssignmentFindFirstArgs<ExtArgs>>): Prisma__KioskOrganizationAssignmentClient<$Result.GetResult<Prisma.$KioskOrganizationAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KioskOrganizationAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskOrganizationAssignmentFindFirstOrThrowArgs} args - Arguments to find a KioskOrganizationAssignment
     * @example
     * // Get one KioskOrganizationAssignment
     * const kioskOrganizationAssignment = await prisma.kioskOrganizationAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KioskOrganizationAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, KioskOrganizationAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__KioskOrganizationAssignmentClient<$Result.GetResult<Prisma.$KioskOrganizationAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KioskOrganizationAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskOrganizationAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KioskOrganizationAssignments
     * const kioskOrganizationAssignments = await prisma.kioskOrganizationAssignment.findMany()
     * 
     * // Get first 10 KioskOrganizationAssignments
     * const kioskOrganizationAssignments = await prisma.kioskOrganizationAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kioskOrganizationAssignmentWithIdOnly = await prisma.kioskOrganizationAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KioskOrganizationAssignmentFindManyArgs>(args?: SelectSubset<T, KioskOrganizationAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KioskOrganizationAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KioskOrganizationAssignment.
     * @param {KioskOrganizationAssignmentCreateArgs} args - Arguments to create a KioskOrganizationAssignment.
     * @example
     * // Create one KioskOrganizationAssignment
     * const KioskOrganizationAssignment = await prisma.kioskOrganizationAssignment.create({
     *   data: {
     *     // ... data to create a KioskOrganizationAssignment
     *   }
     * })
     * 
     */
    create<T extends KioskOrganizationAssignmentCreateArgs>(args: SelectSubset<T, KioskOrganizationAssignmentCreateArgs<ExtArgs>>): Prisma__KioskOrganizationAssignmentClient<$Result.GetResult<Prisma.$KioskOrganizationAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KioskOrganizationAssignments.
     * @param {KioskOrganizationAssignmentCreateManyArgs} args - Arguments to create many KioskOrganizationAssignments.
     * @example
     * // Create many KioskOrganizationAssignments
     * const kioskOrganizationAssignment = await prisma.kioskOrganizationAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KioskOrganizationAssignmentCreateManyArgs>(args?: SelectSubset<T, KioskOrganizationAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KioskOrganizationAssignments and returns the data saved in the database.
     * @param {KioskOrganizationAssignmentCreateManyAndReturnArgs} args - Arguments to create many KioskOrganizationAssignments.
     * @example
     * // Create many KioskOrganizationAssignments
     * const kioskOrganizationAssignment = await prisma.kioskOrganizationAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KioskOrganizationAssignments and only return the `id`
     * const kioskOrganizationAssignmentWithIdOnly = await prisma.kioskOrganizationAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KioskOrganizationAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, KioskOrganizationAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KioskOrganizationAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KioskOrganizationAssignment.
     * @param {KioskOrganizationAssignmentDeleteArgs} args - Arguments to delete one KioskOrganizationAssignment.
     * @example
     * // Delete one KioskOrganizationAssignment
     * const KioskOrganizationAssignment = await prisma.kioskOrganizationAssignment.delete({
     *   where: {
     *     // ... filter to delete one KioskOrganizationAssignment
     *   }
     * })
     * 
     */
    delete<T extends KioskOrganizationAssignmentDeleteArgs>(args: SelectSubset<T, KioskOrganizationAssignmentDeleteArgs<ExtArgs>>): Prisma__KioskOrganizationAssignmentClient<$Result.GetResult<Prisma.$KioskOrganizationAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KioskOrganizationAssignment.
     * @param {KioskOrganizationAssignmentUpdateArgs} args - Arguments to update one KioskOrganizationAssignment.
     * @example
     * // Update one KioskOrganizationAssignment
     * const kioskOrganizationAssignment = await prisma.kioskOrganizationAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KioskOrganizationAssignmentUpdateArgs>(args: SelectSubset<T, KioskOrganizationAssignmentUpdateArgs<ExtArgs>>): Prisma__KioskOrganizationAssignmentClient<$Result.GetResult<Prisma.$KioskOrganizationAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KioskOrganizationAssignments.
     * @param {KioskOrganizationAssignmentDeleteManyArgs} args - Arguments to filter KioskOrganizationAssignments to delete.
     * @example
     * // Delete a few KioskOrganizationAssignments
     * const { count } = await prisma.kioskOrganizationAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KioskOrganizationAssignmentDeleteManyArgs>(args?: SelectSubset<T, KioskOrganizationAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KioskOrganizationAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskOrganizationAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KioskOrganizationAssignments
     * const kioskOrganizationAssignment = await prisma.kioskOrganizationAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KioskOrganizationAssignmentUpdateManyArgs>(args: SelectSubset<T, KioskOrganizationAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KioskOrganizationAssignments and returns the data updated in the database.
     * @param {KioskOrganizationAssignmentUpdateManyAndReturnArgs} args - Arguments to update many KioskOrganizationAssignments.
     * @example
     * // Update many KioskOrganizationAssignments
     * const kioskOrganizationAssignment = await prisma.kioskOrganizationAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KioskOrganizationAssignments and only return the `id`
     * const kioskOrganizationAssignmentWithIdOnly = await prisma.kioskOrganizationAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KioskOrganizationAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, KioskOrganizationAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KioskOrganizationAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KioskOrganizationAssignment.
     * @param {KioskOrganizationAssignmentUpsertArgs} args - Arguments to update or create a KioskOrganizationAssignment.
     * @example
     * // Update or create a KioskOrganizationAssignment
     * const kioskOrganizationAssignment = await prisma.kioskOrganizationAssignment.upsert({
     *   create: {
     *     // ... data to create a KioskOrganizationAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KioskOrganizationAssignment we want to update
     *   }
     * })
     */
    upsert<T extends KioskOrganizationAssignmentUpsertArgs>(args: SelectSubset<T, KioskOrganizationAssignmentUpsertArgs<ExtArgs>>): Prisma__KioskOrganizationAssignmentClient<$Result.GetResult<Prisma.$KioskOrganizationAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KioskOrganizationAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskOrganizationAssignmentCountArgs} args - Arguments to filter KioskOrganizationAssignments to count.
     * @example
     * // Count the number of KioskOrganizationAssignments
     * const count = await prisma.kioskOrganizationAssignment.count({
     *   where: {
     *     // ... the filter for the KioskOrganizationAssignments we want to count
     *   }
     * })
    **/
    count<T extends KioskOrganizationAssignmentCountArgs>(
      args?: Subset<T, KioskOrganizationAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KioskOrganizationAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KioskOrganizationAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskOrganizationAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KioskOrganizationAssignmentAggregateArgs>(args: Subset<T, KioskOrganizationAssignmentAggregateArgs>): Prisma.PrismaPromise<GetKioskOrganizationAssignmentAggregateType<T>>

    /**
     * Group by KioskOrganizationAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskOrganizationAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KioskOrganizationAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KioskOrganizationAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: KioskOrganizationAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KioskOrganizationAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKioskOrganizationAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KioskOrganizationAssignment model
   */
  readonly fields: KioskOrganizationAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KioskOrganizationAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KioskOrganizationAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kiosk<T extends KioskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KioskDefaultArgs<ExtArgs>>): Prisma__KioskClient<$Result.GetResult<Prisma.$KioskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KioskOrganizationAssignment model
   */
  interface KioskOrganizationAssignmentFieldRefs {
    readonly id: FieldRef<"KioskOrganizationAssignment", 'Int'>
    readonly kioskId: FieldRef<"KioskOrganizationAssignment", 'String'>
    readonly organizationId: FieldRef<"KioskOrganizationAssignment", 'Int'>
    readonly department: FieldRef<"KioskOrganizationAssignment", 'String'>
    readonly floor: FieldRef<"KioskOrganizationAssignment", 'String'>
    readonly room: FieldRef<"KioskOrganizationAssignment", 'String'>
    readonly building: FieldRef<"KioskOrganizationAssignment", 'String'>
    readonly assignedBy: FieldRef<"KioskOrganizationAssignment", 'String'>
    readonly assignmentMetadata: FieldRef<"KioskOrganizationAssignment", 'Json'>
    readonly createdAt: FieldRef<"KioskOrganizationAssignment", 'DateTime'>
    readonly updatedAt: FieldRef<"KioskOrganizationAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KioskOrganizationAssignment findUnique
   */
  export type KioskOrganizationAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskOrganizationAssignment
     */
    select?: KioskOrganizationAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskOrganizationAssignment
     */
    omit?: KioskOrganizationAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskOrganizationAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which KioskOrganizationAssignment to fetch.
     */
    where: KioskOrganizationAssignmentWhereUniqueInput
  }

  /**
   * KioskOrganizationAssignment findUniqueOrThrow
   */
  export type KioskOrganizationAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskOrganizationAssignment
     */
    select?: KioskOrganizationAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskOrganizationAssignment
     */
    omit?: KioskOrganizationAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskOrganizationAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which KioskOrganizationAssignment to fetch.
     */
    where: KioskOrganizationAssignmentWhereUniqueInput
  }

  /**
   * KioskOrganizationAssignment findFirst
   */
  export type KioskOrganizationAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskOrganizationAssignment
     */
    select?: KioskOrganizationAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskOrganizationAssignment
     */
    omit?: KioskOrganizationAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskOrganizationAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which KioskOrganizationAssignment to fetch.
     */
    where?: KioskOrganizationAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KioskOrganizationAssignments to fetch.
     */
    orderBy?: KioskOrganizationAssignmentOrderByWithRelationInput | KioskOrganizationAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KioskOrganizationAssignments.
     */
    cursor?: KioskOrganizationAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KioskOrganizationAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KioskOrganizationAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KioskOrganizationAssignments.
     */
    distinct?: KioskOrganizationAssignmentScalarFieldEnum | KioskOrganizationAssignmentScalarFieldEnum[]
  }

  /**
   * KioskOrganizationAssignment findFirstOrThrow
   */
  export type KioskOrganizationAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskOrganizationAssignment
     */
    select?: KioskOrganizationAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskOrganizationAssignment
     */
    omit?: KioskOrganizationAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskOrganizationAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which KioskOrganizationAssignment to fetch.
     */
    where?: KioskOrganizationAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KioskOrganizationAssignments to fetch.
     */
    orderBy?: KioskOrganizationAssignmentOrderByWithRelationInput | KioskOrganizationAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KioskOrganizationAssignments.
     */
    cursor?: KioskOrganizationAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KioskOrganizationAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KioskOrganizationAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KioskOrganizationAssignments.
     */
    distinct?: KioskOrganizationAssignmentScalarFieldEnum | KioskOrganizationAssignmentScalarFieldEnum[]
  }

  /**
   * KioskOrganizationAssignment findMany
   */
  export type KioskOrganizationAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskOrganizationAssignment
     */
    select?: KioskOrganizationAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskOrganizationAssignment
     */
    omit?: KioskOrganizationAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskOrganizationAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which KioskOrganizationAssignments to fetch.
     */
    where?: KioskOrganizationAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KioskOrganizationAssignments to fetch.
     */
    orderBy?: KioskOrganizationAssignmentOrderByWithRelationInput | KioskOrganizationAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KioskOrganizationAssignments.
     */
    cursor?: KioskOrganizationAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KioskOrganizationAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KioskOrganizationAssignments.
     */
    skip?: number
    distinct?: KioskOrganizationAssignmentScalarFieldEnum | KioskOrganizationAssignmentScalarFieldEnum[]
  }

  /**
   * KioskOrganizationAssignment create
   */
  export type KioskOrganizationAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskOrganizationAssignment
     */
    select?: KioskOrganizationAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskOrganizationAssignment
     */
    omit?: KioskOrganizationAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskOrganizationAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a KioskOrganizationAssignment.
     */
    data: XOR<KioskOrganizationAssignmentCreateInput, KioskOrganizationAssignmentUncheckedCreateInput>
  }

  /**
   * KioskOrganizationAssignment createMany
   */
  export type KioskOrganizationAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KioskOrganizationAssignments.
     */
    data: KioskOrganizationAssignmentCreateManyInput | KioskOrganizationAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KioskOrganizationAssignment createManyAndReturn
   */
  export type KioskOrganizationAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskOrganizationAssignment
     */
    select?: KioskOrganizationAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KioskOrganizationAssignment
     */
    omit?: KioskOrganizationAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many KioskOrganizationAssignments.
     */
    data: KioskOrganizationAssignmentCreateManyInput | KioskOrganizationAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskOrganizationAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KioskOrganizationAssignment update
   */
  export type KioskOrganizationAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskOrganizationAssignment
     */
    select?: KioskOrganizationAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskOrganizationAssignment
     */
    omit?: KioskOrganizationAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskOrganizationAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a KioskOrganizationAssignment.
     */
    data: XOR<KioskOrganizationAssignmentUpdateInput, KioskOrganizationAssignmentUncheckedUpdateInput>
    /**
     * Choose, which KioskOrganizationAssignment to update.
     */
    where: KioskOrganizationAssignmentWhereUniqueInput
  }

  /**
   * KioskOrganizationAssignment updateMany
   */
  export type KioskOrganizationAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KioskOrganizationAssignments.
     */
    data: XOR<KioskOrganizationAssignmentUpdateManyMutationInput, KioskOrganizationAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which KioskOrganizationAssignments to update
     */
    where?: KioskOrganizationAssignmentWhereInput
    /**
     * Limit how many KioskOrganizationAssignments to update.
     */
    limit?: number
  }

  /**
   * KioskOrganizationAssignment updateManyAndReturn
   */
  export type KioskOrganizationAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskOrganizationAssignment
     */
    select?: KioskOrganizationAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KioskOrganizationAssignment
     */
    omit?: KioskOrganizationAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update KioskOrganizationAssignments.
     */
    data: XOR<KioskOrganizationAssignmentUpdateManyMutationInput, KioskOrganizationAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which KioskOrganizationAssignments to update
     */
    where?: KioskOrganizationAssignmentWhereInput
    /**
     * Limit how many KioskOrganizationAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskOrganizationAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KioskOrganizationAssignment upsert
   */
  export type KioskOrganizationAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskOrganizationAssignment
     */
    select?: KioskOrganizationAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskOrganizationAssignment
     */
    omit?: KioskOrganizationAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskOrganizationAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the KioskOrganizationAssignment to update in case it exists.
     */
    where: KioskOrganizationAssignmentWhereUniqueInput
    /**
     * In case the KioskOrganizationAssignment found by the `where` argument doesn't exist, create a new KioskOrganizationAssignment with this data.
     */
    create: XOR<KioskOrganizationAssignmentCreateInput, KioskOrganizationAssignmentUncheckedCreateInput>
    /**
     * In case the KioskOrganizationAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KioskOrganizationAssignmentUpdateInput, KioskOrganizationAssignmentUncheckedUpdateInput>
  }

  /**
   * KioskOrganizationAssignment delete
   */
  export type KioskOrganizationAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskOrganizationAssignment
     */
    select?: KioskOrganizationAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskOrganizationAssignment
     */
    omit?: KioskOrganizationAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskOrganizationAssignmentInclude<ExtArgs> | null
    /**
     * Filter which KioskOrganizationAssignment to delete.
     */
    where: KioskOrganizationAssignmentWhereUniqueInput
  }

  /**
   * KioskOrganizationAssignment deleteMany
   */
  export type KioskOrganizationAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KioskOrganizationAssignments to delete
     */
    where?: KioskOrganizationAssignmentWhereInput
    /**
     * Limit how many KioskOrganizationAssignments to delete.
     */
    limit?: number
  }

  /**
   * KioskOrganizationAssignment without action
   */
  export type KioskOrganizationAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskOrganizationAssignment
     */
    select?: KioskOrganizationAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskOrganizationAssignment
     */
    omit?: KioskOrganizationAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskOrganizationAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model KioskMetadataLog
   */

  export type AggregateKioskMetadataLog = {
    _count: KioskMetadataLogCountAggregateOutputType | null
    _avg: KioskMetadataLogAvgAggregateOutputType | null
    _sum: KioskMetadataLogSumAggregateOutputType | null
    _min: KioskMetadataLogMinAggregateOutputType | null
    _max: KioskMetadataLogMaxAggregateOutputType | null
  }

  export type KioskMetadataLogAvgAggregateOutputType = {
    id: number | null
  }

  export type KioskMetadataLogSumAggregateOutputType = {
    id: number | null
  }

  export type KioskMetadataLogMinAggregateOutputType = {
    id: number | null
    kioskId: string | null
    metadataType: string | null
    encryptedMetadata: string | null
    collectionTimestamp: Date | null
  }

  export type KioskMetadataLogMaxAggregateOutputType = {
    id: number | null
    kioskId: string | null
    metadataType: string | null
    encryptedMetadata: string | null
    collectionTimestamp: Date | null
  }

  export type KioskMetadataLogCountAggregateOutputType = {
    id: number
    kioskId: number
    metadataType: number
    encryptedMetadata: number
    collectionTimestamp: number
    _all: number
  }


  export type KioskMetadataLogAvgAggregateInputType = {
    id?: true
  }

  export type KioskMetadataLogSumAggregateInputType = {
    id?: true
  }

  export type KioskMetadataLogMinAggregateInputType = {
    id?: true
    kioskId?: true
    metadataType?: true
    encryptedMetadata?: true
    collectionTimestamp?: true
  }

  export type KioskMetadataLogMaxAggregateInputType = {
    id?: true
    kioskId?: true
    metadataType?: true
    encryptedMetadata?: true
    collectionTimestamp?: true
  }

  export type KioskMetadataLogCountAggregateInputType = {
    id?: true
    kioskId?: true
    metadataType?: true
    encryptedMetadata?: true
    collectionTimestamp?: true
    _all?: true
  }

  export type KioskMetadataLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KioskMetadataLog to aggregate.
     */
    where?: KioskMetadataLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KioskMetadataLogs to fetch.
     */
    orderBy?: KioskMetadataLogOrderByWithRelationInput | KioskMetadataLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KioskMetadataLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KioskMetadataLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KioskMetadataLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KioskMetadataLogs
    **/
    _count?: true | KioskMetadataLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KioskMetadataLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KioskMetadataLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KioskMetadataLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KioskMetadataLogMaxAggregateInputType
  }

  export type GetKioskMetadataLogAggregateType<T extends KioskMetadataLogAggregateArgs> = {
        [P in keyof T & keyof AggregateKioskMetadataLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKioskMetadataLog[P]>
      : GetScalarType<T[P], AggregateKioskMetadataLog[P]>
  }




  export type KioskMetadataLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KioskMetadataLogWhereInput
    orderBy?: KioskMetadataLogOrderByWithAggregationInput | KioskMetadataLogOrderByWithAggregationInput[]
    by: KioskMetadataLogScalarFieldEnum[] | KioskMetadataLogScalarFieldEnum
    having?: KioskMetadataLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KioskMetadataLogCountAggregateInputType | true
    _avg?: KioskMetadataLogAvgAggregateInputType
    _sum?: KioskMetadataLogSumAggregateInputType
    _min?: KioskMetadataLogMinAggregateInputType
    _max?: KioskMetadataLogMaxAggregateInputType
  }

  export type KioskMetadataLogGroupByOutputType = {
    id: number
    kioskId: string
    metadataType: string
    encryptedMetadata: string | null
    collectionTimestamp: Date
    _count: KioskMetadataLogCountAggregateOutputType | null
    _avg: KioskMetadataLogAvgAggregateOutputType | null
    _sum: KioskMetadataLogSumAggregateOutputType | null
    _min: KioskMetadataLogMinAggregateOutputType | null
    _max: KioskMetadataLogMaxAggregateOutputType | null
  }

  type GetKioskMetadataLogGroupByPayload<T extends KioskMetadataLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KioskMetadataLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KioskMetadataLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KioskMetadataLogGroupByOutputType[P]>
            : GetScalarType<T[P], KioskMetadataLogGroupByOutputType[P]>
        }
      >
    >


  export type KioskMetadataLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kioskId?: boolean
    metadataType?: boolean
    encryptedMetadata?: boolean
    collectionTimestamp?: boolean
    kiosk?: boolean | KioskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kioskMetadataLog"]>

  export type KioskMetadataLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kioskId?: boolean
    metadataType?: boolean
    encryptedMetadata?: boolean
    collectionTimestamp?: boolean
    kiosk?: boolean | KioskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kioskMetadataLog"]>

  export type KioskMetadataLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kioskId?: boolean
    metadataType?: boolean
    encryptedMetadata?: boolean
    collectionTimestamp?: boolean
    kiosk?: boolean | KioskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kioskMetadataLog"]>

  export type KioskMetadataLogSelectScalar = {
    id?: boolean
    kioskId?: boolean
    metadataType?: boolean
    encryptedMetadata?: boolean
    collectionTimestamp?: boolean
  }

  export type KioskMetadataLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "kioskId" | "metadataType" | "encryptedMetadata" | "collectionTimestamp", ExtArgs["result"]["kioskMetadataLog"]>
  export type KioskMetadataLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kiosk?: boolean | KioskDefaultArgs<ExtArgs>
  }
  export type KioskMetadataLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kiosk?: boolean | KioskDefaultArgs<ExtArgs>
  }
  export type KioskMetadataLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kiosk?: boolean | KioskDefaultArgs<ExtArgs>
  }

  export type $KioskMetadataLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KioskMetadataLog"
    objects: {
      kiosk: Prisma.$KioskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      kioskId: string
      metadataType: string
      encryptedMetadata: string | null
      collectionTimestamp: Date
    }, ExtArgs["result"]["kioskMetadataLog"]>
    composites: {}
  }

  type KioskMetadataLogGetPayload<S extends boolean | null | undefined | KioskMetadataLogDefaultArgs> = $Result.GetResult<Prisma.$KioskMetadataLogPayload, S>

  type KioskMetadataLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KioskMetadataLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KioskMetadataLogCountAggregateInputType | true
    }

  export interface KioskMetadataLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KioskMetadataLog'], meta: { name: 'KioskMetadataLog' } }
    /**
     * Find zero or one KioskMetadataLog that matches the filter.
     * @param {KioskMetadataLogFindUniqueArgs} args - Arguments to find a KioskMetadataLog
     * @example
     * // Get one KioskMetadataLog
     * const kioskMetadataLog = await prisma.kioskMetadataLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KioskMetadataLogFindUniqueArgs>(args: SelectSubset<T, KioskMetadataLogFindUniqueArgs<ExtArgs>>): Prisma__KioskMetadataLogClient<$Result.GetResult<Prisma.$KioskMetadataLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KioskMetadataLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KioskMetadataLogFindUniqueOrThrowArgs} args - Arguments to find a KioskMetadataLog
     * @example
     * // Get one KioskMetadataLog
     * const kioskMetadataLog = await prisma.kioskMetadataLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KioskMetadataLogFindUniqueOrThrowArgs>(args: SelectSubset<T, KioskMetadataLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KioskMetadataLogClient<$Result.GetResult<Prisma.$KioskMetadataLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KioskMetadataLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskMetadataLogFindFirstArgs} args - Arguments to find a KioskMetadataLog
     * @example
     * // Get one KioskMetadataLog
     * const kioskMetadataLog = await prisma.kioskMetadataLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KioskMetadataLogFindFirstArgs>(args?: SelectSubset<T, KioskMetadataLogFindFirstArgs<ExtArgs>>): Prisma__KioskMetadataLogClient<$Result.GetResult<Prisma.$KioskMetadataLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KioskMetadataLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskMetadataLogFindFirstOrThrowArgs} args - Arguments to find a KioskMetadataLog
     * @example
     * // Get one KioskMetadataLog
     * const kioskMetadataLog = await prisma.kioskMetadataLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KioskMetadataLogFindFirstOrThrowArgs>(args?: SelectSubset<T, KioskMetadataLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__KioskMetadataLogClient<$Result.GetResult<Prisma.$KioskMetadataLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KioskMetadataLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskMetadataLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KioskMetadataLogs
     * const kioskMetadataLogs = await prisma.kioskMetadataLog.findMany()
     * 
     * // Get first 10 KioskMetadataLogs
     * const kioskMetadataLogs = await prisma.kioskMetadataLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kioskMetadataLogWithIdOnly = await prisma.kioskMetadataLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KioskMetadataLogFindManyArgs>(args?: SelectSubset<T, KioskMetadataLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KioskMetadataLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KioskMetadataLog.
     * @param {KioskMetadataLogCreateArgs} args - Arguments to create a KioskMetadataLog.
     * @example
     * // Create one KioskMetadataLog
     * const KioskMetadataLog = await prisma.kioskMetadataLog.create({
     *   data: {
     *     // ... data to create a KioskMetadataLog
     *   }
     * })
     * 
     */
    create<T extends KioskMetadataLogCreateArgs>(args: SelectSubset<T, KioskMetadataLogCreateArgs<ExtArgs>>): Prisma__KioskMetadataLogClient<$Result.GetResult<Prisma.$KioskMetadataLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KioskMetadataLogs.
     * @param {KioskMetadataLogCreateManyArgs} args - Arguments to create many KioskMetadataLogs.
     * @example
     * // Create many KioskMetadataLogs
     * const kioskMetadataLog = await prisma.kioskMetadataLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KioskMetadataLogCreateManyArgs>(args?: SelectSubset<T, KioskMetadataLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KioskMetadataLogs and returns the data saved in the database.
     * @param {KioskMetadataLogCreateManyAndReturnArgs} args - Arguments to create many KioskMetadataLogs.
     * @example
     * // Create many KioskMetadataLogs
     * const kioskMetadataLog = await prisma.kioskMetadataLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KioskMetadataLogs and only return the `id`
     * const kioskMetadataLogWithIdOnly = await prisma.kioskMetadataLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KioskMetadataLogCreateManyAndReturnArgs>(args?: SelectSubset<T, KioskMetadataLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KioskMetadataLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KioskMetadataLog.
     * @param {KioskMetadataLogDeleteArgs} args - Arguments to delete one KioskMetadataLog.
     * @example
     * // Delete one KioskMetadataLog
     * const KioskMetadataLog = await prisma.kioskMetadataLog.delete({
     *   where: {
     *     // ... filter to delete one KioskMetadataLog
     *   }
     * })
     * 
     */
    delete<T extends KioskMetadataLogDeleteArgs>(args: SelectSubset<T, KioskMetadataLogDeleteArgs<ExtArgs>>): Prisma__KioskMetadataLogClient<$Result.GetResult<Prisma.$KioskMetadataLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KioskMetadataLog.
     * @param {KioskMetadataLogUpdateArgs} args - Arguments to update one KioskMetadataLog.
     * @example
     * // Update one KioskMetadataLog
     * const kioskMetadataLog = await prisma.kioskMetadataLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KioskMetadataLogUpdateArgs>(args: SelectSubset<T, KioskMetadataLogUpdateArgs<ExtArgs>>): Prisma__KioskMetadataLogClient<$Result.GetResult<Prisma.$KioskMetadataLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KioskMetadataLogs.
     * @param {KioskMetadataLogDeleteManyArgs} args - Arguments to filter KioskMetadataLogs to delete.
     * @example
     * // Delete a few KioskMetadataLogs
     * const { count } = await prisma.kioskMetadataLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KioskMetadataLogDeleteManyArgs>(args?: SelectSubset<T, KioskMetadataLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KioskMetadataLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskMetadataLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KioskMetadataLogs
     * const kioskMetadataLog = await prisma.kioskMetadataLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KioskMetadataLogUpdateManyArgs>(args: SelectSubset<T, KioskMetadataLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KioskMetadataLogs and returns the data updated in the database.
     * @param {KioskMetadataLogUpdateManyAndReturnArgs} args - Arguments to update many KioskMetadataLogs.
     * @example
     * // Update many KioskMetadataLogs
     * const kioskMetadataLog = await prisma.kioskMetadataLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KioskMetadataLogs and only return the `id`
     * const kioskMetadataLogWithIdOnly = await prisma.kioskMetadataLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KioskMetadataLogUpdateManyAndReturnArgs>(args: SelectSubset<T, KioskMetadataLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KioskMetadataLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KioskMetadataLog.
     * @param {KioskMetadataLogUpsertArgs} args - Arguments to update or create a KioskMetadataLog.
     * @example
     * // Update or create a KioskMetadataLog
     * const kioskMetadataLog = await prisma.kioskMetadataLog.upsert({
     *   create: {
     *     // ... data to create a KioskMetadataLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KioskMetadataLog we want to update
     *   }
     * })
     */
    upsert<T extends KioskMetadataLogUpsertArgs>(args: SelectSubset<T, KioskMetadataLogUpsertArgs<ExtArgs>>): Prisma__KioskMetadataLogClient<$Result.GetResult<Prisma.$KioskMetadataLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KioskMetadataLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskMetadataLogCountArgs} args - Arguments to filter KioskMetadataLogs to count.
     * @example
     * // Count the number of KioskMetadataLogs
     * const count = await prisma.kioskMetadataLog.count({
     *   where: {
     *     // ... the filter for the KioskMetadataLogs we want to count
     *   }
     * })
    **/
    count<T extends KioskMetadataLogCountArgs>(
      args?: Subset<T, KioskMetadataLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KioskMetadataLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KioskMetadataLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskMetadataLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KioskMetadataLogAggregateArgs>(args: Subset<T, KioskMetadataLogAggregateArgs>): Prisma.PrismaPromise<GetKioskMetadataLogAggregateType<T>>

    /**
     * Group by KioskMetadataLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KioskMetadataLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KioskMetadataLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KioskMetadataLogGroupByArgs['orderBy'] }
        : { orderBy?: KioskMetadataLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KioskMetadataLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKioskMetadataLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KioskMetadataLog model
   */
  readonly fields: KioskMetadataLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KioskMetadataLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KioskMetadataLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kiosk<T extends KioskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KioskDefaultArgs<ExtArgs>>): Prisma__KioskClient<$Result.GetResult<Prisma.$KioskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KioskMetadataLog model
   */
  interface KioskMetadataLogFieldRefs {
    readonly id: FieldRef<"KioskMetadataLog", 'Int'>
    readonly kioskId: FieldRef<"KioskMetadataLog", 'String'>
    readonly metadataType: FieldRef<"KioskMetadataLog", 'String'>
    readonly encryptedMetadata: FieldRef<"KioskMetadataLog", 'String'>
    readonly collectionTimestamp: FieldRef<"KioskMetadataLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KioskMetadataLog findUnique
   */
  export type KioskMetadataLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskMetadataLog
     */
    select?: KioskMetadataLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskMetadataLog
     */
    omit?: KioskMetadataLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskMetadataLogInclude<ExtArgs> | null
    /**
     * Filter, which KioskMetadataLog to fetch.
     */
    where: KioskMetadataLogWhereUniqueInput
  }

  /**
   * KioskMetadataLog findUniqueOrThrow
   */
  export type KioskMetadataLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskMetadataLog
     */
    select?: KioskMetadataLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskMetadataLog
     */
    omit?: KioskMetadataLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskMetadataLogInclude<ExtArgs> | null
    /**
     * Filter, which KioskMetadataLog to fetch.
     */
    where: KioskMetadataLogWhereUniqueInput
  }

  /**
   * KioskMetadataLog findFirst
   */
  export type KioskMetadataLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskMetadataLog
     */
    select?: KioskMetadataLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskMetadataLog
     */
    omit?: KioskMetadataLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskMetadataLogInclude<ExtArgs> | null
    /**
     * Filter, which KioskMetadataLog to fetch.
     */
    where?: KioskMetadataLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KioskMetadataLogs to fetch.
     */
    orderBy?: KioskMetadataLogOrderByWithRelationInput | KioskMetadataLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KioskMetadataLogs.
     */
    cursor?: KioskMetadataLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KioskMetadataLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KioskMetadataLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KioskMetadataLogs.
     */
    distinct?: KioskMetadataLogScalarFieldEnum | KioskMetadataLogScalarFieldEnum[]
  }

  /**
   * KioskMetadataLog findFirstOrThrow
   */
  export type KioskMetadataLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskMetadataLog
     */
    select?: KioskMetadataLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskMetadataLog
     */
    omit?: KioskMetadataLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskMetadataLogInclude<ExtArgs> | null
    /**
     * Filter, which KioskMetadataLog to fetch.
     */
    where?: KioskMetadataLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KioskMetadataLogs to fetch.
     */
    orderBy?: KioskMetadataLogOrderByWithRelationInput | KioskMetadataLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KioskMetadataLogs.
     */
    cursor?: KioskMetadataLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KioskMetadataLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KioskMetadataLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KioskMetadataLogs.
     */
    distinct?: KioskMetadataLogScalarFieldEnum | KioskMetadataLogScalarFieldEnum[]
  }

  /**
   * KioskMetadataLog findMany
   */
  export type KioskMetadataLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskMetadataLog
     */
    select?: KioskMetadataLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskMetadataLog
     */
    omit?: KioskMetadataLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskMetadataLogInclude<ExtArgs> | null
    /**
     * Filter, which KioskMetadataLogs to fetch.
     */
    where?: KioskMetadataLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KioskMetadataLogs to fetch.
     */
    orderBy?: KioskMetadataLogOrderByWithRelationInput | KioskMetadataLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KioskMetadataLogs.
     */
    cursor?: KioskMetadataLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KioskMetadataLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KioskMetadataLogs.
     */
    skip?: number
    distinct?: KioskMetadataLogScalarFieldEnum | KioskMetadataLogScalarFieldEnum[]
  }

  /**
   * KioskMetadataLog create
   */
  export type KioskMetadataLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskMetadataLog
     */
    select?: KioskMetadataLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskMetadataLog
     */
    omit?: KioskMetadataLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskMetadataLogInclude<ExtArgs> | null
    /**
     * The data needed to create a KioskMetadataLog.
     */
    data: XOR<KioskMetadataLogCreateInput, KioskMetadataLogUncheckedCreateInput>
  }

  /**
   * KioskMetadataLog createMany
   */
  export type KioskMetadataLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KioskMetadataLogs.
     */
    data: KioskMetadataLogCreateManyInput | KioskMetadataLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KioskMetadataLog createManyAndReturn
   */
  export type KioskMetadataLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskMetadataLog
     */
    select?: KioskMetadataLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KioskMetadataLog
     */
    omit?: KioskMetadataLogOmit<ExtArgs> | null
    /**
     * The data used to create many KioskMetadataLogs.
     */
    data: KioskMetadataLogCreateManyInput | KioskMetadataLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskMetadataLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KioskMetadataLog update
   */
  export type KioskMetadataLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskMetadataLog
     */
    select?: KioskMetadataLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskMetadataLog
     */
    omit?: KioskMetadataLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskMetadataLogInclude<ExtArgs> | null
    /**
     * The data needed to update a KioskMetadataLog.
     */
    data: XOR<KioskMetadataLogUpdateInput, KioskMetadataLogUncheckedUpdateInput>
    /**
     * Choose, which KioskMetadataLog to update.
     */
    where: KioskMetadataLogWhereUniqueInput
  }

  /**
   * KioskMetadataLog updateMany
   */
  export type KioskMetadataLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KioskMetadataLogs.
     */
    data: XOR<KioskMetadataLogUpdateManyMutationInput, KioskMetadataLogUncheckedUpdateManyInput>
    /**
     * Filter which KioskMetadataLogs to update
     */
    where?: KioskMetadataLogWhereInput
    /**
     * Limit how many KioskMetadataLogs to update.
     */
    limit?: number
  }

  /**
   * KioskMetadataLog updateManyAndReturn
   */
  export type KioskMetadataLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskMetadataLog
     */
    select?: KioskMetadataLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KioskMetadataLog
     */
    omit?: KioskMetadataLogOmit<ExtArgs> | null
    /**
     * The data used to update KioskMetadataLogs.
     */
    data: XOR<KioskMetadataLogUpdateManyMutationInput, KioskMetadataLogUncheckedUpdateManyInput>
    /**
     * Filter which KioskMetadataLogs to update
     */
    where?: KioskMetadataLogWhereInput
    /**
     * Limit how many KioskMetadataLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskMetadataLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KioskMetadataLog upsert
   */
  export type KioskMetadataLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskMetadataLog
     */
    select?: KioskMetadataLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskMetadataLog
     */
    omit?: KioskMetadataLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskMetadataLogInclude<ExtArgs> | null
    /**
     * The filter to search for the KioskMetadataLog to update in case it exists.
     */
    where: KioskMetadataLogWhereUniqueInput
    /**
     * In case the KioskMetadataLog found by the `where` argument doesn't exist, create a new KioskMetadataLog with this data.
     */
    create: XOR<KioskMetadataLogCreateInput, KioskMetadataLogUncheckedCreateInput>
    /**
     * In case the KioskMetadataLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KioskMetadataLogUpdateInput, KioskMetadataLogUncheckedUpdateInput>
  }

  /**
   * KioskMetadataLog delete
   */
  export type KioskMetadataLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskMetadataLog
     */
    select?: KioskMetadataLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskMetadataLog
     */
    omit?: KioskMetadataLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskMetadataLogInclude<ExtArgs> | null
    /**
     * Filter which KioskMetadataLog to delete.
     */
    where: KioskMetadataLogWhereUniqueInput
  }

  /**
   * KioskMetadataLog deleteMany
   */
  export type KioskMetadataLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KioskMetadataLogs to delete
     */
    where?: KioskMetadataLogWhereInput
    /**
     * Limit how many KioskMetadataLogs to delete.
     */
    limit?: number
  }

  /**
   * KioskMetadataLog without action
   */
  export type KioskMetadataLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KioskMetadataLog
     */
    select?: KioskMetadataLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KioskMetadataLog
     */
    omit?: KioskMetadataLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KioskMetadataLogInclude<ExtArgs> | null
  }


  /**
   * Model XpEvent
   */

  export type AggregateXpEvent = {
    _count: XpEventCountAggregateOutputType | null
    _avg: XpEventAvgAggregateOutputType | null
    _sum: XpEventSumAggregateOutputType | null
    _min: XpEventMinAggregateOutputType | null
    _max: XpEventMaxAggregateOutputType | null
  }

  export type XpEventAvgAggregateOutputType = {
    id: number | null
    amount: number | null
  }

  export type XpEventSumAggregateOutputType = {
    id: number | null
    amount: number | null
  }

  export type XpEventMinAggregateOutputType = {
    id: number | null
    userId: string | null
    amount: number | null
    reason: string | null
    createdAt: Date | null
  }

  export type XpEventMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    amount: number | null
    reason: string | null
    createdAt: Date | null
  }

  export type XpEventCountAggregateOutputType = {
    id: number
    userId: number
    amount: number
    reason: number
    createdAt: number
    _all: number
  }


  export type XpEventAvgAggregateInputType = {
    id?: true
    amount?: true
  }

  export type XpEventSumAggregateInputType = {
    id?: true
    amount?: true
  }

  export type XpEventMinAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    reason?: true
    createdAt?: true
  }

  export type XpEventMaxAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    reason?: true
    createdAt?: true
  }

  export type XpEventCountAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    reason?: true
    createdAt?: true
    _all?: true
  }

  export type XpEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XpEvent to aggregate.
     */
    where?: XpEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XpEvents to fetch.
     */
    orderBy?: XpEventOrderByWithRelationInput | XpEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: XpEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XpEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XpEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned XpEvents
    **/
    _count?: true | XpEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: XpEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: XpEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: XpEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: XpEventMaxAggregateInputType
  }

  export type GetXpEventAggregateType<T extends XpEventAggregateArgs> = {
        [P in keyof T & keyof AggregateXpEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateXpEvent[P]>
      : GetScalarType<T[P], AggregateXpEvent[P]>
  }




  export type XpEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XpEventWhereInput
    orderBy?: XpEventOrderByWithAggregationInput | XpEventOrderByWithAggregationInput[]
    by: XpEventScalarFieldEnum[] | XpEventScalarFieldEnum
    having?: XpEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: XpEventCountAggregateInputType | true
    _avg?: XpEventAvgAggregateInputType
    _sum?: XpEventSumAggregateInputType
    _min?: XpEventMinAggregateInputType
    _max?: XpEventMaxAggregateInputType
  }

  export type XpEventGroupByOutputType = {
    id: number
    userId: string
    amount: number
    reason: string | null
    createdAt: Date
    _count: XpEventCountAggregateOutputType | null
    _avg: XpEventAvgAggregateOutputType | null
    _sum: XpEventSumAggregateOutputType | null
    _min: XpEventMinAggregateOutputType | null
    _max: XpEventMaxAggregateOutputType | null
  }

  type GetXpEventGroupByPayload<T extends XpEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<XpEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof XpEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], XpEventGroupByOutputType[P]>
            : GetScalarType<T[P], XpEventGroupByOutputType[P]>
        }
      >
    >


  export type XpEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    reason?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["xpEvent"]>

  export type XpEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    reason?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["xpEvent"]>

  export type XpEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    reason?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["xpEvent"]>

  export type XpEventSelectScalar = {
    id?: boolean
    userId?: boolean
    amount?: boolean
    reason?: boolean
    createdAt?: boolean
  }

  export type XpEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "amount" | "reason" | "createdAt", ExtArgs["result"]["xpEvent"]>
  export type XpEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type XpEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type XpEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $XpEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "XpEvent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      amount: number
      reason: string | null
      createdAt: Date
    }, ExtArgs["result"]["xpEvent"]>
    composites: {}
  }

  type XpEventGetPayload<S extends boolean | null | undefined | XpEventDefaultArgs> = $Result.GetResult<Prisma.$XpEventPayload, S>

  type XpEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<XpEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: XpEventCountAggregateInputType | true
    }

  export interface XpEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['XpEvent'], meta: { name: 'XpEvent' } }
    /**
     * Find zero or one XpEvent that matches the filter.
     * @param {XpEventFindUniqueArgs} args - Arguments to find a XpEvent
     * @example
     * // Get one XpEvent
     * const xpEvent = await prisma.xpEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends XpEventFindUniqueArgs>(args: SelectSubset<T, XpEventFindUniqueArgs<ExtArgs>>): Prisma__XpEventClient<$Result.GetResult<Prisma.$XpEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one XpEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {XpEventFindUniqueOrThrowArgs} args - Arguments to find a XpEvent
     * @example
     * // Get one XpEvent
     * const xpEvent = await prisma.xpEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends XpEventFindUniqueOrThrowArgs>(args: SelectSubset<T, XpEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__XpEventClient<$Result.GetResult<Prisma.$XpEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first XpEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XpEventFindFirstArgs} args - Arguments to find a XpEvent
     * @example
     * // Get one XpEvent
     * const xpEvent = await prisma.xpEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends XpEventFindFirstArgs>(args?: SelectSubset<T, XpEventFindFirstArgs<ExtArgs>>): Prisma__XpEventClient<$Result.GetResult<Prisma.$XpEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first XpEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XpEventFindFirstOrThrowArgs} args - Arguments to find a XpEvent
     * @example
     * // Get one XpEvent
     * const xpEvent = await prisma.xpEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends XpEventFindFirstOrThrowArgs>(args?: SelectSubset<T, XpEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__XpEventClient<$Result.GetResult<Prisma.$XpEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more XpEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XpEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all XpEvents
     * const xpEvents = await prisma.xpEvent.findMany()
     * 
     * // Get first 10 XpEvents
     * const xpEvents = await prisma.xpEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const xpEventWithIdOnly = await prisma.xpEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends XpEventFindManyArgs>(args?: SelectSubset<T, XpEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XpEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a XpEvent.
     * @param {XpEventCreateArgs} args - Arguments to create a XpEvent.
     * @example
     * // Create one XpEvent
     * const XpEvent = await prisma.xpEvent.create({
     *   data: {
     *     // ... data to create a XpEvent
     *   }
     * })
     * 
     */
    create<T extends XpEventCreateArgs>(args: SelectSubset<T, XpEventCreateArgs<ExtArgs>>): Prisma__XpEventClient<$Result.GetResult<Prisma.$XpEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many XpEvents.
     * @param {XpEventCreateManyArgs} args - Arguments to create many XpEvents.
     * @example
     * // Create many XpEvents
     * const xpEvent = await prisma.xpEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends XpEventCreateManyArgs>(args?: SelectSubset<T, XpEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many XpEvents and returns the data saved in the database.
     * @param {XpEventCreateManyAndReturnArgs} args - Arguments to create many XpEvents.
     * @example
     * // Create many XpEvents
     * const xpEvent = await prisma.xpEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many XpEvents and only return the `id`
     * const xpEventWithIdOnly = await prisma.xpEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends XpEventCreateManyAndReturnArgs>(args?: SelectSubset<T, XpEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XpEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a XpEvent.
     * @param {XpEventDeleteArgs} args - Arguments to delete one XpEvent.
     * @example
     * // Delete one XpEvent
     * const XpEvent = await prisma.xpEvent.delete({
     *   where: {
     *     // ... filter to delete one XpEvent
     *   }
     * })
     * 
     */
    delete<T extends XpEventDeleteArgs>(args: SelectSubset<T, XpEventDeleteArgs<ExtArgs>>): Prisma__XpEventClient<$Result.GetResult<Prisma.$XpEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one XpEvent.
     * @param {XpEventUpdateArgs} args - Arguments to update one XpEvent.
     * @example
     * // Update one XpEvent
     * const xpEvent = await prisma.xpEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends XpEventUpdateArgs>(args: SelectSubset<T, XpEventUpdateArgs<ExtArgs>>): Prisma__XpEventClient<$Result.GetResult<Prisma.$XpEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more XpEvents.
     * @param {XpEventDeleteManyArgs} args - Arguments to filter XpEvents to delete.
     * @example
     * // Delete a few XpEvents
     * const { count } = await prisma.xpEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends XpEventDeleteManyArgs>(args?: SelectSubset<T, XpEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more XpEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XpEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many XpEvents
     * const xpEvent = await prisma.xpEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends XpEventUpdateManyArgs>(args: SelectSubset<T, XpEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more XpEvents and returns the data updated in the database.
     * @param {XpEventUpdateManyAndReturnArgs} args - Arguments to update many XpEvents.
     * @example
     * // Update many XpEvents
     * const xpEvent = await prisma.xpEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more XpEvents and only return the `id`
     * const xpEventWithIdOnly = await prisma.xpEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends XpEventUpdateManyAndReturnArgs>(args: SelectSubset<T, XpEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XpEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one XpEvent.
     * @param {XpEventUpsertArgs} args - Arguments to update or create a XpEvent.
     * @example
     * // Update or create a XpEvent
     * const xpEvent = await prisma.xpEvent.upsert({
     *   create: {
     *     // ... data to create a XpEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the XpEvent we want to update
     *   }
     * })
     */
    upsert<T extends XpEventUpsertArgs>(args: SelectSubset<T, XpEventUpsertArgs<ExtArgs>>): Prisma__XpEventClient<$Result.GetResult<Prisma.$XpEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of XpEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XpEventCountArgs} args - Arguments to filter XpEvents to count.
     * @example
     * // Count the number of XpEvents
     * const count = await prisma.xpEvent.count({
     *   where: {
     *     // ... the filter for the XpEvents we want to count
     *   }
     * })
    **/
    count<T extends XpEventCountArgs>(
      args?: Subset<T, XpEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], XpEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a XpEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XpEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends XpEventAggregateArgs>(args: Subset<T, XpEventAggregateArgs>): Prisma.PrismaPromise<GetXpEventAggregateType<T>>

    /**
     * Group by XpEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XpEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends XpEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: XpEventGroupByArgs['orderBy'] }
        : { orderBy?: XpEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, XpEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetXpEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the XpEvent model
   */
  readonly fields: XpEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for XpEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__XpEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the XpEvent model
   */
  interface XpEventFieldRefs {
    readonly id: FieldRef<"XpEvent", 'Int'>
    readonly userId: FieldRef<"XpEvent", 'String'>
    readonly amount: FieldRef<"XpEvent", 'Int'>
    readonly reason: FieldRef<"XpEvent", 'String'>
    readonly createdAt: FieldRef<"XpEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * XpEvent findUnique
   */
  export type XpEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XpEvent
     */
    select?: XpEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XpEvent
     */
    omit?: XpEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XpEventInclude<ExtArgs> | null
    /**
     * Filter, which XpEvent to fetch.
     */
    where: XpEventWhereUniqueInput
  }

  /**
   * XpEvent findUniqueOrThrow
   */
  export type XpEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XpEvent
     */
    select?: XpEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XpEvent
     */
    omit?: XpEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XpEventInclude<ExtArgs> | null
    /**
     * Filter, which XpEvent to fetch.
     */
    where: XpEventWhereUniqueInput
  }

  /**
   * XpEvent findFirst
   */
  export type XpEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XpEvent
     */
    select?: XpEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XpEvent
     */
    omit?: XpEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XpEventInclude<ExtArgs> | null
    /**
     * Filter, which XpEvent to fetch.
     */
    where?: XpEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XpEvents to fetch.
     */
    orderBy?: XpEventOrderByWithRelationInput | XpEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XpEvents.
     */
    cursor?: XpEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XpEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XpEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XpEvents.
     */
    distinct?: XpEventScalarFieldEnum | XpEventScalarFieldEnum[]
  }

  /**
   * XpEvent findFirstOrThrow
   */
  export type XpEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XpEvent
     */
    select?: XpEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XpEvent
     */
    omit?: XpEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XpEventInclude<ExtArgs> | null
    /**
     * Filter, which XpEvent to fetch.
     */
    where?: XpEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XpEvents to fetch.
     */
    orderBy?: XpEventOrderByWithRelationInput | XpEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XpEvents.
     */
    cursor?: XpEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XpEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XpEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XpEvents.
     */
    distinct?: XpEventScalarFieldEnum | XpEventScalarFieldEnum[]
  }

  /**
   * XpEvent findMany
   */
  export type XpEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XpEvent
     */
    select?: XpEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XpEvent
     */
    omit?: XpEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XpEventInclude<ExtArgs> | null
    /**
     * Filter, which XpEvents to fetch.
     */
    where?: XpEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XpEvents to fetch.
     */
    orderBy?: XpEventOrderByWithRelationInput | XpEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing XpEvents.
     */
    cursor?: XpEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XpEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XpEvents.
     */
    skip?: number
    distinct?: XpEventScalarFieldEnum | XpEventScalarFieldEnum[]
  }

  /**
   * XpEvent create
   */
  export type XpEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XpEvent
     */
    select?: XpEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XpEvent
     */
    omit?: XpEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XpEventInclude<ExtArgs> | null
    /**
     * The data needed to create a XpEvent.
     */
    data: XOR<XpEventCreateInput, XpEventUncheckedCreateInput>
  }

  /**
   * XpEvent createMany
   */
  export type XpEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many XpEvents.
     */
    data: XpEventCreateManyInput | XpEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * XpEvent createManyAndReturn
   */
  export type XpEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XpEvent
     */
    select?: XpEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the XpEvent
     */
    omit?: XpEventOmit<ExtArgs> | null
    /**
     * The data used to create many XpEvents.
     */
    data: XpEventCreateManyInput | XpEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XpEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * XpEvent update
   */
  export type XpEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XpEvent
     */
    select?: XpEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XpEvent
     */
    omit?: XpEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XpEventInclude<ExtArgs> | null
    /**
     * The data needed to update a XpEvent.
     */
    data: XOR<XpEventUpdateInput, XpEventUncheckedUpdateInput>
    /**
     * Choose, which XpEvent to update.
     */
    where: XpEventWhereUniqueInput
  }

  /**
   * XpEvent updateMany
   */
  export type XpEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update XpEvents.
     */
    data: XOR<XpEventUpdateManyMutationInput, XpEventUncheckedUpdateManyInput>
    /**
     * Filter which XpEvents to update
     */
    where?: XpEventWhereInput
    /**
     * Limit how many XpEvents to update.
     */
    limit?: number
  }

  /**
   * XpEvent updateManyAndReturn
   */
  export type XpEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XpEvent
     */
    select?: XpEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the XpEvent
     */
    omit?: XpEventOmit<ExtArgs> | null
    /**
     * The data used to update XpEvents.
     */
    data: XOR<XpEventUpdateManyMutationInput, XpEventUncheckedUpdateManyInput>
    /**
     * Filter which XpEvents to update
     */
    where?: XpEventWhereInput
    /**
     * Limit how many XpEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XpEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * XpEvent upsert
   */
  export type XpEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XpEvent
     */
    select?: XpEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XpEvent
     */
    omit?: XpEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XpEventInclude<ExtArgs> | null
    /**
     * The filter to search for the XpEvent to update in case it exists.
     */
    where: XpEventWhereUniqueInput
    /**
     * In case the XpEvent found by the `where` argument doesn't exist, create a new XpEvent with this data.
     */
    create: XOR<XpEventCreateInput, XpEventUncheckedCreateInput>
    /**
     * In case the XpEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<XpEventUpdateInput, XpEventUncheckedUpdateInput>
  }

  /**
   * XpEvent delete
   */
  export type XpEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XpEvent
     */
    select?: XpEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XpEvent
     */
    omit?: XpEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XpEventInclude<ExtArgs> | null
    /**
     * Filter which XpEvent to delete.
     */
    where: XpEventWhereUniqueInput
  }

  /**
   * XpEvent deleteMany
   */
  export type XpEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XpEvents to delete
     */
    where?: XpEventWhereInput
    /**
     * Limit how many XpEvents to delete.
     */
    limit?: number
  }

  /**
   * XpEvent without action
   */
  export type XpEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XpEvent
     */
    select?: XpEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XpEvent
     */
    omit?: XpEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XpEventInclude<ExtArgs> | null
  }


  /**
   * Model Leaderboard
   */

  export type AggregateLeaderboard = {
    _count: LeaderboardCountAggregateOutputType | null
    _avg: LeaderboardAvgAggregateOutputType | null
    _sum: LeaderboardSumAggregateOutputType | null
    _min: LeaderboardMinAggregateOutputType | null
    _max: LeaderboardMaxAggregateOutputType | null
  }

  export type LeaderboardAvgAggregateOutputType = {
    xpTotal: number | null
  }

  export type LeaderboardSumAggregateOutputType = {
    xpTotal: number | null
  }

  export type LeaderboardMinAggregateOutputType = {
    userId: string | null
    xpTotal: number | null
  }

  export type LeaderboardMaxAggregateOutputType = {
    userId: string | null
    xpTotal: number | null
  }

  export type LeaderboardCountAggregateOutputType = {
    userId: number
    xpTotal: number
    _all: number
  }


  export type LeaderboardAvgAggregateInputType = {
    xpTotal?: true
  }

  export type LeaderboardSumAggregateInputType = {
    xpTotal?: true
  }

  export type LeaderboardMinAggregateInputType = {
    userId?: true
    xpTotal?: true
  }

  export type LeaderboardMaxAggregateInputType = {
    userId?: true
    xpTotal?: true
  }

  export type LeaderboardCountAggregateInputType = {
    userId?: true
    xpTotal?: true
    _all?: true
  }

  export type LeaderboardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leaderboard to aggregate.
     */
    where?: LeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaderboards to fetch.
     */
    orderBy?: LeaderboardOrderByWithRelationInput | LeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leaderboards
    **/
    _count?: true | LeaderboardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaderboardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaderboardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaderboardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaderboardMaxAggregateInputType
  }

  export type GetLeaderboardAggregateType<T extends LeaderboardAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaderboard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaderboard[P]>
      : GetScalarType<T[P], AggregateLeaderboard[P]>
  }




  export type LeaderboardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaderboardWhereInput
    orderBy?: LeaderboardOrderByWithAggregationInput | LeaderboardOrderByWithAggregationInput[]
    by: LeaderboardScalarFieldEnum[] | LeaderboardScalarFieldEnum
    having?: LeaderboardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaderboardCountAggregateInputType | true
    _avg?: LeaderboardAvgAggregateInputType
    _sum?: LeaderboardSumAggregateInputType
    _min?: LeaderboardMinAggregateInputType
    _max?: LeaderboardMaxAggregateInputType
  }

  export type LeaderboardGroupByOutputType = {
    userId: string
    xpTotal: number
    _count: LeaderboardCountAggregateOutputType | null
    _avg: LeaderboardAvgAggregateOutputType | null
    _sum: LeaderboardSumAggregateOutputType | null
    _min: LeaderboardMinAggregateOutputType | null
    _max: LeaderboardMaxAggregateOutputType | null
  }

  type GetLeaderboardGroupByPayload<T extends LeaderboardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaderboardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaderboardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaderboardGroupByOutputType[P]>
            : GetScalarType<T[P], LeaderboardGroupByOutputType[P]>
        }
      >
    >


  export type LeaderboardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    xpTotal?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaderboard"]>

  export type LeaderboardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    xpTotal?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaderboard"]>

  export type LeaderboardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    xpTotal?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaderboard"]>

  export type LeaderboardSelectScalar = {
    userId?: boolean
    xpTotal?: boolean
  }

  export type LeaderboardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "xpTotal", ExtArgs["result"]["leaderboard"]>
  export type LeaderboardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LeaderboardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LeaderboardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LeaderboardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Leaderboard"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      xpTotal: number
    }, ExtArgs["result"]["leaderboard"]>
    composites: {}
  }

  type LeaderboardGetPayload<S extends boolean | null | undefined | LeaderboardDefaultArgs> = $Result.GetResult<Prisma.$LeaderboardPayload, S>

  type LeaderboardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeaderboardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeaderboardCountAggregateInputType | true
    }

  export interface LeaderboardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Leaderboard'], meta: { name: 'Leaderboard' } }
    /**
     * Find zero or one Leaderboard that matches the filter.
     * @param {LeaderboardFindUniqueArgs} args - Arguments to find a Leaderboard
     * @example
     * // Get one Leaderboard
     * const leaderboard = await prisma.leaderboard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaderboardFindUniqueArgs>(args: SelectSubset<T, LeaderboardFindUniqueArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Leaderboard that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeaderboardFindUniqueOrThrowArgs} args - Arguments to find a Leaderboard
     * @example
     * // Get one Leaderboard
     * const leaderboard = await prisma.leaderboard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaderboardFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaderboardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Leaderboard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardFindFirstArgs} args - Arguments to find a Leaderboard
     * @example
     * // Get one Leaderboard
     * const leaderboard = await prisma.leaderboard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaderboardFindFirstArgs>(args?: SelectSubset<T, LeaderboardFindFirstArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Leaderboard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardFindFirstOrThrowArgs} args - Arguments to find a Leaderboard
     * @example
     * // Get one Leaderboard
     * const leaderboard = await prisma.leaderboard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaderboardFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaderboardFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leaderboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leaderboards
     * const leaderboards = await prisma.leaderboard.findMany()
     * 
     * // Get first 10 Leaderboards
     * const leaderboards = await prisma.leaderboard.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const leaderboardWithUserIdOnly = await prisma.leaderboard.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends LeaderboardFindManyArgs>(args?: SelectSubset<T, LeaderboardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Leaderboard.
     * @param {LeaderboardCreateArgs} args - Arguments to create a Leaderboard.
     * @example
     * // Create one Leaderboard
     * const Leaderboard = await prisma.leaderboard.create({
     *   data: {
     *     // ... data to create a Leaderboard
     *   }
     * })
     * 
     */
    create<T extends LeaderboardCreateArgs>(args: SelectSubset<T, LeaderboardCreateArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leaderboards.
     * @param {LeaderboardCreateManyArgs} args - Arguments to create many Leaderboards.
     * @example
     * // Create many Leaderboards
     * const leaderboard = await prisma.leaderboard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaderboardCreateManyArgs>(args?: SelectSubset<T, LeaderboardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leaderboards and returns the data saved in the database.
     * @param {LeaderboardCreateManyAndReturnArgs} args - Arguments to create many Leaderboards.
     * @example
     * // Create many Leaderboards
     * const leaderboard = await prisma.leaderboard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leaderboards and only return the `userId`
     * const leaderboardWithUserIdOnly = await prisma.leaderboard.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaderboardCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaderboardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Leaderboard.
     * @param {LeaderboardDeleteArgs} args - Arguments to delete one Leaderboard.
     * @example
     * // Delete one Leaderboard
     * const Leaderboard = await prisma.leaderboard.delete({
     *   where: {
     *     // ... filter to delete one Leaderboard
     *   }
     * })
     * 
     */
    delete<T extends LeaderboardDeleteArgs>(args: SelectSubset<T, LeaderboardDeleteArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Leaderboard.
     * @param {LeaderboardUpdateArgs} args - Arguments to update one Leaderboard.
     * @example
     * // Update one Leaderboard
     * const leaderboard = await prisma.leaderboard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaderboardUpdateArgs>(args: SelectSubset<T, LeaderboardUpdateArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leaderboards.
     * @param {LeaderboardDeleteManyArgs} args - Arguments to filter Leaderboards to delete.
     * @example
     * // Delete a few Leaderboards
     * const { count } = await prisma.leaderboard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaderboardDeleteManyArgs>(args?: SelectSubset<T, LeaderboardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leaderboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leaderboards
     * const leaderboard = await prisma.leaderboard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaderboardUpdateManyArgs>(args: SelectSubset<T, LeaderboardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leaderboards and returns the data updated in the database.
     * @param {LeaderboardUpdateManyAndReturnArgs} args - Arguments to update many Leaderboards.
     * @example
     * // Update many Leaderboards
     * const leaderboard = await prisma.leaderboard.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Leaderboards and only return the `userId`
     * const leaderboardWithUserIdOnly = await prisma.leaderboard.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeaderboardUpdateManyAndReturnArgs>(args: SelectSubset<T, LeaderboardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Leaderboard.
     * @param {LeaderboardUpsertArgs} args - Arguments to update or create a Leaderboard.
     * @example
     * // Update or create a Leaderboard
     * const leaderboard = await prisma.leaderboard.upsert({
     *   create: {
     *     // ... data to create a Leaderboard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Leaderboard we want to update
     *   }
     * })
     */
    upsert<T extends LeaderboardUpsertArgs>(args: SelectSubset<T, LeaderboardUpsertArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leaderboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardCountArgs} args - Arguments to filter Leaderboards to count.
     * @example
     * // Count the number of Leaderboards
     * const count = await prisma.leaderboard.count({
     *   where: {
     *     // ... the filter for the Leaderboards we want to count
     *   }
     * })
    **/
    count<T extends LeaderboardCountArgs>(
      args?: Subset<T, LeaderboardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaderboardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Leaderboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaderboardAggregateArgs>(args: Subset<T, LeaderboardAggregateArgs>): Prisma.PrismaPromise<GetLeaderboardAggregateType<T>>

    /**
     * Group by Leaderboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaderboardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaderboardGroupByArgs['orderBy'] }
        : { orderBy?: LeaderboardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaderboardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaderboardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Leaderboard model
   */
  readonly fields: LeaderboardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Leaderboard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaderboardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Leaderboard model
   */
  interface LeaderboardFieldRefs {
    readonly userId: FieldRef<"Leaderboard", 'String'>
    readonly xpTotal: FieldRef<"Leaderboard", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Leaderboard findUnique
   */
  export type LeaderboardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leaderboard
     */
    omit?: LeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which Leaderboard to fetch.
     */
    where: LeaderboardWhereUniqueInput
  }

  /**
   * Leaderboard findUniqueOrThrow
   */
  export type LeaderboardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leaderboard
     */
    omit?: LeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which Leaderboard to fetch.
     */
    where: LeaderboardWhereUniqueInput
  }

  /**
   * Leaderboard findFirst
   */
  export type LeaderboardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leaderboard
     */
    omit?: LeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which Leaderboard to fetch.
     */
    where?: LeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaderboards to fetch.
     */
    orderBy?: LeaderboardOrderByWithRelationInput | LeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leaderboards.
     */
    cursor?: LeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leaderboards.
     */
    distinct?: LeaderboardScalarFieldEnum | LeaderboardScalarFieldEnum[]
  }

  /**
   * Leaderboard findFirstOrThrow
   */
  export type LeaderboardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leaderboard
     */
    omit?: LeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which Leaderboard to fetch.
     */
    where?: LeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaderboards to fetch.
     */
    orderBy?: LeaderboardOrderByWithRelationInput | LeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leaderboards.
     */
    cursor?: LeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leaderboards.
     */
    distinct?: LeaderboardScalarFieldEnum | LeaderboardScalarFieldEnum[]
  }

  /**
   * Leaderboard findMany
   */
  export type LeaderboardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leaderboard
     */
    omit?: LeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which Leaderboards to fetch.
     */
    where?: LeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaderboards to fetch.
     */
    orderBy?: LeaderboardOrderByWithRelationInput | LeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leaderboards.
     */
    cursor?: LeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaderboards.
     */
    skip?: number
    distinct?: LeaderboardScalarFieldEnum | LeaderboardScalarFieldEnum[]
  }

  /**
   * Leaderboard create
   */
  export type LeaderboardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leaderboard
     */
    omit?: LeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * The data needed to create a Leaderboard.
     */
    data: XOR<LeaderboardCreateInput, LeaderboardUncheckedCreateInput>
  }

  /**
   * Leaderboard createMany
   */
  export type LeaderboardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leaderboards.
     */
    data: LeaderboardCreateManyInput | LeaderboardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Leaderboard createManyAndReturn
   */
  export type LeaderboardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Leaderboard
     */
    omit?: LeaderboardOmit<ExtArgs> | null
    /**
     * The data used to create many Leaderboards.
     */
    data: LeaderboardCreateManyInput | LeaderboardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Leaderboard update
   */
  export type LeaderboardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leaderboard
     */
    omit?: LeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * The data needed to update a Leaderboard.
     */
    data: XOR<LeaderboardUpdateInput, LeaderboardUncheckedUpdateInput>
    /**
     * Choose, which Leaderboard to update.
     */
    where: LeaderboardWhereUniqueInput
  }

  /**
   * Leaderboard updateMany
   */
  export type LeaderboardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leaderboards.
     */
    data: XOR<LeaderboardUpdateManyMutationInput, LeaderboardUncheckedUpdateManyInput>
    /**
     * Filter which Leaderboards to update
     */
    where?: LeaderboardWhereInput
    /**
     * Limit how many Leaderboards to update.
     */
    limit?: number
  }

  /**
   * Leaderboard updateManyAndReturn
   */
  export type LeaderboardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Leaderboard
     */
    omit?: LeaderboardOmit<ExtArgs> | null
    /**
     * The data used to update Leaderboards.
     */
    data: XOR<LeaderboardUpdateManyMutationInput, LeaderboardUncheckedUpdateManyInput>
    /**
     * Filter which Leaderboards to update
     */
    where?: LeaderboardWhereInput
    /**
     * Limit how many Leaderboards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Leaderboard upsert
   */
  export type LeaderboardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leaderboard
     */
    omit?: LeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * The filter to search for the Leaderboard to update in case it exists.
     */
    where: LeaderboardWhereUniqueInput
    /**
     * In case the Leaderboard found by the `where` argument doesn't exist, create a new Leaderboard with this data.
     */
    create: XOR<LeaderboardCreateInput, LeaderboardUncheckedCreateInput>
    /**
     * In case the Leaderboard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaderboardUpdateInput, LeaderboardUncheckedUpdateInput>
  }

  /**
   * Leaderboard delete
   */
  export type LeaderboardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leaderboard
     */
    omit?: LeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter which Leaderboard to delete.
     */
    where: LeaderboardWhereUniqueInput
  }

  /**
   * Leaderboard deleteMany
   */
  export type LeaderboardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leaderboards to delete
     */
    where?: LeaderboardWhereInput
    /**
     * Limit how many Leaderboards to delete.
     */
    limit?: number
  }

  /**
   * Leaderboard without action
   */
  export type LeaderboardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leaderboard
     */
    omit?: LeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
  }


  /**
   * Model ScimMapping
   */

  export type AggregateScimMapping = {
    _count: ScimMappingCountAggregateOutputType | null
    _min: ScimMappingMinAggregateOutputType | null
    _max: ScimMappingMaxAggregateOutputType | null
  }

  export type ScimMappingMinAggregateOutputType = {
    id: string | null
    externalId: string | null
    userId: string | null
    provider: string | null
    syncTime: Date | null
  }

  export type ScimMappingMaxAggregateOutputType = {
    id: string | null
    externalId: string | null
    userId: string | null
    provider: string | null
    syncTime: Date | null
  }

  export type ScimMappingCountAggregateOutputType = {
    id: number
    externalId: number
    userId: number
    provider: number
    syncTime: number
    _all: number
  }


  export type ScimMappingMinAggregateInputType = {
    id?: true
    externalId?: true
    userId?: true
    provider?: true
    syncTime?: true
  }

  export type ScimMappingMaxAggregateInputType = {
    id?: true
    externalId?: true
    userId?: true
    provider?: true
    syncTime?: true
  }

  export type ScimMappingCountAggregateInputType = {
    id?: true
    externalId?: true
    userId?: true
    provider?: true
    syncTime?: true
    _all?: true
  }

  export type ScimMappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScimMapping to aggregate.
     */
    where?: ScimMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScimMappings to fetch.
     */
    orderBy?: ScimMappingOrderByWithRelationInput | ScimMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScimMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScimMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScimMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScimMappings
    **/
    _count?: true | ScimMappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScimMappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScimMappingMaxAggregateInputType
  }

  export type GetScimMappingAggregateType<T extends ScimMappingAggregateArgs> = {
        [P in keyof T & keyof AggregateScimMapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScimMapping[P]>
      : GetScalarType<T[P], AggregateScimMapping[P]>
  }




  export type ScimMappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScimMappingWhereInput
    orderBy?: ScimMappingOrderByWithAggregationInput | ScimMappingOrderByWithAggregationInput[]
    by: ScimMappingScalarFieldEnum[] | ScimMappingScalarFieldEnum
    having?: ScimMappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScimMappingCountAggregateInputType | true
    _min?: ScimMappingMinAggregateInputType
    _max?: ScimMappingMaxAggregateInputType
  }

  export type ScimMappingGroupByOutputType = {
    id: string
    externalId: string | null
    userId: string
    provider: string | null
    syncTime: Date | null
    _count: ScimMappingCountAggregateOutputType | null
    _min: ScimMappingMinAggregateOutputType | null
    _max: ScimMappingMaxAggregateOutputType | null
  }

  type GetScimMappingGroupByPayload<T extends ScimMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScimMappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScimMappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScimMappingGroupByOutputType[P]>
            : GetScalarType<T[P], ScimMappingGroupByOutputType[P]>
        }
      >
    >


  export type ScimMappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    userId?: boolean
    provider?: boolean
    syncTime?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scimMapping"]>

  export type ScimMappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    userId?: boolean
    provider?: boolean
    syncTime?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scimMapping"]>

  export type ScimMappingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    userId?: boolean
    provider?: boolean
    syncTime?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scimMapping"]>

  export type ScimMappingSelectScalar = {
    id?: boolean
    externalId?: boolean
    userId?: boolean
    provider?: boolean
    syncTime?: boolean
  }

  export type ScimMappingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "externalId" | "userId" | "provider" | "syncTime", ExtArgs["result"]["scimMapping"]>
  export type ScimMappingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ScimMappingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ScimMappingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ScimMappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScimMapping"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      externalId: string | null
      userId: string
      provider: string | null
      syncTime: Date | null
    }, ExtArgs["result"]["scimMapping"]>
    composites: {}
  }

  type ScimMappingGetPayload<S extends boolean | null | undefined | ScimMappingDefaultArgs> = $Result.GetResult<Prisma.$ScimMappingPayload, S>

  type ScimMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScimMappingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScimMappingCountAggregateInputType | true
    }

  export interface ScimMappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScimMapping'], meta: { name: 'ScimMapping' } }
    /**
     * Find zero or one ScimMapping that matches the filter.
     * @param {ScimMappingFindUniqueArgs} args - Arguments to find a ScimMapping
     * @example
     * // Get one ScimMapping
     * const scimMapping = await prisma.scimMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScimMappingFindUniqueArgs>(args: SelectSubset<T, ScimMappingFindUniqueArgs<ExtArgs>>): Prisma__ScimMappingClient<$Result.GetResult<Prisma.$ScimMappingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScimMapping that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScimMappingFindUniqueOrThrowArgs} args - Arguments to find a ScimMapping
     * @example
     * // Get one ScimMapping
     * const scimMapping = await prisma.scimMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScimMappingFindUniqueOrThrowArgs>(args: SelectSubset<T, ScimMappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScimMappingClient<$Result.GetResult<Prisma.$ScimMappingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScimMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScimMappingFindFirstArgs} args - Arguments to find a ScimMapping
     * @example
     * // Get one ScimMapping
     * const scimMapping = await prisma.scimMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScimMappingFindFirstArgs>(args?: SelectSubset<T, ScimMappingFindFirstArgs<ExtArgs>>): Prisma__ScimMappingClient<$Result.GetResult<Prisma.$ScimMappingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScimMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScimMappingFindFirstOrThrowArgs} args - Arguments to find a ScimMapping
     * @example
     * // Get one ScimMapping
     * const scimMapping = await prisma.scimMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScimMappingFindFirstOrThrowArgs>(args?: SelectSubset<T, ScimMappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScimMappingClient<$Result.GetResult<Prisma.$ScimMappingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScimMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScimMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScimMappings
     * const scimMappings = await prisma.scimMapping.findMany()
     * 
     * // Get first 10 ScimMappings
     * const scimMappings = await prisma.scimMapping.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scimMappingWithIdOnly = await prisma.scimMapping.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScimMappingFindManyArgs>(args?: SelectSubset<T, ScimMappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScimMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScimMapping.
     * @param {ScimMappingCreateArgs} args - Arguments to create a ScimMapping.
     * @example
     * // Create one ScimMapping
     * const ScimMapping = await prisma.scimMapping.create({
     *   data: {
     *     // ... data to create a ScimMapping
     *   }
     * })
     * 
     */
    create<T extends ScimMappingCreateArgs>(args: SelectSubset<T, ScimMappingCreateArgs<ExtArgs>>): Prisma__ScimMappingClient<$Result.GetResult<Prisma.$ScimMappingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScimMappings.
     * @param {ScimMappingCreateManyArgs} args - Arguments to create many ScimMappings.
     * @example
     * // Create many ScimMappings
     * const scimMapping = await prisma.scimMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScimMappingCreateManyArgs>(args?: SelectSubset<T, ScimMappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScimMappings and returns the data saved in the database.
     * @param {ScimMappingCreateManyAndReturnArgs} args - Arguments to create many ScimMappings.
     * @example
     * // Create many ScimMappings
     * const scimMapping = await prisma.scimMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScimMappings and only return the `id`
     * const scimMappingWithIdOnly = await prisma.scimMapping.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScimMappingCreateManyAndReturnArgs>(args?: SelectSubset<T, ScimMappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScimMappingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ScimMapping.
     * @param {ScimMappingDeleteArgs} args - Arguments to delete one ScimMapping.
     * @example
     * // Delete one ScimMapping
     * const ScimMapping = await prisma.scimMapping.delete({
     *   where: {
     *     // ... filter to delete one ScimMapping
     *   }
     * })
     * 
     */
    delete<T extends ScimMappingDeleteArgs>(args: SelectSubset<T, ScimMappingDeleteArgs<ExtArgs>>): Prisma__ScimMappingClient<$Result.GetResult<Prisma.$ScimMappingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScimMapping.
     * @param {ScimMappingUpdateArgs} args - Arguments to update one ScimMapping.
     * @example
     * // Update one ScimMapping
     * const scimMapping = await prisma.scimMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScimMappingUpdateArgs>(args: SelectSubset<T, ScimMappingUpdateArgs<ExtArgs>>): Prisma__ScimMappingClient<$Result.GetResult<Prisma.$ScimMappingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScimMappings.
     * @param {ScimMappingDeleteManyArgs} args - Arguments to filter ScimMappings to delete.
     * @example
     * // Delete a few ScimMappings
     * const { count } = await prisma.scimMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScimMappingDeleteManyArgs>(args?: SelectSubset<T, ScimMappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScimMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScimMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScimMappings
     * const scimMapping = await prisma.scimMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScimMappingUpdateManyArgs>(args: SelectSubset<T, ScimMappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScimMappings and returns the data updated in the database.
     * @param {ScimMappingUpdateManyAndReturnArgs} args - Arguments to update many ScimMappings.
     * @example
     * // Update many ScimMappings
     * const scimMapping = await prisma.scimMapping.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ScimMappings and only return the `id`
     * const scimMappingWithIdOnly = await prisma.scimMapping.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScimMappingUpdateManyAndReturnArgs>(args: SelectSubset<T, ScimMappingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScimMappingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ScimMapping.
     * @param {ScimMappingUpsertArgs} args - Arguments to update or create a ScimMapping.
     * @example
     * // Update or create a ScimMapping
     * const scimMapping = await prisma.scimMapping.upsert({
     *   create: {
     *     // ... data to create a ScimMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScimMapping we want to update
     *   }
     * })
     */
    upsert<T extends ScimMappingUpsertArgs>(args: SelectSubset<T, ScimMappingUpsertArgs<ExtArgs>>): Prisma__ScimMappingClient<$Result.GetResult<Prisma.$ScimMappingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScimMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScimMappingCountArgs} args - Arguments to filter ScimMappings to count.
     * @example
     * // Count the number of ScimMappings
     * const count = await prisma.scimMapping.count({
     *   where: {
     *     // ... the filter for the ScimMappings we want to count
     *   }
     * })
    **/
    count<T extends ScimMappingCountArgs>(
      args?: Subset<T, ScimMappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScimMappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScimMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScimMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScimMappingAggregateArgs>(args: Subset<T, ScimMappingAggregateArgs>): Prisma.PrismaPromise<GetScimMappingAggregateType<T>>

    /**
     * Group by ScimMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScimMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScimMappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScimMappingGroupByArgs['orderBy'] }
        : { orderBy?: ScimMappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScimMappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScimMappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScimMapping model
   */
  readonly fields: ScimMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScimMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScimMappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScimMapping model
   */
  interface ScimMappingFieldRefs {
    readonly id: FieldRef<"ScimMapping", 'String'>
    readonly externalId: FieldRef<"ScimMapping", 'String'>
    readonly userId: FieldRef<"ScimMapping", 'String'>
    readonly provider: FieldRef<"ScimMapping", 'String'>
    readonly syncTime: FieldRef<"ScimMapping", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScimMapping findUnique
   */
  export type ScimMappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScimMapping
     */
    select?: ScimMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScimMapping
     */
    omit?: ScimMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScimMappingInclude<ExtArgs> | null
    /**
     * Filter, which ScimMapping to fetch.
     */
    where: ScimMappingWhereUniqueInput
  }

  /**
   * ScimMapping findUniqueOrThrow
   */
  export type ScimMappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScimMapping
     */
    select?: ScimMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScimMapping
     */
    omit?: ScimMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScimMappingInclude<ExtArgs> | null
    /**
     * Filter, which ScimMapping to fetch.
     */
    where: ScimMappingWhereUniqueInput
  }

  /**
   * ScimMapping findFirst
   */
  export type ScimMappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScimMapping
     */
    select?: ScimMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScimMapping
     */
    omit?: ScimMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScimMappingInclude<ExtArgs> | null
    /**
     * Filter, which ScimMapping to fetch.
     */
    where?: ScimMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScimMappings to fetch.
     */
    orderBy?: ScimMappingOrderByWithRelationInput | ScimMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScimMappings.
     */
    cursor?: ScimMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScimMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScimMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScimMappings.
     */
    distinct?: ScimMappingScalarFieldEnum | ScimMappingScalarFieldEnum[]
  }

  /**
   * ScimMapping findFirstOrThrow
   */
  export type ScimMappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScimMapping
     */
    select?: ScimMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScimMapping
     */
    omit?: ScimMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScimMappingInclude<ExtArgs> | null
    /**
     * Filter, which ScimMapping to fetch.
     */
    where?: ScimMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScimMappings to fetch.
     */
    orderBy?: ScimMappingOrderByWithRelationInput | ScimMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScimMappings.
     */
    cursor?: ScimMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScimMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScimMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScimMappings.
     */
    distinct?: ScimMappingScalarFieldEnum | ScimMappingScalarFieldEnum[]
  }

  /**
   * ScimMapping findMany
   */
  export type ScimMappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScimMapping
     */
    select?: ScimMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScimMapping
     */
    omit?: ScimMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScimMappingInclude<ExtArgs> | null
    /**
     * Filter, which ScimMappings to fetch.
     */
    where?: ScimMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScimMappings to fetch.
     */
    orderBy?: ScimMappingOrderByWithRelationInput | ScimMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScimMappings.
     */
    cursor?: ScimMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScimMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScimMappings.
     */
    skip?: number
    distinct?: ScimMappingScalarFieldEnum | ScimMappingScalarFieldEnum[]
  }

  /**
   * ScimMapping create
   */
  export type ScimMappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScimMapping
     */
    select?: ScimMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScimMapping
     */
    omit?: ScimMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScimMappingInclude<ExtArgs> | null
    /**
     * The data needed to create a ScimMapping.
     */
    data: XOR<ScimMappingCreateInput, ScimMappingUncheckedCreateInput>
  }

  /**
   * ScimMapping createMany
   */
  export type ScimMappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScimMappings.
     */
    data: ScimMappingCreateManyInput | ScimMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScimMapping createManyAndReturn
   */
  export type ScimMappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScimMapping
     */
    select?: ScimMappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScimMapping
     */
    omit?: ScimMappingOmit<ExtArgs> | null
    /**
     * The data used to create many ScimMappings.
     */
    data: ScimMappingCreateManyInput | ScimMappingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScimMappingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScimMapping update
   */
  export type ScimMappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScimMapping
     */
    select?: ScimMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScimMapping
     */
    omit?: ScimMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScimMappingInclude<ExtArgs> | null
    /**
     * The data needed to update a ScimMapping.
     */
    data: XOR<ScimMappingUpdateInput, ScimMappingUncheckedUpdateInput>
    /**
     * Choose, which ScimMapping to update.
     */
    where: ScimMappingWhereUniqueInput
  }

  /**
   * ScimMapping updateMany
   */
  export type ScimMappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScimMappings.
     */
    data: XOR<ScimMappingUpdateManyMutationInput, ScimMappingUncheckedUpdateManyInput>
    /**
     * Filter which ScimMappings to update
     */
    where?: ScimMappingWhereInput
    /**
     * Limit how many ScimMappings to update.
     */
    limit?: number
  }

  /**
   * ScimMapping updateManyAndReturn
   */
  export type ScimMappingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScimMapping
     */
    select?: ScimMappingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScimMapping
     */
    omit?: ScimMappingOmit<ExtArgs> | null
    /**
     * The data used to update ScimMappings.
     */
    data: XOR<ScimMappingUpdateManyMutationInput, ScimMappingUncheckedUpdateManyInput>
    /**
     * Filter which ScimMappings to update
     */
    where?: ScimMappingWhereInput
    /**
     * Limit how many ScimMappings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScimMappingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScimMapping upsert
   */
  export type ScimMappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScimMapping
     */
    select?: ScimMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScimMapping
     */
    omit?: ScimMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScimMappingInclude<ExtArgs> | null
    /**
     * The filter to search for the ScimMapping to update in case it exists.
     */
    where: ScimMappingWhereUniqueInput
    /**
     * In case the ScimMapping found by the `where` argument doesn't exist, create a new ScimMapping with this data.
     */
    create: XOR<ScimMappingCreateInput, ScimMappingUncheckedCreateInput>
    /**
     * In case the ScimMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScimMappingUpdateInput, ScimMappingUncheckedUpdateInput>
  }

  /**
   * ScimMapping delete
   */
  export type ScimMappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScimMapping
     */
    select?: ScimMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScimMapping
     */
    omit?: ScimMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScimMappingInclude<ExtArgs> | null
    /**
     * Filter which ScimMapping to delete.
     */
    where: ScimMappingWhereUniqueInput
  }

  /**
   * ScimMapping deleteMany
   */
  export type ScimMappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScimMappings to delete
     */
    where?: ScimMappingWhereInput
    /**
     * Limit how many ScimMappings to delete.
     */
    limit?: number
  }

  /**
   * ScimMapping without action
   */
  export type ScimMappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScimMapping
     */
    select?: ScimMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScimMapping
     */
    omit?: ScimMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScimMappingInclude<ExtArgs> | null
  }


  /**
   * Model ScimLog
   */

  export type AggregateScimLog = {
    _count: ScimLogCountAggregateOutputType | null
    _avg: ScimLogAvgAggregateOutputType | null
    _sum: ScimLogSumAggregateOutputType | null
    _min: ScimLogMinAggregateOutputType | null
    _max: ScimLogMaxAggregateOutputType | null
  }

  export type ScimLogAvgAggregateOutputType = {
    statusCode: number | null
    duration: number | null
  }

  export type ScimLogSumAggregateOutputType = {
    statusCode: number | null
    duration: number | null
  }

  export type ScimLogMinAggregateOutputType = {
    id: string | null
    operation: string | null
    entityType: string | null
    entityId: string | null
    statusCode: number | null
    message: string | null
    userAgent: string | null
    ipAddress: string | null
    duration: number | null
    createdAt: Date | null
  }

  export type ScimLogMaxAggregateOutputType = {
    id: string | null
    operation: string | null
    entityType: string | null
    entityId: string | null
    statusCode: number | null
    message: string | null
    userAgent: string | null
    ipAddress: string | null
    duration: number | null
    createdAt: Date | null
  }

  export type ScimLogCountAggregateOutputType = {
    id: number
    operation: number
    entityType: number
    entityId: number
    statusCode: number
    message: number
    requestBody: number
    responseBody: number
    userAgent: number
    ipAddress: number
    duration: number
    createdAt: number
    _all: number
  }


  export type ScimLogAvgAggregateInputType = {
    statusCode?: true
    duration?: true
  }

  export type ScimLogSumAggregateInputType = {
    statusCode?: true
    duration?: true
  }

  export type ScimLogMinAggregateInputType = {
    id?: true
    operation?: true
    entityType?: true
    entityId?: true
    statusCode?: true
    message?: true
    userAgent?: true
    ipAddress?: true
    duration?: true
    createdAt?: true
  }

  export type ScimLogMaxAggregateInputType = {
    id?: true
    operation?: true
    entityType?: true
    entityId?: true
    statusCode?: true
    message?: true
    userAgent?: true
    ipAddress?: true
    duration?: true
    createdAt?: true
  }

  export type ScimLogCountAggregateInputType = {
    id?: true
    operation?: true
    entityType?: true
    entityId?: true
    statusCode?: true
    message?: true
    requestBody?: true
    responseBody?: true
    userAgent?: true
    ipAddress?: true
    duration?: true
    createdAt?: true
    _all?: true
  }

  export type ScimLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScimLog to aggregate.
     */
    where?: ScimLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScimLogs to fetch.
     */
    orderBy?: ScimLogOrderByWithRelationInput | ScimLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScimLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScimLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScimLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScimLogs
    **/
    _count?: true | ScimLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScimLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScimLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScimLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScimLogMaxAggregateInputType
  }

  export type GetScimLogAggregateType<T extends ScimLogAggregateArgs> = {
        [P in keyof T & keyof AggregateScimLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScimLog[P]>
      : GetScalarType<T[P], AggregateScimLog[P]>
  }




  export type ScimLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScimLogWhereInput
    orderBy?: ScimLogOrderByWithAggregationInput | ScimLogOrderByWithAggregationInput[]
    by: ScimLogScalarFieldEnum[] | ScimLogScalarFieldEnum
    having?: ScimLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScimLogCountAggregateInputType | true
    _avg?: ScimLogAvgAggregateInputType
    _sum?: ScimLogSumAggregateInputType
    _min?: ScimLogMinAggregateInputType
    _max?: ScimLogMaxAggregateInputType
  }

  export type ScimLogGroupByOutputType = {
    id: string
    operation: string
    entityType: string
    entityId: string | null
    statusCode: number
    message: string | null
    requestBody: JsonValue | null
    responseBody: JsonValue | null
    userAgent: string | null
    ipAddress: string | null
    duration: number | null
    createdAt: Date
    _count: ScimLogCountAggregateOutputType | null
    _avg: ScimLogAvgAggregateOutputType | null
    _sum: ScimLogSumAggregateOutputType | null
    _min: ScimLogMinAggregateOutputType | null
    _max: ScimLogMaxAggregateOutputType | null
  }

  type GetScimLogGroupByPayload<T extends ScimLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScimLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScimLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScimLogGroupByOutputType[P]>
            : GetScalarType<T[P], ScimLogGroupByOutputType[P]>
        }
      >
    >


  export type ScimLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    operation?: boolean
    entityType?: boolean
    entityId?: boolean
    statusCode?: boolean
    message?: boolean
    requestBody?: boolean
    responseBody?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    duration?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["scimLog"]>

  export type ScimLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    operation?: boolean
    entityType?: boolean
    entityId?: boolean
    statusCode?: boolean
    message?: boolean
    requestBody?: boolean
    responseBody?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    duration?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["scimLog"]>

  export type ScimLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    operation?: boolean
    entityType?: boolean
    entityId?: boolean
    statusCode?: boolean
    message?: boolean
    requestBody?: boolean
    responseBody?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    duration?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["scimLog"]>

  export type ScimLogSelectScalar = {
    id?: boolean
    operation?: boolean
    entityType?: boolean
    entityId?: boolean
    statusCode?: boolean
    message?: boolean
    requestBody?: boolean
    responseBody?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    duration?: boolean
    createdAt?: boolean
  }

  export type ScimLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "operation" | "entityType" | "entityId" | "statusCode" | "message" | "requestBody" | "responseBody" | "userAgent" | "ipAddress" | "duration" | "createdAt", ExtArgs["result"]["scimLog"]>

  export type $ScimLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScimLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      operation: string
      entityType: string
      entityId: string | null
      statusCode: number
      message: string | null
      requestBody: Prisma.JsonValue | null
      responseBody: Prisma.JsonValue | null
      userAgent: string | null
      ipAddress: string | null
      duration: number | null
      createdAt: Date
    }, ExtArgs["result"]["scimLog"]>
    composites: {}
  }

  type ScimLogGetPayload<S extends boolean | null | undefined | ScimLogDefaultArgs> = $Result.GetResult<Prisma.$ScimLogPayload, S>

  type ScimLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScimLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScimLogCountAggregateInputType | true
    }

  export interface ScimLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScimLog'], meta: { name: 'ScimLog' } }
    /**
     * Find zero or one ScimLog that matches the filter.
     * @param {ScimLogFindUniqueArgs} args - Arguments to find a ScimLog
     * @example
     * // Get one ScimLog
     * const scimLog = await prisma.scimLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScimLogFindUniqueArgs>(args: SelectSubset<T, ScimLogFindUniqueArgs<ExtArgs>>): Prisma__ScimLogClient<$Result.GetResult<Prisma.$ScimLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScimLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScimLogFindUniqueOrThrowArgs} args - Arguments to find a ScimLog
     * @example
     * // Get one ScimLog
     * const scimLog = await prisma.scimLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScimLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ScimLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScimLogClient<$Result.GetResult<Prisma.$ScimLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScimLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScimLogFindFirstArgs} args - Arguments to find a ScimLog
     * @example
     * // Get one ScimLog
     * const scimLog = await prisma.scimLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScimLogFindFirstArgs>(args?: SelectSubset<T, ScimLogFindFirstArgs<ExtArgs>>): Prisma__ScimLogClient<$Result.GetResult<Prisma.$ScimLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScimLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScimLogFindFirstOrThrowArgs} args - Arguments to find a ScimLog
     * @example
     * // Get one ScimLog
     * const scimLog = await prisma.scimLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScimLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ScimLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScimLogClient<$Result.GetResult<Prisma.$ScimLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScimLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScimLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScimLogs
     * const scimLogs = await prisma.scimLog.findMany()
     * 
     * // Get first 10 ScimLogs
     * const scimLogs = await prisma.scimLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scimLogWithIdOnly = await prisma.scimLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScimLogFindManyArgs>(args?: SelectSubset<T, ScimLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScimLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScimLog.
     * @param {ScimLogCreateArgs} args - Arguments to create a ScimLog.
     * @example
     * // Create one ScimLog
     * const ScimLog = await prisma.scimLog.create({
     *   data: {
     *     // ... data to create a ScimLog
     *   }
     * })
     * 
     */
    create<T extends ScimLogCreateArgs>(args: SelectSubset<T, ScimLogCreateArgs<ExtArgs>>): Prisma__ScimLogClient<$Result.GetResult<Prisma.$ScimLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScimLogs.
     * @param {ScimLogCreateManyArgs} args - Arguments to create many ScimLogs.
     * @example
     * // Create many ScimLogs
     * const scimLog = await prisma.scimLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScimLogCreateManyArgs>(args?: SelectSubset<T, ScimLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScimLogs and returns the data saved in the database.
     * @param {ScimLogCreateManyAndReturnArgs} args - Arguments to create many ScimLogs.
     * @example
     * // Create many ScimLogs
     * const scimLog = await prisma.scimLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScimLogs and only return the `id`
     * const scimLogWithIdOnly = await prisma.scimLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScimLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ScimLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScimLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ScimLog.
     * @param {ScimLogDeleteArgs} args - Arguments to delete one ScimLog.
     * @example
     * // Delete one ScimLog
     * const ScimLog = await prisma.scimLog.delete({
     *   where: {
     *     // ... filter to delete one ScimLog
     *   }
     * })
     * 
     */
    delete<T extends ScimLogDeleteArgs>(args: SelectSubset<T, ScimLogDeleteArgs<ExtArgs>>): Prisma__ScimLogClient<$Result.GetResult<Prisma.$ScimLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScimLog.
     * @param {ScimLogUpdateArgs} args - Arguments to update one ScimLog.
     * @example
     * // Update one ScimLog
     * const scimLog = await prisma.scimLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScimLogUpdateArgs>(args: SelectSubset<T, ScimLogUpdateArgs<ExtArgs>>): Prisma__ScimLogClient<$Result.GetResult<Prisma.$ScimLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScimLogs.
     * @param {ScimLogDeleteManyArgs} args - Arguments to filter ScimLogs to delete.
     * @example
     * // Delete a few ScimLogs
     * const { count } = await prisma.scimLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScimLogDeleteManyArgs>(args?: SelectSubset<T, ScimLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScimLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScimLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScimLogs
     * const scimLog = await prisma.scimLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScimLogUpdateManyArgs>(args: SelectSubset<T, ScimLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScimLogs and returns the data updated in the database.
     * @param {ScimLogUpdateManyAndReturnArgs} args - Arguments to update many ScimLogs.
     * @example
     * // Update many ScimLogs
     * const scimLog = await prisma.scimLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ScimLogs and only return the `id`
     * const scimLogWithIdOnly = await prisma.scimLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScimLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ScimLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScimLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ScimLog.
     * @param {ScimLogUpsertArgs} args - Arguments to update or create a ScimLog.
     * @example
     * // Update or create a ScimLog
     * const scimLog = await prisma.scimLog.upsert({
     *   create: {
     *     // ... data to create a ScimLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScimLog we want to update
     *   }
     * })
     */
    upsert<T extends ScimLogUpsertArgs>(args: SelectSubset<T, ScimLogUpsertArgs<ExtArgs>>): Prisma__ScimLogClient<$Result.GetResult<Prisma.$ScimLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScimLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScimLogCountArgs} args - Arguments to filter ScimLogs to count.
     * @example
     * // Count the number of ScimLogs
     * const count = await prisma.scimLog.count({
     *   where: {
     *     // ... the filter for the ScimLogs we want to count
     *   }
     * })
    **/
    count<T extends ScimLogCountArgs>(
      args?: Subset<T, ScimLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScimLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScimLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScimLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScimLogAggregateArgs>(args: Subset<T, ScimLogAggregateArgs>): Prisma.PrismaPromise<GetScimLogAggregateType<T>>

    /**
     * Group by ScimLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScimLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScimLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScimLogGroupByArgs['orderBy'] }
        : { orderBy?: ScimLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScimLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScimLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScimLog model
   */
  readonly fields: ScimLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScimLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScimLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScimLog model
   */
  interface ScimLogFieldRefs {
    readonly id: FieldRef<"ScimLog", 'String'>
    readonly operation: FieldRef<"ScimLog", 'String'>
    readonly entityType: FieldRef<"ScimLog", 'String'>
    readonly entityId: FieldRef<"ScimLog", 'String'>
    readonly statusCode: FieldRef<"ScimLog", 'Int'>
    readonly message: FieldRef<"ScimLog", 'String'>
    readonly requestBody: FieldRef<"ScimLog", 'Json'>
    readonly responseBody: FieldRef<"ScimLog", 'Json'>
    readonly userAgent: FieldRef<"ScimLog", 'String'>
    readonly ipAddress: FieldRef<"ScimLog", 'String'>
    readonly duration: FieldRef<"ScimLog", 'Int'>
    readonly createdAt: FieldRef<"ScimLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScimLog findUnique
   */
  export type ScimLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScimLog
     */
    select?: ScimLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScimLog
     */
    omit?: ScimLogOmit<ExtArgs> | null
    /**
     * Filter, which ScimLog to fetch.
     */
    where: ScimLogWhereUniqueInput
  }

  /**
   * ScimLog findUniqueOrThrow
   */
  export type ScimLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScimLog
     */
    select?: ScimLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScimLog
     */
    omit?: ScimLogOmit<ExtArgs> | null
    /**
     * Filter, which ScimLog to fetch.
     */
    where: ScimLogWhereUniqueInput
  }

  /**
   * ScimLog findFirst
   */
  export type ScimLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScimLog
     */
    select?: ScimLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScimLog
     */
    omit?: ScimLogOmit<ExtArgs> | null
    /**
     * Filter, which ScimLog to fetch.
     */
    where?: ScimLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScimLogs to fetch.
     */
    orderBy?: ScimLogOrderByWithRelationInput | ScimLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScimLogs.
     */
    cursor?: ScimLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScimLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScimLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScimLogs.
     */
    distinct?: ScimLogScalarFieldEnum | ScimLogScalarFieldEnum[]
  }

  /**
   * ScimLog findFirstOrThrow
   */
  export type ScimLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScimLog
     */
    select?: ScimLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScimLog
     */
    omit?: ScimLogOmit<ExtArgs> | null
    /**
     * Filter, which ScimLog to fetch.
     */
    where?: ScimLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScimLogs to fetch.
     */
    orderBy?: ScimLogOrderByWithRelationInput | ScimLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScimLogs.
     */
    cursor?: ScimLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScimLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScimLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScimLogs.
     */
    distinct?: ScimLogScalarFieldEnum | ScimLogScalarFieldEnum[]
  }

  /**
   * ScimLog findMany
   */
  export type ScimLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScimLog
     */
    select?: ScimLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScimLog
     */
    omit?: ScimLogOmit<ExtArgs> | null
    /**
     * Filter, which ScimLogs to fetch.
     */
    where?: ScimLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScimLogs to fetch.
     */
    orderBy?: ScimLogOrderByWithRelationInput | ScimLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScimLogs.
     */
    cursor?: ScimLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScimLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScimLogs.
     */
    skip?: number
    distinct?: ScimLogScalarFieldEnum | ScimLogScalarFieldEnum[]
  }

  /**
   * ScimLog create
   */
  export type ScimLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScimLog
     */
    select?: ScimLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScimLog
     */
    omit?: ScimLogOmit<ExtArgs> | null
    /**
     * The data needed to create a ScimLog.
     */
    data: XOR<ScimLogCreateInput, ScimLogUncheckedCreateInput>
  }

  /**
   * ScimLog createMany
   */
  export type ScimLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScimLogs.
     */
    data: ScimLogCreateManyInput | ScimLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScimLog createManyAndReturn
   */
  export type ScimLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScimLog
     */
    select?: ScimLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScimLog
     */
    omit?: ScimLogOmit<ExtArgs> | null
    /**
     * The data used to create many ScimLogs.
     */
    data: ScimLogCreateManyInput | ScimLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScimLog update
   */
  export type ScimLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScimLog
     */
    select?: ScimLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScimLog
     */
    omit?: ScimLogOmit<ExtArgs> | null
    /**
     * The data needed to update a ScimLog.
     */
    data: XOR<ScimLogUpdateInput, ScimLogUncheckedUpdateInput>
    /**
     * Choose, which ScimLog to update.
     */
    where: ScimLogWhereUniqueInput
  }

  /**
   * ScimLog updateMany
   */
  export type ScimLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScimLogs.
     */
    data: XOR<ScimLogUpdateManyMutationInput, ScimLogUncheckedUpdateManyInput>
    /**
     * Filter which ScimLogs to update
     */
    where?: ScimLogWhereInput
    /**
     * Limit how many ScimLogs to update.
     */
    limit?: number
  }

  /**
   * ScimLog updateManyAndReturn
   */
  export type ScimLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScimLog
     */
    select?: ScimLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScimLog
     */
    omit?: ScimLogOmit<ExtArgs> | null
    /**
     * The data used to update ScimLogs.
     */
    data: XOR<ScimLogUpdateManyMutationInput, ScimLogUncheckedUpdateManyInput>
    /**
     * Filter which ScimLogs to update
     */
    where?: ScimLogWhereInput
    /**
     * Limit how many ScimLogs to update.
     */
    limit?: number
  }

  /**
   * ScimLog upsert
   */
  export type ScimLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScimLog
     */
    select?: ScimLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScimLog
     */
    omit?: ScimLogOmit<ExtArgs> | null
    /**
     * The filter to search for the ScimLog to update in case it exists.
     */
    where: ScimLogWhereUniqueInput
    /**
     * In case the ScimLog found by the `where` argument doesn't exist, create a new ScimLog with this data.
     */
    create: XOR<ScimLogCreateInput, ScimLogUncheckedCreateInput>
    /**
     * In case the ScimLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScimLogUpdateInput, ScimLogUncheckedUpdateInput>
  }

  /**
   * ScimLog delete
   */
  export type ScimLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScimLog
     */
    select?: ScimLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScimLog
     */
    omit?: ScimLogOmit<ExtArgs> | null
    /**
     * Filter which ScimLog to delete.
     */
    where: ScimLogWhereUniqueInput
  }

  /**
   * ScimLog deleteMany
   */
  export type ScimLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScimLogs to delete
     */
    where?: ScimLogWhereInput
    /**
     * Limit how many ScimLogs to delete.
     */
    limit?: number
  }

  /**
   * ScimLog without action
   */
  export type ScimLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScimLog
     */
    select?: ScimLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScimLog
     */
    omit?: ScimLogOmit<ExtArgs> | null
  }


  /**
   * Model MailroomPackage
   */

  export type AggregateMailroomPackage = {
    _count: MailroomPackageCountAggregateOutputType | null
    _avg: MailroomPackageAvgAggregateOutputType | null
    _sum: MailroomPackageSumAggregateOutputType | null
    _min: MailroomPackageMinAggregateOutputType | null
    _max: MailroomPackageMaxAggregateOutputType | null
  }

  export type MailroomPackageAvgAggregateOutputType = {
    id: number | null
    linkedTicketId: number | null
    linkedAssetId: number | null
  }

  export type MailroomPackageSumAggregateOutputType = {
    id: number | null
    linkedTicketId: number | null
    linkedAssetId: number | null
  }

  export type MailroomPackageMinAggregateOutputType = {
    id: number | null
    trackingNumber: string | null
    carrier: string | null
    sender: string | null
    recipientId: string | null
    department: string | null
    packageType: string | null
    status: string | null
    assignedLocation: string | null
    linkedTicketId: number | null
    linkedAssetId: number | null
    intakePhotoUrl: string | null
    deliveryPhotoUrl: string | null
    signatureUrl: string | null
    intakeLocation: string | null
    deliveryLocation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MailroomPackageMaxAggregateOutputType = {
    id: number | null
    trackingNumber: string | null
    carrier: string | null
    sender: string | null
    recipientId: string | null
    department: string | null
    packageType: string | null
    status: string | null
    assignedLocation: string | null
    linkedTicketId: number | null
    linkedAssetId: number | null
    intakePhotoUrl: string | null
    deliveryPhotoUrl: string | null
    signatureUrl: string | null
    intakeLocation: string | null
    deliveryLocation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MailroomPackageCountAggregateOutputType = {
    id: number
    trackingNumber: number
    carrier: number
    sender: number
    recipientId: number
    department: number
    packageType: number
    status: number
    assignedLocation: number
    linkedTicketId: number
    linkedAssetId: number
    flags: number
    intakePhotoUrl: number
    deliveryPhotoUrl: number
    signatureUrl: number
    intakeLocation: number
    deliveryLocation: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MailroomPackageAvgAggregateInputType = {
    id?: true
    linkedTicketId?: true
    linkedAssetId?: true
  }

  export type MailroomPackageSumAggregateInputType = {
    id?: true
    linkedTicketId?: true
    linkedAssetId?: true
  }

  export type MailroomPackageMinAggregateInputType = {
    id?: true
    trackingNumber?: true
    carrier?: true
    sender?: true
    recipientId?: true
    department?: true
    packageType?: true
    status?: true
    assignedLocation?: true
    linkedTicketId?: true
    linkedAssetId?: true
    intakePhotoUrl?: true
    deliveryPhotoUrl?: true
    signatureUrl?: true
    intakeLocation?: true
    deliveryLocation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MailroomPackageMaxAggregateInputType = {
    id?: true
    trackingNumber?: true
    carrier?: true
    sender?: true
    recipientId?: true
    department?: true
    packageType?: true
    status?: true
    assignedLocation?: true
    linkedTicketId?: true
    linkedAssetId?: true
    intakePhotoUrl?: true
    deliveryPhotoUrl?: true
    signatureUrl?: true
    intakeLocation?: true
    deliveryLocation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MailroomPackageCountAggregateInputType = {
    id?: true
    trackingNumber?: true
    carrier?: true
    sender?: true
    recipientId?: true
    department?: true
    packageType?: true
    status?: true
    assignedLocation?: true
    linkedTicketId?: true
    linkedAssetId?: true
    flags?: true
    intakePhotoUrl?: true
    deliveryPhotoUrl?: true
    signatureUrl?: true
    intakeLocation?: true
    deliveryLocation?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MailroomPackageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MailroomPackage to aggregate.
     */
    where?: MailroomPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MailroomPackages to fetch.
     */
    orderBy?: MailroomPackageOrderByWithRelationInput | MailroomPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MailroomPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MailroomPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MailroomPackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MailroomPackages
    **/
    _count?: true | MailroomPackageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MailroomPackageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MailroomPackageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MailroomPackageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MailroomPackageMaxAggregateInputType
  }

  export type GetMailroomPackageAggregateType<T extends MailroomPackageAggregateArgs> = {
        [P in keyof T & keyof AggregateMailroomPackage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMailroomPackage[P]>
      : GetScalarType<T[P], AggregateMailroomPackage[P]>
  }




  export type MailroomPackageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MailroomPackageWhereInput
    orderBy?: MailroomPackageOrderByWithAggregationInput | MailroomPackageOrderByWithAggregationInput[]
    by: MailroomPackageScalarFieldEnum[] | MailroomPackageScalarFieldEnum
    having?: MailroomPackageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MailroomPackageCountAggregateInputType | true
    _avg?: MailroomPackageAvgAggregateInputType
    _sum?: MailroomPackageSumAggregateInputType
    _min?: MailroomPackageMinAggregateInputType
    _max?: MailroomPackageMaxAggregateInputType
  }

  export type MailroomPackageGroupByOutputType = {
    id: number
    trackingNumber: string
    carrier: string
    sender: string | null
    recipientId: string
    department: string | null
    packageType: string | null
    status: string
    assignedLocation: string | null
    linkedTicketId: number | null
    linkedAssetId: number | null
    flags: string[]
    intakePhotoUrl: string | null
    deliveryPhotoUrl: string | null
    signatureUrl: string | null
    intakeLocation: string | null
    deliveryLocation: string | null
    createdAt: Date
    updatedAt: Date
    _count: MailroomPackageCountAggregateOutputType | null
    _avg: MailroomPackageAvgAggregateOutputType | null
    _sum: MailroomPackageSumAggregateOutputType | null
    _min: MailroomPackageMinAggregateOutputType | null
    _max: MailroomPackageMaxAggregateOutputType | null
  }

  type GetMailroomPackageGroupByPayload<T extends MailroomPackageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MailroomPackageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MailroomPackageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MailroomPackageGroupByOutputType[P]>
            : GetScalarType<T[P], MailroomPackageGroupByOutputType[P]>
        }
      >
    >


  export type MailroomPackageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trackingNumber?: boolean
    carrier?: boolean
    sender?: boolean
    recipientId?: boolean
    department?: boolean
    packageType?: boolean
    status?: boolean
    assignedLocation?: boolean
    linkedTicketId?: boolean
    linkedAssetId?: boolean
    flags?: boolean
    intakePhotoUrl?: boolean
    deliveryPhotoUrl?: boolean
    signatureUrl?: boolean
    intakeLocation?: boolean
    deliveryLocation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    ticket?: boolean | MailroomPackage$ticketArgs<ExtArgs>
    asset?: boolean | MailroomPackage$assetArgs<ExtArgs>
    deliveryEvents?: boolean | MailroomPackage$deliveryEventsArgs<ExtArgs>
    proxyAuthorizations?: boolean | MailroomPackage$proxyAuthorizationsArgs<ExtArgs>
    _count?: boolean | MailroomPackageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mailroomPackage"]>

  export type MailroomPackageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trackingNumber?: boolean
    carrier?: boolean
    sender?: boolean
    recipientId?: boolean
    department?: boolean
    packageType?: boolean
    status?: boolean
    assignedLocation?: boolean
    linkedTicketId?: boolean
    linkedAssetId?: boolean
    flags?: boolean
    intakePhotoUrl?: boolean
    deliveryPhotoUrl?: boolean
    signatureUrl?: boolean
    intakeLocation?: boolean
    deliveryLocation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    ticket?: boolean | MailroomPackage$ticketArgs<ExtArgs>
    asset?: boolean | MailroomPackage$assetArgs<ExtArgs>
  }, ExtArgs["result"]["mailroomPackage"]>

  export type MailroomPackageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trackingNumber?: boolean
    carrier?: boolean
    sender?: boolean
    recipientId?: boolean
    department?: boolean
    packageType?: boolean
    status?: boolean
    assignedLocation?: boolean
    linkedTicketId?: boolean
    linkedAssetId?: boolean
    flags?: boolean
    intakePhotoUrl?: boolean
    deliveryPhotoUrl?: boolean
    signatureUrl?: boolean
    intakeLocation?: boolean
    deliveryLocation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    ticket?: boolean | MailroomPackage$ticketArgs<ExtArgs>
    asset?: boolean | MailroomPackage$assetArgs<ExtArgs>
  }, ExtArgs["result"]["mailroomPackage"]>

  export type MailroomPackageSelectScalar = {
    id?: boolean
    trackingNumber?: boolean
    carrier?: boolean
    sender?: boolean
    recipientId?: boolean
    department?: boolean
    packageType?: boolean
    status?: boolean
    assignedLocation?: boolean
    linkedTicketId?: boolean
    linkedAssetId?: boolean
    flags?: boolean
    intakePhotoUrl?: boolean
    deliveryPhotoUrl?: boolean
    signatureUrl?: boolean
    intakeLocation?: boolean
    deliveryLocation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MailroomPackageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "trackingNumber" | "carrier" | "sender" | "recipientId" | "department" | "packageType" | "status" | "assignedLocation" | "linkedTicketId" | "linkedAssetId" | "flags" | "intakePhotoUrl" | "deliveryPhotoUrl" | "signatureUrl" | "intakeLocation" | "deliveryLocation" | "createdAt" | "updatedAt", ExtArgs["result"]["mailroomPackage"]>
  export type MailroomPackageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    ticket?: boolean | MailroomPackage$ticketArgs<ExtArgs>
    asset?: boolean | MailroomPackage$assetArgs<ExtArgs>
    deliveryEvents?: boolean | MailroomPackage$deliveryEventsArgs<ExtArgs>
    proxyAuthorizations?: boolean | MailroomPackage$proxyAuthorizationsArgs<ExtArgs>
    _count?: boolean | MailroomPackageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MailroomPackageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    ticket?: boolean | MailroomPackage$ticketArgs<ExtArgs>
    asset?: boolean | MailroomPackage$assetArgs<ExtArgs>
  }
  export type MailroomPackageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    ticket?: boolean | MailroomPackage$ticketArgs<ExtArgs>
    asset?: boolean | MailroomPackage$assetArgs<ExtArgs>
  }

  export type $MailroomPackagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MailroomPackage"
    objects: {
      recipient: Prisma.$UserPayload<ExtArgs>
      ticket: Prisma.$SupportTicketPayload<ExtArgs> | null
      asset: Prisma.$InventoryAssetPayload<ExtArgs> | null
      deliveryEvents: Prisma.$DeliveryEventPayload<ExtArgs>[]
      proxyAuthorizations: Prisma.$ProxyAuthorizationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      trackingNumber: string
      carrier: string
      sender: string | null
      recipientId: string
      department: string | null
      packageType: string | null
      status: string
      assignedLocation: string | null
      linkedTicketId: number | null
      linkedAssetId: number | null
      flags: string[]
      intakePhotoUrl: string | null
      deliveryPhotoUrl: string | null
      signatureUrl: string | null
      intakeLocation: string | null
      deliveryLocation: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mailroomPackage"]>
    composites: {}
  }

  type MailroomPackageGetPayload<S extends boolean | null | undefined | MailroomPackageDefaultArgs> = $Result.GetResult<Prisma.$MailroomPackagePayload, S>

  type MailroomPackageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MailroomPackageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MailroomPackageCountAggregateInputType | true
    }

  export interface MailroomPackageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MailroomPackage'], meta: { name: 'MailroomPackage' } }
    /**
     * Find zero or one MailroomPackage that matches the filter.
     * @param {MailroomPackageFindUniqueArgs} args - Arguments to find a MailroomPackage
     * @example
     * // Get one MailroomPackage
     * const mailroomPackage = await prisma.mailroomPackage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MailroomPackageFindUniqueArgs>(args: SelectSubset<T, MailroomPackageFindUniqueArgs<ExtArgs>>): Prisma__MailroomPackageClient<$Result.GetResult<Prisma.$MailroomPackagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MailroomPackage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MailroomPackageFindUniqueOrThrowArgs} args - Arguments to find a MailroomPackage
     * @example
     * // Get one MailroomPackage
     * const mailroomPackage = await prisma.mailroomPackage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MailroomPackageFindUniqueOrThrowArgs>(args: SelectSubset<T, MailroomPackageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MailroomPackageClient<$Result.GetResult<Prisma.$MailroomPackagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MailroomPackage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailroomPackageFindFirstArgs} args - Arguments to find a MailroomPackage
     * @example
     * // Get one MailroomPackage
     * const mailroomPackage = await prisma.mailroomPackage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MailroomPackageFindFirstArgs>(args?: SelectSubset<T, MailroomPackageFindFirstArgs<ExtArgs>>): Prisma__MailroomPackageClient<$Result.GetResult<Prisma.$MailroomPackagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MailroomPackage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailroomPackageFindFirstOrThrowArgs} args - Arguments to find a MailroomPackage
     * @example
     * // Get one MailroomPackage
     * const mailroomPackage = await prisma.mailroomPackage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MailroomPackageFindFirstOrThrowArgs>(args?: SelectSubset<T, MailroomPackageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MailroomPackageClient<$Result.GetResult<Prisma.$MailroomPackagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MailroomPackages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailroomPackageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MailroomPackages
     * const mailroomPackages = await prisma.mailroomPackage.findMany()
     * 
     * // Get first 10 MailroomPackages
     * const mailroomPackages = await prisma.mailroomPackage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mailroomPackageWithIdOnly = await prisma.mailroomPackage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MailroomPackageFindManyArgs>(args?: SelectSubset<T, MailroomPackageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MailroomPackagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MailroomPackage.
     * @param {MailroomPackageCreateArgs} args - Arguments to create a MailroomPackage.
     * @example
     * // Create one MailroomPackage
     * const MailroomPackage = await prisma.mailroomPackage.create({
     *   data: {
     *     // ... data to create a MailroomPackage
     *   }
     * })
     * 
     */
    create<T extends MailroomPackageCreateArgs>(args: SelectSubset<T, MailroomPackageCreateArgs<ExtArgs>>): Prisma__MailroomPackageClient<$Result.GetResult<Prisma.$MailroomPackagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MailroomPackages.
     * @param {MailroomPackageCreateManyArgs} args - Arguments to create many MailroomPackages.
     * @example
     * // Create many MailroomPackages
     * const mailroomPackage = await prisma.mailroomPackage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MailroomPackageCreateManyArgs>(args?: SelectSubset<T, MailroomPackageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MailroomPackages and returns the data saved in the database.
     * @param {MailroomPackageCreateManyAndReturnArgs} args - Arguments to create many MailroomPackages.
     * @example
     * // Create many MailroomPackages
     * const mailroomPackage = await prisma.mailroomPackage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MailroomPackages and only return the `id`
     * const mailroomPackageWithIdOnly = await prisma.mailroomPackage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MailroomPackageCreateManyAndReturnArgs>(args?: SelectSubset<T, MailroomPackageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MailroomPackagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MailroomPackage.
     * @param {MailroomPackageDeleteArgs} args - Arguments to delete one MailroomPackage.
     * @example
     * // Delete one MailroomPackage
     * const MailroomPackage = await prisma.mailroomPackage.delete({
     *   where: {
     *     // ... filter to delete one MailroomPackage
     *   }
     * })
     * 
     */
    delete<T extends MailroomPackageDeleteArgs>(args: SelectSubset<T, MailroomPackageDeleteArgs<ExtArgs>>): Prisma__MailroomPackageClient<$Result.GetResult<Prisma.$MailroomPackagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MailroomPackage.
     * @param {MailroomPackageUpdateArgs} args - Arguments to update one MailroomPackage.
     * @example
     * // Update one MailroomPackage
     * const mailroomPackage = await prisma.mailroomPackage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MailroomPackageUpdateArgs>(args: SelectSubset<T, MailroomPackageUpdateArgs<ExtArgs>>): Prisma__MailroomPackageClient<$Result.GetResult<Prisma.$MailroomPackagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MailroomPackages.
     * @param {MailroomPackageDeleteManyArgs} args - Arguments to filter MailroomPackages to delete.
     * @example
     * // Delete a few MailroomPackages
     * const { count } = await prisma.mailroomPackage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MailroomPackageDeleteManyArgs>(args?: SelectSubset<T, MailroomPackageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MailroomPackages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailroomPackageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MailroomPackages
     * const mailroomPackage = await prisma.mailroomPackage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MailroomPackageUpdateManyArgs>(args: SelectSubset<T, MailroomPackageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MailroomPackages and returns the data updated in the database.
     * @param {MailroomPackageUpdateManyAndReturnArgs} args - Arguments to update many MailroomPackages.
     * @example
     * // Update many MailroomPackages
     * const mailroomPackage = await prisma.mailroomPackage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MailroomPackages and only return the `id`
     * const mailroomPackageWithIdOnly = await prisma.mailroomPackage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MailroomPackageUpdateManyAndReturnArgs>(args: SelectSubset<T, MailroomPackageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MailroomPackagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MailroomPackage.
     * @param {MailroomPackageUpsertArgs} args - Arguments to update or create a MailroomPackage.
     * @example
     * // Update or create a MailroomPackage
     * const mailroomPackage = await prisma.mailroomPackage.upsert({
     *   create: {
     *     // ... data to create a MailroomPackage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MailroomPackage we want to update
     *   }
     * })
     */
    upsert<T extends MailroomPackageUpsertArgs>(args: SelectSubset<T, MailroomPackageUpsertArgs<ExtArgs>>): Prisma__MailroomPackageClient<$Result.GetResult<Prisma.$MailroomPackagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MailroomPackages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailroomPackageCountArgs} args - Arguments to filter MailroomPackages to count.
     * @example
     * // Count the number of MailroomPackages
     * const count = await prisma.mailroomPackage.count({
     *   where: {
     *     // ... the filter for the MailroomPackages we want to count
     *   }
     * })
    **/
    count<T extends MailroomPackageCountArgs>(
      args?: Subset<T, MailroomPackageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MailroomPackageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MailroomPackage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailroomPackageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MailroomPackageAggregateArgs>(args: Subset<T, MailroomPackageAggregateArgs>): Prisma.PrismaPromise<GetMailroomPackageAggregateType<T>>

    /**
     * Group by MailroomPackage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailroomPackageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MailroomPackageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MailroomPackageGroupByArgs['orderBy'] }
        : { orderBy?: MailroomPackageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MailroomPackageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMailroomPackageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MailroomPackage model
   */
  readonly fields: MailroomPackageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MailroomPackage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MailroomPackageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipient<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ticket<T extends MailroomPackage$ticketArgs<ExtArgs> = {}>(args?: Subset<T, MailroomPackage$ticketArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    asset<T extends MailroomPackage$assetArgs<ExtArgs> = {}>(args?: Subset<T, MailroomPackage$assetArgs<ExtArgs>>): Prisma__InventoryAssetClient<$Result.GetResult<Prisma.$InventoryAssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    deliveryEvents<T extends MailroomPackage$deliveryEventsArgs<ExtArgs> = {}>(args?: Subset<T, MailroomPackage$deliveryEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    proxyAuthorizations<T extends MailroomPackage$proxyAuthorizationsArgs<ExtArgs> = {}>(args?: Subset<T, MailroomPackage$proxyAuthorizationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxyAuthorizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MailroomPackage model
   */
  interface MailroomPackageFieldRefs {
    readonly id: FieldRef<"MailroomPackage", 'Int'>
    readonly trackingNumber: FieldRef<"MailroomPackage", 'String'>
    readonly carrier: FieldRef<"MailroomPackage", 'String'>
    readonly sender: FieldRef<"MailroomPackage", 'String'>
    readonly recipientId: FieldRef<"MailroomPackage", 'String'>
    readonly department: FieldRef<"MailroomPackage", 'String'>
    readonly packageType: FieldRef<"MailroomPackage", 'String'>
    readonly status: FieldRef<"MailroomPackage", 'String'>
    readonly assignedLocation: FieldRef<"MailroomPackage", 'String'>
    readonly linkedTicketId: FieldRef<"MailroomPackage", 'Int'>
    readonly linkedAssetId: FieldRef<"MailroomPackage", 'Int'>
    readonly flags: FieldRef<"MailroomPackage", 'String[]'>
    readonly intakePhotoUrl: FieldRef<"MailroomPackage", 'String'>
    readonly deliveryPhotoUrl: FieldRef<"MailroomPackage", 'String'>
    readonly signatureUrl: FieldRef<"MailroomPackage", 'String'>
    readonly intakeLocation: FieldRef<"MailroomPackage", 'String'>
    readonly deliveryLocation: FieldRef<"MailroomPackage", 'String'>
    readonly createdAt: FieldRef<"MailroomPackage", 'DateTime'>
    readonly updatedAt: FieldRef<"MailroomPackage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MailroomPackage findUnique
   */
  export type MailroomPackageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailroomPackage
     */
    select?: MailroomPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MailroomPackage
     */
    omit?: MailroomPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailroomPackageInclude<ExtArgs> | null
    /**
     * Filter, which MailroomPackage to fetch.
     */
    where: MailroomPackageWhereUniqueInput
  }

  /**
   * MailroomPackage findUniqueOrThrow
   */
  export type MailroomPackageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailroomPackage
     */
    select?: MailroomPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MailroomPackage
     */
    omit?: MailroomPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailroomPackageInclude<ExtArgs> | null
    /**
     * Filter, which MailroomPackage to fetch.
     */
    where: MailroomPackageWhereUniqueInput
  }

  /**
   * MailroomPackage findFirst
   */
  export type MailroomPackageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailroomPackage
     */
    select?: MailroomPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MailroomPackage
     */
    omit?: MailroomPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailroomPackageInclude<ExtArgs> | null
    /**
     * Filter, which MailroomPackage to fetch.
     */
    where?: MailroomPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MailroomPackages to fetch.
     */
    orderBy?: MailroomPackageOrderByWithRelationInput | MailroomPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MailroomPackages.
     */
    cursor?: MailroomPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MailroomPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MailroomPackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MailroomPackages.
     */
    distinct?: MailroomPackageScalarFieldEnum | MailroomPackageScalarFieldEnum[]
  }

  /**
   * MailroomPackage findFirstOrThrow
   */
  export type MailroomPackageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailroomPackage
     */
    select?: MailroomPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MailroomPackage
     */
    omit?: MailroomPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailroomPackageInclude<ExtArgs> | null
    /**
     * Filter, which MailroomPackage to fetch.
     */
    where?: MailroomPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MailroomPackages to fetch.
     */
    orderBy?: MailroomPackageOrderByWithRelationInput | MailroomPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MailroomPackages.
     */
    cursor?: MailroomPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MailroomPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MailroomPackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MailroomPackages.
     */
    distinct?: MailroomPackageScalarFieldEnum | MailroomPackageScalarFieldEnum[]
  }

  /**
   * MailroomPackage findMany
   */
  export type MailroomPackageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailroomPackage
     */
    select?: MailroomPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MailroomPackage
     */
    omit?: MailroomPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailroomPackageInclude<ExtArgs> | null
    /**
     * Filter, which MailroomPackages to fetch.
     */
    where?: MailroomPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MailroomPackages to fetch.
     */
    orderBy?: MailroomPackageOrderByWithRelationInput | MailroomPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MailroomPackages.
     */
    cursor?: MailroomPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MailroomPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MailroomPackages.
     */
    skip?: number
    distinct?: MailroomPackageScalarFieldEnum | MailroomPackageScalarFieldEnum[]
  }

  /**
   * MailroomPackage create
   */
  export type MailroomPackageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailroomPackage
     */
    select?: MailroomPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MailroomPackage
     */
    omit?: MailroomPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailroomPackageInclude<ExtArgs> | null
    /**
     * The data needed to create a MailroomPackage.
     */
    data: XOR<MailroomPackageCreateInput, MailroomPackageUncheckedCreateInput>
  }

  /**
   * MailroomPackage createMany
   */
  export type MailroomPackageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MailroomPackages.
     */
    data: MailroomPackageCreateManyInput | MailroomPackageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MailroomPackage createManyAndReturn
   */
  export type MailroomPackageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailroomPackage
     */
    select?: MailroomPackageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MailroomPackage
     */
    omit?: MailroomPackageOmit<ExtArgs> | null
    /**
     * The data used to create many MailroomPackages.
     */
    data: MailroomPackageCreateManyInput | MailroomPackageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailroomPackageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MailroomPackage update
   */
  export type MailroomPackageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailroomPackage
     */
    select?: MailroomPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MailroomPackage
     */
    omit?: MailroomPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailroomPackageInclude<ExtArgs> | null
    /**
     * The data needed to update a MailroomPackage.
     */
    data: XOR<MailroomPackageUpdateInput, MailroomPackageUncheckedUpdateInput>
    /**
     * Choose, which MailroomPackage to update.
     */
    where: MailroomPackageWhereUniqueInput
  }

  /**
   * MailroomPackage updateMany
   */
  export type MailroomPackageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MailroomPackages.
     */
    data: XOR<MailroomPackageUpdateManyMutationInput, MailroomPackageUncheckedUpdateManyInput>
    /**
     * Filter which MailroomPackages to update
     */
    where?: MailroomPackageWhereInput
    /**
     * Limit how many MailroomPackages to update.
     */
    limit?: number
  }

  /**
   * MailroomPackage updateManyAndReturn
   */
  export type MailroomPackageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailroomPackage
     */
    select?: MailroomPackageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MailroomPackage
     */
    omit?: MailroomPackageOmit<ExtArgs> | null
    /**
     * The data used to update MailroomPackages.
     */
    data: XOR<MailroomPackageUpdateManyMutationInput, MailroomPackageUncheckedUpdateManyInput>
    /**
     * Filter which MailroomPackages to update
     */
    where?: MailroomPackageWhereInput
    /**
     * Limit how many MailroomPackages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailroomPackageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MailroomPackage upsert
   */
  export type MailroomPackageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailroomPackage
     */
    select?: MailroomPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MailroomPackage
     */
    omit?: MailroomPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailroomPackageInclude<ExtArgs> | null
    /**
     * The filter to search for the MailroomPackage to update in case it exists.
     */
    where: MailroomPackageWhereUniqueInput
    /**
     * In case the MailroomPackage found by the `where` argument doesn't exist, create a new MailroomPackage with this data.
     */
    create: XOR<MailroomPackageCreateInput, MailroomPackageUncheckedCreateInput>
    /**
     * In case the MailroomPackage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MailroomPackageUpdateInput, MailroomPackageUncheckedUpdateInput>
  }

  /**
   * MailroomPackage delete
   */
  export type MailroomPackageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailroomPackage
     */
    select?: MailroomPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MailroomPackage
     */
    omit?: MailroomPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailroomPackageInclude<ExtArgs> | null
    /**
     * Filter which MailroomPackage to delete.
     */
    where: MailroomPackageWhereUniqueInput
  }

  /**
   * MailroomPackage deleteMany
   */
  export type MailroomPackageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MailroomPackages to delete
     */
    where?: MailroomPackageWhereInput
    /**
     * Limit how many MailroomPackages to delete.
     */
    limit?: number
  }

  /**
   * MailroomPackage.ticket
   */
  export type MailroomPackage$ticketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    where?: SupportTicketWhereInput
  }

  /**
   * MailroomPackage.asset
   */
  export type MailroomPackage$assetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAsset
     */
    select?: InventoryAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAsset
     */
    omit?: InventoryAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAssetInclude<ExtArgs> | null
    where?: InventoryAssetWhereInput
  }

  /**
   * MailroomPackage.deliveryEvents
   */
  export type MailroomPackage$deliveryEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEvent
     */
    select?: DeliveryEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEvent
     */
    omit?: DeliveryEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEventInclude<ExtArgs> | null
    where?: DeliveryEventWhereInput
    orderBy?: DeliveryEventOrderByWithRelationInput | DeliveryEventOrderByWithRelationInput[]
    cursor?: DeliveryEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryEventScalarFieldEnum | DeliveryEventScalarFieldEnum[]
  }

  /**
   * MailroomPackage.proxyAuthorizations
   */
  export type MailroomPackage$proxyAuthorizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyAuthorization
     */
    select?: ProxyAuthorizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyAuthorization
     */
    omit?: ProxyAuthorizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyAuthorizationInclude<ExtArgs> | null
    where?: ProxyAuthorizationWhereInput
    orderBy?: ProxyAuthorizationOrderByWithRelationInput | ProxyAuthorizationOrderByWithRelationInput[]
    cursor?: ProxyAuthorizationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProxyAuthorizationScalarFieldEnum | ProxyAuthorizationScalarFieldEnum[]
  }

  /**
   * MailroomPackage without action
   */
  export type MailroomPackageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailroomPackage
     */
    select?: MailroomPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MailroomPackage
     */
    omit?: MailroomPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailroomPackageInclude<ExtArgs> | null
  }


  /**
   * Model DeliveryEvent
   */

  export type AggregateDeliveryEvent = {
    _count: DeliveryEventCountAggregateOutputType | null
    _avg: DeliveryEventAvgAggregateOutputType | null
    _sum: DeliveryEventSumAggregateOutputType | null
    _min: DeliveryEventMinAggregateOutputType | null
    _max: DeliveryEventMaxAggregateOutputType | null
  }

  export type DeliveryEventAvgAggregateOutputType = {
    id: number | null
    packageId: number | null
  }

  export type DeliveryEventSumAggregateOutputType = {
    id: number | null
    packageId: number | null
  }

  export type DeliveryEventMinAggregateOutputType = {
    id: number | null
    packageId: number | null
    eventType: string | null
    performedBy: string | null
    location: string | null
    timestamp: Date | null
    photoUrl: string | null
    signatureBlob: Uint8Array | null
  }

  export type DeliveryEventMaxAggregateOutputType = {
    id: number | null
    packageId: number | null
    eventType: string | null
    performedBy: string | null
    location: string | null
    timestamp: Date | null
    photoUrl: string | null
    signatureBlob: Uint8Array | null
  }

  export type DeliveryEventCountAggregateOutputType = {
    id: number
    packageId: number
    eventType: number
    performedBy: number
    location: number
    timestamp: number
    photoUrl: number
    signatureBlob: number
    _all: number
  }


  export type DeliveryEventAvgAggregateInputType = {
    id?: true
    packageId?: true
  }

  export type DeliveryEventSumAggregateInputType = {
    id?: true
    packageId?: true
  }

  export type DeliveryEventMinAggregateInputType = {
    id?: true
    packageId?: true
    eventType?: true
    performedBy?: true
    location?: true
    timestamp?: true
    photoUrl?: true
    signatureBlob?: true
  }

  export type DeliveryEventMaxAggregateInputType = {
    id?: true
    packageId?: true
    eventType?: true
    performedBy?: true
    location?: true
    timestamp?: true
    photoUrl?: true
    signatureBlob?: true
  }

  export type DeliveryEventCountAggregateInputType = {
    id?: true
    packageId?: true
    eventType?: true
    performedBy?: true
    location?: true
    timestamp?: true
    photoUrl?: true
    signatureBlob?: true
    _all?: true
  }

  export type DeliveryEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryEvent to aggregate.
     */
    where?: DeliveryEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryEvents to fetch.
     */
    orderBy?: DeliveryEventOrderByWithRelationInput | DeliveryEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryEvents
    **/
    _count?: true | DeliveryEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliveryEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryEventMaxAggregateInputType
  }

  export type GetDeliveryEventAggregateType<T extends DeliveryEventAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryEvent[P]>
      : GetScalarType<T[P], AggregateDeliveryEvent[P]>
  }




  export type DeliveryEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryEventWhereInput
    orderBy?: DeliveryEventOrderByWithAggregationInput | DeliveryEventOrderByWithAggregationInput[]
    by: DeliveryEventScalarFieldEnum[] | DeliveryEventScalarFieldEnum
    having?: DeliveryEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryEventCountAggregateInputType | true
    _avg?: DeliveryEventAvgAggregateInputType
    _sum?: DeliveryEventSumAggregateInputType
    _min?: DeliveryEventMinAggregateInputType
    _max?: DeliveryEventMaxAggregateInputType
  }

  export type DeliveryEventGroupByOutputType = {
    id: number
    packageId: number
    eventType: string
    performedBy: string
    location: string | null
    timestamp: Date
    photoUrl: string | null
    signatureBlob: Uint8Array | null
    _count: DeliveryEventCountAggregateOutputType | null
    _avg: DeliveryEventAvgAggregateOutputType | null
    _sum: DeliveryEventSumAggregateOutputType | null
    _min: DeliveryEventMinAggregateOutputType | null
    _max: DeliveryEventMaxAggregateOutputType | null
  }

  type GetDeliveryEventGroupByPayload<T extends DeliveryEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryEventGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryEventGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    packageId?: boolean
    eventType?: boolean
    performedBy?: boolean
    location?: boolean
    timestamp?: boolean
    photoUrl?: boolean
    signatureBlob?: boolean
    package?: boolean | MailroomPackageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryEvent"]>

  export type DeliveryEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    packageId?: boolean
    eventType?: boolean
    performedBy?: boolean
    location?: boolean
    timestamp?: boolean
    photoUrl?: boolean
    signatureBlob?: boolean
    package?: boolean | MailroomPackageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryEvent"]>

  export type DeliveryEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    packageId?: boolean
    eventType?: boolean
    performedBy?: boolean
    location?: boolean
    timestamp?: boolean
    photoUrl?: boolean
    signatureBlob?: boolean
    package?: boolean | MailroomPackageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryEvent"]>

  export type DeliveryEventSelectScalar = {
    id?: boolean
    packageId?: boolean
    eventType?: boolean
    performedBy?: boolean
    location?: boolean
    timestamp?: boolean
    photoUrl?: boolean
    signatureBlob?: boolean
  }

  export type DeliveryEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "packageId" | "eventType" | "performedBy" | "location" | "timestamp" | "photoUrl" | "signatureBlob", ExtArgs["result"]["deliveryEvent"]>
  export type DeliveryEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    package?: boolean | MailroomPackageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeliveryEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    package?: boolean | MailroomPackageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeliveryEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    package?: boolean | MailroomPackageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DeliveryEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryEvent"
    objects: {
      package: Prisma.$MailroomPackagePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      packageId: number
      eventType: string
      performedBy: string
      location: string | null
      timestamp: Date
      photoUrl: string | null
      signatureBlob: Uint8Array | null
    }, ExtArgs["result"]["deliveryEvent"]>
    composites: {}
  }

  type DeliveryEventGetPayload<S extends boolean | null | undefined | DeliveryEventDefaultArgs> = $Result.GetResult<Prisma.$DeliveryEventPayload, S>

  type DeliveryEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeliveryEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliveryEventCountAggregateInputType | true
    }

  export interface DeliveryEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryEvent'], meta: { name: 'DeliveryEvent' } }
    /**
     * Find zero or one DeliveryEvent that matches the filter.
     * @param {DeliveryEventFindUniqueArgs} args - Arguments to find a DeliveryEvent
     * @example
     * // Get one DeliveryEvent
     * const deliveryEvent = await prisma.deliveryEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryEventFindUniqueArgs>(args: SelectSubset<T, DeliveryEventFindUniqueArgs<ExtArgs>>): Prisma__DeliveryEventClient<$Result.GetResult<Prisma.$DeliveryEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeliveryEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeliveryEventFindUniqueOrThrowArgs} args - Arguments to find a DeliveryEvent
     * @example
     * // Get one DeliveryEvent
     * const deliveryEvent = await prisma.deliveryEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryEventFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryEventClient<$Result.GetResult<Prisma.$DeliveryEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryEventFindFirstArgs} args - Arguments to find a DeliveryEvent
     * @example
     * // Get one DeliveryEvent
     * const deliveryEvent = await prisma.deliveryEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryEventFindFirstArgs>(args?: SelectSubset<T, DeliveryEventFindFirstArgs<ExtArgs>>): Prisma__DeliveryEventClient<$Result.GetResult<Prisma.$DeliveryEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryEventFindFirstOrThrowArgs} args - Arguments to find a DeliveryEvent
     * @example
     * // Get one DeliveryEvent
     * const deliveryEvent = await prisma.deliveryEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryEventFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryEventClient<$Result.GetResult<Prisma.$DeliveryEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeliveryEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryEvents
     * const deliveryEvents = await prisma.deliveryEvent.findMany()
     * 
     * // Get first 10 DeliveryEvents
     * const deliveryEvents = await prisma.deliveryEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryEventWithIdOnly = await prisma.deliveryEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryEventFindManyArgs>(args?: SelectSubset<T, DeliveryEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeliveryEvent.
     * @param {DeliveryEventCreateArgs} args - Arguments to create a DeliveryEvent.
     * @example
     * // Create one DeliveryEvent
     * const DeliveryEvent = await prisma.deliveryEvent.create({
     *   data: {
     *     // ... data to create a DeliveryEvent
     *   }
     * })
     * 
     */
    create<T extends DeliveryEventCreateArgs>(args: SelectSubset<T, DeliveryEventCreateArgs<ExtArgs>>): Prisma__DeliveryEventClient<$Result.GetResult<Prisma.$DeliveryEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeliveryEvents.
     * @param {DeliveryEventCreateManyArgs} args - Arguments to create many DeliveryEvents.
     * @example
     * // Create many DeliveryEvents
     * const deliveryEvent = await prisma.deliveryEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryEventCreateManyArgs>(args?: SelectSubset<T, DeliveryEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeliveryEvents and returns the data saved in the database.
     * @param {DeliveryEventCreateManyAndReturnArgs} args - Arguments to create many DeliveryEvents.
     * @example
     * // Create many DeliveryEvents
     * const deliveryEvent = await prisma.deliveryEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeliveryEvents and only return the `id`
     * const deliveryEventWithIdOnly = await prisma.deliveryEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryEventCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeliveryEvent.
     * @param {DeliveryEventDeleteArgs} args - Arguments to delete one DeliveryEvent.
     * @example
     * // Delete one DeliveryEvent
     * const DeliveryEvent = await prisma.deliveryEvent.delete({
     *   where: {
     *     // ... filter to delete one DeliveryEvent
     *   }
     * })
     * 
     */
    delete<T extends DeliveryEventDeleteArgs>(args: SelectSubset<T, DeliveryEventDeleteArgs<ExtArgs>>): Prisma__DeliveryEventClient<$Result.GetResult<Prisma.$DeliveryEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeliveryEvent.
     * @param {DeliveryEventUpdateArgs} args - Arguments to update one DeliveryEvent.
     * @example
     * // Update one DeliveryEvent
     * const deliveryEvent = await prisma.deliveryEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryEventUpdateArgs>(args: SelectSubset<T, DeliveryEventUpdateArgs<ExtArgs>>): Prisma__DeliveryEventClient<$Result.GetResult<Prisma.$DeliveryEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeliveryEvents.
     * @param {DeliveryEventDeleteManyArgs} args - Arguments to filter DeliveryEvents to delete.
     * @example
     * // Delete a few DeliveryEvents
     * const { count } = await prisma.deliveryEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryEventDeleteManyArgs>(args?: SelectSubset<T, DeliveryEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryEvents
     * const deliveryEvent = await prisma.deliveryEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryEventUpdateManyArgs>(args: SelectSubset<T, DeliveryEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryEvents and returns the data updated in the database.
     * @param {DeliveryEventUpdateManyAndReturnArgs} args - Arguments to update many DeliveryEvents.
     * @example
     * // Update many DeliveryEvents
     * const deliveryEvent = await prisma.deliveryEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeliveryEvents and only return the `id`
     * const deliveryEventWithIdOnly = await prisma.deliveryEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeliveryEventUpdateManyAndReturnArgs>(args: SelectSubset<T, DeliveryEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeliveryEvent.
     * @param {DeliveryEventUpsertArgs} args - Arguments to update or create a DeliveryEvent.
     * @example
     * // Update or create a DeliveryEvent
     * const deliveryEvent = await prisma.deliveryEvent.upsert({
     *   create: {
     *     // ... data to create a DeliveryEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryEvent we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryEventUpsertArgs>(args: SelectSubset<T, DeliveryEventUpsertArgs<ExtArgs>>): Prisma__DeliveryEventClient<$Result.GetResult<Prisma.$DeliveryEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeliveryEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryEventCountArgs} args - Arguments to filter DeliveryEvents to count.
     * @example
     * // Count the number of DeliveryEvents
     * const count = await prisma.deliveryEvent.count({
     *   where: {
     *     // ... the filter for the DeliveryEvents we want to count
     *   }
     * })
    **/
    count<T extends DeliveryEventCountArgs>(
      args?: Subset<T, DeliveryEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryEventAggregateArgs>(args: Subset<T, DeliveryEventAggregateArgs>): Prisma.PrismaPromise<GetDeliveryEventAggregateType<T>>

    /**
     * Group by DeliveryEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryEventGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryEvent model
   */
  readonly fields: DeliveryEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    package<T extends MailroomPackageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MailroomPackageDefaultArgs<ExtArgs>>): Prisma__MailroomPackageClient<$Result.GetResult<Prisma.$MailroomPackagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryEvent model
   */
  interface DeliveryEventFieldRefs {
    readonly id: FieldRef<"DeliveryEvent", 'Int'>
    readonly packageId: FieldRef<"DeliveryEvent", 'Int'>
    readonly eventType: FieldRef<"DeliveryEvent", 'String'>
    readonly performedBy: FieldRef<"DeliveryEvent", 'String'>
    readonly location: FieldRef<"DeliveryEvent", 'String'>
    readonly timestamp: FieldRef<"DeliveryEvent", 'DateTime'>
    readonly photoUrl: FieldRef<"DeliveryEvent", 'String'>
    readonly signatureBlob: FieldRef<"DeliveryEvent", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryEvent findUnique
   */
  export type DeliveryEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEvent
     */
    select?: DeliveryEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEvent
     */
    omit?: DeliveryEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEventInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryEvent to fetch.
     */
    where: DeliveryEventWhereUniqueInput
  }

  /**
   * DeliveryEvent findUniqueOrThrow
   */
  export type DeliveryEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEvent
     */
    select?: DeliveryEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEvent
     */
    omit?: DeliveryEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEventInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryEvent to fetch.
     */
    where: DeliveryEventWhereUniqueInput
  }

  /**
   * DeliveryEvent findFirst
   */
  export type DeliveryEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEvent
     */
    select?: DeliveryEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEvent
     */
    omit?: DeliveryEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEventInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryEvent to fetch.
     */
    where?: DeliveryEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryEvents to fetch.
     */
    orderBy?: DeliveryEventOrderByWithRelationInput | DeliveryEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryEvents.
     */
    cursor?: DeliveryEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryEvents.
     */
    distinct?: DeliveryEventScalarFieldEnum | DeliveryEventScalarFieldEnum[]
  }

  /**
   * DeliveryEvent findFirstOrThrow
   */
  export type DeliveryEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEvent
     */
    select?: DeliveryEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEvent
     */
    omit?: DeliveryEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEventInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryEvent to fetch.
     */
    where?: DeliveryEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryEvents to fetch.
     */
    orderBy?: DeliveryEventOrderByWithRelationInput | DeliveryEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryEvents.
     */
    cursor?: DeliveryEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryEvents.
     */
    distinct?: DeliveryEventScalarFieldEnum | DeliveryEventScalarFieldEnum[]
  }

  /**
   * DeliveryEvent findMany
   */
  export type DeliveryEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEvent
     */
    select?: DeliveryEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEvent
     */
    omit?: DeliveryEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEventInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryEvents to fetch.
     */
    where?: DeliveryEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryEvents to fetch.
     */
    orderBy?: DeliveryEventOrderByWithRelationInput | DeliveryEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryEvents.
     */
    cursor?: DeliveryEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryEvents.
     */
    skip?: number
    distinct?: DeliveryEventScalarFieldEnum | DeliveryEventScalarFieldEnum[]
  }

  /**
   * DeliveryEvent create
   */
  export type DeliveryEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEvent
     */
    select?: DeliveryEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEvent
     */
    omit?: DeliveryEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEventInclude<ExtArgs> | null
    /**
     * The data needed to create a DeliveryEvent.
     */
    data: XOR<DeliveryEventCreateInput, DeliveryEventUncheckedCreateInput>
  }

  /**
   * DeliveryEvent createMany
   */
  export type DeliveryEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryEvents.
     */
    data: DeliveryEventCreateManyInput | DeliveryEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryEvent createManyAndReturn
   */
  export type DeliveryEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEvent
     */
    select?: DeliveryEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEvent
     */
    omit?: DeliveryEventOmit<ExtArgs> | null
    /**
     * The data used to create many DeliveryEvents.
     */
    data: DeliveryEventCreateManyInput | DeliveryEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryEvent update
   */
  export type DeliveryEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEvent
     */
    select?: DeliveryEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEvent
     */
    omit?: DeliveryEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEventInclude<ExtArgs> | null
    /**
     * The data needed to update a DeliveryEvent.
     */
    data: XOR<DeliveryEventUpdateInput, DeliveryEventUncheckedUpdateInput>
    /**
     * Choose, which DeliveryEvent to update.
     */
    where: DeliveryEventWhereUniqueInput
  }

  /**
   * DeliveryEvent updateMany
   */
  export type DeliveryEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryEvents.
     */
    data: XOR<DeliveryEventUpdateManyMutationInput, DeliveryEventUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryEvents to update
     */
    where?: DeliveryEventWhereInput
    /**
     * Limit how many DeliveryEvents to update.
     */
    limit?: number
  }

  /**
   * DeliveryEvent updateManyAndReturn
   */
  export type DeliveryEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEvent
     */
    select?: DeliveryEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEvent
     */
    omit?: DeliveryEventOmit<ExtArgs> | null
    /**
     * The data used to update DeliveryEvents.
     */
    data: XOR<DeliveryEventUpdateManyMutationInput, DeliveryEventUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryEvents to update
     */
    where?: DeliveryEventWhereInput
    /**
     * Limit how many DeliveryEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryEvent upsert
   */
  export type DeliveryEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEvent
     */
    select?: DeliveryEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEvent
     */
    omit?: DeliveryEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEventInclude<ExtArgs> | null
    /**
     * The filter to search for the DeliveryEvent to update in case it exists.
     */
    where: DeliveryEventWhereUniqueInput
    /**
     * In case the DeliveryEvent found by the `where` argument doesn't exist, create a new DeliveryEvent with this data.
     */
    create: XOR<DeliveryEventCreateInput, DeliveryEventUncheckedCreateInput>
    /**
     * In case the DeliveryEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryEventUpdateInput, DeliveryEventUncheckedUpdateInput>
  }

  /**
   * DeliveryEvent delete
   */
  export type DeliveryEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEvent
     */
    select?: DeliveryEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEvent
     */
    omit?: DeliveryEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEventInclude<ExtArgs> | null
    /**
     * Filter which DeliveryEvent to delete.
     */
    where: DeliveryEventWhereUniqueInput
  }

  /**
   * DeliveryEvent deleteMany
   */
  export type DeliveryEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryEvents to delete
     */
    where?: DeliveryEventWhereInput
    /**
     * Limit how many DeliveryEvents to delete.
     */
    limit?: number
  }

  /**
   * DeliveryEvent without action
   */
  export type DeliveryEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEvent
     */
    select?: DeliveryEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEvent
     */
    omit?: DeliveryEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEventInclude<ExtArgs> | null
  }


  /**
   * Model ProxyAuthorization
   */

  export type AggregateProxyAuthorization = {
    _count: ProxyAuthorizationCountAggregateOutputType | null
    _avg: ProxyAuthorizationAvgAggregateOutputType | null
    _sum: ProxyAuthorizationSumAggregateOutputType | null
    _min: ProxyAuthorizationMinAggregateOutputType | null
    _max: ProxyAuthorizationMaxAggregateOutputType | null
  }

  export type ProxyAuthorizationAvgAggregateOutputType = {
    id: number | null
    packageId: number | null
  }

  export type ProxyAuthorizationSumAggregateOutputType = {
    id: number | null
    packageId: number | null
  }

  export type ProxyAuthorizationMinAggregateOutputType = {
    id: number | null
    recipientId: string | null
    proxyId: string | null
    packageId: number | null
    expiration: Date | null
    status: string | null
  }

  export type ProxyAuthorizationMaxAggregateOutputType = {
    id: number | null
    recipientId: string | null
    proxyId: string | null
    packageId: number | null
    expiration: Date | null
    status: string | null
  }

  export type ProxyAuthorizationCountAggregateOutputType = {
    id: number
    recipientId: number
    proxyId: number
    packageId: number
    expiration: number
    status: number
    _all: number
  }


  export type ProxyAuthorizationAvgAggregateInputType = {
    id?: true
    packageId?: true
  }

  export type ProxyAuthorizationSumAggregateInputType = {
    id?: true
    packageId?: true
  }

  export type ProxyAuthorizationMinAggregateInputType = {
    id?: true
    recipientId?: true
    proxyId?: true
    packageId?: true
    expiration?: true
    status?: true
  }

  export type ProxyAuthorizationMaxAggregateInputType = {
    id?: true
    recipientId?: true
    proxyId?: true
    packageId?: true
    expiration?: true
    status?: true
  }

  export type ProxyAuthorizationCountAggregateInputType = {
    id?: true
    recipientId?: true
    proxyId?: true
    packageId?: true
    expiration?: true
    status?: true
    _all?: true
  }

  export type ProxyAuthorizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProxyAuthorization to aggregate.
     */
    where?: ProxyAuthorizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxyAuthorizations to fetch.
     */
    orderBy?: ProxyAuthorizationOrderByWithRelationInput | ProxyAuthorizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProxyAuthorizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProxyAuthorizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxyAuthorizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProxyAuthorizations
    **/
    _count?: true | ProxyAuthorizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProxyAuthorizationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProxyAuthorizationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProxyAuthorizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProxyAuthorizationMaxAggregateInputType
  }

  export type GetProxyAuthorizationAggregateType<T extends ProxyAuthorizationAggregateArgs> = {
        [P in keyof T & keyof AggregateProxyAuthorization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProxyAuthorization[P]>
      : GetScalarType<T[P], AggregateProxyAuthorization[P]>
  }




  export type ProxyAuthorizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProxyAuthorizationWhereInput
    orderBy?: ProxyAuthorizationOrderByWithAggregationInput | ProxyAuthorizationOrderByWithAggregationInput[]
    by: ProxyAuthorizationScalarFieldEnum[] | ProxyAuthorizationScalarFieldEnum
    having?: ProxyAuthorizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProxyAuthorizationCountAggregateInputType | true
    _avg?: ProxyAuthorizationAvgAggregateInputType
    _sum?: ProxyAuthorizationSumAggregateInputType
    _min?: ProxyAuthorizationMinAggregateInputType
    _max?: ProxyAuthorizationMaxAggregateInputType
  }

  export type ProxyAuthorizationGroupByOutputType = {
    id: number
    recipientId: string
    proxyId: string
    packageId: number
    expiration: Date | null
    status: string
    _count: ProxyAuthorizationCountAggregateOutputType | null
    _avg: ProxyAuthorizationAvgAggregateOutputType | null
    _sum: ProxyAuthorizationSumAggregateOutputType | null
    _min: ProxyAuthorizationMinAggregateOutputType | null
    _max: ProxyAuthorizationMaxAggregateOutputType | null
  }

  type GetProxyAuthorizationGroupByPayload<T extends ProxyAuthorizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProxyAuthorizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProxyAuthorizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProxyAuthorizationGroupByOutputType[P]>
            : GetScalarType<T[P], ProxyAuthorizationGroupByOutputType[P]>
        }
      >
    >


  export type ProxyAuthorizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipientId?: boolean
    proxyId?: boolean
    packageId?: boolean
    expiration?: boolean
    status?: boolean
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    proxy?: boolean | UserDefaultArgs<ExtArgs>
    package?: boolean | MailroomPackageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proxyAuthorization"]>

  export type ProxyAuthorizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipientId?: boolean
    proxyId?: boolean
    packageId?: boolean
    expiration?: boolean
    status?: boolean
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    proxy?: boolean | UserDefaultArgs<ExtArgs>
    package?: boolean | MailroomPackageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proxyAuthorization"]>

  export type ProxyAuthorizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipientId?: boolean
    proxyId?: boolean
    packageId?: boolean
    expiration?: boolean
    status?: boolean
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    proxy?: boolean | UserDefaultArgs<ExtArgs>
    package?: boolean | MailroomPackageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proxyAuthorization"]>

  export type ProxyAuthorizationSelectScalar = {
    id?: boolean
    recipientId?: boolean
    proxyId?: boolean
    packageId?: boolean
    expiration?: boolean
    status?: boolean
  }

  export type ProxyAuthorizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "recipientId" | "proxyId" | "packageId" | "expiration" | "status", ExtArgs["result"]["proxyAuthorization"]>
  export type ProxyAuthorizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    proxy?: boolean | UserDefaultArgs<ExtArgs>
    package?: boolean | MailroomPackageDefaultArgs<ExtArgs>
  }
  export type ProxyAuthorizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    proxy?: boolean | UserDefaultArgs<ExtArgs>
    package?: boolean | MailroomPackageDefaultArgs<ExtArgs>
  }
  export type ProxyAuthorizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    proxy?: boolean | UserDefaultArgs<ExtArgs>
    package?: boolean | MailroomPackageDefaultArgs<ExtArgs>
  }

  export type $ProxyAuthorizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProxyAuthorization"
    objects: {
      recipient: Prisma.$UserPayload<ExtArgs>
      proxy: Prisma.$UserPayload<ExtArgs>
      package: Prisma.$MailroomPackagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      recipientId: string
      proxyId: string
      packageId: number
      expiration: Date | null
      status: string
    }, ExtArgs["result"]["proxyAuthorization"]>
    composites: {}
  }

  type ProxyAuthorizationGetPayload<S extends boolean | null | undefined | ProxyAuthorizationDefaultArgs> = $Result.GetResult<Prisma.$ProxyAuthorizationPayload, S>

  type ProxyAuthorizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProxyAuthorizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProxyAuthorizationCountAggregateInputType | true
    }

  export interface ProxyAuthorizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProxyAuthorization'], meta: { name: 'ProxyAuthorization' } }
    /**
     * Find zero or one ProxyAuthorization that matches the filter.
     * @param {ProxyAuthorizationFindUniqueArgs} args - Arguments to find a ProxyAuthorization
     * @example
     * // Get one ProxyAuthorization
     * const proxyAuthorization = await prisma.proxyAuthorization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProxyAuthorizationFindUniqueArgs>(args: SelectSubset<T, ProxyAuthorizationFindUniqueArgs<ExtArgs>>): Prisma__ProxyAuthorizationClient<$Result.GetResult<Prisma.$ProxyAuthorizationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProxyAuthorization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProxyAuthorizationFindUniqueOrThrowArgs} args - Arguments to find a ProxyAuthorization
     * @example
     * // Get one ProxyAuthorization
     * const proxyAuthorization = await prisma.proxyAuthorization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProxyAuthorizationFindUniqueOrThrowArgs>(args: SelectSubset<T, ProxyAuthorizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProxyAuthorizationClient<$Result.GetResult<Prisma.$ProxyAuthorizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProxyAuthorization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyAuthorizationFindFirstArgs} args - Arguments to find a ProxyAuthorization
     * @example
     * // Get one ProxyAuthorization
     * const proxyAuthorization = await prisma.proxyAuthorization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProxyAuthorizationFindFirstArgs>(args?: SelectSubset<T, ProxyAuthorizationFindFirstArgs<ExtArgs>>): Prisma__ProxyAuthorizationClient<$Result.GetResult<Prisma.$ProxyAuthorizationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProxyAuthorization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyAuthorizationFindFirstOrThrowArgs} args - Arguments to find a ProxyAuthorization
     * @example
     * // Get one ProxyAuthorization
     * const proxyAuthorization = await prisma.proxyAuthorization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProxyAuthorizationFindFirstOrThrowArgs>(args?: SelectSubset<T, ProxyAuthorizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProxyAuthorizationClient<$Result.GetResult<Prisma.$ProxyAuthorizationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProxyAuthorizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyAuthorizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProxyAuthorizations
     * const proxyAuthorizations = await prisma.proxyAuthorization.findMany()
     * 
     * // Get first 10 ProxyAuthorizations
     * const proxyAuthorizations = await prisma.proxyAuthorization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proxyAuthorizationWithIdOnly = await prisma.proxyAuthorization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProxyAuthorizationFindManyArgs>(args?: SelectSubset<T, ProxyAuthorizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxyAuthorizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProxyAuthorization.
     * @param {ProxyAuthorizationCreateArgs} args - Arguments to create a ProxyAuthorization.
     * @example
     * // Create one ProxyAuthorization
     * const ProxyAuthorization = await prisma.proxyAuthorization.create({
     *   data: {
     *     // ... data to create a ProxyAuthorization
     *   }
     * })
     * 
     */
    create<T extends ProxyAuthorizationCreateArgs>(args: SelectSubset<T, ProxyAuthorizationCreateArgs<ExtArgs>>): Prisma__ProxyAuthorizationClient<$Result.GetResult<Prisma.$ProxyAuthorizationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProxyAuthorizations.
     * @param {ProxyAuthorizationCreateManyArgs} args - Arguments to create many ProxyAuthorizations.
     * @example
     * // Create many ProxyAuthorizations
     * const proxyAuthorization = await prisma.proxyAuthorization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProxyAuthorizationCreateManyArgs>(args?: SelectSubset<T, ProxyAuthorizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProxyAuthorizations and returns the data saved in the database.
     * @param {ProxyAuthorizationCreateManyAndReturnArgs} args - Arguments to create many ProxyAuthorizations.
     * @example
     * // Create many ProxyAuthorizations
     * const proxyAuthorization = await prisma.proxyAuthorization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProxyAuthorizations and only return the `id`
     * const proxyAuthorizationWithIdOnly = await prisma.proxyAuthorization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProxyAuthorizationCreateManyAndReturnArgs>(args?: SelectSubset<T, ProxyAuthorizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxyAuthorizationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProxyAuthorization.
     * @param {ProxyAuthorizationDeleteArgs} args - Arguments to delete one ProxyAuthorization.
     * @example
     * // Delete one ProxyAuthorization
     * const ProxyAuthorization = await prisma.proxyAuthorization.delete({
     *   where: {
     *     // ... filter to delete one ProxyAuthorization
     *   }
     * })
     * 
     */
    delete<T extends ProxyAuthorizationDeleteArgs>(args: SelectSubset<T, ProxyAuthorizationDeleteArgs<ExtArgs>>): Prisma__ProxyAuthorizationClient<$Result.GetResult<Prisma.$ProxyAuthorizationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProxyAuthorization.
     * @param {ProxyAuthorizationUpdateArgs} args - Arguments to update one ProxyAuthorization.
     * @example
     * // Update one ProxyAuthorization
     * const proxyAuthorization = await prisma.proxyAuthorization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProxyAuthorizationUpdateArgs>(args: SelectSubset<T, ProxyAuthorizationUpdateArgs<ExtArgs>>): Prisma__ProxyAuthorizationClient<$Result.GetResult<Prisma.$ProxyAuthorizationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProxyAuthorizations.
     * @param {ProxyAuthorizationDeleteManyArgs} args - Arguments to filter ProxyAuthorizations to delete.
     * @example
     * // Delete a few ProxyAuthorizations
     * const { count } = await prisma.proxyAuthorization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProxyAuthorizationDeleteManyArgs>(args?: SelectSubset<T, ProxyAuthorizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProxyAuthorizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyAuthorizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProxyAuthorizations
     * const proxyAuthorization = await prisma.proxyAuthorization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProxyAuthorizationUpdateManyArgs>(args: SelectSubset<T, ProxyAuthorizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProxyAuthorizations and returns the data updated in the database.
     * @param {ProxyAuthorizationUpdateManyAndReturnArgs} args - Arguments to update many ProxyAuthorizations.
     * @example
     * // Update many ProxyAuthorizations
     * const proxyAuthorization = await prisma.proxyAuthorization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProxyAuthorizations and only return the `id`
     * const proxyAuthorizationWithIdOnly = await prisma.proxyAuthorization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProxyAuthorizationUpdateManyAndReturnArgs>(args: SelectSubset<T, ProxyAuthorizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxyAuthorizationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProxyAuthorization.
     * @param {ProxyAuthorizationUpsertArgs} args - Arguments to update or create a ProxyAuthorization.
     * @example
     * // Update or create a ProxyAuthorization
     * const proxyAuthorization = await prisma.proxyAuthorization.upsert({
     *   create: {
     *     // ... data to create a ProxyAuthorization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProxyAuthorization we want to update
     *   }
     * })
     */
    upsert<T extends ProxyAuthorizationUpsertArgs>(args: SelectSubset<T, ProxyAuthorizationUpsertArgs<ExtArgs>>): Prisma__ProxyAuthorizationClient<$Result.GetResult<Prisma.$ProxyAuthorizationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProxyAuthorizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyAuthorizationCountArgs} args - Arguments to filter ProxyAuthorizations to count.
     * @example
     * // Count the number of ProxyAuthorizations
     * const count = await prisma.proxyAuthorization.count({
     *   where: {
     *     // ... the filter for the ProxyAuthorizations we want to count
     *   }
     * })
    **/
    count<T extends ProxyAuthorizationCountArgs>(
      args?: Subset<T, ProxyAuthorizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProxyAuthorizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProxyAuthorization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyAuthorizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProxyAuthorizationAggregateArgs>(args: Subset<T, ProxyAuthorizationAggregateArgs>): Prisma.PrismaPromise<GetProxyAuthorizationAggregateType<T>>

    /**
     * Group by ProxyAuthorization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyAuthorizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProxyAuthorizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProxyAuthorizationGroupByArgs['orderBy'] }
        : { orderBy?: ProxyAuthorizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProxyAuthorizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProxyAuthorizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProxyAuthorization model
   */
  readonly fields: ProxyAuthorizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProxyAuthorization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProxyAuthorizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipient<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    proxy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    package<T extends MailroomPackageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MailroomPackageDefaultArgs<ExtArgs>>): Prisma__MailroomPackageClient<$Result.GetResult<Prisma.$MailroomPackagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProxyAuthorization model
   */
  interface ProxyAuthorizationFieldRefs {
    readonly id: FieldRef<"ProxyAuthorization", 'Int'>
    readonly recipientId: FieldRef<"ProxyAuthorization", 'String'>
    readonly proxyId: FieldRef<"ProxyAuthorization", 'String'>
    readonly packageId: FieldRef<"ProxyAuthorization", 'Int'>
    readonly expiration: FieldRef<"ProxyAuthorization", 'DateTime'>
    readonly status: FieldRef<"ProxyAuthorization", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProxyAuthorization findUnique
   */
  export type ProxyAuthorizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyAuthorization
     */
    select?: ProxyAuthorizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyAuthorization
     */
    omit?: ProxyAuthorizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyAuthorizationInclude<ExtArgs> | null
    /**
     * Filter, which ProxyAuthorization to fetch.
     */
    where: ProxyAuthorizationWhereUniqueInput
  }

  /**
   * ProxyAuthorization findUniqueOrThrow
   */
  export type ProxyAuthorizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyAuthorization
     */
    select?: ProxyAuthorizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyAuthorization
     */
    omit?: ProxyAuthorizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyAuthorizationInclude<ExtArgs> | null
    /**
     * Filter, which ProxyAuthorization to fetch.
     */
    where: ProxyAuthorizationWhereUniqueInput
  }

  /**
   * ProxyAuthorization findFirst
   */
  export type ProxyAuthorizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyAuthorization
     */
    select?: ProxyAuthorizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyAuthorization
     */
    omit?: ProxyAuthorizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyAuthorizationInclude<ExtArgs> | null
    /**
     * Filter, which ProxyAuthorization to fetch.
     */
    where?: ProxyAuthorizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxyAuthorizations to fetch.
     */
    orderBy?: ProxyAuthorizationOrderByWithRelationInput | ProxyAuthorizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProxyAuthorizations.
     */
    cursor?: ProxyAuthorizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProxyAuthorizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxyAuthorizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProxyAuthorizations.
     */
    distinct?: ProxyAuthorizationScalarFieldEnum | ProxyAuthorizationScalarFieldEnum[]
  }

  /**
   * ProxyAuthorization findFirstOrThrow
   */
  export type ProxyAuthorizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyAuthorization
     */
    select?: ProxyAuthorizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyAuthorization
     */
    omit?: ProxyAuthorizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyAuthorizationInclude<ExtArgs> | null
    /**
     * Filter, which ProxyAuthorization to fetch.
     */
    where?: ProxyAuthorizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxyAuthorizations to fetch.
     */
    orderBy?: ProxyAuthorizationOrderByWithRelationInput | ProxyAuthorizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProxyAuthorizations.
     */
    cursor?: ProxyAuthorizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProxyAuthorizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxyAuthorizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProxyAuthorizations.
     */
    distinct?: ProxyAuthorizationScalarFieldEnum | ProxyAuthorizationScalarFieldEnum[]
  }

  /**
   * ProxyAuthorization findMany
   */
  export type ProxyAuthorizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyAuthorization
     */
    select?: ProxyAuthorizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyAuthorization
     */
    omit?: ProxyAuthorizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyAuthorizationInclude<ExtArgs> | null
    /**
     * Filter, which ProxyAuthorizations to fetch.
     */
    where?: ProxyAuthorizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxyAuthorizations to fetch.
     */
    orderBy?: ProxyAuthorizationOrderByWithRelationInput | ProxyAuthorizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProxyAuthorizations.
     */
    cursor?: ProxyAuthorizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProxyAuthorizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxyAuthorizations.
     */
    skip?: number
    distinct?: ProxyAuthorizationScalarFieldEnum | ProxyAuthorizationScalarFieldEnum[]
  }

  /**
   * ProxyAuthorization create
   */
  export type ProxyAuthorizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyAuthorization
     */
    select?: ProxyAuthorizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyAuthorization
     */
    omit?: ProxyAuthorizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyAuthorizationInclude<ExtArgs> | null
    /**
     * The data needed to create a ProxyAuthorization.
     */
    data: XOR<ProxyAuthorizationCreateInput, ProxyAuthorizationUncheckedCreateInput>
  }

  /**
   * ProxyAuthorization createMany
   */
  export type ProxyAuthorizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProxyAuthorizations.
     */
    data: ProxyAuthorizationCreateManyInput | ProxyAuthorizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProxyAuthorization createManyAndReturn
   */
  export type ProxyAuthorizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyAuthorization
     */
    select?: ProxyAuthorizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyAuthorization
     */
    omit?: ProxyAuthorizationOmit<ExtArgs> | null
    /**
     * The data used to create many ProxyAuthorizations.
     */
    data: ProxyAuthorizationCreateManyInput | ProxyAuthorizationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyAuthorizationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProxyAuthorization update
   */
  export type ProxyAuthorizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyAuthorization
     */
    select?: ProxyAuthorizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyAuthorization
     */
    omit?: ProxyAuthorizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyAuthorizationInclude<ExtArgs> | null
    /**
     * The data needed to update a ProxyAuthorization.
     */
    data: XOR<ProxyAuthorizationUpdateInput, ProxyAuthorizationUncheckedUpdateInput>
    /**
     * Choose, which ProxyAuthorization to update.
     */
    where: ProxyAuthorizationWhereUniqueInput
  }

  /**
   * ProxyAuthorization updateMany
   */
  export type ProxyAuthorizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProxyAuthorizations.
     */
    data: XOR<ProxyAuthorizationUpdateManyMutationInput, ProxyAuthorizationUncheckedUpdateManyInput>
    /**
     * Filter which ProxyAuthorizations to update
     */
    where?: ProxyAuthorizationWhereInput
    /**
     * Limit how many ProxyAuthorizations to update.
     */
    limit?: number
  }

  /**
   * ProxyAuthorization updateManyAndReturn
   */
  export type ProxyAuthorizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyAuthorization
     */
    select?: ProxyAuthorizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyAuthorization
     */
    omit?: ProxyAuthorizationOmit<ExtArgs> | null
    /**
     * The data used to update ProxyAuthorizations.
     */
    data: XOR<ProxyAuthorizationUpdateManyMutationInput, ProxyAuthorizationUncheckedUpdateManyInput>
    /**
     * Filter which ProxyAuthorizations to update
     */
    where?: ProxyAuthorizationWhereInput
    /**
     * Limit how many ProxyAuthorizations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyAuthorizationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProxyAuthorization upsert
   */
  export type ProxyAuthorizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyAuthorization
     */
    select?: ProxyAuthorizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyAuthorization
     */
    omit?: ProxyAuthorizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyAuthorizationInclude<ExtArgs> | null
    /**
     * The filter to search for the ProxyAuthorization to update in case it exists.
     */
    where: ProxyAuthorizationWhereUniqueInput
    /**
     * In case the ProxyAuthorization found by the `where` argument doesn't exist, create a new ProxyAuthorization with this data.
     */
    create: XOR<ProxyAuthorizationCreateInput, ProxyAuthorizationUncheckedCreateInput>
    /**
     * In case the ProxyAuthorization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProxyAuthorizationUpdateInput, ProxyAuthorizationUncheckedUpdateInput>
  }

  /**
   * ProxyAuthorization delete
   */
  export type ProxyAuthorizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyAuthorization
     */
    select?: ProxyAuthorizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyAuthorization
     */
    omit?: ProxyAuthorizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyAuthorizationInclude<ExtArgs> | null
    /**
     * Filter which ProxyAuthorization to delete.
     */
    where: ProxyAuthorizationWhereUniqueInput
  }

  /**
   * ProxyAuthorization deleteMany
   */
  export type ProxyAuthorizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProxyAuthorizations to delete
     */
    where?: ProxyAuthorizationWhereInput
    /**
     * Limit how many ProxyAuthorizations to delete.
     */
    limit?: number
  }

  /**
   * ProxyAuthorization without action
   */
  export type ProxyAuthorizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyAuthorization
     */
    select?: ProxyAuthorizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyAuthorization
     */
    omit?: ProxyAuthorizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyAuthorizationInclude<ExtArgs> | null
  }


  /**
   * Model RequestCatalogItem
   */

  export type AggregateRequestCatalogItem = {
    _count: RequestCatalogItemCountAggregateOutputType | null
    _avg: RequestCatalogItemAvgAggregateOutputType | null
    _sum: RequestCatalogItemSumAggregateOutputType | null
    _min: RequestCatalogItemMinAggregateOutputType | null
    _max: RequestCatalogItemMaxAggregateOutputType | null
  }

  export type RequestCatalogItemAvgAggregateOutputType = {
    id: number | null
    workflowId: number | null
  }

  export type RequestCatalogItemSumAggregateOutputType = {
    id: number | null
    workflowId: number | null
  }

  export type RequestCatalogItemMinAggregateOutputType = {
    id: number | null
    name: string | null
    workflowId: number | null
  }

  export type RequestCatalogItemMaxAggregateOutputType = {
    id: number | null
    name: string | null
    workflowId: number | null
  }

  export type RequestCatalogItemCountAggregateOutputType = {
    id: number
    name: number
    formSchema: number
    workflowId: number
    _all: number
  }


  export type RequestCatalogItemAvgAggregateInputType = {
    id?: true
    workflowId?: true
  }

  export type RequestCatalogItemSumAggregateInputType = {
    id?: true
    workflowId?: true
  }

  export type RequestCatalogItemMinAggregateInputType = {
    id?: true
    name?: true
    workflowId?: true
  }

  export type RequestCatalogItemMaxAggregateInputType = {
    id?: true
    name?: true
    workflowId?: true
  }

  export type RequestCatalogItemCountAggregateInputType = {
    id?: true
    name?: true
    formSchema?: true
    workflowId?: true
    _all?: true
  }

  export type RequestCatalogItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequestCatalogItem to aggregate.
     */
    where?: RequestCatalogItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestCatalogItems to fetch.
     */
    orderBy?: RequestCatalogItemOrderByWithRelationInput | RequestCatalogItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RequestCatalogItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestCatalogItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestCatalogItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequestCatalogItems
    **/
    _count?: true | RequestCatalogItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestCatalogItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestCatalogItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestCatalogItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestCatalogItemMaxAggregateInputType
  }

  export type GetRequestCatalogItemAggregateType<T extends RequestCatalogItemAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestCatalogItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestCatalogItem[P]>
      : GetScalarType<T[P], AggregateRequestCatalogItem[P]>
  }




  export type RequestCatalogItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestCatalogItemWhereInput
    orderBy?: RequestCatalogItemOrderByWithAggregationInput | RequestCatalogItemOrderByWithAggregationInput[]
    by: RequestCatalogItemScalarFieldEnum[] | RequestCatalogItemScalarFieldEnum
    having?: RequestCatalogItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestCatalogItemCountAggregateInputType | true
    _avg?: RequestCatalogItemAvgAggregateInputType
    _sum?: RequestCatalogItemSumAggregateInputType
    _min?: RequestCatalogItemMinAggregateInputType
    _max?: RequestCatalogItemMaxAggregateInputType
  }

  export type RequestCatalogItemGroupByOutputType = {
    id: number
    name: string
    formSchema: JsonValue | null
    workflowId: number | null
    _count: RequestCatalogItemCountAggregateOutputType | null
    _avg: RequestCatalogItemAvgAggregateOutputType | null
    _sum: RequestCatalogItemSumAggregateOutputType | null
    _min: RequestCatalogItemMinAggregateOutputType | null
    _max: RequestCatalogItemMaxAggregateOutputType | null
  }

  type GetRequestCatalogItemGroupByPayload<T extends RequestCatalogItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequestCatalogItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestCatalogItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestCatalogItemGroupByOutputType[P]>
            : GetScalarType<T[P], RequestCatalogItemGroupByOutputType[P]>
        }
      >
    >


  export type RequestCatalogItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    formSchema?: boolean
    workflowId?: boolean
    ritms?: boolean | RequestCatalogItem$ritmsArgs<ExtArgs>
    _count?: boolean | RequestCatalogItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requestCatalogItem"]>

  export type RequestCatalogItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    formSchema?: boolean
    workflowId?: boolean
  }, ExtArgs["result"]["requestCatalogItem"]>

  export type RequestCatalogItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    formSchema?: boolean
    workflowId?: boolean
  }, ExtArgs["result"]["requestCatalogItem"]>

  export type RequestCatalogItemSelectScalar = {
    id?: boolean
    name?: boolean
    formSchema?: boolean
    workflowId?: boolean
  }

  export type RequestCatalogItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "formSchema" | "workflowId", ExtArgs["result"]["requestCatalogItem"]>
  export type RequestCatalogItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ritms?: boolean | RequestCatalogItem$ritmsArgs<ExtArgs>
    _count?: boolean | RequestCatalogItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RequestCatalogItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RequestCatalogItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RequestCatalogItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RequestCatalogItem"
    objects: {
      ritms: Prisma.$RITMPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      formSchema: Prisma.JsonValue | null
      workflowId: number | null
    }, ExtArgs["result"]["requestCatalogItem"]>
    composites: {}
  }

  type RequestCatalogItemGetPayload<S extends boolean | null | undefined | RequestCatalogItemDefaultArgs> = $Result.GetResult<Prisma.$RequestCatalogItemPayload, S>

  type RequestCatalogItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RequestCatalogItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RequestCatalogItemCountAggregateInputType | true
    }

  export interface RequestCatalogItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RequestCatalogItem'], meta: { name: 'RequestCatalogItem' } }
    /**
     * Find zero or one RequestCatalogItem that matches the filter.
     * @param {RequestCatalogItemFindUniqueArgs} args - Arguments to find a RequestCatalogItem
     * @example
     * // Get one RequestCatalogItem
     * const requestCatalogItem = await prisma.requestCatalogItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RequestCatalogItemFindUniqueArgs>(args: SelectSubset<T, RequestCatalogItemFindUniqueArgs<ExtArgs>>): Prisma__RequestCatalogItemClient<$Result.GetResult<Prisma.$RequestCatalogItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RequestCatalogItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RequestCatalogItemFindUniqueOrThrowArgs} args - Arguments to find a RequestCatalogItem
     * @example
     * // Get one RequestCatalogItem
     * const requestCatalogItem = await prisma.requestCatalogItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RequestCatalogItemFindUniqueOrThrowArgs>(args: SelectSubset<T, RequestCatalogItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RequestCatalogItemClient<$Result.GetResult<Prisma.$RequestCatalogItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequestCatalogItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCatalogItemFindFirstArgs} args - Arguments to find a RequestCatalogItem
     * @example
     * // Get one RequestCatalogItem
     * const requestCatalogItem = await prisma.requestCatalogItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RequestCatalogItemFindFirstArgs>(args?: SelectSubset<T, RequestCatalogItemFindFirstArgs<ExtArgs>>): Prisma__RequestCatalogItemClient<$Result.GetResult<Prisma.$RequestCatalogItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequestCatalogItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCatalogItemFindFirstOrThrowArgs} args - Arguments to find a RequestCatalogItem
     * @example
     * // Get one RequestCatalogItem
     * const requestCatalogItem = await prisma.requestCatalogItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RequestCatalogItemFindFirstOrThrowArgs>(args?: SelectSubset<T, RequestCatalogItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__RequestCatalogItemClient<$Result.GetResult<Prisma.$RequestCatalogItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RequestCatalogItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCatalogItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestCatalogItems
     * const requestCatalogItems = await prisma.requestCatalogItem.findMany()
     * 
     * // Get first 10 RequestCatalogItems
     * const requestCatalogItems = await prisma.requestCatalogItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestCatalogItemWithIdOnly = await prisma.requestCatalogItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RequestCatalogItemFindManyArgs>(args?: SelectSubset<T, RequestCatalogItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestCatalogItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RequestCatalogItem.
     * @param {RequestCatalogItemCreateArgs} args - Arguments to create a RequestCatalogItem.
     * @example
     * // Create one RequestCatalogItem
     * const RequestCatalogItem = await prisma.requestCatalogItem.create({
     *   data: {
     *     // ... data to create a RequestCatalogItem
     *   }
     * })
     * 
     */
    create<T extends RequestCatalogItemCreateArgs>(args: SelectSubset<T, RequestCatalogItemCreateArgs<ExtArgs>>): Prisma__RequestCatalogItemClient<$Result.GetResult<Prisma.$RequestCatalogItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RequestCatalogItems.
     * @param {RequestCatalogItemCreateManyArgs} args - Arguments to create many RequestCatalogItems.
     * @example
     * // Create many RequestCatalogItems
     * const requestCatalogItem = await prisma.requestCatalogItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RequestCatalogItemCreateManyArgs>(args?: SelectSubset<T, RequestCatalogItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RequestCatalogItems and returns the data saved in the database.
     * @param {RequestCatalogItemCreateManyAndReturnArgs} args - Arguments to create many RequestCatalogItems.
     * @example
     * // Create many RequestCatalogItems
     * const requestCatalogItem = await prisma.requestCatalogItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RequestCatalogItems and only return the `id`
     * const requestCatalogItemWithIdOnly = await prisma.requestCatalogItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RequestCatalogItemCreateManyAndReturnArgs>(args?: SelectSubset<T, RequestCatalogItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestCatalogItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RequestCatalogItem.
     * @param {RequestCatalogItemDeleteArgs} args - Arguments to delete one RequestCatalogItem.
     * @example
     * // Delete one RequestCatalogItem
     * const RequestCatalogItem = await prisma.requestCatalogItem.delete({
     *   where: {
     *     // ... filter to delete one RequestCatalogItem
     *   }
     * })
     * 
     */
    delete<T extends RequestCatalogItemDeleteArgs>(args: SelectSubset<T, RequestCatalogItemDeleteArgs<ExtArgs>>): Prisma__RequestCatalogItemClient<$Result.GetResult<Prisma.$RequestCatalogItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RequestCatalogItem.
     * @param {RequestCatalogItemUpdateArgs} args - Arguments to update one RequestCatalogItem.
     * @example
     * // Update one RequestCatalogItem
     * const requestCatalogItem = await prisma.requestCatalogItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RequestCatalogItemUpdateArgs>(args: SelectSubset<T, RequestCatalogItemUpdateArgs<ExtArgs>>): Prisma__RequestCatalogItemClient<$Result.GetResult<Prisma.$RequestCatalogItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RequestCatalogItems.
     * @param {RequestCatalogItemDeleteManyArgs} args - Arguments to filter RequestCatalogItems to delete.
     * @example
     * // Delete a few RequestCatalogItems
     * const { count } = await prisma.requestCatalogItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RequestCatalogItemDeleteManyArgs>(args?: SelectSubset<T, RequestCatalogItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestCatalogItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCatalogItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestCatalogItems
     * const requestCatalogItem = await prisma.requestCatalogItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RequestCatalogItemUpdateManyArgs>(args: SelectSubset<T, RequestCatalogItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestCatalogItems and returns the data updated in the database.
     * @param {RequestCatalogItemUpdateManyAndReturnArgs} args - Arguments to update many RequestCatalogItems.
     * @example
     * // Update many RequestCatalogItems
     * const requestCatalogItem = await prisma.requestCatalogItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RequestCatalogItems and only return the `id`
     * const requestCatalogItemWithIdOnly = await prisma.requestCatalogItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RequestCatalogItemUpdateManyAndReturnArgs>(args: SelectSubset<T, RequestCatalogItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestCatalogItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RequestCatalogItem.
     * @param {RequestCatalogItemUpsertArgs} args - Arguments to update or create a RequestCatalogItem.
     * @example
     * // Update or create a RequestCatalogItem
     * const requestCatalogItem = await prisma.requestCatalogItem.upsert({
     *   create: {
     *     // ... data to create a RequestCatalogItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestCatalogItem we want to update
     *   }
     * })
     */
    upsert<T extends RequestCatalogItemUpsertArgs>(args: SelectSubset<T, RequestCatalogItemUpsertArgs<ExtArgs>>): Prisma__RequestCatalogItemClient<$Result.GetResult<Prisma.$RequestCatalogItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RequestCatalogItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCatalogItemCountArgs} args - Arguments to filter RequestCatalogItems to count.
     * @example
     * // Count the number of RequestCatalogItems
     * const count = await prisma.requestCatalogItem.count({
     *   where: {
     *     // ... the filter for the RequestCatalogItems we want to count
     *   }
     * })
    **/
    count<T extends RequestCatalogItemCountArgs>(
      args?: Subset<T, RequestCatalogItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestCatalogItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestCatalogItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCatalogItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestCatalogItemAggregateArgs>(args: Subset<T, RequestCatalogItemAggregateArgs>): Prisma.PrismaPromise<GetRequestCatalogItemAggregateType<T>>

    /**
     * Group by RequestCatalogItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCatalogItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestCatalogItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestCatalogItemGroupByArgs['orderBy'] }
        : { orderBy?: RequestCatalogItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestCatalogItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestCatalogItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RequestCatalogItem model
   */
  readonly fields: RequestCatalogItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RequestCatalogItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RequestCatalogItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ritms<T extends RequestCatalogItem$ritmsArgs<ExtArgs> = {}>(args?: Subset<T, RequestCatalogItem$ritmsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RITMPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RequestCatalogItem model
   */
  interface RequestCatalogItemFieldRefs {
    readonly id: FieldRef<"RequestCatalogItem", 'Int'>
    readonly name: FieldRef<"RequestCatalogItem", 'String'>
    readonly formSchema: FieldRef<"RequestCatalogItem", 'Json'>
    readonly workflowId: FieldRef<"RequestCatalogItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RequestCatalogItem findUnique
   */
  export type RequestCatalogItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestCatalogItem
     */
    select?: RequestCatalogItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestCatalogItem
     */
    omit?: RequestCatalogItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestCatalogItemInclude<ExtArgs> | null
    /**
     * Filter, which RequestCatalogItem to fetch.
     */
    where: RequestCatalogItemWhereUniqueInput
  }

  /**
   * RequestCatalogItem findUniqueOrThrow
   */
  export type RequestCatalogItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestCatalogItem
     */
    select?: RequestCatalogItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestCatalogItem
     */
    omit?: RequestCatalogItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestCatalogItemInclude<ExtArgs> | null
    /**
     * Filter, which RequestCatalogItem to fetch.
     */
    where: RequestCatalogItemWhereUniqueInput
  }

  /**
   * RequestCatalogItem findFirst
   */
  export type RequestCatalogItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestCatalogItem
     */
    select?: RequestCatalogItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestCatalogItem
     */
    omit?: RequestCatalogItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestCatalogItemInclude<ExtArgs> | null
    /**
     * Filter, which RequestCatalogItem to fetch.
     */
    where?: RequestCatalogItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestCatalogItems to fetch.
     */
    orderBy?: RequestCatalogItemOrderByWithRelationInput | RequestCatalogItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestCatalogItems.
     */
    cursor?: RequestCatalogItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestCatalogItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestCatalogItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestCatalogItems.
     */
    distinct?: RequestCatalogItemScalarFieldEnum | RequestCatalogItemScalarFieldEnum[]
  }

  /**
   * RequestCatalogItem findFirstOrThrow
   */
  export type RequestCatalogItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestCatalogItem
     */
    select?: RequestCatalogItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestCatalogItem
     */
    omit?: RequestCatalogItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestCatalogItemInclude<ExtArgs> | null
    /**
     * Filter, which RequestCatalogItem to fetch.
     */
    where?: RequestCatalogItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestCatalogItems to fetch.
     */
    orderBy?: RequestCatalogItemOrderByWithRelationInput | RequestCatalogItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestCatalogItems.
     */
    cursor?: RequestCatalogItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestCatalogItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestCatalogItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestCatalogItems.
     */
    distinct?: RequestCatalogItemScalarFieldEnum | RequestCatalogItemScalarFieldEnum[]
  }

  /**
   * RequestCatalogItem findMany
   */
  export type RequestCatalogItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestCatalogItem
     */
    select?: RequestCatalogItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestCatalogItem
     */
    omit?: RequestCatalogItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestCatalogItemInclude<ExtArgs> | null
    /**
     * Filter, which RequestCatalogItems to fetch.
     */
    where?: RequestCatalogItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestCatalogItems to fetch.
     */
    orderBy?: RequestCatalogItemOrderByWithRelationInput | RequestCatalogItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequestCatalogItems.
     */
    cursor?: RequestCatalogItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestCatalogItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestCatalogItems.
     */
    skip?: number
    distinct?: RequestCatalogItemScalarFieldEnum | RequestCatalogItemScalarFieldEnum[]
  }

  /**
   * RequestCatalogItem create
   */
  export type RequestCatalogItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestCatalogItem
     */
    select?: RequestCatalogItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestCatalogItem
     */
    omit?: RequestCatalogItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestCatalogItemInclude<ExtArgs> | null
    /**
     * The data needed to create a RequestCatalogItem.
     */
    data: XOR<RequestCatalogItemCreateInput, RequestCatalogItemUncheckedCreateInput>
  }

  /**
   * RequestCatalogItem createMany
   */
  export type RequestCatalogItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RequestCatalogItems.
     */
    data: RequestCatalogItemCreateManyInput | RequestCatalogItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RequestCatalogItem createManyAndReturn
   */
  export type RequestCatalogItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestCatalogItem
     */
    select?: RequestCatalogItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RequestCatalogItem
     */
    omit?: RequestCatalogItemOmit<ExtArgs> | null
    /**
     * The data used to create many RequestCatalogItems.
     */
    data: RequestCatalogItemCreateManyInput | RequestCatalogItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RequestCatalogItem update
   */
  export type RequestCatalogItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestCatalogItem
     */
    select?: RequestCatalogItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestCatalogItem
     */
    omit?: RequestCatalogItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestCatalogItemInclude<ExtArgs> | null
    /**
     * The data needed to update a RequestCatalogItem.
     */
    data: XOR<RequestCatalogItemUpdateInput, RequestCatalogItemUncheckedUpdateInput>
    /**
     * Choose, which RequestCatalogItem to update.
     */
    where: RequestCatalogItemWhereUniqueInput
  }

  /**
   * RequestCatalogItem updateMany
   */
  export type RequestCatalogItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RequestCatalogItems.
     */
    data: XOR<RequestCatalogItemUpdateManyMutationInput, RequestCatalogItemUncheckedUpdateManyInput>
    /**
     * Filter which RequestCatalogItems to update
     */
    where?: RequestCatalogItemWhereInput
    /**
     * Limit how many RequestCatalogItems to update.
     */
    limit?: number
  }

  /**
   * RequestCatalogItem updateManyAndReturn
   */
  export type RequestCatalogItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestCatalogItem
     */
    select?: RequestCatalogItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RequestCatalogItem
     */
    omit?: RequestCatalogItemOmit<ExtArgs> | null
    /**
     * The data used to update RequestCatalogItems.
     */
    data: XOR<RequestCatalogItemUpdateManyMutationInput, RequestCatalogItemUncheckedUpdateManyInput>
    /**
     * Filter which RequestCatalogItems to update
     */
    where?: RequestCatalogItemWhereInput
    /**
     * Limit how many RequestCatalogItems to update.
     */
    limit?: number
  }

  /**
   * RequestCatalogItem upsert
   */
  export type RequestCatalogItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestCatalogItem
     */
    select?: RequestCatalogItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestCatalogItem
     */
    omit?: RequestCatalogItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestCatalogItemInclude<ExtArgs> | null
    /**
     * The filter to search for the RequestCatalogItem to update in case it exists.
     */
    where: RequestCatalogItemWhereUniqueInput
    /**
     * In case the RequestCatalogItem found by the `where` argument doesn't exist, create a new RequestCatalogItem with this data.
     */
    create: XOR<RequestCatalogItemCreateInput, RequestCatalogItemUncheckedCreateInput>
    /**
     * In case the RequestCatalogItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequestCatalogItemUpdateInput, RequestCatalogItemUncheckedUpdateInput>
  }

  /**
   * RequestCatalogItem delete
   */
  export type RequestCatalogItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestCatalogItem
     */
    select?: RequestCatalogItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestCatalogItem
     */
    omit?: RequestCatalogItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestCatalogItemInclude<ExtArgs> | null
    /**
     * Filter which RequestCatalogItem to delete.
     */
    where: RequestCatalogItemWhereUniqueInput
  }

  /**
   * RequestCatalogItem deleteMany
   */
  export type RequestCatalogItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequestCatalogItems to delete
     */
    where?: RequestCatalogItemWhereInput
    /**
     * Limit how many RequestCatalogItems to delete.
     */
    limit?: number
  }

  /**
   * RequestCatalogItem.ritms
   */
  export type RequestCatalogItem$ritmsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RITM
     */
    select?: RITMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RITM
     */
    omit?: RITMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RITMInclude<ExtArgs> | null
    where?: RITMWhereInput
    orderBy?: RITMOrderByWithRelationInput | RITMOrderByWithRelationInput[]
    cursor?: RITMWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RITMScalarFieldEnum | RITMScalarFieldEnum[]
  }

  /**
   * RequestCatalogItem without action
   */
  export type RequestCatalogItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestCatalogItem
     */
    select?: RequestCatalogItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestCatalogItem
     */
    omit?: RequestCatalogItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestCatalogItemInclude<ExtArgs> | null
  }


  /**
   * Model RITM
   */

  export type AggregateRITM = {
    _count: RITMCountAggregateOutputType | null
    _avg: RITMAvgAggregateOutputType | null
    _sum: RITMSumAggregateOutputType | null
    _min: RITMMinAggregateOutputType | null
    _max: RITMMaxAggregateOutputType | null
  }

  export type RITMAvgAggregateOutputType = {
    id: number | null
    reqId: number | null
    catalogItemId: number | null
  }

  export type RITMSumAggregateOutputType = {
    id: number | null
    reqId: number | null
    catalogItemId: number | null
  }

  export type RITMMinAggregateOutputType = {
    id: number | null
    reqId: number | null
    catalogItemId: number | null
    status: string | null
  }

  export type RITMMaxAggregateOutputType = {
    id: number | null
    reqId: number | null
    catalogItemId: number | null
    status: string | null
  }

  export type RITMCountAggregateOutputType = {
    id: number
    reqId: number
    catalogItemId: number
    status: number
    _all: number
  }


  export type RITMAvgAggregateInputType = {
    id?: true
    reqId?: true
    catalogItemId?: true
  }

  export type RITMSumAggregateInputType = {
    id?: true
    reqId?: true
    catalogItemId?: true
  }

  export type RITMMinAggregateInputType = {
    id?: true
    reqId?: true
    catalogItemId?: true
    status?: true
  }

  export type RITMMaxAggregateInputType = {
    id?: true
    reqId?: true
    catalogItemId?: true
    status?: true
  }

  export type RITMCountAggregateInputType = {
    id?: true
    reqId?: true
    catalogItemId?: true
    status?: true
    _all?: true
  }

  export type RITMAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RITM to aggregate.
     */
    where?: RITMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RITMS to fetch.
     */
    orderBy?: RITMOrderByWithRelationInput | RITMOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RITMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RITMS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RITMS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RITMS
    **/
    _count?: true | RITMCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RITMAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RITMSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RITMMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RITMMaxAggregateInputType
  }

  export type GetRITMAggregateType<T extends RITMAggregateArgs> = {
        [P in keyof T & keyof AggregateRITM]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRITM[P]>
      : GetScalarType<T[P], AggregateRITM[P]>
  }




  export type RITMGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RITMWhereInput
    orderBy?: RITMOrderByWithAggregationInput | RITMOrderByWithAggregationInput[]
    by: RITMScalarFieldEnum[] | RITMScalarFieldEnum
    having?: RITMScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RITMCountAggregateInputType | true
    _avg?: RITMAvgAggregateInputType
    _sum?: RITMSumAggregateInputType
    _min?: RITMMinAggregateInputType
    _max?: RITMMaxAggregateInputType
  }

  export type RITMGroupByOutputType = {
    id: number
    reqId: number
    catalogItemId: number
    status: string
    _count: RITMCountAggregateOutputType | null
    _avg: RITMAvgAggregateOutputType | null
    _sum: RITMSumAggregateOutputType | null
    _min: RITMMinAggregateOutputType | null
    _max: RITMMaxAggregateOutputType | null
  }

  type GetRITMGroupByPayload<T extends RITMGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RITMGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RITMGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RITMGroupByOutputType[P]>
            : GetScalarType<T[P], RITMGroupByOutputType[P]>
        }
      >
    >


  export type RITMSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reqId?: boolean
    catalogItemId?: boolean
    status?: boolean
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
    catalogItem?: boolean | RequestCatalogItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rITM"]>

  export type RITMSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reqId?: boolean
    catalogItemId?: boolean
    status?: boolean
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
    catalogItem?: boolean | RequestCatalogItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rITM"]>

  export type RITMSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reqId?: boolean
    catalogItemId?: boolean
    status?: boolean
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
    catalogItem?: boolean | RequestCatalogItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rITM"]>

  export type RITMSelectScalar = {
    id?: boolean
    reqId?: boolean
    catalogItemId?: boolean
    status?: boolean
  }

  export type RITMOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reqId" | "catalogItemId" | "status", ExtArgs["result"]["rITM"]>
  export type RITMInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
    catalogItem?: boolean | RequestCatalogItemDefaultArgs<ExtArgs>
  }
  export type RITMIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
    catalogItem?: boolean | RequestCatalogItemDefaultArgs<ExtArgs>
  }
  export type RITMIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
    catalogItem?: boolean | RequestCatalogItemDefaultArgs<ExtArgs>
  }

  export type $RITMPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RITM"
    objects: {
      ticket: Prisma.$SupportTicketPayload<ExtArgs>
      catalogItem: Prisma.$RequestCatalogItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      reqId: number
      catalogItemId: number
      status: string
    }, ExtArgs["result"]["rITM"]>
    composites: {}
  }

  type RITMGetPayload<S extends boolean | null | undefined | RITMDefaultArgs> = $Result.GetResult<Prisma.$RITMPayload, S>

  type RITMCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RITMFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RITMCountAggregateInputType | true
    }

  export interface RITMDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RITM'], meta: { name: 'RITM' } }
    /**
     * Find zero or one RITM that matches the filter.
     * @param {RITMFindUniqueArgs} args - Arguments to find a RITM
     * @example
     * // Get one RITM
     * const rITM = await prisma.rITM.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RITMFindUniqueArgs>(args: SelectSubset<T, RITMFindUniqueArgs<ExtArgs>>): Prisma__RITMClient<$Result.GetResult<Prisma.$RITMPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RITM that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RITMFindUniqueOrThrowArgs} args - Arguments to find a RITM
     * @example
     * // Get one RITM
     * const rITM = await prisma.rITM.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RITMFindUniqueOrThrowArgs>(args: SelectSubset<T, RITMFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RITMClient<$Result.GetResult<Prisma.$RITMPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RITM that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RITMFindFirstArgs} args - Arguments to find a RITM
     * @example
     * // Get one RITM
     * const rITM = await prisma.rITM.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RITMFindFirstArgs>(args?: SelectSubset<T, RITMFindFirstArgs<ExtArgs>>): Prisma__RITMClient<$Result.GetResult<Prisma.$RITMPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RITM that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RITMFindFirstOrThrowArgs} args - Arguments to find a RITM
     * @example
     * // Get one RITM
     * const rITM = await prisma.rITM.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RITMFindFirstOrThrowArgs>(args?: SelectSubset<T, RITMFindFirstOrThrowArgs<ExtArgs>>): Prisma__RITMClient<$Result.GetResult<Prisma.$RITMPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RITMS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RITMFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RITMS
     * const rITMS = await prisma.rITM.findMany()
     * 
     * // Get first 10 RITMS
     * const rITMS = await prisma.rITM.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rITMWithIdOnly = await prisma.rITM.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RITMFindManyArgs>(args?: SelectSubset<T, RITMFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RITMPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RITM.
     * @param {RITMCreateArgs} args - Arguments to create a RITM.
     * @example
     * // Create one RITM
     * const RITM = await prisma.rITM.create({
     *   data: {
     *     // ... data to create a RITM
     *   }
     * })
     * 
     */
    create<T extends RITMCreateArgs>(args: SelectSubset<T, RITMCreateArgs<ExtArgs>>): Prisma__RITMClient<$Result.GetResult<Prisma.$RITMPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RITMS.
     * @param {RITMCreateManyArgs} args - Arguments to create many RITMS.
     * @example
     * // Create many RITMS
     * const rITM = await prisma.rITM.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RITMCreateManyArgs>(args?: SelectSubset<T, RITMCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RITMS and returns the data saved in the database.
     * @param {RITMCreateManyAndReturnArgs} args - Arguments to create many RITMS.
     * @example
     * // Create many RITMS
     * const rITM = await prisma.rITM.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RITMS and only return the `id`
     * const rITMWithIdOnly = await prisma.rITM.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RITMCreateManyAndReturnArgs>(args?: SelectSubset<T, RITMCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RITMPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RITM.
     * @param {RITMDeleteArgs} args - Arguments to delete one RITM.
     * @example
     * // Delete one RITM
     * const RITM = await prisma.rITM.delete({
     *   where: {
     *     // ... filter to delete one RITM
     *   }
     * })
     * 
     */
    delete<T extends RITMDeleteArgs>(args: SelectSubset<T, RITMDeleteArgs<ExtArgs>>): Prisma__RITMClient<$Result.GetResult<Prisma.$RITMPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RITM.
     * @param {RITMUpdateArgs} args - Arguments to update one RITM.
     * @example
     * // Update one RITM
     * const rITM = await prisma.rITM.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RITMUpdateArgs>(args: SelectSubset<T, RITMUpdateArgs<ExtArgs>>): Prisma__RITMClient<$Result.GetResult<Prisma.$RITMPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RITMS.
     * @param {RITMDeleteManyArgs} args - Arguments to filter RITMS to delete.
     * @example
     * // Delete a few RITMS
     * const { count } = await prisma.rITM.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RITMDeleteManyArgs>(args?: SelectSubset<T, RITMDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RITMS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RITMUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RITMS
     * const rITM = await prisma.rITM.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RITMUpdateManyArgs>(args: SelectSubset<T, RITMUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RITMS and returns the data updated in the database.
     * @param {RITMUpdateManyAndReturnArgs} args - Arguments to update many RITMS.
     * @example
     * // Update many RITMS
     * const rITM = await prisma.rITM.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RITMS and only return the `id`
     * const rITMWithIdOnly = await prisma.rITM.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RITMUpdateManyAndReturnArgs>(args: SelectSubset<T, RITMUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RITMPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RITM.
     * @param {RITMUpsertArgs} args - Arguments to update or create a RITM.
     * @example
     * // Update or create a RITM
     * const rITM = await prisma.rITM.upsert({
     *   create: {
     *     // ... data to create a RITM
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RITM we want to update
     *   }
     * })
     */
    upsert<T extends RITMUpsertArgs>(args: SelectSubset<T, RITMUpsertArgs<ExtArgs>>): Prisma__RITMClient<$Result.GetResult<Prisma.$RITMPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RITMS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RITMCountArgs} args - Arguments to filter RITMS to count.
     * @example
     * // Count the number of RITMS
     * const count = await prisma.rITM.count({
     *   where: {
     *     // ... the filter for the RITMS we want to count
     *   }
     * })
    **/
    count<T extends RITMCountArgs>(
      args?: Subset<T, RITMCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RITMCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RITM.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RITMAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RITMAggregateArgs>(args: Subset<T, RITMAggregateArgs>): Prisma.PrismaPromise<GetRITMAggregateType<T>>

    /**
     * Group by RITM.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RITMGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RITMGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RITMGroupByArgs['orderBy'] }
        : { orderBy?: RITMGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RITMGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRITMGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RITM model
   */
  readonly fields: RITMFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RITM.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RITMClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ticket<T extends SupportTicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicketDefaultArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    catalogItem<T extends RequestCatalogItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RequestCatalogItemDefaultArgs<ExtArgs>>): Prisma__RequestCatalogItemClient<$Result.GetResult<Prisma.$RequestCatalogItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RITM model
   */
  interface RITMFieldRefs {
    readonly id: FieldRef<"RITM", 'Int'>
    readonly reqId: FieldRef<"RITM", 'Int'>
    readonly catalogItemId: FieldRef<"RITM", 'Int'>
    readonly status: FieldRef<"RITM", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RITM findUnique
   */
  export type RITMFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RITM
     */
    select?: RITMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RITM
     */
    omit?: RITMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RITMInclude<ExtArgs> | null
    /**
     * Filter, which RITM to fetch.
     */
    where: RITMWhereUniqueInput
  }

  /**
   * RITM findUniqueOrThrow
   */
  export type RITMFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RITM
     */
    select?: RITMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RITM
     */
    omit?: RITMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RITMInclude<ExtArgs> | null
    /**
     * Filter, which RITM to fetch.
     */
    where: RITMWhereUniqueInput
  }

  /**
   * RITM findFirst
   */
  export type RITMFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RITM
     */
    select?: RITMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RITM
     */
    omit?: RITMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RITMInclude<ExtArgs> | null
    /**
     * Filter, which RITM to fetch.
     */
    where?: RITMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RITMS to fetch.
     */
    orderBy?: RITMOrderByWithRelationInput | RITMOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RITMS.
     */
    cursor?: RITMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RITMS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RITMS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RITMS.
     */
    distinct?: RITMScalarFieldEnum | RITMScalarFieldEnum[]
  }

  /**
   * RITM findFirstOrThrow
   */
  export type RITMFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RITM
     */
    select?: RITMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RITM
     */
    omit?: RITMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RITMInclude<ExtArgs> | null
    /**
     * Filter, which RITM to fetch.
     */
    where?: RITMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RITMS to fetch.
     */
    orderBy?: RITMOrderByWithRelationInput | RITMOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RITMS.
     */
    cursor?: RITMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RITMS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RITMS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RITMS.
     */
    distinct?: RITMScalarFieldEnum | RITMScalarFieldEnum[]
  }

  /**
   * RITM findMany
   */
  export type RITMFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RITM
     */
    select?: RITMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RITM
     */
    omit?: RITMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RITMInclude<ExtArgs> | null
    /**
     * Filter, which RITMS to fetch.
     */
    where?: RITMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RITMS to fetch.
     */
    orderBy?: RITMOrderByWithRelationInput | RITMOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RITMS.
     */
    cursor?: RITMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RITMS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RITMS.
     */
    skip?: number
    distinct?: RITMScalarFieldEnum | RITMScalarFieldEnum[]
  }

  /**
   * RITM create
   */
  export type RITMCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RITM
     */
    select?: RITMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RITM
     */
    omit?: RITMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RITMInclude<ExtArgs> | null
    /**
     * The data needed to create a RITM.
     */
    data: XOR<RITMCreateInput, RITMUncheckedCreateInput>
  }

  /**
   * RITM createMany
   */
  export type RITMCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RITMS.
     */
    data: RITMCreateManyInput | RITMCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RITM createManyAndReturn
   */
  export type RITMCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RITM
     */
    select?: RITMSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RITM
     */
    omit?: RITMOmit<ExtArgs> | null
    /**
     * The data used to create many RITMS.
     */
    data: RITMCreateManyInput | RITMCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RITMIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RITM update
   */
  export type RITMUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RITM
     */
    select?: RITMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RITM
     */
    omit?: RITMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RITMInclude<ExtArgs> | null
    /**
     * The data needed to update a RITM.
     */
    data: XOR<RITMUpdateInput, RITMUncheckedUpdateInput>
    /**
     * Choose, which RITM to update.
     */
    where: RITMWhereUniqueInput
  }

  /**
   * RITM updateMany
   */
  export type RITMUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RITMS.
     */
    data: XOR<RITMUpdateManyMutationInput, RITMUncheckedUpdateManyInput>
    /**
     * Filter which RITMS to update
     */
    where?: RITMWhereInput
    /**
     * Limit how many RITMS to update.
     */
    limit?: number
  }

  /**
   * RITM updateManyAndReturn
   */
  export type RITMUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RITM
     */
    select?: RITMSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RITM
     */
    omit?: RITMOmit<ExtArgs> | null
    /**
     * The data used to update RITMS.
     */
    data: XOR<RITMUpdateManyMutationInput, RITMUncheckedUpdateManyInput>
    /**
     * Filter which RITMS to update
     */
    where?: RITMWhereInput
    /**
     * Limit how many RITMS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RITMIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RITM upsert
   */
  export type RITMUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RITM
     */
    select?: RITMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RITM
     */
    omit?: RITMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RITMInclude<ExtArgs> | null
    /**
     * The filter to search for the RITM to update in case it exists.
     */
    where: RITMWhereUniqueInput
    /**
     * In case the RITM found by the `where` argument doesn't exist, create a new RITM with this data.
     */
    create: XOR<RITMCreateInput, RITMUncheckedCreateInput>
    /**
     * In case the RITM was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RITMUpdateInput, RITMUncheckedUpdateInput>
  }

  /**
   * RITM delete
   */
  export type RITMDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RITM
     */
    select?: RITMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RITM
     */
    omit?: RITMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RITMInclude<ExtArgs> | null
    /**
     * Filter which RITM to delete.
     */
    where: RITMWhereUniqueInput
  }

  /**
   * RITM deleteMany
   */
  export type RITMDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RITMS to delete
     */
    where?: RITMWhereInput
    /**
     * Limit how many RITMS to delete.
     */
    limit?: number
  }

  /**
   * RITM without action
   */
  export type RITMDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RITM
     */
    select?: RITMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RITM
     */
    omit?: RITMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RITMInclude<ExtArgs> | null
  }


  /**
   * Model VipProxy
   */

  export type AggregateVipProxy = {
    _count: VipProxyCountAggregateOutputType | null
    _avg: VipProxyAvgAggregateOutputType | null
    _sum: VipProxySumAggregateOutputType | null
    _min: VipProxyMinAggregateOutputType | null
    _max: VipProxyMaxAggregateOutputType | null
  }

  export type VipProxyAvgAggregateOutputType = {
    id: number | null
  }

  export type VipProxySumAggregateOutputType = {
    id: number | null
  }

  export type VipProxyMinAggregateOutputType = {
    id: number | null
    vipId: string | null
    proxyId: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type VipProxyMaxAggregateOutputType = {
    id: number | null
    vipId: string | null
    proxyId: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type VipProxyCountAggregateOutputType = {
    id: number
    vipId: number
    proxyId: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type VipProxyAvgAggregateInputType = {
    id?: true
  }

  export type VipProxySumAggregateInputType = {
    id?: true
  }

  export type VipProxyMinAggregateInputType = {
    id?: true
    vipId?: true
    proxyId?: true
    createdAt?: true
    expiresAt?: true
  }

  export type VipProxyMaxAggregateInputType = {
    id?: true
    vipId?: true
    proxyId?: true
    createdAt?: true
    expiresAt?: true
  }

  export type VipProxyCountAggregateInputType = {
    id?: true
    vipId?: true
    proxyId?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type VipProxyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VipProxy to aggregate.
     */
    where?: VipProxyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VipProxies to fetch.
     */
    orderBy?: VipProxyOrderByWithRelationInput | VipProxyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VipProxyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VipProxies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VipProxies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VipProxies
    **/
    _count?: true | VipProxyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VipProxyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VipProxySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VipProxyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VipProxyMaxAggregateInputType
  }

  export type GetVipProxyAggregateType<T extends VipProxyAggregateArgs> = {
        [P in keyof T & keyof AggregateVipProxy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVipProxy[P]>
      : GetScalarType<T[P], AggregateVipProxy[P]>
  }




  export type VipProxyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VipProxyWhereInput
    orderBy?: VipProxyOrderByWithAggregationInput | VipProxyOrderByWithAggregationInput[]
    by: VipProxyScalarFieldEnum[] | VipProxyScalarFieldEnum
    having?: VipProxyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VipProxyCountAggregateInputType | true
    _avg?: VipProxyAvgAggregateInputType
    _sum?: VipProxySumAggregateInputType
    _min?: VipProxyMinAggregateInputType
    _max?: VipProxyMaxAggregateInputType
  }

  export type VipProxyGroupByOutputType = {
    id: number
    vipId: string
    proxyId: string
    createdAt: Date
    expiresAt: Date | null
    _count: VipProxyCountAggregateOutputType | null
    _avg: VipProxyAvgAggregateOutputType | null
    _sum: VipProxySumAggregateOutputType | null
    _min: VipProxyMinAggregateOutputType | null
    _max: VipProxyMaxAggregateOutputType | null
  }

  type GetVipProxyGroupByPayload<T extends VipProxyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VipProxyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VipProxyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VipProxyGroupByOutputType[P]>
            : GetScalarType<T[P], VipProxyGroupByOutputType[P]>
        }
      >
    >


  export type VipProxySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vipId?: boolean
    proxyId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    vip?: boolean | UserDefaultArgs<ExtArgs>
    proxy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vipProxy"]>

  export type VipProxySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vipId?: boolean
    proxyId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    vip?: boolean | UserDefaultArgs<ExtArgs>
    proxy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vipProxy"]>

  export type VipProxySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vipId?: boolean
    proxyId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    vip?: boolean | UserDefaultArgs<ExtArgs>
    proxy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vipProxy"]>

  export type VipProxySelectScalar = {
    id?: boolean
    vipId?: boolean
    proxyId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type VipProxyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vipId" | "proxyId" | "createdAt" | "expiresAt", ExtArgs["result"]["vipProxy"]>
  export type VipProxyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vip?: boolean | UserDefaultArgs<ExtArgs>
    proxy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VipProxyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vip?: boolean | UserDefaultArgs<ExtArgs>
    proxy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VipProxyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vip?: boolean | UserDefaultArgs<ExtArgs>
    proxy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VipProxyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VipProxy"
    objects: {
      vip: Prisma.$UserPayload<ExtArgs>
      proxy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      vipId: string
      proxyId: string
      createdAt: Date
      expiresAt: Date | null
    }, ExtArgs["result"]["vipProxy"]>
    composites: {}
  }

  type VipProxyGetPayload<S extends boolean | null | undefined | VipProxyDefaultArgs> = $Result.GetResult<Prisma.$VipProxyPayload, S>

  type VipProxyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VipProxyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VipProxyCountAggregateInputType | true
    }

  export interface VipProxyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VipProxy'], meta: { name: 'VipProxy' } }
    /**
     * Find zero or one VipProxy that matches the filter.
     * @param {VipProxyFindUniqueArgs} args - Arguments to find a VipProxy
     * @example
     * // Get one VipProxy
     * const vipProxy = await prisma.vipProxy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VipProxyFindUniqueArgs>(args: SelectSubset<T, VipProxyFindUniqueArgs<ExtArgs>>): Prisma__VipProxyClient<$Result.GetResult<Prisma.$VipProxyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VipProxy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VipProxyFindUniqueOrThrowArgs} args - Arguments to find a VipProxy
     * @example
     * // Get one VipProxy
     * const vipProxy = await prisma.vipProxy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VipProxyFindUniqueOrThrowArgs>(args: SelectSubset<T, VipProxyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VipProxyClient<$Result.GetResult<Prisma.$VipProxyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VipProxy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipProxyFindFirstArgs} args - Arguments to find a VipProxy
     * @example
     * // Get one VipProxy
     * const vipProxy = await prisma.vipProxy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VipProxyFindFirstArgs>(args?: SelectSubset<T, VipProxyFindFirstArgs<ExtArgs>>): Prisma__VipProxyClient<$Result.GetResult<Prisma.$VipProxyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VipProxy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipProxyFindFirstOrThrowArgs} args - Arguments to find a VipProxy
     * @example
     * // Get one VipProxy
     * const vipProxy = await prisma.vipProxy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VipProxyFindFirstOrThrowArgs>(args?: SelectSubset<T, VipProxyFindFirstOrThrowArgs<ExtArgs>>): Prisma__VipProxyClient<$Result.GetResult<Prisma.$VipProxyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VipProxies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipProxyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VipProxies
     * const vipProxies = await prisma.vipProxy.findMany()
     * 
     * // Get first 10 VipProxies
     * const vipProxies = await prisma.vipProxy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vipProxyWithIdOnly = await prisma.vipProxy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VipProxyFindManyArgs>(args?: SelectSubset<T, VipProxyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VipProxyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VipProxy.
     * @param {VipProxyCreateArgs} args - Arguments to create a VipProxy.
     * @example
     * // Create one VipProxy
     * const VipProxy = await prisma.vipProxy.create({
     *   data: {
     *     // ... data to create a VipProxy
     *   }
     * })
     * 
     */
    create<T extends VipProxyCreateArgs>(args: SelectSubset<T, VipProxyCreateArgs<ExtArgs>>): Prisma__VipProxyClient<$Result.GetResult<Prisma.$VipProxyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VipProxies.
     * @param {VipProxyCreateManyArgs} args - Arguments to create many VipProxies.
     * @example
     * // Create many VipProxies
     * const vipProxy = await prisma.vipProxy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VipProxyCreateManyArgs>(args?: SelectSubset<T, VipProxyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VipProxies and returns the data saved in the database.
     * @param {VipProxyCreateManyAndReturnArgs} args - Arguments to create many VipProxies.
     * @example
     * // Create many VipProxies
     * const vipProxy = await prisma.vipProxy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VipProxies and only return the `id`
     * const vipProxyWithIdOnly = await prisma.vipProxy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VipProxyCreateManyAndReturnArgs>(args?: SelectSubset<T, VipProxyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VipProxyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VipProxy.
     * @param {VipProxyDeleteArgs} args - Arguments to delete one VipProxy.
     * @example
     * // Delete one VipProxy
     * const VipProxy = await prisma.vipProxy.delete({
     *   where: {
     *     // ... filter to delete one VipProxy
     *   }
     * })
     * 
     */
    delete<T extends VipProxyDeleteArgs>(args: SelectSubset<T, VipProxyDeleteArgs<ExtArgs>>): Prisma__VipProxyClient<$Result.GetResult<Prisma.$VipProxyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VipProxy.
     * @param {VipProxyUpdateArgs} args - Arguments to update one VipProxy.
     * @example
     * // Update one VipProxy
     * const vipProxy = await prisma.vipProxy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VipProxyUpdateArgs>(args: SelectSubset<T, VipProxyUpdateArgs<ExtArgs>>): Prisma__VipProxyClient<$Result.GetResult<Prisma.$VipProxyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VipProxies.
     * @param {VipProxyDeleteManyArgs} args - Arguments to filter VipProxies to delete.
     * @example
     * // Delete a few VipProxies
     * const { count } = await prisma.vipProxy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VipProxyDeleteManyArgs>(args?: SelectSubset<T, VipProxyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VipProxies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipProxyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VipProxies
     * const vipProxy = await prisma.vipProxy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VipProxyUpdateManyArgs>(args: SelectSubset<T, VipProxyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VipProxies and returns the data updated in the database.
     * @param {VipProxyUpdateManyAndReturnArgs} args - Arguments to update many VipProxies.
     * @example
     * // Update many VipProxies
     * const vipProxy = await prisma.vipProxy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VipProxies and only return the `id`
     * const vipProxyWithIdOnly = await prisma.vipProxy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VipProxyUpdateManyAndReturnArgs>(args: SelectSubset<T, VipProxyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VipProxyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VipProxy.
     * @param {VipProxyUpsertArgs} args - Arguments to update or create a VipProxy.
     * @example
     * // Update or create a VipProxy
     * const vipProxy = await prisma.vipProxy.upsert({
     *   create: {
     *     // ... data to create a VipProxy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VipProxy we want to update
     *   }
     * })
     */
    upsert<T extends VipProxyUpsertArgs>(args: SelectSubset<T, VipProxyUpsertArgs<ExtArgs>>): Prisma__VipProxyClient<$Result.GetResult<Prisma.$VipProxyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VipProxies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipProxyCountArgs} args - Arguments to filter VipProxies to count.
     * @example
     * // Count the number of VipProxies
     * const count = await prisma.vipProxy.count({
     *   where: {
     *     // ... the filter for the VipProxies we want to count
     *   }
     * })
    **/
    count<T extends VipProxyCountArgs>(
      args?: Subset<T, VipProxyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VipProxyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VipProxy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipProxyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VipProxyAggregateArgs>(args: Subset<T, VipProxyAggregateArgs>): Prisma.PrismaPromise<GetVipProxyAggregateType<T>>

    /**
     * Group by VipProxy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipProxyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VipProxyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VipProxyGroupByArgs['orderBy'] }
        : { orderBy?: VipProxyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VipProxyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVipProxyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VipProxy model
   */
  readonly fields: VipProxyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VipProxy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VipProxyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vip<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    proxy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VipProxy model
   */
  interface VipProxyFieldRefs {
    readonly id: FieldRef<"VipProxy", 'Int'>
    readonly vipId: FieldRef<"VipProxy", 'String'>
    readonly proxyId: FieldRef<"VipProxy", 'String'>
    readonly createdAt: FieldRef<"VipProxy", 'DateTime'>
    readonly expiresAt: FieldRef<"VipProxy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VipProxy findUnique
   */
  export type VipProxyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipProxy
     */
    select?: VipProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipProxy
     */
    omit?: VipProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipProxyInclude<ExtArgs> | null
    /**
     * Filter, which VipProxy to fetch.
     */
    where: VipProxyWhereUniqueInput
  }

  /**
   * VipProxy findUniqueOrThrow
   */
  export type VipProxyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipProxy
     */
    select?: VipProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipProxy
     */
    omit?: VipProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipProxyInclude<ExtArgs> | null
    /**
     * Filter, which VipProxy to fetch.
     */
    where: VipProxyWhereUniqueInput
  }

  /**
   * VipProxy findFirst
   */
  export type VipProxyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipProxy
     */
    select?: VipProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipProxy
     */
    omit?: VipProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipProxyInclude<ExtArgs> | null
    /**
     * Filter, which VipProxy to fetch.
     */
    where?: VipProxyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VipProxies to fetch.
     */
    orderBy?: VipProxyOrderByWithRelationInput | VipProxyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VipProxies.
     */
    cursor?: VipProxyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VipProxies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VipProxies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VipProxies.
     */
    distinct?: VipProxyScalarFieldEnum | VipProxyScalarFieldEnum[]
  }

  /**
   * VipProxy findFirstOrThrow
   */
  export type VipProxyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipProxy
     */
    select?: VipProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipProxy
     */
    omit?: VipProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipProxyInclude<ExtArgs> | null
    /**
     * Filter, which VipProxy to fetch.
     */
    where?: VipProxyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VipProxies to fetch.
     */
    orderBy?: VipProxyOrderByWithRelationInput | VipProxyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VipProxies.
     */
    cursor?: VipProxyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VipProxies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VipProxies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VipProxies.
     */
    distinct?: VipProxyScalarFieldEnum | VipProxyScalarFieldEnum[]
  }

  /**
   * VipProxy findMany
   */
  export type VipProxyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipProxy
     */
    select?: VipProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipProxy
     */
    omit?: VipProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipProxyInclude<ExtArgs> | null
    /**
     * Filter, which VipProxies to fetch.
     */
    where?: VipProxyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VipProxies to fetch.
     */
    orderBy?: VipProxyOrderByWithRelationInput | VipProxyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VipProxies.
     */
    cursor?: VipProxyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VipProxies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VipProxies.
     */
    skip?: number
    distinct?: VipProxyScalarFieldEnum | VipProxyScalarFieldEnum[]
  }

  /**
   * VipProxy create
   */
  export type VipProxyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipProxy
     */
    select?: VipProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipProxy
     */
    omit?: VipProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipProxyInclude<ExtArgs> | null
    /**
     * The data needed to create a VipProxy.
     */
    data: XOR<VipProxyCreateInput, VipProxyUncheckedCreateInput>
  }

  /**
   * VipProxy createMany
   */
  export type VipProxyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VipProxies.
     */
    data: VipProxyCreateManyInput | VipProxyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VipProxy createManyAndReturn
   */
  export type VipProxyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipProxy
     */
    select?: VipProxySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VipProxy
     */
    omit?: VipProxyOmit<ExtArgs> | null
    /**
     * The data used to create many VipProxies.
     */
    data: VipProxyCreateManyInput | VipProxyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipProxyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VipProxy update
   */
  export type VipProxyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipProxy
     */
    select?: VipProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipProxy
     */
    omit?: VipProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipProxyInclude<ExtArgs> | null
    /**
     * The data needed to update a VipProxy.
     */
    data: XOR<VipProxyUpdateInput, VipProxyUncheckedUpdateInput>
    /**
     * Choose, which VipProxy to update.
     */
    where: VipProxyWhereUniqueInput
  }

  /**
   * VipProxy updateMany
   */
  export type VipProxyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VipProxies.
     */
    data: XOR<VipProxyUpdateManyMutationInput, VipProxyUncheckedUpdateManyInput>
    /**
     * Filter which VipProxies to update
     */
    where?: VipProxyWhereInput
    /**
     * Limit how many VipProxies to update.
     */
    limit?: number
  }

  /**
   * VipProxy updateManyAndReturn
   */
  export type VipProxyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipProxy
     */
    select?: VipProxySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VipProxy
     */
    omit?: VipProxyOmit<ExtArgs> | null
    /**
     * The data used to update VipProxies.
     */
    data: XOR<VipProxyUpdateManyMutationInput, VipProxyUncheckedUpdateManyInput>
    /**
     * Filter which VipProxies to update
     */
    where?: VipProxyWhereInput
    /**
     * Limit how many VipProxies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipProxyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VipProxy upsert
   */
  export type VipProxyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipProxy
     */
    select?: VipProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipProxy
     */
    omit?: VipProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipProxyInclude<ExtArgs> | null
    /**
     * The filter to search for the VipProxy to update in case it exists.
     */
    where: VipProxyWhereUniqueInput
    /**
     * In case the VipProxy found by the `where` argument doesn't exist, create a new VipProxy with this data.
     */
    create: XOR<VipProxyCreateInput, VipProxyUncheckedCreateInput>
    /**
     * In case the VipProxy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VipProxyUpdateInput, VipProxyUncheckedUpdateInput>
  }

  /**
   * VipProxy delete
   */
  export type VipProxyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipProxy
     */
    select?: VipProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipProxy
     */
    omit?: VipProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipProxyInclude<ExtArgs> | null
    /**
     * Filter which VipProxy to delete.
     */
    where: VipProxyWhereUniqueInput
  }

  /**
   * VipProxy deleteMany
   */
  export type VipProxyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VipProxies to delete
     */
    where?: VipProxyWhereInput
    /**
     * Limit how many VipProxies to delete.
     */
    limit?: number
  }

  /**
   * VipProxy without action
   */
  export type VipProxyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipProxy
     */
    select?: VipProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipProxy
     */
    omit?: VipProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipProxyInclude<ExtArgs> | null
  }


  /**
   * Model VipSlaHistory
   */

  export type AggregateVipSlaHistory = {
    _count: VipSlaHistoryCountAggregateOutputType | null
    _avg: VipSlaHistoryAvgAggregateOutputType | null
    _sum: VipSlaHistorySumAggregateOutputType | null
    _min: VipSlaHistoryMinAggregateOutputType | null
    _max: VipSlaHistoryMaxAggregateOutputType | null
  }

  export type VipSlaHistoryAvgAggregateOutputType = {
    id: number | null
  }

  export type VipSlaHistorySumAggregateOutputType = {
    id: number | null
  }

  export type VipSlaHistoryMinAggregateOutputType = {
    id: number | null
    userId: string | null
    effectiveAt: Date | null
    endedAt: Date | null
  }

  export type VipSlaHistoryMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    effectiveAt: Date | null
    endedAt: Date | null
  }

  export type VipSlaHistoryCountAggregateOutputType = {
    id: number
    userId: number
    sla: number
    effectiveAt: number
    endedAt: number
    _all: number
  }


  export type VipSlaHistoryAvgAggregateInputType = {
    id?: true
  }

  export type VipSlaHistorySumAggregateInputType = {
    id?: true
  }

  export type VipSlaHistoryMinAggregateInputType = {
    id?: true
    userId?: true
    effectiveAt?: true
    endedAt?: true
  }

  export type VipSlaHistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    effectiveAt?: true
    endedAt?: true
  }

  export type VipSlaHistoryCountAggregateInputType = {
    id?: true
    userId?: true
    sla?: true
    effectiveAt?: true
    endedAt?: true
    _all?: true
  }

  export type VipSlaHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VipSlaHistory to aggregate.
     */
    where?: VipSlaHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VipSlaHistories to fetch.
     */
    orderBy?: VipSlaHistoryOrderByWithRelationInput | VipSlaHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VipSlaHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VipSlaHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VipSlaHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VipSlaHistories
    **/
    _count?: true | VipSlaHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VipSlaHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VipSlaHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VipSlaHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VipSlaHistoryMaxAggregateInputType
  }

  export type GetVipSlaHistoryAggregateType<T extends VipSlaHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateVipSlaHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVipSlaHistory[P]>
      : GetScalarType<T[P], AggregateVipSlaHistory[P]>
  }




  export type VipSlaHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VipSlaHistoryWhereInput
    orderBy?: VipSlaHistoryOrderByWithAggregationInput | VipSlaHistoryOrderByWithAggregationInput[]
    by: VipSlaHistoryScalarFieldEnum[] | VipSlaHistoryScalarFieldEnum
    having?: VipSlaHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VipSlaHistoryCountAggregateInputType | true
    _avg?: VipSlaHistoryAvgAggregateInputType
    _sum?: VipSlaHistorySumAggregateInputType
    _min?: VipSlaHistoryMinAggregateInputType
    _max?: VipSlaHistoryMaxAggregateInputType
  }

  export type VipSlaHistoryGroupByOutputType = {
    id: number
    userId: string
    sla: JsonValue
    effectiveAt: Date
    endedAt: Date | null
    _count: VipSlaHistoryCountAggregateOutputType | null
    _avg: VipSlaHistoryAvgAggregateOutputType | null
    _sum: VipSlaHistorySumAggregateOutputType | null
    _min: VipSlaHistoryMinAggregateOutputType | null
    _max: VipSlaHistoryMaxAggregateOutputType | null
  }

  type GetVipSlaHistoryGroupByPayload<T extends VipSlaHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VipSlaHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VipSlaHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VipSlaHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], VipSlaHistoryGroupByOutputType[P]>
        }
      >
    >


  export type VipSlaHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sla?: boolean
    effectiveAt?: boolean
    endedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vipSlaHistory"]>

  export type VipSlaHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sla?: boolean
    effectiveAt?: boolean
    endedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vipSlaHistory"]>

  export type VipSlaHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sla?: boolean
    effectiveAt?: boolean
    endedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vipSlaHistory"]>

  export type VipSlaHistorySelectScalar = {
    id?: boolean
    userId?: boolean
    sla?: boolean
    effectiveAt?: boolean
    endedAt?: boolean
  }

  export type VipSlaHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "sla" | "effectiveAt" | "endedAt", ExtArgs["result"]["vipSlaHistory"]>
  export type VipSlaHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VipSlaHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VipSlaHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VipSlaHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VipSlaHistory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      sla: Prisma.JsonValue
      effectiveAt: Date
      endedAt: Date | null
    }, ExtArgs["result"]["vipSlaHistory"]>
    composites: {}
  }

  type VipSlaHistoryGetPayload<S extends boolean | null | undefined | VipSlaHistoryDefaultArgs> = $Result.GetResult<Prisma.$VipSlaHistoryPayload, S>

  type VipSlaHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VipSlaHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VipSlaHistoryCountAggregateInputType | true
    }

  export interface VipSlaHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VipSlaHistory'], meta: { name: 'VipSlaHistory' } }
    /**
     * Find zero or one VipSlaHistory that matches the filter.
     * @param {VipSlaHistoryFindUniqueArgs} args - Arguments to find a VipSlaHistory
     * @example
     * // Get one VipSlaHistory
     * const vipSlaHistory = await prisma.vipSlaHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VipSlaHistoryFindUniqueArgs>(args: SelectSubset<T, VipSlaHistoryFindUniqueArgs<ExtArgs>>): Prisma__VipSlaHistoryClient<$Result.GetResult<Prisma.$VipSlaHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VipSlaHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VipSlaHistoryFindUniqueOrThrowArgs} args - Arguments to find a VipSlaHistory
     * @example
     * // Get one VipSlaHistory
     * const vipSlaHistory = await prisma.vipSlaHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VipSlaHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, VipSlaHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VipSlaHistoryClient<$Result.GetResult<Prisma.$VipSlaHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VipSlaHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipSlaHistoryFindFirstArgs} args - Arguments to find a VipSlaHistory
     * @example
     * // Get one VipSlaHistory
     * const vipSlaHistory = await prisma.vipSlaHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VipSlaHistoryFindFirstArgs>(args?: SelectSubset<T, VipSlaHistoryFindFirstArgs<ExtArgs>>): Prisma__VipSlaHistoryClient<$Result.GetResult<Prisma.$VipSlaHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VipSlaHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipSlaHistoryFindFirstOrThrowArgs} args - Arguments to find a VipSlaHistory
     * @example
     * // Get one VipSlaHistory
     * const vipSlaHistory = await prisma.vipSlaHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VipSlaHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, VipSlaHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__VipSlaHistoryClient<$Result.GetResult<Prisma.$VipSlaHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VipSlaHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipSlaHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VipSlaHistories
     * const vipSlaHistories = await prisma.vipSlaHistory.findMany()
     * 
     * // Get first 10 VipSlaHistories
     * const vipSlaHistories = await prisma.vipSlaHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vipSlaHistoryWithIdOnly = await prisma.vipSlaHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VipSlaHistoryFindManyArgs>(args?: SelectSubset<T, VipSlaHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VipSlaHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VipSlaHistory.
     * @param {VipSlaHistoryCreateArgs} args - Arguments to create a VipSlaHistory.
     * @example
     * // Create one VipSlaHistory
     * const VipSlaHistory = await prisma.vipSlaHistory.create({
     *   data: {
     *     // ... data to create a VipSlaHistory
     *   }
     * })
     * 
     */
    create<T extends VipSlaHistoryCreateArgs>(args: SelectSubset<T, VipSlaHistoryCreateArgs<ExtArgs>>): Prisma__VipSlaHistoryClient<$Result.GetResult<Prisma.$VipSlaHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VipSlaHistories.
     * @param {VipSlaHistoryCreateManyArgs} args - Arguments to create many VipSlaHistories.
     * @example
     * // Create many VipSlaHistories
     * const vipSlaHistory = await prisma.vipSlaHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VipSlaHistoryCreateManyArgs>(args?: SelectSubset<T, VipSlaHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VipSlaHistories and returns the data saved in the database.
     * @param {VipSlaHistoryCreateManyAndReturnArgs} args - Arguments to create many VipSlaHistories.
     * @example
     * // Create many VipSlaHistories
     * const vipSlaHistory = await prisma.vipSlaHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VipSlaHistories and only return the `id`
     * const vipSlaHistoryWithIdOnly = await prisma.vipSlaHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VipSlaHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, VipSlaHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VipSlaHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VipSlaHistory.
     * @param {VipSlaHistoryDeleteArgs} args - Arguments to delete one VipSlaHistory.
     * @example
     * // Delete one VipSlaHistory
     * const VipSlaHistory = await prisma.vipSlaHistory.delete({
     *   where: {
     *     // ... filter to delete one VipSlaHistory
     *   }
     * })
     * 
     */
    delete<T extends VipSlaHistoryDeleteArgs>(args: SelectSubset<T, VipSlaHistoryDeleteArgs<ExtArgs>>): Prisma__VipSlaHistoryClient<$Result.GetResult<Prisma.$VipSlaHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VipSlaHistory.
     * @param {VipSlaHistoryUpdateArgs} args - Arguments to update one VipSlaHistory.
     * @example
     * // Update one VipSlaHistory
     * const vipSlaHistory = await prisma.vipSlaHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VipSlaHistoryUpdateArgs>(args: SelectSubset<T, VipSlaHistoryUpdateArgs<ExtArgs>>): Prisma__VipSlaHistoryClient<$Result.GetResult<Prisma.$VipSlaHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VipSlaHistories.
     * @param {VipSlaHistoryDeleteManyArgs} args - Arguments to filter VipSlaHistories to delete.
     * @example
     * // Delete a few VipSlaHistories
     * const { count } = await prisma.vipSlaHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VipSlaHistoryDeleteManyArgs>(args?: SelectSubset<T, VipSlaHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VipSlaHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipSlaHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VipSlaHistories
     * const vipSlaHistory = await prisma.vipSlaHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VipSlaHistoryUpdateManyArgs>(args: SelectSubset<T, VipSlaHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VipSlaHistories and returns the data updated in the database.
     * @param {VipSlaHistoryUpdateManyAndReturnArgs} args - Arguments to update many VipSlaHistories.
     * @example
     * // Update many VipSlaHistories
     * const vipSlaHistory = await prisma.vipSlaHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VipSlaHistories and only return the `id`
     * const vipSlaHistoryWithIdOnly = await prisma.vipSlaHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VipSlaHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, VipSlaHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VipSlaHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VipSlaHistory.
     * @param {VipSlaHistoryUpsertArgs} args - Arguments to update or create a VipSlaHistory.
     * @example
     * // Update or create a VipSlaHistory
     * const vipSlaHistory = await prisma.vipSlaHistory.upsert({
     *   create: {
     *     // ... data to create a VipSlaHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VipSlaHistory we want to update
     *   }
     * })
     */
    upsert<T extends VipSlaHistoryUpsertArgs>(args: SelectSubset<T, VipSlaHistoryUpsertArgs<ExtArgs>>): Prisma__VipSlaHistoryClient<$Result.GetResult<Prisma.$VipSlaHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VipSlaHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipSlaHistoryCountArgs} args - Arguments to filter VipSlaHistories to count.
     * @example
     * // Count the number of VipSlaHistories
     * const count = await prisma.vipSlaHistory.count({
     *   where: {
     *     // ... the filter for the VipSlaHistories we want to count
     *   }
     * })
    **/
    count<T extends VipSlaHistoryCountArgs>(
      args?: Subset<T, VipSlaHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VipSlaHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VipSlaHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipSlaHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VipSlaHistoryAggregateArgs>(args: Subset<T, VipSlaHistoryAggregateArgs>): Prisma.PrismaPromise<GetVipSlaHistoryAggregateType<T>>

    /**
     * Group by VipSlaHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipSlaHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VipSlaHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VipSlaHistoryGroupByArgs['orderBy'] }
        : { orderBy?: VipSlaHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VipSlaHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVipSlaHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VipSlaHistory model
   */
  readonly fields: VipSlaHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VipSlaHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VipSlaHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VipSlaHistory model
   */
  interface VipSlaHistoryFieldRefs {
    readonly id: FieldRef<"VipSlaHistory", 'Int'>
    readonly userId: FieldRef<"VipSlaHistory", 'String'>
    readonly sla: FieldRef<"VipSlaHistory", 'Json'>
    readonly effectiveAt: FieldRef<"VipSlaHistory", 'DateTime'>
    readonly endedAt: FieldRef<"VipSlaHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VipSlaHistory findUnique
   */
  export type VipSlaHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipSlaHistory
     */
    select?: VipSlaHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipSlaHistory
     */
    omit?: VipSlaHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipSlaHistoryInclude<ExtArgs> | null
    /**
     * Filter, which VipSlaHistory to fetch.
     */
    where: VipSlaHistoryWhereUniqueInput
  }

  /**
   * VipSlaHistory findUniqueOrThrow
   */
  export type VipSlaHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipSlaHistory
     */
    select?: VipSlaHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipSlaHistory
     */
    omit?: VipSlaHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipSlaHistoryInclude<ExtArgs> | null
    /**
     * Filter, which VipSlaHistory to fetch.
     */
    where: VipSlaHistoryWhereUniqueInput
  }

  /**
   * VipSlaHistory findFirst
   */
  export type VipSlaHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipSlaHistory
     */
    select?: VipSlaHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipSlaHistory
     */
    omit?: VipSlaHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipSlaHistoryInclude<ExtArgs> | null
    /**
     * Filter, which VipSlaHistory to fetch.
     */
    where?: VipSlaHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VipSlaHistories to fetch.
     */
    orderBy?: VipSlaHistoryOrderByWithRelationInput | VipSlaHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VipSlaHistories.
     */
    cursor?: VipSlaHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VipSlaHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VipSlaHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VipSlaHistories.
     */
    distinct?: VipSlaHistoryScalarFieldEnum | VipSlaHistoryScalarFieldEnum[]
  }

  /**
   * VipSlaHistory findFirstOrThrow
   */
  export type VipSlaHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipSlaHistory
     */
    select?: VipSlaHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipSlaHistory
     */
    omit?: VipSlaHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipSlaHistoryInclude<ExtArgs> | null
    /**
     * Filter, which VipSlaHistory to fetch.
     */
    where?: VipSlaHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VipSlaHistories to fetch.
     */
    orderBy?: VipSlaHistoryOrderByWithRelationInput | VipSlaHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VipSlaHistories.
     */
    cursor?: VipSlaHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VipSlaHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VipSlaHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VipSlaHistories.
     */
    distinct?: VipSlaHistoryScalarFieldEnum | VipSlaHistoryScalarFieldEnum[]
  }

  /**
   * VipSlaHistory findMany
   */
  export type VipSlaHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipSlaHistory
     */
    select?: VipSlaHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipSlaHistory
     */
    omit?: VipSlaHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipSlaHistoryInclude<ExtArgs> | null
    /**
     * Filter, which VipSlaHistories to fetch.
     */
    where?: VipSlaHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VipSlaHistories to fetch.
     */
    orderBy?: VipSlaHistoryOrderByWithRelationInput | VipSlaHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VipSlaHistories.
     */
    cursor?: VipSlaHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VipSlaHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VipSlaHistories.
     */
    skip?: number
    distinct?: VipSlaHistoryScalarFieldEnum | VipSlaHistoryScalarFieldEnum[]
  }

  /**
   * VipSlaHistory create
   */
  export type VipSlaHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipSlaHistory
     */
    select?: VipSlaHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipSlaHistory
     */
    omit?: VipSlaHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipSlaHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a VipSlaHistory.
     */
    data: XOR<VipSlaHistoryCreateInput, VipSlaHistoryUncheckedCreateInput>
  }

  /**
   * VipSlaHistory createMany
   */
  export type VipSlaHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VipSlaHistories.
     */
    data: VipSlaHistoryCreateManyInput | VipSlaHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VipSlaHistory createManyAndReturn
   */
  export type VipSlaHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipSlaHistory
     */
    select?: VipSlaHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VipSlaHistory
     */
    omit?: VipSlaHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many VipSlaHistories.
     */
    data: VipSlaHistoryCreateManyInput | VipSlaHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipSlaHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VipSlaHistory update
   */
  export type VipSlaHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipSlaHistory
     */
    select?: VipSlaHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipSlaHistory
     */
    omit?: VipSlaHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipSlaHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a VipSlaHistory.
     */
    data: XOR<VipSlaHistoryUpdateInput, VipSlaHistoryUncheckedUpdateInput>
    /**
     * Choose, which VipSlaHistory to update.
     */
    where: VipSlaHistoryWhereUniqueInput
  }

  /**
   * VipSlaHistory updateMany
   */
  export type VipSlaHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VipSlaHistories.
     */
    data: XOR<VipSlaHistoryUpdateManyMutationInput, VipSlaHistoryUncheckedUpdateManyInput>
    /**
     * Filter which VipSlaHistories to update
     */
    where?: VipSlaHistoryWhereInput
    /**
     * Limit how many VipSlaHistories to update.
     */
    limit?: number
  }

  /**
   * VipSlaHistory updateManyAndReturn
   */
  export type VipSlaHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipSlaHistory
     */
    select?: VipSlaHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VipSlaHistory
     */
    omit?: VipSlaHistoryOmit<ExtArgs> | null
    /**
     * The data used to update VipSlaHistories.
     */
    data: XOR<VipSlaHistoryUpdateManyMutationInput, VipSlaHistoryUncheckedUpdateManyInput>
    /**
     * Filter which VipSlaHistories to update
     */
    where?: VipSlaHistoryWhereInput
    /**
     * Limit how many VipSlaHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipSlaHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VipSlaHistory upsert
   */
  export type VipSlaHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipSlaHistory
     */
    select?: VipSlaHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipSlaHistory
     */
    omit?: VipSlaHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipSlaHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the VipSlaHistory to update in case it exists.
     */
    where: VipSlaHistoryWhereUniqueInput
    /**
     * In case the VipSlaHistory found by the `where` argument doesn't exist, create a new VipSlaHistory with this data.
     */
    create: XOR<VipSlaHistoryCreateInput, VipSlaHistoryUncheckedCreateInput>
    /**
     * In case the VipSlaHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VipSlaHistoryUpdateInput, VipSlaHistoryUncheckedUpdateInput>
  }

  /**
   * VipSlaHistory delete
   */
  export type VipSlaHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipSlaHistory
     */
    select?: VipSlaHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipSlaHistory
     */
    omit?: VipSlaHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipSlaHistoryInclude<ExtArgs> | null
    /**
     * Filter which VipSlaHistory to delete.
     */
    where: VipSlaHistoryWhereUniqueInput
  }

  /**
   * VipSlaHistory deleteMany
   */
  export type VipSlaHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VipSlaHistories to delete
     */
    where?: VipSlaHistoryWhereInput
    /**
     * Limit how many VipSlaHistories to delete.
     */
    limit?: number
  }

  /**
   * VipSlaHistory without action
   */
  export type VipSlaHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipSlaHistory
     */
    select?: VipSlaHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipSlaHistory
     */
    omit?: VipSlaHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipSlaHistoryInclude<ExtArgs> | null
  }


  /**
   * Model AgentAvailability
   */

  export type AggregateAgentAvailability = {
    _count: AgentAvailabilityCountAggregateOutputType | null
    _avg: AgentAvailabilityAvgAggregateOutputType | null
    _sum: AgentAvailabilitySumAggregateOutputType | null
    _min: AgentAvailabilityMinAggregateOutputType | null
    _max: AgentAvailabilityMaxAggregateOutputType | null
  }

  export type AgentAvailabilityAvgAggregateOutputType = {
    maxCapacity: number | null
    currentLoad: number | null
  }

  export type AgentAvailabilitySumAggregateOutputType = {
    maxCapacity: number | null
    currentLoad: number | null
  }

  export type AgentAvailabilityMinAggregateOutputType = {
    id: string | null
    userId: string | null
    queueName: string | null
    isAvailable: boolean | null
    maxCapacity: number | null
    currentLoad: number | null
    status: string | null
    lastUpdated: Date | null
    createdAt: Date | null
  }

  export type AgentAvailabilityMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    queueName: string | null
    isAvailable: boolean | null
    maxCapacity: number | null
    currentLoad: number | null
    status: string | null
    lastUpdated: Date | null
    createdAt: Date | null
  }

  export type AgentAvailabilityCountAggregateOutputType = {
    id: number
    userId: number
    queueName: number
    isAvailable: number
    maxCapacity: number
    currentLoad: number
    status: number
    lastUpdated: number
    createdAt: number
    _all: number
  }


  export type AgentAvailabilityAvgAggregateInputType = {
    maxCapacity?: true
    currentLoad?: true
  }

  export type AgentAvailabilitySumAggregateInputType = {
    maxCapacity?: true
    currentLoad?: true
  }

  export type AgentAvailabilityMinAggregateInputType = {
    id?: true
    userId?: true
    queueName?: true
    isAvailable?: true
    maxCapacity?: true
    currentLoad?: true
    status?: true
    lastUpdated?: true
    createdAt?: true
  }

  export type AgentAvailabilityMaxAggregateInputType = {
    id?: true
    userId?: true
    queueName?: true
    isAvailable?: true
    maxCapacity?: true
    currentLoad?: true
    status?: true
    lastUpdated?: true
    createdAt?: true
  }

  export type AgentAvailabilityCountAggregateInputType = {
    id?: true
    userId?: true
    queueName?: true
    isAvailable?: true
    maxCapacity?: true
    currentLoad?: true
    status?: true
    lastUpdated?: true
    createdAt?: true
    _all?: true
  }

  export type AgentAvailabilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentAvailability to aggregate.
     */
    where?: AgentAvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentAvailabilities to fetch.
     */
    orderBy?: AgentAvailabilityOrderByWithRelationInput | AgentAvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentAvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentAvailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentAvailabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgentAvailabilities
    **/
    _count?: true | AgentAvailabilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgentAvailabilityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgentAvailabilitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentAvailabilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentAvailabilityMaxAggregateInputType
  }

  export type GetAgentAvailabilityAggregateType<T extends AgentAvailabilityAggregateArgs> = {
        [P in keyof T & keyof AggregateAgentAvailability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgentAvailability[P]>
      : GetScalarType<T[P], AggregateAgentAvailability[P]>
  }




  export type AgentAvailabilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentAvailabilityWhereInput
    orderBy?: AgentAvailabilityOrderByWithAggregationInput | AgentAvailabilityOrderByWithAggregationInput[]
    by: AgentAvailabilityScalarFieldEnum[] | AgentAvailabilityScalarFieldEnum
    having?: AgentAvailabilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentAvailabilityCountAggregateInputType | true
    _avg?: AgentAvailabilityAvgAggregateInputType
    _sum?: AgentAvailabilitySumAggregateInputType
    _min?: AgentAvailabilityMinAggregateInputType
    _max?: AgentAvailabilityMaxAggregateInputType
  }

  export type AgentAvailabilityGroupByOutputType = {
    id: string
    userId: string
    queueName: string
    isAvailable: boolean
    maxCapacity: number
    currentLoad: number
    status: string
    lastUpdated: Date
    createdAt: Date
    _count: AgentAvailabilityCountAggregateOutputType | null
    _avg: AgentAvailabilityAvgAggregateOutputType | null
    _sum: AgentAvailabilitySumAggregateOutputType | null
    _min: AgentAvailabilityMinAggregateOutputType | null
    _max: AgentAvailabilityMaxAggregateOutputType | null
  }

  type GetAgentAvailabilityGroupByPayload<T extends AgentAvailabilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentAvailabilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentAvailabilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentAvailabilityGroupByOutputType[P]>
            : GetScalarType<T[P], AgentAvailabilityGroupByOutputType[P]>
        }
      >
    >


  export type AgentAvailabilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    queueName?: boolean
    isAvailable?: boolean
    maxCapacity?: boolean
    currentLoad?: boolean
    status?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentAvailability"]>

  export type AgentAvailabilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    queueName?: boolean
    isAvailable?: boolean
    maxCapacity?: boolean
    currentLoad?: boolean
    status?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentAvailability"]>

  export type AgentAvailabilitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    queueName?: boolean
    isAvailable?: boolean
    maxCapacity?: boolean
    currentLoad?: boolean
    status?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentAvailability"]>

  export type AgentAvailabilitySelectScalar = {
    id?: boolean
    userId?: boolean
    queueName?: boolean
    isAvailable?: boolean
    maxCapacity?: boolean
    currentLoad?: boolean
    status?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
  }

  export type AgentAvailabilityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "queueName" | "isAvailable" | "maxCapacity" | "currentLoad" | "status" | "lastUpdated" | "createdAt", ExtArgs["result"]["agentAvailability"]>
  export type AgentAvailabilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AgentAvailabilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AgentAvailabilityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AgentAvailabilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgentAvailability"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      queueName: string
      isAvailable: boolean
      maxCapacity: number
      currentLoad: number
      status: string
      lastUpdated: Date
      createdAt: Date
    }, ExtArgs["result"]["agentAvailability"]>
    composites: {}
  }

  type AgentAvailabilityGetPayload<S extends boolean | null | undefined | AgentAvailabilityDefaultArgs> = $Result.GetResult<Prisma.$AgentAvailabilityPayload, S>

  type AgentAvailabilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentAvailabilityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentAvailabilityCountAggregateInputType | true
    }

  export interface AgentAvailabilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgentAvailability'], meta: { name: 'AgentAvailability' } }
    /**
     * Find zero or one AgentAvailability that matches the filter.
     * @param {AgentAvailabilityFindUniqueArgs} args - Arguments to find a AgentAvailability
     * @example
     * // Get one AgentAvailability
     * const agentAvailability = await prisma.agentAvailability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentAvailabilityFindUniqueArgs>(args: SelectSubset<T, AgentAvailabilityFindUniqueArgs<ExtArgs>>): Prisma__AgentAvailabilityClient<$Result.GetResult<Prisma.$AgentAvailabilityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgentAvailability that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentAvailabilityFindUniqueOrThrowArgs} args - Arguments to find a AgentAvailability
     * @example
     * // Get one AgentAvailability
     * const agentAvailability = await prisma.agentAvailability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentAvailabilityFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentAvailabilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentAvailabilityClient<$Result.GetResult<Prisma.$AgentAvailabilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentAvailability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentAvailabilityFindFirstArgs} args - Arguments to find a AgentAvailability
     * @example
     * // Get one AgentAvailability
     * const agentAvailability = await prisma.agentAvailability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentAvailabilityFindFirstArgs>(args?: SelectSubset<T, AgentAvailabilityFindFirstArgs<ExtArgs>>): Prisma__AgentAvailabilityClient<$Result.GetResult<Prisma.$AgentAvailabilityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentAvailability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentAvailabilityFindFirstOrThrowArgs} args - Arguments to find a AgentAvailability
     * @example
     * // Get one AgentAvailability
     * const agentAvailability = await prisma.agentAvailability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentAvailabilityFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentAvailabilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentAvailabilityClient<$Result.GetResult<Prisma.$AgentAvailabilityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgentAvailabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentAvailabilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgentAvailabilities
     * const agentAvailabilities = await prisma.agentAvailability.findMany()
     * 
     * // Get first 10 AgentAvailabilities
     * const agentAvailabilities = await prisma.agentAvailability.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentAvailabilityWithIdOnly = await prisma.agentAvailability.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentAvailabilityFindManyArgs>(args?: SelectSubset<T, AgentAvailabilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentAvailabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgentAvailability.
     * @param {AgentAvailabilityCreateArgs} args - Arguments to create a AgentAvailability.
     * @example
     * // Create one AgentAvailability
     * const AgentAvailability = await prisma.agentAvailability.create({
     *   data: {
     *     // ... data to create a AgentAvailability
     *   }
     * })
     * 
     */
    create<T extends AgentAvailabilityCreateArgs>(args: SelectSubset<T, AgentAvailabilityCreateArgs<ExtArgs>>): Prisma__AgentAvailabilityClient<$Result.GetResult<Prisma.$AgentAvailabilityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgentAvailabilities.
     * @param {AgentAvailabilityCreateManyArgs} args - Arguments to create many AgentAvailabilities.
     * @example
     * // Create many AgentAvailabilities
     * const agentAvailability = await prisma.agentAvailability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentAvailabilityCreateManyArgs>(args?: SelectSubset<T, AgentAvailabilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgentAvailabilities and returns the data saved in the database.
     * @param {AgentAvailabilityCreateManyAndReturnArgs} args - Arguments to create many AgentAvailabilities.
     * @example
     * // Create many AgentAvailabilities
     * const agentAvailability = await prisma.agentAvailability.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgentAvailabilities and only return the `id`
     * const agentAvailabilityWithIdOnly = await prisma.agentAvailability.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentAvailabilityCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentAvailabilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentAvailabilityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgentAvailability.
     * @param {AgentAvailabilityDeleteArgs} args - Arguments to delete one AgentAvailability.
     * @example
     * // Delete one AgentAvailability
     * const AgentAvailability = await prisma.agentAvailability.delete({
     *   where: {
     *     // ... filter to delete one AgentAvailability
     *   }
     * })
     * 
     */
    delete<T extends AgentAvailabilityDeleteArgs>(args: SelectSubset<T, AgentAvailabilityDeleteArgs<ExtArgs>>): Prisma__AgentAvailabilityClient<$Result.GetResult<Prisma.$AgentAvailabilityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgentAvailability.
     * @param {AgentAvailabilityUpdateArgs} args - Arguments to update one AgentAvailability.
     * @example
     * // Update one AgentAvailability
     * const agentAvailability = await prisma.agentAvailability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentAvailabilityUpdateArgs>(args: SelectSubset<T, AgentAvailabilityUpdateArgs<ExtArgs>>): Prisma__AgentAvailabilityClient<$Result.GetResult<Prisma.$AgentAvailabilityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgentAvailabilities.
     * @param {AgentAvailabilityDeleteManyArgs} args - Arguments to filter AgentAvailabilities to delete.
     * @example
     * // Delete a few AgentAvailabilities
     * const { count } = await prisma.agentAvailability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentAvailabilityDeleteManyArgs>(args?: SelectSubset<T, AgentAvailabilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentAvailabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentAvailabilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgentAvailabilities
     * const agentAvailability = await prisma.agentAvailability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentAvailabilityUpdateManyArgs>(args: SelectSubset<T, AgentAvailabilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentAvailabilities and returns the data updated in the database.
     * @param {AgentAvailabilityUpdateManyAndReturnArgs} args - Arguments to update many AgentAvailabilities.
     * @example
     * // Update many AgentAvailabilities
     * const agentAvailability = await prisma.agentAvailability.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgentAvailabilities and only return the `id`
     * const agentAvailabilityWithIdOnly = await prisma.agentAvailability.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentAvailabilityUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentAvailabilityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentAvailabilityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgentAvailability.
     * @param {AgentAvailabilityUpsertArgs} args - Arguments to update or create a AgentAvailability.
     * @example
     * // Update or create a AgentAvailability
     * const agentAvailability = await prisma.agentAvailability.upsert({
     *   create: {
     *     // ... data to create a AgentAvailability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgentAvailability we want to update
     *   }
     * })
     */
    upsert<T extends AgentAvailabilityUpsertArgs>(args: SelectSubset<T, AgentAvailabilityUpsertArgs<ExtArgs>>): Prisma__AgentAvailabilityClient<$Result.GetResult<Prisma.$AgentAvailabilityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgentAvailabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentAvailabilityCountArgs} args - Arguments to filter AgentAvailabilities to count.
     * @example
     * // Count the number of AgentAvailabilities
     * const count = await prisma.agentAvailability.count({
     *   where: {
     *     // ... the filter for the AgentAvailabilities we want to count
     *   }
     * })
    **/
    count<T extends AgentAvailabilityCountArgs>(
      args?: Subset<T, AgentAvailabilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentAvailabilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgentAvailability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentAvailabilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentAvailabilityAggregateArgs>(args: Subset<T, AgentAvailabilityAggregateArgs>): Prisma.PrismaPromise<GetAgentAvailabilityAggregateType<T>>

    /**
     * Group by AgentAvailability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentAvailabilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentAvailabilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentAvailabilityGroupByArgs['orderBy'] }
        : { orderBy?: AgentAvailabilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentAvailabilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentAvailabilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgentAvailability model
   */
  readonly fields: AgentAvailabilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgentAvailability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentAvailabilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgentAvailability model
   */
  interface AgentAvailabilityFieldRefs {
    readonly id: FieldRef<"AgentAvailability", 'String'>
    readonly userId: FieldRef<"AgentAvailability", 'String'>
    readonly queueName: FieldRef<"AgentAvailability", 'String'>
    readonly isAvailable: FieldRef<"AgentAvailability", 'Boolean'>
    readonly maxCapacity: FieldRef<"AgentAvailability", 'Int'>
    readonly currentLoad: FieldRef<"AgentAvailability", 'Int'>
    readonly status: FieldRef<"AgentAvailability", 'String'>
    readonly lastUpdated: FieldRef<"AgentAvailability", 'DateTime'>
    readonly createdAt: FieldRef<"AgentAvailability", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgentAvailability findUnique
   */
  export type AgentAvailabilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentAvailability
     */
    select?: AgentAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentAvailability
     */
    omit?: AgentAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which AgentAvailability to fetch.
     */
    where: AgentAvailabilityWhereUniqueInput
  }

  /**
   * AgentAvailability findUniqueOrThrow
   */
  export type AgentAvailabilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentAvailability
     */
    select?: AgentAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentAvailability
     */
    omit?: AgentAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which AgentAvailability to fetch.
     */
    where: AgentAvailabilityWhereUniqueInput
  }

  /**
   * AgentAvailability findFirst
   */
  export type AgentAvailabilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentAvailability
     */
    select?: AgentAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentAvailability
     */
    omit?: AgentAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which AgentAvailability to fetch.
     */
    where?: AgentAvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentAvailabilities to fetch.
     */
    orderBy?: AgentAvailabilityOrderByWithRelationInput | AgentAvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentAvailabilities.
     */
    cursor?: AgentAvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentAvailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentAvailabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentAvailabilities.
     */
    distinct?: AgentAvailabilityScalarFieldEnum | AgentAvailabilityScalarFieldEnum[]
  }

  /**
   * AgentAvailability findFirstOrThrow
   */
  export type AgentAvailabilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentAvailability
     */
    select?: AgentAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentAvailability
     */
    omit?: AgentAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which AgentAvailability to fetch.
     */
    where?: AgentAvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentAvailabilities to fetch.
     */
    orderBy?: AgentAvailabilityOrderByWithRelationInput | AgentAvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentAvailabilities.
     */
    cursor?: AgentAvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentAvailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentAvailabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentAvailabilities.
     */
    distinct?: AgentAvailabilityScalarFieldEnum | AgentAvailabilityScalarFieldEnum[]
  }

  /**
   * AgentAvailability findMany
   */
  export type AgentAvailabilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentAvailability
     */
    select?: AgentAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentAvailability
     */
    omit?: AgentAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which AgentAvailabilities to fetch.
     */
    where?: AgentAvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentAvailabilities to fetch.
     */
    orderBy?: AgentAvailabilityOrderByWithRelationInput | AgentAvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgentAvailabilities.
     */
    cursor?: AgentAvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentAvailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentAvailabilities.
     */
    skip?: number
    distinct?: AgentAvailabilityScalarFieldEnum | AgentAvailabilityScalarFieldEnum[]
  }

  /**
   * AgentAvailability create
   */
  export type AgentAvailabilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentAvailability
     */
    select?: AgentAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentAvailability
     */
    omit?: AgentAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentAvailabilityInclude<ExtArgs> | null
    /**
     * The data needed to create a AgentAvailability.
     */
    data: XOR<AgentAvailabilityCreateInput, AgentAvailabilityUncheckedCreateInput>
  }

  /**
   * AgentAvailability createMany
   */
  export type AgentAvailabilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgentAvailabilities.
     */
    data: AgentAvailabilityCreateManyInput | AgentAvailabilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentAvailability createManyAndReturn
   */
  export type AgentAvailabilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentAvailability
     */
    select?: AgentAvailabilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentAvailability
     */
    omit?: AgentAvailabilityOmit<ExtArgs> | null
    /**
     * The data used to create many AgentAvailabilities.
     */
    data: AgentAvailabilityCreateManyInput | AgentAvailabilityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentAvailabilityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentAvailability update
   */
  export type AgentAvailabilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentAvailability
     */
    select?: AgentAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentAvailability
     */
    omit?: AgentAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentAvailabilityInclude<ExtArgs> | null
    /**
     * The data needed to update a AgentAvailability.
     */
    data: XOR<AgentAvailabilityUpdateInput, AgentAvailabilityUncheckedUpdateInput>
    /**
     * Choose, which AgentAvailability to update.
     */
    where: AgentAvailabilityWhereUniqueInput
  }

  /**
   * AgentAvailability updateMany
   */
  export type AgentAvailabilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgentAvailabilities.
     */
    data: XOR<AgentAvailabilityUpdateManyMutationInput, AgentAvailabilityUncheckedUpdateManyInput>
    /**
     * Filter which AgentAvailabilities to update
     */
    where?: AgentAvailabilityWhereInput
    /**
     * Limit how many AgentAvailabilities to update.
     */
    limit?: number
  }

  /**
   * AgentAvailability updateManyAndReturn
   */
  export type AgentAvailabilityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentAvailability
     */
    select?: AgentAvailabilitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentAvailability
     */
    omit?: AgentAvailabilityOmit<ExtArgs> | null
    /**
     * The data used to update AgentAvailabilities.
     */
    data: XOR<AgentAvailabilityUpdateManyMutationInput, AgentAvailabilityUncheckedUpdateManyInput>
    /**
     * Filter which AgentAvailabilities to update
     */
    where?: AgentAvailabilityWhereInput
    /**
     * Limit how many AgentAvailabilities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentAvailabilityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentAvailability upsert
   */
  export type AgentAvailabilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentAvailability
     */
    select?: AgentAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentAvailability
     */
    omit?: AgentAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentAvailabilityInclude<ExtArgs> | null
    /**
     * The filter to search for the AgentAvailability to update in case it exists.
     */
    where: AgentAvailabilityWhereUniqueInput
    /**
     * In case the AgentAvailability found by the `where` argument doesn't exist, create a new AgentAvailability with this data.
     */
    create: XOR<AgentAvailabilityCreateInput, AgentAvailabilityUncheckedCreateInput>
    /**
     * In case the AgentAvailability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentAvailabilityUpdateInput, AgentAvailabilityUncheckedUpdateInput>
  }

  /**
   * AgentAvailability delete
   */
  export type AgentAvailabilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentAvailability
     */
    select?: AgentAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentAvailability
     */
    omit?: AgentAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentAvailabilityInclude<ExtArgs> | null
    /**
     * Filter which AgentAvailability to delete.
     */
    where: AgentAvailabilityWhereUniqueInput
  }

  /**
   * AgentAvailability deleteMany
   */
  export type AgentAvailabilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentAvailabilities to delete
     */
    where?: AgentAvailabilityWhereInput
    /**
     * Limit how many AgentAvailabilities to delete.
     */
    limit?: number
  }

  /**
   * AgentAvailability without action
   */
  export type AgentAvailabilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentAvailability
     */
    select?: AgentAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentAvailability
     */
    omit?: AgentAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentAvailabilityInclude<ExtArgs> | null
  }


  /**
   * Model QueueMetrics
   */

  export type AggregateQueueMetrics = {
    _count: QueueMetricsCountAggregateOutputType | null
    _avg: QueueMetricsAvgAggregateOutputType | null
    _sum: QueueMetricsSumAggregateOutputType | null
    _min: QueueMetricsMinAggregateOutputType | null
    _max: QueueMetricsMaxAggregateOutputType | null
  }

  export type QueueMetricsAvgAggregateOutputType = {
    totalAgents: number | null
    availableAgents: number | null
    totalTickets: number | null
    openTickets: number | null
    avgResponseTime: number | null
    avgResolutionTime: number | null
    slaBreaches: number | null
    highPriorityTickets: number | null
    capacityUtilization: number | null
    averageWaitTime: number | null
  }

  export type QueueMetricsSumAggregateOutputType = {
    totalAgents: number | null
    availableAgents: number | null
    totalTickets: number | null
    openTickets: number | null
    avgResponseTime: number | null
    avgResolutionTime: number | null
    slaBreaches: number | null
    highPriorityTickets: number | null
    capacityUtilization: number | null
    averageWaitTime: number | null
  }

  export type QueueMetricsMinAggregateOutputType = {
    id: string | null
    queueName: string | null
    totalAgents: number | null
    availableAgents: number | null
    totalTickets: number | null
    openTickets: number | null
    avgResponseTime: number | null
    avgResolutionTime: number | null
    slaBreaches: number | null
    highPriorityTickets: number | null
    capacityUtilization: number | null
    averageWaitTime: number | null
    thresholdWarning: boolean | null
    thresholdCritical: boolean | null
    lastCalculated: Date | null
  }

  export type QueueMetricsMaxAggregateOutputType = {
    id: string | null
    queueName: string | null
    totalAgents: number | null
    availableAgents: number | null
    totalTickets: number | null
    openTickets: number | null
    avgResponseTime: number | null
    avgResolutionTime: number | null
    slaBreaches: number | null
    highPriorityTickets: number | null
    capacityUtilization: number | null
    averageWaitTime: number | null
    thresholdWarning: boolean | null
    thresholdCritical: boolean | null
    lastCalculated: Date | null
  }

  export type QueueMetricsCountAggregateOutputType = {
    id: number
    queueName: number
    totalAgents: number
    availableAgents: number
    totalTickets: number
    openTickets: number
    avgResponseTime: number
    avgResolutionTime: number
    slaBreaches: number
    highPriorityTickets: number
    capacityUtilization: number
    averageWaitTime: number
    thresholdWarning: number
    thresholdCritical: number
    lastCalculated: number
    _all: number
  }


  export type QueueMetricsAvgAggregateInputType = {
    totalAgents?: true
    availableAgents?: true
    totalTickets?: true
    openTickets?: true
    avgResponseTime?: true
    avgResolutionTime?: true
    slaBreaches?: true
    highPriorityTickets?: true
    capacityUtilization?: true
    averageWaitTime?: true
  }

  export type QueueMetricsSumAggregateInputType = {
    totalAgents?: true
    availableAgents?: true
    totalTickets?: true
    openTickets?: true
    avgResponseTime?: true
    avgResolutionTime?: true
    slaBreaches?: true
    highPriorityTickets?: true
    capacityUtilization?: true
    averageWaitTime?: true
  }

  export type QueueMetricsMinAggregateInputType = {
    id?: true
    queueName?: true
    totalAgents?: true
    availableAgents?: true
    totalTickets?: true
    openTickets?: true
    avgResponseTime?: true
    avgResolutionTime?: true
    slaBreaches?: true
    highPriorityTickets?: true
    capacityUtilization?: true
    averageWaitTime?: true
    thresholdWarning?: true
    thresholdCritical?: true
    lastCalculated?: true
  }

  export type QueueMetricsMaxAggregateInputType = {
    id?: true
    queueName?: true
    totalAgents?: true
    availableAgents?: true
    totalTickets?: true
    openTickets?: true
    avgResponseTime?: true
    avgResolutionTime?: true
    slaBreaches?: true
    highPriorityTickets?: true
    capacityUtilization?: true
    averageWaitTime?: true
    thresholdWarning?: true
    thresholdCritical?: true
    lastCalculated?: true
  }

  export type QueueMetricsCountAggregateInputType = {
    id?: true
    queueName?: true
    totalAgents?: true
    availableAgents?: true
    totalTickets?: true
    openTickets?: true
    avgResponseTime?: true
    avgResolutionTime?: true
    slaBreaches?: true
    highPriorityTickets?: true
    capacityUtilization?: true
    averageWaitTime?: true
    thresholdWarning?: true
    thresholdCritical?: true
    lastCalculated?: true
    _all?: true
  }

  export type QueueMetricsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QueueMetrics to aggregate.
     */
    where?: QueueMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueMetrics to fetch.
     */
    orderBy?: QueueMetricsOrderByWithRelationInput | QueueMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QueueMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QueueMetrics
    **/
    _count?: true | QueueMetricsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QueueMetricsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QueueMetricsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QueueMetricsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QueueMetricsMaxAggregateInputType
  }

  export type GetQueueMetricsAggregateType<T extends QueueMetricsAggregateArgs> = {
        [P in keyof T & keyof AggregateQueueMetrics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQueueMetrics[P]>
      : GetScalarType<T[P], AggregateQueueMetrics[P]>
  }




  export type QueueMetricsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueueMetricsWhereInput
    orderBy?: QueueMetricsOrderByWithAggregationInput | QueueMetricsOrderByWithAggregationInput[]
    by: QueueMetricsScalarFieldEnum[] | QueueMetricsScalarFieldEnum
    having?: QueueMetricsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QueueMetricsCountAggregateInputType | true
    _avg?: QueueMetricsAvgAggregateInputType
    _sum?: QueueMetricsSumAggregateInputType
    _min?: QueueMetricsMinAggregateInputType
    _max?: QueueMetricsMaxAggregateInputType
  }

  export type QueueMetricsGroupByOutputType = {
    id: string
    queueName: string
    totalAgents: number
    availableAgents: number
    totalTickets: number
    openTickets: number
    avgResponseTime: number
    avgResolutionTime: number
    slaBreaches: number
    highPriorityTickets: number
    capacityUtilization: number
    averageWaitTime: number
    thresholdWarning: boolean
    thresholdCritical: boolean
    lastCalculated: Date
    _count: QueueMetricsCountAggregateOutputType | null
    _avg: QueueMetricsAvgAggregateOutputType | null
    _sum: QueueMetricsSumAggregateOutputType | null
    _min: QueueMetricsMinAggregateOutputType | null
    _max: QueueMetricsMaxAggregateOutputType | null
  }

  type GetQueueMetricsGroupByPayload<T extends QueueMetricsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QueueMetricsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QueueMetricsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QueueMetricsGroupByOutputType[P]>
            : GetScalarType<T[P], QueueMetricsGroupByOutputType[P]>
        }
      >
    >


  export type QueueMetricsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queueName?: boolean
    totalAgents?: boolean
    availableAgents?: boolean
    totalTickets?: boolean
    openTickets?: boolean
    avgResponseTime?: boolean
    avgResolutionTime?: boolean
    slaBreaches?: boolean
    highPriorityTickets?: boolean
    capacityUtilization?: boolean
    averageWaitTime?: boolean
    thresholdWarning?: boolean
    thresholdCritical?: boolean
    lastCalculated?: boolean
  }, ExtArgs["result"]["queueMetrics"]>

  export type QueueMetricsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queueName?: boolean
    totalAgents?: boolean
    availableAgents?: boolean
    totalTickets?: boolean
    openTickets?: boolean
    avgResponseTime?: boolean
    avgResolutionTime?: boolean
    slaBreaches?: boolean
    highPriorityTickets?: boolean
    capacityUtilization?: boolean
    averageWaitTime?: boolean
    thresholdWarning?: boolean
    thresholdCritical?: boolean
    lastCalculated?: boolean
  }, ExtArgs["result"]["queueMetrics"]>

  export type QueueMetricsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queueName?: boolean
    totalAgents?: boolean
    availableAgents?: boolean
    totalTickets?: boolean
    openTickets?: boolean
    avgResponseTime?: boolean
    avgResolutionTime?: boolean
    slaBreaches?: boolean
    highPriorityTickets?: boolean
    capacityUtilization?: boolean
    averageWaitTime?: boolean
    thresholdWarning?: boolean
    thresholdCritical?: boolean
    lastCalculated?: boolean
  }, ExtArgs["result"]["queueMetrics"]>

  export type QueueMetricsSelectScalar = {
    id?: boolean
    queueName?: boolean
    totalAgents?: boolean
    availableAgents?: boolean
    totalTickets?: boolean
    openTickets?: boolean
    avgResponseTime?: boolean
    avgResolutionTime?: boolean
    slaBreaches?: boolean
    highPriorityTickets?: boolean
    capacityUtilization?: boolean
    averageWaitTime?: boolean
    thresholdWarning?: boolean
    thresholdCritical?: boolean
    lastCalculated?: boolean
  }

  export type QueueMetricsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "queueName" | "totalAgents" | "availableAgents" | "totalTickets" | "openTickets" | "avgResponseTime" | "avgResolutionTime" | "slaBreaches" | "highPriorityTickets" | "capacityUtilization" | "averageWaitTime" | "thresholdWarning" | "thresholdCritical" | "lastCalculated", ExtArgs["result"]["queueMetrics"]>

  export type $QueueMetricsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QueueMetrics"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      queueName: string
      totalAgents: number
      availableAgents: number
      totalTickets: number
      openTickets: number
      avgResponseTime: number
      avgResolutionTime: number
      slaBreaches: number
      highPriorityTickets: number
      capacityUtilization: number
      averageWaitTime: number
      thresholdWarning: boolean
      thresholdCritical: boolean
      lastCalculated: Date
    }, ExtArgs["result"]["queueMetrics"]>
    composites: {}
  }

  type QueueMetricsGetPayload<S extends boolean | null | undefined | QueueMetricsDefaultArgs> = $Result.GetResult<Prisma.$QueueMetricsPayload, S>

  type QueueMetricsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QueueMetricsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QueueMetricsCountAggregateInputType | true
    }

  export interface QueueMetricsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QueueMetrics'], meta: { name: 'QueueMetrics' } }
    /**
     * Find zero or one QueueMetrics that matches the filter.
     * @param {QueueMetricsFindUniqueArgs} args - Arguments to find a QueueMetrics
     * @example
     * // Get one QueueMetrics
     * const queueMetrics = await prisma.queueMetrics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QueueMetricsFindUniqueArgs>(args: SelectSubset<T, QueueMetricsFindUniqueArgs<ExtArgs>>): Prisma__QueueMetricsClient<$Result.GetResult<Prisma.$QueueMetricsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QueueMetrics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QueueMetricsFindUniqueOrThrowArgs} args - Arguments to find a QueueMetrics
     * @example
     * // Get one QueueMetrics
     * const queueMetrics = await prisma.queueMetrics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QueueMetricsFindUniqueOrThrowArgs>(args: SelectSubset<T, QueueMetricsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QueueMetricsClient<$Result.GetResult<Prisma.$QueueMetricsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QueueMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueMetricsFindFirstArgs} args - Arguments to find a QueueMetrics
     * @example
     * // Get one QueueMetrics
     * const queueMetrics = await prisma.queueMetrics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QueueMetricsFindFirstArgs>(args?: SelectSubset<T, QueueMetricsFindFirstArgs<ExtArgs>>): Prisma__QueueMetricsClient<$Result.GetResult<Prisma.$QueueMetricsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QueueMetrics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueMetricsFindFirstOrThrowArgs} args - Arguments to find a QueueMetrics
     * @example
     * // Get one QueueMetrics
     * const queueMetrics = await prisma.queueMetrics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QueueMetricsFindFirstOrThrowArgs>(args?: SelectSubset<T, QueueMetricsFindFirstOrThrowArgs<ExtArgs>>): Prisma__QueueMetricsClient<$Result.GetResult<Prisma.$QueueMetricsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QueueMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueMetricsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QueueMetrics
     * const queueMetrics = await prisma.queueMetrics.findMany()
     * 
     * // Get first 10 QueueMetrics
     * const queueMetrics = await prisma.queueMetrics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const queueMetricsWithIdOnly = await prisma.queueMetrics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QueueMetricsFindManyArgs>(args?: SelectSubset<T, QueueMetricsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueueMetricsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QueueMetrics.
     * @param {QueueMetricsCreateArgs} args - Arguments to create a QueueMetrics.
     * @example
     * // Create one QueueMetrics
     * const QueueMetrics = await prisma.queueMetrics.create({
     *   data: {
     *     // ... data to create a QueueMetrics
     *   }
     * })
     * 
     */
    create<T extends QueueMetricsCreateArgs>(args: SelectSubset<T, QueueMetricsCreateArgs<ExtArgs>>): Prisma__QueueMetricsClient<$Result.GetResult<Prisma.$QueueMetricsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QueueMetrics.
     * @param {QueueMetricsCreateManyArgs} args - Arguments to create many QueueMetrics.
     * @example
     * // Create many QueueMetrics
     * const queueMetrics = await prisma.queueMetrics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QueueMetricsCreateManyArgs>(args?: SelectSubset<T, QueueMetricsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QueueMetrics and returns the data saved in the database.
     * @param {QueueMetricsCreateManyAndReturnArgs} args - Arguments to create many QueueMetrics.
     * @example
     * // Create many QueueMetrics
     * const queueMetrics = await prisma.queueMetrics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QueueMetrics and only return the `id`
     * const queueMetricsWithIdOnly = await prisma.queueMetrics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QueueMetricsCreateManyAndReturnArgs>(args?: SelectSubset<T, QueueMetricsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueueMetricsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QueueMetrics.
     * @param {QueueMetricsDeleteArgs} args - Arguments to delete one QueueMetrics.
     * @example
     * // Delete one QueueMetrics
     * const QueueMetrics = await prisma.queueMetrics.delete({
     *   where: {
     *     // ... filter to delete one QueueMetrics
     *   }
     * })
     * 
     */
    delete<T extends QueueMetricsDeleteArgs>(args: SelectSubset<T, QueueMetricsDeleteArgs<ExtArgs>>): Prisma__QueueMetricsClient<$Result.GetResult<Prisma.$QueueMetricsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QueueMetrics.
     * @param {QueueMetricsUpdateArgs} args - Arguments to update one QueueMetrics.
     * @example
     * // Update one QueueMetrics
     * const queueMetrics = await prisma.queueMetrics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QueueMetricsUpdateArgs>(args: SelectSubset<T, QueueMetricsUpdateArgs<ExtArgs>>): Prisma__QueueMetricsClient<$Result.GetResult<Prisma.$QueueMetricsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QueueMetrics.
     * @param {QueueMetricsDeleteManyArgs} args - Arguments to filter QueueMetrics to delete.
     * @example
     * // Delete a few QueueMetrics
     * const { count } = await prisma.queueMetrics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QueueMetricsDeleteManyArgs>(args?: SelectSubset<T, QueueMetricsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QueueMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueMetricsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QueueMetrics
     * const queueMetrics = await prisma.queueMetrics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QueueMetricsUpdateManyArgs>(args: SelectSubset<T, QueueMetricsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QueueMetrics and returns the data updated in the database.
     * @param {QueueMetricsUpdateManyAndReturnArgs} args - Arguments to update many QueueMetrics.
     * @example
     * // Update many QueueMetrics
     * const queueMetrics = await prisma.queueMetrics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QueueMetrics and only return the `id`
     * const queueMetricsWithIdOnly = await prisma.queueMetrics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QueueMetricsUpdateManyAndReturnArgs>(args: SelectSubset<T, QueueMetricsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueueMetricsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QueueMetrics.
     * @param {QueueMetricsUpsertArgs} args - Arguments to update or create a QueueMetrics.
     * @example
     * // Update or create a QueueMetrics
     * const queueMetrics = await prisma.queueMetrics.upsert({
     *   create: {
     *     // ... data to create a QueueMetrics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QueueMetrics we want to update
     *   }
     * })
     */
    upsert<T extends QueueMetricsUpsertArgs>(args: SelectSubset<T, QueueMetricsUpsertArgs<ExtArgs>>): Prisma__QueueMetricsClient<$Result.GetResult<Prisma.$QueueMetricsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QueueMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueMetricsCountArgs} args - Arguments to filter QueueMetrics to count.
     * @example
     * // Count the number of QueueMetrics
     * const count = await prisma.queueMetrics.count({
     *   where: {
     *     // ... the filter for the QueueMetrics we want to count
     *   }
     * })
    **/
    count<T extends QueueMetricsCountArgs>(
      args?: Subset<T, QueueMetricsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QueueMetricsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QueueMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueMetricsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QueueMetricsAggregateArgs>(args: Subset<T, QueueMetricsAggregateArgs>): Prisma.PrismaPromise<GetQueueMetricsAggregateType<T>>

    /**
     * Group by QueueMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueMetricsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QueueMetricsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QueueMetricsGroupByArgs['orderBy'] }
        : { orderBy?: QueueMetricsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QueueMetricsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQueueMetricsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QueueMetrics model
   */
  readonly fields: QueueMetricsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QueueMetrics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QueueMetricsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QueueMetrics model
   */
  interface QueueMetricsFieldRefs {
    readonly id: FieldRef<"QueueMetrics", 'String'>
    readonly queueName: FieldRef<"QueueMetrics", 'String'>
    readonly totalAgents: FieldRef<"QueueMetrics", 'Int'>
    readonly availableAgents: FieldRef<"QueueMetrics", 'Int'>
    readonly totalTickets: FieldRef<"QueueMetrics", 'Int'>
    readonly openTickets: FieldRef<"QueueMetrics", 'Int'>
    readonly avgResponseTime: FieldRef<"QueueMetrics", 'Float'>
    readonly avgResolutionTime: FieldRef<"QueueMetrics", 'Float'>
    readonly slaBreaches: FieldRef<"QueueMetrics", 'Int'>
    readonly highPriorityTickets: FieldRef<"QueueMetrics", 'Int'>
    readonly capacityUtilization: FieldRef<"QueueMetrics", 'Float'>
    readonly averageWaitTime: FieldRef<"QueueMetrics", 'Float'>
    readonly thresholdWarning: FieldRef<"QueueMetrics", 'Boolean'>
    readonly thresholdCritical: FieldRef<"QueueMetrics", 'Boolean'>
    readonly lastCalculated: FieldRef<"QueueMetrics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QueueMetrics findUnique
   */
  export type QueueMetricsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueMetrics
     */
    select?: QueueMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueMetrics
     */
    omit?: QueueMetricsOmit<ExtArgs> | null
    /**
     * Filter, which QueueMetrics to fetch.
     */
    where: QueueMetricsWhereUniqueInput
  }

  /**
   * QueueMetrics findUniqueOrThrow
   */
  export type QueueMetricsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueMetrics
     */
    select?: QueueMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueMetrics
     */
    omit?: QueueMetricsOmit<ExtArgs> | null
    /**
     * Filter, which QueueMetrics to fetch.
     */
    where: QueueMetricsWhereUniqueInput
  }

  /**
   * QueueMetrics findFirst
   */
  export type QueueMetricsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueMetrics
     */
    select?: QueueMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueMetrics
     */
    omit?: QueueMetricsOmit<ExtArgs> | null
    /**
     * Filter, which QueueMetrics to fetch.
     */
    where?: QueueMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueMetrics to fetch.
     */
    orderBy?: QueueMetricsOrderByWithRelationInput | QueueMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QueueMetrics.
     */
    cursor?: QueueMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QueueMetrics.
     */
    distinct?: QueueMetricsScalarFieldEnum | QueueMetricsScalarFieldEnum[]
  }

  /**
   * QueueMetrics findFirstOrThrow
   */
  export type QueueMetricsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueMetrics
     */
    select?: QueueMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueMetrics
     */
    omit?: QueueMetricsOmit<ExtArgs> | null
    /**
     * Filter, which QueueMetrics to fetch.
     */
    where?: QueueMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueMetrics to fetch.
     */
    orderBy?: QueueMetricsOrderByWithRelationInput | QueueMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QueueMetrics.
     */
    cursor?: QueueMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QueueMetrics.
     */
    distinct?: QueueMetricsScalarFieldEnum | QueueMetricsScalarFieldEnum[]
  }

  /**
   * QueueMetrics findMany
   */
  export type QueueMetricsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueMetrics
     */
    select?: QueueMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueMetrics
     */
    omit?: QueueMetricsOmit<ExtArgs> | null
    /**
     * Filter, which QueueMetrics to fetch.
     */
    where?: QueueMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueMetrics to fetch.
     */
    orderBy?: QueueMetricsOrderByWithRelationInput | QueueMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QueueMetrics.
     */
    cursor?: QueueMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueMetrics.
     */
    skip?: number
    distinct?: QueueMetricsScalarFieldEnum | QueueMetricsScalarFieldEnum[]
  }

  /**
   * QueueMetrics create
   */
  export type QueueMetricsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueMetrics
     */
    select?: QueueMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueMetrics
     */
    omit?: QueueMetricsOmit<ExtArgs> | null
    /**
     * The data needed to create a QueueMetrics.
     */
    data: XOR<QueueMetricsCreateInput, QueueMetricsUncheckedCreateInput>
  }

  /**
   * QueueMetrics createMany
   */
  export type QueueMetricsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QueueMetrics.
     */
    data: QueueMetricsCreateManyInput | QueueMetricsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QueueMetrics createManyAndReturn
   */
  export type QueueMetricsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueMetrics
     */
    select?: QueueMetricsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QueueMetrics
     */
    omit?: QueueMetricsOmit<ExtArgs> | null
    /**
     * The data used to create many QueueMetrics.
     */
    data: QueueMetricsCreateManyInput | QueueMetricsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QueueMetrics update
   */
  export type QueueMetricsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueMetrics
     */
    select?: QueueMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueMetrics
     */
    omit?: QueueMetricsOmit<ExtArgs> | null
    /**
     * The data needed to update a QueueMetrics.
     */
    data: XOR<QueueMetricsUpdateInput, QueueMetricsUncheckedUpdateInput>
    /**
     * Choose, which QueueMetrics to update.
     */
    where: QueueMetricsWhereUniqueInput
  }

  /**
   * QueueMetrics updateMany
   */
  export type QueueMetricsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QueueMetrics.
     */
    data: XOR<QueueMetricsUpdateManyMutationInput, QueueMetricsUncheckedUpdateManyInput>
    /**
     * Filter which QueueMetrics to update
     */
    where?: QueueMetricsWhereInput
    /**
     * Limit how many QueueMetrics to update.
     */
    limit?: number
  }

  /**
   * QueueMetrics updateManyAndReturn
   */
  export type QueueMetricsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueMetrics
     */
    select?: QueueMetricsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QueueMetrics
     */
    omit?: QueueMetricsOmit<ExtArgs> | null
    /**
     * The data used to update QueueMetrics.
     */
    data: XOR<QueueMetricsUpdateManyMutationInput, QueueMetricsUncheckedUpdateManyInput>
    /**
     * Filter which QueueMetrics to update
     */
    where?: QueueMetricsWhereInput
    /**
     * Limit how many QueueMetrics to update.
     */
    limit?: number
  }

  /**
   * QueueMetrics upsert
   */
  export type QueueMetricsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueMetrics
     */
    select?: QueueMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueMetrics
     */
    omit?: QueueMetricsOmit<ExtArgs> | null
    /**
     * The filter to search for the QueueMetrics to update in case it exists.
     */
    where: QueueMetricsWhereUniqueInput
    /**
     * In case the QueueMetrics found by the `where` argument doesn't exist, create a new QueueMetrics with this data.
     */
    create: XOR<QueueMetricsCreateInput, QueueMetricsUncheckedCreateInput>
    /**
     * In case the QueueMetrics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QueueMetricsUpdateInput, QueueMetricsUncheckedUpdateInput>
  }

  /**
   * QueueMetrics delete
   */
  export type QueueMetricsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueMetrics
     */
    select?: QueueMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueMetrics
     */
    omit?: QueueMetricsOmit<ExtArgs> | null
    /**
     * Filter which QueueMetrics to delete.
     */
    where: QueueMetricsWhereUniqueInput
  }

  /**
   * QueueMetrics deleteMany
   */
  export type QueueMetricsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QueueMetrics to delete
     */
    where?: QueueMetricsWhereInput
    /**
     * Limit how many QueueMetrics to delete.
     */
    limit?: number
  }

  /**
   * QueueMetrics without action
   */
  export type QueueMetricsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueMetrics
     */
    select?: QueueMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueMetrics
     */
    omit?: QueueMetricsOmit<ExtArgs> | null
  }


  /**
   * Model QueueAlert
   */

  export type AggregateQueueAlert = {
    _count: QueueAlertCountAggregateOutputType | null
    _min: QueueAlertMinAggregateOutputType | null
    _max: QueueAlertMaxAggregateOutputType | null
  }

  export type QueueAlertMinAggregateOutputType = {
    id: string | null
    queueName: string | null
    alertType: string | null
    message: string | null
    isActive: boolean | null
    alertedAt: Date | null
    resolvedAt: Date | null
  }

  export type QueueAlertMaxAggregateOutputType = {
    id: string | null
    queueName: string | null
    alertType: string | null
    message: string | null
    isActive: boolean | null
    alertedAt: Date | null
    resolvedAt: Date | null
  }

  export type QueueAlertCountAggregateOutputType = {
    id: number
    queueName: number
    alertType: number
    message: number
    isActive: number
    alertedAt: number
    resolvedAt: number
    notifiedUsers: number
    _all: number
  }


  export type QueueAlertMinAggregateInputType = {
    id?: true
    queueName?: true
    alertType?: true
    message?: true
    isActive?: true
    alertedAt?: true
    resolvedAt?: true
  }

  export type QueueAlertMaxAggregateInputType = {
    id?: true
    queueName?: true
    alertType?: true
    message?: true
    isActive?: true
    alertedAt?: true
    resolvedAt?: true
  }

  export type QueueAlertCountAggregateInputType = {
    id?: true
    queueName?: true
    alertType?: true
    message?: true
    isActive?: true
    alertedAt?: true
    resolvedAt?: true
    notifiedUsers?: true
    _all?: true
  }

  export type QueueAlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QueueAlert to aggregate.
     */
    where?: QueueAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueAlerts to fetch.
     */
    orderBy?: QueueAlertOrderByWithRelationInput | QueueAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QueueAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QueueAlerts
    **/
    _count?: true | QueueAlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QueueAlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QueueAlertMaxAggregateInputType
  }

  export type GetQueueAlertAggregateType<T extends QueueAlertAggregateArgs> = {
        [P in keyof T & keyof AggregateQueueAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQueueAlert[P]>
      : GetScalarType<T[P], AggregateQueueAlert[P]>
  }




  export type QueueAlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueueAlertWhereInput
    orderBy?: QueueAlertOrderByWithAggregationInput | QueueAlertOrderByWithAggregationInput[]
    by: QueueAlertScalarFieldEnum[] | QueueAlertScalarFieldEnum
    having?: QueueAlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QueueAlertCountAggregateInputType | true
    _min?: QueueAlertMinAggregateInputType
    _max?: QueueAlertMaxAggregateInputType
  }

  export type QueueAlertGroupByOutputType = {
    id: string
    queueName: string
    alertType: string
    message: string
    isActive: boolean
    alertedAt: Date
    resolvedAt: Date | null
    notifiedUsers: string[]
    _count: QueueAlertCountAggregateOutputType | null
    _min: QueueAlertMinAggregateOutputType | null
    _max: QueueAlertMaxAggregateOutputType | null
  }

  type GetQueueAlertGroupByPayload<T extends QueueAlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QueueAlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QueueAlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QueueAlertGroupByOutputType[P]>
            : GetScalarType<T[P], QueueAlertGroupByOutputType[P]>
        }
      >
    >


  export type QueueAlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queueName?: boolean
    alertType?: boolean
    message?: boolean
    isActive?: boolean
    alertedAt?: boolean
    resolvedAt?: boolean
    notifiedUsers?: boolean
  }, ExtArgs["result"]["queueAlert"]>

  export type QueueAlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queueName?: boolean
    alertType?: boolean
    message?: boolean
    isActive?: boolean
    alertedAt?: boolean
    resolvedAt?: boolean
    notifiedUsers?: boolean
  }, ExtArgs["result"]["queueAlert"]>

  export type QueueAlertSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queueName?: boolean
    alertType?: boolean
    message?: boolean
    isActive?: boolean
    alertedAt?: boolean
    resolvedAt?: boolean
    notifiedUsers?: boolean
  }, ExtArgs["result"]["queueAlert"]>

  export type QueueAlertSelectScalar = {
    id?: boolean
    queueName?: boolean
    alertType?: boolean
    message?: boolean
    isActive?: boolean
    alertedAt?: boolean
    resolvedAt?: boolean
    notifiedUsers?: boolean
  }

  export type QueueAlertOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "queueName" | "alertType" | "message" | "isActive" | "alertedAt" | "resolvedAt" | "notifiedUsers", ExtArgs["result"]["queueAlert"]>

  export type $QueueAlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QueueAlert"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      queueName: string
      alertType: string
      message: string
      isActive: boolean
      alertedAt: Date
      resolvedAt: Date | null
      notifiedUsers: string[]
    }, ExtArgs["result"]["queueAlert"]>
    composites: {}
  }

  type QueueAlertGetPayload<S extends boolean | null | undefined | QueueAlertDefaultArgs> = $Result.GetResult<Prisma.$QueueAlertPayload, S>

  type QueueAlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QueueAlertFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QueueAlertCountAggregateInputType | true
    }

  export interface QueueAlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QueueAlert'], meta: { name: 'QueueAlert' } }
    /**
     * Find zero or one QueueAlert that matches the filter.
     * @param {QueueAlertFindUniqueArgs} args - Arguments to find a QueueAlert
     * @example
     * // Get one QueueAlert
     * const queueAlert = await prisma.queueAlert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QueueAlertFindUniqueArgs>(args: SelectSubset<T, QueueAlertFindUniqueArgs<ExtArgs>>): Prisma__QueueAlertClient<$Result.GetResult<Prisma.$QueueAlertPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QueueAlert that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QueueAlertFindUniqueOrThrowArgs} args - Arguments to find a QueueAlert
     * @example
     * // Get one QueueAlert
     * const queueAlert = await prisma.queueAlert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QueueAlertFindUniqueOrThrowArgs>(args: SelectSubset<T, QueueAlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QueueAlertClient<$Result.GetResult<Prisma.$QueueAlertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QueueAlert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueAlertFindFirstArgs} args - Arguments to find a QueueAlert
     * @example
     * // Get one QueueAlert
     * const queueAlert = await prisma.queueAlert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QueueAlertFindFirstArgs>(args?: SelectSubset<T, QueueAlertFindFirstArgs<ExtArgs>>): Prisma__QueueAlertClient<$Result.GetResult<Prisma.$QueueAlertPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QueueAlert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueAlertFindFirstOrThrowArgs} args - Arguments to find a QueueAlert
     * @example
     * // Get one QueueAlert
     * const queueAlert = await prisma.queueAlert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QueueAlertFindFirstOrThrowArgs>(args?: SelectSubset<T, QueueAlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__QueueAlertClient<$Result.GetResult<Prisma.$QueueAlertPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QueueAlerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueAlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QueueAlerts
     * const queueAlerts = await prisma.queueAlert.findMany()
     * 
     * // Get first 10 QueueAlerts
     * const queueAlerts = await prisma.queueAlert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const queueAlertWithIdOnly = await prisma.queueAlert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QueueAlertFindManyArgs>(args?: SelectSubset<T, QueueAlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueueAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QueueAlert.
     * @param {QueueAlertCreateArgs} args - Arguments to create a QueueAlert.
     * @example
     * // Create one QueueAlert
     * const QueueAlert = await prisma.queueAlert.create({
     *   data: {
     *     // ... data to create a QueueAlert
     *   }
     * })
     * 
     */
    create<T extends QueueAlertCreateArgs>(args: SelectSubset<T, QueueAlertCreateArgs<ExtArgs>>): Prisma__QueueAlertClient<$Result.GetResult<Prisma.$QueueAlertPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QueueAlerts.
     * @param {QueueAlertCreateManyArgs} args - Arguments to create many QueueAlerts.
     * @example
     * // Create many QueueAlerts
     * const queueAlert = await prisma.queueAlert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QueueAlertCreateManyArgs>(args?: SelectSubset<T, QueueAlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QueueAlerts and returns the data saved in the database.
     * @param {QueueAlertCreateManyAndReturnArgs} args - Arguments to create many QueueAlerts.
     * @example
     * // Create many QueueAlerts
     * const queueAlert = await prisma.queueAlert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QueueAlerts and only return the `id`
     * const queueAlertWithIdOnly = await prisma.queueAlert.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QueueAlertCreateManyAndReturnArgs>(args?: SelectSubset<T, QueueAlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueueAlertPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QueueAlert.
     * @param {QueueAlertDeleteArgs} args - Arguments to delete one QueueAlert.
     * @example
     * // Delete one QueueAlert
     * const QueueAlert = await prisma.queueAlert.delete({
     *   where: {
     *     // ... filter to delete one QueueAlert
     *   }
     * })
     * 
     */
    delete<T extends QueueAlertDeleteArgs>(args: SelectSubset<T, QueueAlertDeleteArgs<ExtArgs>>): Prisma__QueueAlertClient<$Result.GetResult<Prisma.$QueueAlertPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QueueAlert.
     * @param {QueueAlertUpdateArgs} args - Arguments to update one QueueAlert.
     * @example
     * // Update one QueueAlert
     * const queueAlert = await prisma.queueAlert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QueueAlertUpdateArgs>(args: SelectSubset<T, QueueAlertUpdateArgs<ExtArgs>>): Prisma__QueueAlertClient<$Result.GetResult<Prisma.$QueueAlertPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QueueAlerts.
     * @param {QueueAlertDeleteManyArgs} args - Arguments to filter QueueAlerts to delete.
     * @example
     * // Delete a few QueueAlerts
     * const { count } = await prisma.queueAlert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QueueAlertDeleteManyArgs>(args?: SelectSubset<T, QueueAlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QueueAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueAlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QueueAlerts
     * const queueAlert = await prisma.queueAlert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QueueAlertUpdateManyArgs>(args: SelectSubset<T, QueueAlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QueueAlerts and returns the data updated in the database.
     * @param {QueueAlertUpdateManyAndReturnArgs} args - Arguments to update many QueueAlerts.
     * @example
     * // Update many QueueAlerts
     * const queueAlert = await prisma.queueAlert.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QueueAlerts and only return the `id`
     * const queueAlertWithIdOnly = await prisma.queueAlert.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QueueAlertUpdateManyAndReturnArgs>(args: SelectSubset<T, QueueAlertUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueueAlertPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QueueAlert.
     * @param {QueueAlertUpsertArgs} args - Arguments to update or create a QueueAlert.
     * @example
     * // Update or create a QueueAlert
     * const queueAlert = await prisma.queueAlert.upsert({
     *   create: {
     *     // ... data to create a QueueAlert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QueueAlert we want to update
     *   }
     * })
     */
    upsert<T extends QueueAlertUpsertArgs>(args: SelectSubset<T, QueueAlertUpsertArgs<ExtArgs>>): Prisma__QueueAlertClient<$Result.GetResult<Prisma.$QueueAlertPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QueueAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueAlertCountArgs} args - Arguments to filter QueueAlerts to count.
     * @example
     * // Count the number of QueueAlerts
     * const count = await prisma.queueAlert.count({
     *   where: {
     *     // ... the filter for the QueueAlerts we want to count
     *   }
     * })
    **/
    count<T extends QueueAlertCountArgs>(
      args?: Subset<T, QueueAlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QueueAlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QueueAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueAlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QueueAlertAggregateArgs>(args: Subset<T, QueueAlertAggregateArgs>): Prisma.PrismaPromise<GetQueueAlertAggregateType<T>>

    /**
     * Group by QueueAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueAlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QueueAlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QueueAlertGroupByArgs['orderBy'] }
        : { orderBy?: QueueAlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QueueAlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQueueAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QueueAlert model
   */
  readonly fields: QueueAlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QueueAlert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QueueAlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QueueAlert model
   */
  interface QueueAlertFieldRefs {
    readonly id: FieldRef<"QueueAlert", 'String'>
    readonly queueName: FieldRef<"QueueAlert", 'String'>
    readonly alertType: FieldRef<"QueueAlert", 'String'>
    readonly message: FieldRef<"QueueAlert", 'String'>
    readonly isActive: FieldRef<"QueueAlert", 'Boolean'>
    readonly alertedAt: FieldRef<"QueueAlert", 'DateTime'>
    readonly resolvedAt: FieldRef<"QueueAlert", 'DateTime'>
    readonly notifiedUsers: FieldRef<"QueueAlert", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * QueueAlert findUnique
   */
  export type QueueAlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueAlert
     */
    select?: QueueAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueAlert
     */
    omit?: QueueAlertOmit<ExtArgs> | null
    /**
     * Filter, which QueueAlert to fetch.
     */
    where: QueueAlertWhereUniqueInput
  }

  /**
   * QueueAlert findUniqueOrThrow
   */
  export type QueueAlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueAlert
     */
    select?: QueueAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueAlert
     */
    omit?: QueueAlertOmit<ExtArgs> | null
    /**
     * Filter, which QueueAlert to fetch.
     */
    where: QueueAlertWhereUniqueInput
  }

  /**
   * QueueAlert findFirst
   */
  export type QueueAlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueAlert
     */
    select?: QueueAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueAlert
     */
    omit?: QueueAlertOmit<ExtArgs> | null
    /**
     * Filter, which QueueAlert to fetch.
     */
    where?: QueueAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueAlerts to fetch.
     */
    orderBy?: QueueAlertOrderByWithRelationInput | QueueAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QueueAlerts.
     */
    cursor?: QueueAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QueueAlerts.
     */
    distinct?: QueueAlertScalarFieldEnum | QueueAlertScalarFieldEnum[]
  }

  /**
   * QueueAlert findFirstOrThrow
   */
  export type QueueAlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueAlert
     */
    select?: QueueAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueAlert
     */
    omit?: QueueAlertOmit<ExtArgs> | null
    /**
     * Filter, which QueueAlert to fetch.
     */
    where?: QueueAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueAlerts to fetch.
     */
    orderBy?: QueueAlertOrderByWithRelationInput | QueueAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QueueAlerts.
     */
    cursor?: QueueAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QueueAlerts.
     */
    distinct?: QueueAlertScalarFieldEnum | QueueAlertScalarFieldEnum[]
  }

  /**
   * QueueAlert findMany
   */
  export type QueueAlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueAlert
     */
    select?: QueueAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueAlert
     */
    omit?: QueueAlertOmit<ExtArgs> | null
    /**
     * Filter, which QueueAlerts to fetch.
     */
    where?: QueueAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueAlerts to fetch.
     */
    orderBy?: QueueAlertOrderByWithRelationInput | QueueAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QueueAlerts.
     */
    cursor?: QueueAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueAlerts.
     */
    skip?: number
    distinct?: QueueAlertScalarFieldEnum | QueueAlertScalarFieldEnum[]
  }

  /**
   * QueueAlert create
   */
  export type QueueAlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueAlert
     */
    select?: QueueAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueAlert
     */
    omit?: QueueAlertOmit<ExtArgs> | null
    /**
     * The data needed to create a QueueAlert.
     */
    data: XOR<QueueAlertCreateInput, QueueAlertUncheckedCreateInput>
  }

  /**
   * QueueAlert createMany
   */
  export type QueueAlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QueueAlerts.
     */
    data: QueueAlertCreateManyInput | QueueAlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QueueAlert createManyAndReturn
   */
  export type QueueAlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueAlert
     */
    select?: QueueAlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QueueAlert
     */
    omit?: QueueAlertOmit<ExtArgs> | null
    /**
     * The data used to create many QueueAlerts.
     */
    data: QueueAlertCreateManyInput | QueueAlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QueueAlert update
   */
  export type QueueAlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueAlert
     */
    select?: QueueAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueAlert
     */
    omit?: QueueAlertOmit<ExtArgs> | null
    /**
     * The data needed to update a QueueAlert.
     */
    data: XOR<QueueAlertUpdateInput, QueueAlertUncheckedUpdateInput>
    /**
     * Choose, which QueueAlert to update.
     */
    where: QueueAlertWhereUniqueInput
  }

  /**
   * QueueAlert updateMany
   */
  export type QueueAlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QueueAlerts.
     */
    data: XOR<QueueAlertUpdateManyMutationInput, QueueAlertUncheckedUpdateManyInput>
    /**
     * Filter which QueueAlerts to update
     */
    where?: QueueAlertWhereInput
    /**
     * Limit how many QueueAlerts to update.
     */
    limit?: number
  }

  /**
   * QueueAlert updateManyAndReturn
   */
  export type QueueAlertUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueAlert
     */
    select?: QueueAlertSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QueueAlert
     */
    omit?: QueueAlertOmit<ExtArgs> | null
    /**
     * The data used to update QueueAlerts.
     */
    data: XOR<QueueAlertUpdateManyMutationInput, QueueAlertUncheckedUpdateManyInput>
    /**
     * Filter which QueueAlerts to update
     */
    where?: QueueAlertWhereInput
    /**
     * Limit how many QueueAlerts to update.
     */
    limit?: number
  }

  /**
   * QueueAlert upsert
   */
  export type QueueAlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueAlert
     */
    select?: QueueAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueAlert
     */
    omit?: QueueAlertOmit<ExtArgs> | null
    /**
     * The filter to search for the QueueAlert to update in case it exists.
     */
    where: QueueAlertWhereUniqueInput
    /**
     * In case the QueueAlert found by the `where` argument doesn't exist, create a new QueueAlert with this data.
     */
    create: XOR<QueueAlertCreateInput, QueueAlertUncheckedCreateInput>
    /**
     * In case the QueueAlert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QueueAlertUpdateInput, QueueAlertUncheckedUpdateInput>
  }

  /**
   * QueueAlert delete
   */
  export type QueueAlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueAlert
     */
    select?: QueueAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueAlert
     */
    omit?: QueueAlertOmit<ExtArgs> | null
    /**
     * Filter which QueueAlert to delete.
     */
    where: QueueAlertWhereUniqueInput
  }

  /**
   * QueueAlert deleteMany
   */
  export type QueueAlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QueueAlerts to delete
     */
    where?: QueueAlertWhereInput
    /**
     * Limit how many QueueAlerts to delete.
     */
    limit?: number
  }

  /**
   * QueueAlert without action
   */
  export type QueueAlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueAlert
     */
    select?: QueueAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueAlert
     */
    omit?: QueueAlertOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    passwordHash: 'passwordHash',
    disabled: 'disabled',
    isDefault: 'isDefault',
    lastLogin: 'lastLogin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    twoFactorEnabled: 'twoFactorEnabled',
    twoFactorSecret: 'twoFactorSecret',
    twoFactorBackupCodes: 'twoFactorBackupCodes',
    twoFactorVerified: 'twoFactorVerified',
    samlNameId: 'samlNameId',
    samlSessionIndex: 'samlSessionIndex',
    scimExternalId: 'scimExternalId',
    department: 'department',
    lastSamlLogin: 'lastSamlLogin',
    isVip: 'isVip',
    vipLevel: 'vipLevel',
    vipSlaOverride: 'vipSlaOverride'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    resource: 'resource',
    action: 'action',
    createdAt: 'createdAt'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    userId: 'userId',
    roleId: 'roleId',
    assignedAt: 'assignedAt'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const RolePermissionScalarFieldEnum: {
    roleId: 'roleId',
    permissionId: 'permissionId',
    assignedAt: 'assignedAt'
  };

  export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


  export const PasskeyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    credentialId: 'credentialId',
    publicKey: 'publicKey',
    counter: 'counter',
    transports: 'transports',
    deviceType: 'deviceType',
    backedUp: 'backedUp',
    createdAt: 'createdAt',
    lastUsed: 'lastUsed'
  };

  export type PasskeyScalarFieldEnum = (typeof PasskeyScalarFieldEnum)[keyof typeof PasskeyScalarFieldEnum]


  export const LogScalarFieldEnum: {
    id: 'id',
    ticketId: 'ticketId',
    name: 'name',
    email: 'email',
    title: 'title',
    system: 'system',
    urgency: 'urgency',
    timestamp: 'timestamp',
    emailStatus: 'emailStatus',
    userId: 'userId'
  };

  export type LogScalarFieldEnum = (typeof LogScalarFieldEnum)[keyof typeof LogScalarFieldEnum]


  export const ConfigScalarFieldEnum: {
    key: 'key',
    value: 'value',
    valueType: 'valueType',
    description: 'description',
    isPublic: 'isPublic',
    category: 'category',
    subcategory: 'subcategory',
    isUIEditable: 'isUIEditable',
    isRequired: 'isRequired',
    defaultValue: 'defaultValue',
    validationRules: 'validationRules',
    displayOrder: 'displayOrder',
    helpText: 'helpText',
    isAdvanced: 'isAdvanced',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type ConfigScalarFieldEnum = (typeof ConfigScalarFieldEnum)[keyof typeof ConfigScalarFieldEnum]


  export const ConfigHistoryScalarFieldEnum: {
    id: 'id',
    configKey: 'configKey',
    oldValue: 'oldValue',
    newValue: 'newValue',
    changedBy: 'changedBy',
    changeReason: 'changeReason',
    createdAt: 'createdAt'
  };

  export type ConfigHistoryScalarFieldEnum = (typeof ConfigHistoryScalarFieldEnum)[keyof typeof ConfigHistoryScalarFieldEnum]


  export const ConfigTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category',
    template: 'template',
    isDefault: 'isDefault',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConfigTemplateScalarFieldEnum = (typeof ConfigTemplateScalarFieldEnum)[keyof typeof ConfigTemplateScalarFieldEnum]


  export const KioskScalarFieldEnum: {
    id: 'id',
    lastSeen: 'lastSeen',
    version: 'version',
    active: 'active',
    logoUrl: 'logoUrl',
    bgUrl: 'bgUrl',
    statusEnabled: 'statusEnabled',
    currentStatus: 'currentStatus',
    openMsg: 'openMsg',
    closedMsg: 'closedMsg',
    errorMsg: 'errorMsg',
    meetingMsg: 'meetingMsg',
    brbMsg: 'brbMsg',
    lunchMsg: 'lunchMsg',
    unavailableMsg: 'unavailableMsg',
    schedule: 'schedule',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KioskScalarFieldEnum = (typeof KioskScalarFieldEnum)[keyof typeof KioskScalarFieldEnum]


  export const FeedbackScalarFieldEnum: {
    id: 'id',
    name: 'name',
    message: 'message',
    timestamp: 'timestamp',
    userId: 'userId'
  };

  export type FeedbackScalarFieldEnum = (typeof FeedbackScalarFieldEnum)[keyof typeof FeedbackScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    message: 'message',
    level: 'level',
    active: 'active',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const DirectoryIntegrationScalarFieldEnum: {
    id: 'id',
    provider: 'provider',
    settings: 'settings',
    enabled: 'enabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DirectoryIntegrationScalarFieldEnum = (typeof DirectoryIntegrationScalarFieldEnum)[keyof typeof DirectoryIntegrationScalarFieldEnum]


  export const AssetScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    filename: 'filename',
    url: 'url',
    sizeBytes: 'sizeBytes',
    mimeType: 'mimeType',
    uploadedAt: 'uploadedAt'
  };

  export type AssetScalarFieldEnum = (typeof AssetScalarFieldEnum)[keyof typeof AssetScalarFieldEnum]


  export const KioskActivationScalarFieldEnum: {
    id: 'id',
    code: 'code',
    qrCode: 'qrCode',
    expiresAt: 'expiresAt',
    used: 'used',
    usedAt: 'usedAt',
    createdAt: 'createdAt',
    kioskId: 'kioskId'
  };

  export type KioskActivationScalarFieldEnum = (typeof KioskActivationScalarFieldEnum)[keyof typeof KioskActivationScalarFieldEnum]


  export const SsoConfigurationScalarFieldEnum: {
    id: 'id',
    provider: 'provider',
    enabled: 'enabled',
    configuration: 'configuration',
    updatedAt: 'updatedAt'
  };

  export type SsoConfigurationScalarFieldEnum = (typeof SsoConfigurationScalarFieldEnum)[keyof typeof SsoConfigurationScalarFieldEnum]


  export const AdminPinScalarFieldEnum: {
    id: 'id',
    globalPin: 'globalPin',
    kioskPins: 'kioskPins',
    updatedAt: 'updatedAt'
  };

  export type AdminPinScalarFieldEnum = (typeof AdminPinScalarFieldEnum)[keyof typeof AdminPinScalarFieldEnum]


  export const KbArticleScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    title: 'title',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    authorId: 'authorId',
    currentVersionId: 'currentVersionId',
    isPublished: 'isPublished',
    tags: 'tags'
  };

  export type KbArticleScalarFieldEnum = (typeof KbArticleScalarFieldEnum)[keyof typeof KbArticleScalarFieldEnum]


  export const KbArticleVersionScalarFieldEnum: {
    id: 'id',
    articleId: 'articleId',
    content: 'content',
    summary: 'summary',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    authorId: 'authorId',
    version: 'version',
    isApproved: 'isApproved'
  };

  export type KbArticleVersionScalarFieldEnum = (typeof KbArticleVersionScalarFieldEnum)[keyof typeof KbArticleVersionScalarFieldEnum]


  export const KbArticleCommentScalarFieldEnum: {
    id: 'id',
    articleId: 'articleId',
    userId: 'userId',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted'
  };

  export type KbArticleCommentScalarFieldEnum = (typeof KbArticleCommentScalarFieldEnum)[keyof typeof KbArticleCommentScalarFieldEnum]


  export const SupportTicketScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    assigneeId: 'assigneeId',
    vipPriorityScore: 'vipPriorityScore',
    vipTriggerSource: 'vipTriggerSource'
  };

  export type SupportTicketScalarFieldEnum = (typeof SupportTicketScalarFieldEnum)[keyof typeof SupportTicketScalarFieldEnum]


  export const InventoryAssetScalarFieldEnum: {
    id: 'id',
    assetTag: 'assetTag',
    typeId: 'typeId',
    serialNumber: 'serialNumber',
    model: 'model',
    vendorId: 'vendorId',
    purchaseDate: 'purchaseDate',
    warrantyExpiry: 'warrantyExpiry',
    assignedToUserId: 'assignedToUserId',
    assignedToOrgId: 'assignedToOrgId',
    assignedToCustomerId: 'assignedToCustomerId',
    department: 'department',
    status: 'status',
    locationId: 'locationId',
    kioskId: 'kioskId',
    customFields: 'customFields',
    notes: 'notes',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    serialNumberEnc: 'serialNumberEnc',
    warrantyInfoEnc: 'warrantyInfoEnc',
    purchaseInfoEnc: 'purchaseInfoEnc',
    maintenanceNotesEnc: 'maintenanceNotesEnc',
    warrantyAlertDays: 'warrantyAlertDays',
    warrantyAlertEnabled: 'warrantyAlertEnabled',
    lastWarrantyAlertSent: 'lastWarrantyAlertSent',
    importBatchId: 'importBatchId',
    importSource: 'importSource',
    importValidated: 'importValidated',
    validationErrors: 'validationErrors'
  };

  export type InventoryAssetScalarFieldEnum = (typeof InventoryAssetScalarFieldEnum)[keyof typeof InventoryAssetScalarFieldEnum]


  export const AssetStatusLogScalarFieldEnum: {
    id: 'id',
    assetId: 'assetId',
    previousStatus: 'previousStatus',
    newStatus: 'newStatus',
    changedByUserId: 'changedByUserId',
    notes: 'notes',
    timestamp: 'timestamp'
  };

  export type AssetStatusLogScalarFieldEnum = (typeof AssetStatusLogScalarFieldEnum)[keyof typeof AssetStatusLogScalarFieldEnum]


  export const AssetAssignmentScalarFieldEnum: {
    id: 'id',
    assetId: 'assetId',
    userId: 'userId',
    orgId: 'orgId',
    customerId: 'customerId',
    assignedBy: 'assignedBy',
    assignedDate: 'assignedDate',
    expectedReturn: 'expectedReturn',
    returnDate: 'returnDate',
    managerId: 'managerId'
  };

  export type AssetAssignmentScalarFieldEnum = (typeof AssetAssignmentScalarFieldEnum)[keyof typeof AssetAssignmentScalarFieldEnum]


  export const AssetTicketHistoryScalarFieldEnum: {
    id: 'id',
    assetId: 'assetId',
    ticketId: 'ticketId',
    relationshipType: 'relationshipType',
    createdAt: 'createdAt',
    endedAt: 'endedAt',
    createdBy: 'createdBy',
    notes: 'notes'
  };

  export type AssetTicketHistoryScalarFieldEnum = (typeof AssetTicketHistoryScalarFieldEnum)[keyof typeof AssetTicketHistoryScalarFieldEnum]


  export const AssetWarrantyAlertScalarFieldEnum: {
    id: 'id',
    assetId: 'assetId',
    alertType: 'alertType',
    alertDate: 'alertDate',
    expiryDate: 'expiryDate',
    daysRemaining: 'daysRemaining',
    notificationSent: 'notificationSent',
    notificationSentAt: 'notificationSentAt',
    dismissed: 'dismissed',
    dismissedBy: 'dismissedBy',
    dismissedAt: 'dismissedAt'
  };

  export type AssetWarrantyAlertScalarFieldEnum = (typeof AssetWarrantyAlertScalarFieldEnum)[keyof typeof AssetWarrantyAlertScalarFieldEnum]


  export const AssetImportBatchScalarFieldEnum: {
    id: 'id',
    filename: 'filename',
    importedBy: 'importedBy',
    importDate: 'importDate',
    totalRecords: 'totalRecords',
    successfulRecords: 'successfulRecords',
    failedRecords: 'failedRecords',
    validationStatus: 'validationStatus',
    validationErrors: 'validationErrors',
    rollbackDate: 'rollbackDate',
    rollbackBy: 'rollbackBy'
  };

  export type AssetImportBatchScalarFieldEnum = (typeof AssetImportBatchScalarFieldEnum)[keyof typeof AssetImportBatchScalarFieldEnum]


  export const AssetValidationLogScalarFieldEnum: {
    id: 'id',
    batchId: 'batchId',
    assetId: 'assetId',
    rowNumber: 'rowNumber',
    validationLevel: 'validationLevel',
    fieldName: 'fieldName',
    message: 'message',
    rawData: 'rawData',
    createdAt: 'createdAt'
  };

  export type AssetValidationLogScalarFieldEnum = (typeof AssetValidationLogScalarFieldEnum)[keyof typeof AssetValidationLogScalarFieldEnum]


  export const KioskAssetRegistryScalarFieldEnum: {
    id: 'id',
    kioskId: 'kioskId',
    assetId: 'assetId',
    registrationDate: 'registrationDate',
    lastCheckIn: 'lastCheckIn',
    status: 'status',
    helixSyncStatus: 'helixSyncStatus',
    helixLastSync: 'helixLastSync',
    helixErrorMessage: 'helixErrorMessage',
    encryptedMetadata: 'encryptedMetadata',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type KioskAssetRegistryScalarFieldEnum = (typeof KioskAssetRegistryScalarFieldEnum)[keyof typeof KioskAssetRegistryScalarFieldEnum]


  export const HelixSyncFailureScalarFieldEnum: {
    id: 'id',
    kioskId: 'kioskId',
    assetId: 'assetId',
    errorMessage: 'errorMessage',
    metadata: 'metadata',
    retryCount: 'retryCount',
    nextRetryAt: 'nextRetryAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HelixSyncFailureScalarFieldEnum = (typeof HelixSyncFailureScalarFieldEnum)[keyof typeof HelixSyncFailureScalarFieldEnum]


  export const KioskOrganizationAssignmentScalarFieldEnum: {
    id: 'id',
    kioskId: 'kioskId',
    organizationId: 'organizationId',
    department: 'department',
    floor: 'floor',
    room: 'room',
    building: 'building',
    assignedBy: 'assignedBy',
    assignmentMetadata: 'assignmentMetadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KioskOrganizationAssignmentScalarFieldEnum = (typeof KioskOrganizationAssignmentScalarFieldEnum)[keyof typeof KioskOrganizationAssignmentScalarFieldEnum]


  export const KioskMetadataLogScalarFieldEnum: {
    id: 'id',
    kioskId: 'kioskId',
    metadataType: 'metadataType',
    encryptedMetadata: 'encryptedMetadata',
    collectionTimestamp: 'collectionTimestamp'
  };

  export type KioskMetadataLogScalarFieldEnum = (typeof KioskMetadataLogScalarFieldEnum)[keyof typeof KioskMetadataLogScalarFieldEnum]


  export const XpEventScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    amount: 'amount',
    reason: 'reason',
    createdAt: 'createdAt'
  };

  export type XpEventScalarFieldEnum = (typeof XpEventScalarFieldEnum)[keyof typeof XpEventScalarFieldEnum]


  export const LeaderboardScalarFieldEnum: {
    userId: 'userId',
    xpTotal: 'xpTotal'
  };

  export type LeaderboardScalarFieldEnum = (typeof LeaderboardScalarFieldEnum)[keyof typeof LeaderboardScalarFieldEnum]


  export const ScimMappingScalarFieldEnum: {
    id: 'id',
    externalId: 'externalId',
    userId: 'userId',
    provider: 'provider',
    syncTime: 'syncTime'
  };

  export type ScimMappingScalarFieldEnum = (typeof ScimMappingScalarFieldEnum)[keyof typeof ScimMappingScalarFieldEnum]


  export const ScimLogScalarFieldEnum: {
    id: 'id',
    operation: 'operation',
    entityType: 'entityType',
    entityId: 'entityId',
    statusCode: 'statusCode',
    message: 'message',
    requestBody: 'requestBody',
    responseBody: 'responseBody',
    userAgent: 'userAgent',
    ipAddress: 'ipAddress',
    duration: 'duration',
    createdAt: 'createdAt'
  };

  export type ScimLogScalarFieldEnum = (typeof ScimLogScalarFieldEnum)[keyof typeof ScimLogScalarFieldEnum]


  export const MailroomPackageScalarFieldEnum: {
    id: 'id',
    trackingNumber: 'trackingNumber',
    carrier: 'carrier',
    sender: 'sender',
    recipientId: 'recipientId',
    department: 'department',
    packageType: 'packageType',
    status: 'status',
    assignedLocation: 'assignedLocation',
    linkedTicketId: 'linkedTicketId',
    linkedAssetId: 'linkedAssetId',
    flags: 'flags',
    intakePhotoUrl: 'intakePhotoUrl',
    deliveryPhotoUrl: 'deliveryPhotoUrl',
    signatureUrl: 'signatureUrl',
    intakeLocation: 'intakeLocation',
    deliveryLocation: 'deliveryLocation',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MailroomPackageScalarFieldEnum = (typeof MailroomPackageScalarFieldEnum)[keyof typeof MailroomPackageScalarFieldEnum]


  export const DeliveryEventScalarFieldEnum: {
    id: 'id',
    packageId: 'packageId',
    eventType: 'eventType',
    performedBy: 'performedBy',
    location: 'location',
    timestamp: 'timestamp',
    photoUrl: 'photoUrl',
    signatureBlob: 'signatureBlob'
  };

  export type DeliveryEventScalarFieldEnum = (typeof DeliveryEventScalarFieldEnum)[keyof typeof DeliveryEventScalarFieldEnum]


  export const ProxyAuthorizationScalarFieldEnum: {
    id: 'id',
    recipientId: 'recipientId',
    proxyId: 'proxyId',
    packageId: 'packageId',
    expiration: 'expiration',
    status: 'status'
  };

  export type ProxyAuthorizationScalarFieldEnum = (typeof ProxyAuthorizationScalarFieldEnum)[keyof typeof ProxyAuthorizationScalarFieldEnum]


  export const RequestCatalogItemScalarFieldEnum: {
    id: 'id',
    name: 'name',
    formSchema: 'formSchema',
    workflowId: 'workflowId'
  };

  export type RequestCatalogItemScalarFieldEnum = (typeof RequestCatalogItemScalarFieldEnum)[keyof typeof RequestCatalogItemScalarFieldEnum]


  export const RITMScalarFieldEnum: {
    id: 'id',
    reqId: 'reqId',
    catalogItemId: 'catalogItemId',
    status: 'status'
  };

  export type RITMScalarFieldEnum = (typeof RITMScalarFieldEnum)[keyof typeof RITMScalarFieldEnum]


  export const VipProxyScalarFieldEnum: {
    id: 'id',
    vipId: 'vipId',
    proxyId: 'proxyId',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type VipProxyScalarFieldEnum = (typeof VipProxyScalarFieldEnum)[keyof typeof VipProxyScalarFieldEnum]


  export const VipSlaHistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    sla: 'sla',
    effectiveAt: 'effectiveAt',
    endedAt: 'endedAt'
  };

  export type VipSlaHistoryScalarFieldEnum = (typeof VipSlaHistoryScalarFieldEnum)[keyof typeof VipSlaHistoryScalarFieldEnum]


  export const AgentAvailabilityScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    queueName: 'queueName',
    isAvailable: 'isAvailable',
    maxCapacity: 'maxCapacity',
    currentLoad: 'currentLoad',
    status: 'status',
    lastUpdated: 'lastUpdated',
    createdAt: 'createdAt'
  };

  export type AgentAvailabilityScalarFieldEnum = (typeof AgentAvailabilityScalarFieldEnum)[keyof typeof AgentAvailabilityScalarFieldEnum]


  export const QueueMetricsScalarFieldEnum: {
    id: 'id',
    queueName: 'queueName',
    totalAgents: 'totalAgents',
    availableAgents: 'availableAgents',
    totalTickets: 'totalTickets',
    openTickets: 'openTickets',
    avgResponseTime: 'avgResponseTime',
    avgResolutionTime: 'avgResolutionTime',
    slaBreaches: 'slaBreaches',
    highPriorityTickets: 'highPriorityTickets',
    capacityUtilization: 'capacityUtilization',
    averageWaitTime: 'averageWaitTime',
    thresholdWarning: 'thresholdWarning',
    thresholdCritical: 'thresholdCritical',
    lastCalculated: 'lastCalculated'
  };

  export type QueueMetricsScalarFieldEnum = (typeof QueueMetricsScalarFieldEnum)[keyof typeof QueueMetricsScalarFieldEnum]


  export const QueueAlertScalarFieldEnum: {
    id: 'id',
    queueName: 'queueName',
    alertType: 'alertType',
    message: 'message',
    isActive: 'isActive',
    alertedAt: 'alertedAt',
    resolvedAt: 'resolvedAt',
    notifiedUsers: 'notifiedUsers'
  };

  export type QueueAlertScalarFieldEnum = (typeof QueueAlertScalarFieldEnum)[keyof typeof QueueAlertScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    passwordHash?: StringNullableFilter<"User"> | string | null
    disabled?: BoolFilter<"User"> | boolean
    isDefault?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    twoFactorBackupCodes?: JsonNullableFilter<"User">
    twoFactorVerified?: BoolFilter<"User"> | boolean
    samlNameId?: StringNullableFilter<"User"> | string | null
    samlSessionIndex?: StringNullableFilter<"User"> | string | null
    scimExternalId?: StringNullableFilter<"User"> | string | null
    department?: StringNullableFilter<"User"> | string | null
    lastSamlLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    isVip?: BoolFilter<"User"> | boolean
    vipLevel?: StringNullableFilter<"User"> | string | null
    vipSlaOverride?: JsonNullableFilter<"User">
    feedback?: FeedbackListRelationFilter
    logs?: LogListRelationFilter
    passkeys?: PasskeyListRelationFilter
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketListRelationFilter
    support_tickets_support_tickets_userIdTousers?: SupportTicketListRelationFilter
    roles?: UserRoleListRelationFilter
    scimMappings?: ScimMappingListRelationFilter
    kbArticlesAuthored?: KbArticleListRelationFilter
    kbArticleVersionsAuthored?: KbArticleVersionListRelationFilter
    kbArticleComments?: KbArticleCommentListRelationFilter
    xpEvents?: XpEventListRelationFilter
    leaderboard?: XOR<LeaderboardNullableScalarRelationFilter, LeaderboardWhereInput> | null
    mailroomPackages?: MailroomPackageListRelationFilter
    deliveryEvents?: DeliveryEventListRelationFilter
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationListRelationFilter
    proxyAuthorizationsAsProxy?: ProxyAuthorizationListRelationFilter
    vipProxiesAsVip?: VipProxyListRelationFilter
    vipProxiesAsProxy?: VipProxyListRelationFilter
    vipSlaHistory?: VipSlaHistoryListRelationFilter
    agentAvailability?: AgentAvailabilityListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    disabled?: SortOrder
    isDefault?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    twoFactorBackupCodes?: SortOrderInput | SortOrder
    twoFactorVerified?: SortOrder
    samlNameId?: SortOrderInput | SortOrder
    samlSessionIndex?: SortOrderInput | SortOrder
    scimExternalId?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    lastSamlLogin?: SortOrderInput | SortOrder
    isVip?: SortOrder
    vipLevel?: SortOrderInput | SortOrder
    vipSlaOverride?: SortOrderInput | SortOrder
    feedback?: FeedbackOrderByRelationAggregateInput
    logs?: LogOrderByRelationAggregateInput
    passkeys?: PasskeyOrderByRelationAggregateInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketOrderByRelationAggregateInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketOrderByRelationAggregateInput
    roles?: UserRoleOrderByRelationAggregateInput
    scimMappings?: ScimMappingOrderByRelationAggregateInput
    kbArticlesAuthored?: KbArticleOrderByRelationAggregateInput
    kbArticleVersionsAuthored?: KbArticleVersionOrderByRelationAggregateInput
    kbArticleComments?: KbArticleCommentOrderByRelationAggregateInput
    xpEvents?: XpEventOrderByRelationAggregateInput
    leaderboard?: LeaderboardOrderByWithRelationInput
    mailroomPackages?: MailroomPackageOrderByRelationAggregateInput
    deliveryEvents?: DeliveryEventOrderByRelationAggregateInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationOrderByRelationAggregateInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationOrderByRelationAggregateInput
    vipProxiesAsVip?: VipProxyOrderByRelationAggregateInput
    vipProxiesAsProxy?: VipProxyOrderByRelationAggregateInput
    vipSlaHistory?: VipSlaHistoryOrderByRelationAggregateInput
    agentAvailability?: AgentAvailabilityOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    samlNameId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    disabled?: BoolFilter<"User"> | boolean
    isDefault?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    twoFactorBackupCodes?: JsonNullableFilter<"User">
    twoFactorVerified?: BoolFilter<"User"> | boolean
    samlSessionIndex?: StringNullableFilter<"User"> | string | null
    scimExternalId?: StringNullableFilter<"User"> | string | null
    department?: StringNullableFilter<"User"> | string | null
    lastSamlLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    isVip?: BoolFilter<"User"> | boolean
    vipLevel?: StringNullableFilter<"User"> | string | null
    vipSlaOverride?: JsonNullableFilter<"User">
    feedback?: FeedbackListRelationFilter
    logs?: LogListRelationFilter
    passkeys?: PasskeyListRelationFilter
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketListRelationFilter
    support_tickets_support_tickets_userIdTousers?: SupportTicketListRelationFilter
    roles?: UserRoleListRelationFilter
    scimMappings?: ScimMappingListRelationFilter
    kbArticlesAuthored?: KbArticleListRelationFilter
    kbArticleVersionsAuthored?: KbArticleVersionListRelationFilter
    kbArticleComments?: KbArticleCommentListRelationFilter
    xpEvents?: XpEventListRelationFilter
    leaderboard?: XOR<LeaderboardNullableScalarRelationFilter, LeaderboardWhereInput> | null
    mailroomPackages?: MailroomPackageListRelationFilter
    deliveryEvents?: DeliveryEventListRelationFilter
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationListRelationFilter
    proxyAuthorizationsAsProxy?: ProxyAuthorizationListRelationFilter
    vipProxiesAsVip?: VipProxyListRelationFilter
    vipProxiesAsProxy?: VipProxyListRelationFilter
    vipSlaHistory?: VipSlaHistoryListRelationFilter
    agentAvailability?: AgentAvailabilityListRelationFilter
  }, "id" | "email" | "samlNameId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    disabled?: SortOrder
    isDefault?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    twoFactorBackupCodes?: SortOrderInput | SortOrder
    twoFactorVerified?: SortOrder
    samlNameId?: SortOrderInput | SortOrder
    samlSessionIndex?: SortOrderInput | SortOrder
    scimExternalId?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    lastSamlLogin?: SortOrderInput | SortOrder
    isVip?: SortOrder
    vipLevel?: SortOrderInput | SortOrder
    vipSlaOverride?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    disabled?: BoolWithAggregatesFilter<"User"> | boolean
    isDefault?: BoolWithAggregatesFilter<"User"> | boolean
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    twoFactorEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    twoFactorSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    twoFactorBackupCodes?: JsonNullableWithAggregatesFilter<"User">
    twoFactorVerified?: BoolWithAggregatesFilter<"User"> | boolean
    samlNameId?: StringNullableWithAggregatesFilter<"User"> | string | null
    samlSessionIndex?: StringNullableWithAggregatesFilter<"User"> | string | null
    scimExternalId?: StringNullableWithAggregatesFilter<"User"> | string | null
    department?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastSamlLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isVip?: BoolWithAggregatesFilter<"User"> | boolean
    vipLevel?: StringNullableWithAggregatesFilter<"User"> | string | null
    vipSlaOverride?: JsonNullableWithAggregatesFilter<"User">
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: IntFilter<"Role"> | number
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    permissions?: RolePermissionListRelationFilter
    users?: UserRoleListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    permissions?: RolePermissionOrderByRelationAggregateInput
    users?: UserRoleOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    description?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    permissions?: RolePermissionListRelationFilter
    users?: UserRoleListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Role"> | number
    name?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: IntFilter<"Permission"> | number
    name?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    resource?: StringNullableFilter<"Permission"> | string | null
    action?: StringNullableFilter<"Permission"> | string | null
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    roles?: RolePermissionListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    resource?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    roles?: RolePermissionOrderByRelationAggregateInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    description?: StringNullableFilter<"Permission"> | string | null
    resource?: StringNullableFilter<"Permission"> | string | null
    action?: StringNullableFilter<"Permission"> | string | null
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    roles?: RolePermissionListRelationFilter
  }, "id" | "name">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    resource?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _avg?: PermissionAvgOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
    _sum?: PermissionSumOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Permission"> | number
    name?: StringWithAggregatesFilter<"Permission"> | string
    description?: StringNullableWithAggregatesFilter<"Permission"> | string | null
    resource?: StringNullableWithAggregatesFilter<"Permission"> | string | null
    action?: StringNullableWithAggregatesFilter<"Permission"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: StringFilter<"UserRole"> | string
    roleId?: IntFilter<"UserRole"> | number
    assignedAt?: DateTimeFilter<"UserRole"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserRoleOrderByWithRelationInput = {
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
    role?: RoleOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    userId_roleId?: UserRoleUserIdRoleIdCompoundUniqueInput
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: StringFilter<"UserRole"> | string
    roleId?: IntFilter<"UserRole"> | number
    assignedAt?: DateTimeFilter<"UserRole"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "userId_roleId">

  export type UserRoleOrderByWithAggregationInput = {
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _avg?: UserRoleAvgOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
    _sum?: UserRoleSumOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserRole"> | string
    roleId?: IntWithAggregatesFilter<"UserRole"> | number
    assignedAt?: DateTimeWithAggregatesFilter<"UserRole"> | Date | string
  }

  export type RolePermissionWhereInput = {
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    roleId?: IntFilter<"RolePermission"> | number
    permissionId?: IntFilter<"RolePermission"> | number
    assignedAt?: DateTimeFilter<"RolePermission"> | Date | string
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }

  export type RolePermissionOrderByWithRelationInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
    assignedAt?: SortOrder
    permission?: PermissionOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
  }

  export type RolePermissionWhereUniqueInput = Prisma.AtLeast<{
    roleId_permissionId?: RolePermissionRoleIdPermissionIdCompoundUniqueInput
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    roleId?: IntFilter<"RolePermission"> | number
    permissionId?: IntFilter<"RolePermission"> | number
    assignedAt?: DateTimeFilter<"RolePermission"> | Date | string
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }, "roleId_permissionId">

  export type RolePermissionOrderByWithAggregationInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
    assignedAt?: SortOrder
    _count?: RolePermissionCountOrderByAggregateInput
    _avg?: RolePermissionAvgOrderByAggregateInput
    _max?: RolePermissionMaxOrderByAggregateInput
    _min?: RolePermissionMinOrderByAggregateInput
    _sum?: RolePermissionSumOrderByAggregateInput
  }

  export type RolePermissionScalarWhereWithAggregatesInput = {
    AND?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    OR?: RolePermissionScalarWhereWithAggregatesInput[]
    NOT?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    roleId?: IntWithAggregatesFilter<"RolePermission"> | number
    permissionId?: IntWithAggregatesFilter<"RolePermission"> | number
    assignedAt?: DateTimeWithAggregatesFilter<"RolePermission"> | Date | string
  }

  export type PasskeyWhereInput = {
    AND?: PasskeyWhereInput | PasskeyWhereInput[]
    OR?: PasskeyWhereInput[]
    NOT?: PasskeyWhereInput | PasskeyWhereInput[]
    id?: IntFilter<"Passkey"> | number
    userId?: StringFilter<"Passkey"> | string
    credentialId?: StringFilter<"Passkey"> | string
    publicKey?: StringFilter<"Passkey"> | string
    counter?: IntFilter<"Passkey"> | number
    transports?: StringNullableFilter<"Passkey"> | string | null
    deviceType?: StringNullableFilter<"Passkey"> | string | null
    backedUp?: BoolFilter<"Passkey"> | boolean
    createdAt?: DateTimeFilter<"Passkey"> | Date | string
    lastUsed?: DateTimeNullableFilter<"Passkey"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PasskeyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    credentialId?: SortOrder
    publicKey?: SortOrder
    counter?: SortOrder
    transports?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    backedUp?: SortOrder
    createdAt?: SortOrder
    lastUsed?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PasskeyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    credentialId?: string
    AND?: PasskeyWhereInput | PasskeyWhereInput[]
    OR?: PasskeyWhereInput[]
    NOT?: PasskeyWhereInput | PasskeyWhereInput[]
    userId?: StringFilter<"Passkey"> | string
    publicKey?: StringFilter<"Passkey"> | string
    counter?: IntFilter<"Passkey"> | number
    transports?: StringNullableFilter<"Passkey"> | string | null
    deviceType?: StringNullableFilter<"Passkey"> | string | null
    backedUp?: BoolFilter<"Passkey"> | boolean
    createdAt?: DateTimeFilter<"Passkey"> | Date | string
    lastUsed?: DateTimeNullableFilter<"Passkey"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "credentialId">

  export type PasskeyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    credentialId?: SortOrder
    publicKey?: SortOrder
    counter?: SortOrder
    transports?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    backedUp?: SortOrder
    createdAt?: SortOrder
    lastUsed?: SortOrderInput | SortOrder
    _count?: PasskeyCountOrderByAggregateInput
    _avg?: PasskeyAvgOrderByAggregateInput
    _max?: PasskeyMaxOrderByAggregateInput
    _min?: PasskeyMinOrderByAggregateInput
    _sum?: PasskeySumOrderByAggregateInput
  }

  export type PasskeyScalarWhereWithAggregatesInput = {
    AND?: PasskeyScalarWhereWithAggregatesInput | PasskeyScalarWhereWithAggregatesInput[]
    OR?: PasskeyScalarWhereWithAggregatesInput[]
    NOT?: PasskeyScalarWhereWithAggregatesInput | PasskeyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Passkey"> | number
    userId?: StringWithAggregatesFilter<"Passkey"> | string
    credentialId?: StringWithAggregatesFilter<"Passkey"> | string
    publicKey?: StringWithAggregatesFilter<"Passkey"> | string
    counter?: IntWithAggregatesFilter<"Passkey"> | number
    transports?: StringNullableWithAggregatesFilter<"Passkey"> | string | null
    deviceType?: StringNullableWithAggregatesFilter<"Passkey"> | string | null
    backedUp?: BoolWithAggregatesFilter<"Passkey"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Passkey"> | Date | string
    lastUsed?: DateTimeNullableWithAggregatesFilter<"Passkey"> | Date | string | null
  }

  export type LogWhereInput = {
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    id?: IntFilter<"Log"> | number
    ticketId?: StringNullableFilter<"Log"> | string | null
    name?: StringNullableFilter<"Log"> | string | null
    email?: StringNullableFilter<"Log"> | string | null
    title?: StringNullableFilter<"Log"> | string | null
    system?: StringNullableFilter<"Log"> | string | null
    urgency?: StringNullableFilter<"Log"> | string | null
    timestamp?: DateTimeFilter<"Log"> | Date | string
    emailStatus?: StringNullableFilter<"Log"> | string | null
    userId?: StringNullableFilter<"Log"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type LogOrderByWithRelationInput = {
    id?: SortOrder
    ticketId?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    system?: SortOrderInput | SortOrder
    urgency?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    emailStatus?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    ticketId?: StringNullableFilter<"Log"> | string | null
    name?: StringNullableFilter<"Log"> | string | null
    email?: StringNullableFilter<"Log"> | string | null
    title?: StringNullableFilter<"Log"> | string | null
    system?: StringNullableFilter<"Log"> | string | null
    urgency?: StringNullableFilter<"Log"> | string | null
    timestamp?: DateTimeFilter<"Log"> | Date | string
    emailStatus?: StringNullableFilter<"Log"> | string | null
    userId?: StringNullableFilter<"Log"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type LogOrderByWithAggregationInput = {
    id?: SortOrder
    ticketId?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    system?: SortOrderInput | SortOrder
    urgency?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    emailStatus?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: LogCountOrderByAggregateInput
    _avg?: LogAvgOrderByAggregateInput
    _max?: LogMaxOrderByAggregateInput
    _min?: LogMinOrderByAggregateInput
    _sum?: LogSumOrderByAggregateInput
  }

  export type LogScalarWhereWithAggregatesInput = {
    AND?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    OR?: LogScalarWhereWithAggregatesInput[]
    NOT?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Log"> | number
    ticketId?: StringNullableWithAggregatesFilter<"Log"> | string | null
    name?: StringNullableWithAggregatesFilter<"Log"> | string | null
    email?: StringNullableWithAggregatesFilter<"Log"> | string | null
    title?: StringNullableWithAggregatesFilter<"Log"> | string | null
    system?: StringNullableWithAggregatesFilter<"Log"> | string | null
    urgency?: StringNullableWithAggregatesFilter<"Log"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"Log"> | Date | string
    emailStatus?: StringNullableWithAggregatesFilter<"Log"> | string | null
    userId?: StringNullableWithAggregatesFilter<"Log"> | string | null
  }

  export type ConfigWhereInput = {
    AND?: ConfigWhereInput | ConfigWhereInput[]
    OR?: ConfigWhereInput[]
    NOT?: ConfigWhereInput | ConfigWhereInput[]
    key?: StringFilter<"Config"> | string
    value?: StringNullableFilter<"Config"> | string | null
    valueType?: StringNullableFilter<"Config"> | string | null
    description?: StringNullableFilter<"Config"> | string | null
    isPublic?: BoolFilter<"Config"> | boolean
    category?: StringNullableFilter<"Config"> | string | null
    subcategory?: StringNullableFilter<"Config"> | string | null
    isUIEditable?: BoolFilter<"Config"> | boolean
    isRequired?: BoolFilter<"Config"> | boolean
    defaultValue?: StringNullableFilter<"Config"> | string | null
    validationRules?: JsonNullableFilter<"Config">
    displayOrder?: IntNullableFilter<"Config"> | number | null
    helpText?: StringNullableFilter<"Config"> | string | null
    isAdvanced?: BoolFilter<"Config"> | boolean
    createdAt?: DateTimeFilter<"Config"> | Date | string
    updatedAt?: DateTimeFilter<"Config"> | Date | string
    updatedBy?: StringNullableFilter<"Config"> | string | null
    history?: ConfigHistoryListRelationFilter
  }

  export type ConfigOrderByWithRelationInput = {
    key?: SortOrder
    value?: SortOrderInput | SortOrder
    valueType?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    category?: SortOrderInput | SortOrder
    subcategory?: SortOrderInput | SortOrder
    isUIEditable?: SortOrder
    isRequired?: SortOrder
    defaultValue?: SortOrderInput | SortOrder
    validationRules?: SortOrderInput | SortOrder
    displayOrder?: SortOrderInput | SortOrder
    helpText?: SortOrderInput | SortOrder
    isAdvanced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    history?: ConfigHistoryOrderByRelationAggregateInput
  }

  export type ConfigWhereUniqueInput = Prisma.AtLeast<{
    key?: string
    AND?: ConfigWhereInput | ConfigWhereInput[]
    OR?: ConfigWhereInput[]
    NOT?: ConfigWhereInput | ConfigWhereInput[]
    value?: StringNullableFilter<"Config"> | string | null
    valueType?: StringNullableFilter<"Config"> | string | null
    description?: StringNullableFilter<"Config"> | string | null
    isPublic?: BoolFilter<"Config"> | boolean
    category?: StringNullableFilter<"Config"> | string | null
    subcategory?: StringNullableFilter<"Config"> | string | null
    isUIEditable?: BoolFilter<"Config"> | boolean
    isRequired?: BoolFilter<"Config"> | boolean
    defaultValue?: StringNullableFilter<"Config"> | string | null
    validationRules?: JsonNullableFilter<"Config">
    displayOrder?: IntNullableFilter<"Config"> | number | null
    helpText?: StringNullableFilter<"Config"> | string | null
    isAdvanced?: BoolFilter<"Config"> | boolean
    createdAt?: DateTimeFilter<"Config"> | Date | string
    updatedAt?: DateTimeFilter<"Config"> | Date | string
    updatedBy?: StringNullableFilter<"Config"> | string | null
    history?: ConfigHistoryListRelationFilter
  }, "key">

  export type ConfigOrderByWithAggregationInput = {
    key?: SortOrder
    value?: SortOrderInput | SortOrder
    valueType?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    category?: SortOrderInput | SortOrder
    subcategory?: SortOrderInput | SortOrder
    isUIEditable?: SortOrder
    isRequired?: SortOrder
    defaultValue?: SortOrderInput | SortOrder
    validationRules?: SortOrderInput | SortOrder
    displayOrder?: SortOrderInput | SortOrder
    helpText?: SortOrderInput | SortOrder
    isAdvanced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: ConfigCountOrderByAggregateInput
    _avg?: ConfigAvgOrderByAggregateInput
    _max?: ConfigMaxOrderByAggregateInput
    _min?: ConfigMinOrderByAggregateInput
    _sum?: ConfigSumOrderByAggregateInput
  }

  export type ConfigScalarWhereWithAggregatesInput = {
    AND?: ConfigScalarWhereWithAggregatesInput | ConfigScalarWhereWithAggregatesInput[]
    OR?: ConfigScalarWhereWithAggregatesInput[]
    NOT?: ConfigScalarWhereWithAggregatesInput | ConfigScalarWhereWithAggregatesInput[]
    key?: StringWithAggregatesFilter<"Config"> | string
    value?: StringNullableWithAggregatesFilter<"Config"> | string | null
    valueType?: StringNullableWithAggregatesFilter<"Config"> | string | null
    description?: StringNullableWithAggregatesFilter<"Config"> | string | null
    isPublic?: BoolWithAggregatesFilter<"Config"> | boolean
    category?: StringNullableWithAggregatesFilter<"Config"> | string | null
    subcategory?: StringNullableWithAggregatesFilter<"Config"> | string | null
    isUIEditable?: BoolWithAggregatesFilter<"Config"> | boolean
    isRequired?: BoolWithAggregatesFilter<"Config"> | boolean
    defaultValue?: StringNullableWithAggregatesFilter<"Config"> | string | null
    validationRules?: JsonNullableWithAggregatesFilter<"Config">
    displayOrder?: IntNullableWithAggregatesFilter<"Config"> | number | null
    helpText?: StringNullableWithAggregatesFilter<"Config"> | string | null
    isAdvanced?: BoolWithAggregatesFilter<"Config"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Config"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Config"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"Config"> | string | null
  }

  export type ConfigHistoryWhereInput = {
    AND?: ConfigHistoryWhereInput | ConfigHistoryWhereInput[]
    OR?: ConfigHistoryWhereInput[]
    NOT?: ConfigHistoryWhereInput | ConfigHistoryWhereInput[]
    id?: IntFilter<"ConfigHistory"> | number
    configKey?: StringFilter<"ConfigHistory"> | string
    oldValue?: StringNullableFilter<"ConfigHistory"> | string | null
    newValue?: StringNullableFilter<"ConfigHistory"> | string | null
    changedBy?: StringNullableFilter<"ConfigHistory"> | string | null
    changeReason?: StringNullableFilter<"ConfigHistory"> | string | null
    createdAt?: DateTimeFilter<"ConfigHistory"> | Date | string
    config?: XOR<ConfigScalarRelationFilter, ConfigWhereInput>
  }

  export type ConfigHistoryOrderByWithRelationInput = {
    id?: SortOrder
    configKey?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    changedBy?: SortOrderInput | SortOrder
    changeReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    config?: ConfigOrderByWithRelationInput
  }

  export type ConfigHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ConfigHistoryWhereInput | ConfigHistoryWhereInput[]
    OR?: ConfigHistoryWhereInput[]
    NOT?: ConfigHistoryWhereInput | ConfigHistoryWhereInput[]
    configKey?: StringFilter<"ConfigHistory"> | string
    oldValue?: StringNullableFilter<"ConfigHistory"> | string | null
    newValue?: StringNullableFilter<"ConfigHistory"> | string | null
    changedBy?: StringNullableFilter<"ConfigHistory"> | string | null
    changeReason?: StringNullableFilter<"ConfigHistory"> | string | null
    createdAt?: DateTimeFilter<"ConfigHistory"> | Date | string
    config?: XOR<ConfigScalarRelationFilter, ConfigWhereInput>
  }, "id">

  export type ConfigHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    configKey?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    changedBy?: SortOrderInput | SortOrder
    changeReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ConfigHistoryCountOrderByAggregateInput
    _avg?: ConfigHistoryAvgOrderByAggregateInput
    _max?: ConfigHistoryMaxOrderByAggregateInput
    _min?: ConfigHistoryMinOrderByAggregateInput
    _sum?: ConfigHistorySumOrderByAggregateInput
  }

  export type ConfigHistoryScalarWhereWithAggregatesInput = {
    AND?: ConfigHistoryScalarWhereWithAggregatesInput | ConfigHistoryScalarWhereWithAggregatesInput[]
    OR?: ConfigHistoryScalarWhereWithAggregatesInput[]
    NOT?: ConfigHistoryScalarWhereWithAggregatesInput | ConfigHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ConfigHistory"> | number
    configKey?: StringWithAggregatesFilter<"ConfigHistory"> | string
    oldValue?: StringNullableWithAggregatesFilter<"ConfigHistory"> | string | null
    newValue?: StringNullableWithAggregatesFilter<"ConfigHistory"> | string | null
    changedBy?: StringNullableWithAggregatesFilter<"ConfigHistory"> | string | null
    changeReason?: StringNullableWithAggregatesFilter<"ConfigHistory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ConfigHistory"> | Date | string
  }

  export type ConfigTemplateWhereInput = {
    AND?: ConfigTemplateWhereInput | ConfigTemplateWhereInput[]
    OR?: ConfigTemplateWhereInput[]
    NOT?: ConfigTemplateWhereInput | ConfigTemplateWhereInput[]
    id?: IntFilter<"ConfigTemplate"> | number
    name?: StringFilter<"ConfigTemplate"> | string
    description?: StringNullableFilter<"ConfigTemplate"> | string | null
    category?: StringFilter<"ConfigTemplate"> | string
    template?: JsonFilter<"ConfigTemplate">
    isDefault?: BoolFilter<"ConfigTemplate"> | boolean
    createdBy?: StringNullableFilter<"ConfigTemplate"> | string | null
    createdAt?: DateTimeFilter<"ConfigTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ConfigTemplate"> | Date | string
  }

  export type ConfigTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    template?: SortOrder
    isDefault?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfigTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: ConfigTemplateWhereInput | ConfigTemplateWhereInput[]
    OR?: ConfigTemplateWhereInput[]
    NOT?: ConfigTemplateWhereInput | ConfigTemplateWhereInput[]
    description?: StringNullableFilter<"ConfigTemplate"> | string | null
    category?: StringFilter<"ConfigTemplate"> | string
    template?: JsonFilter<"ConfigTemplate">
    isDefault?: BoolFilter<"ConfigTemplate"> | boolean
    createdBy?: StringNullableFilter<"ConfigTemplate"> | string | null
    createdAt?: DateTimeFilter<"ConfigTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ConfigTemplate"> | Date | string
  }, "id" | "name">

  export type ConfigTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    template?: SortOrder
    isDefault?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConfigTemplateCountOrderByAggregateInput
    _avg?: ConfigTemplateAvgOrderByAggregateInput
    _max?: ConfigTemplateMaxOrderByAggregateInput
    _min?: ConfigTemplateMinOrderByAggregateInput
    _sum?: ConfigTemplateSumOrderByAggregateInput
  }

  export type ConfigTemplateScalarWhereWithAggregatesInput = {
    AND?: ConfigTemplateScalarWhereWithAggregatesInput | ConfigTemplateScalarWhereWithAggregatesInput[]
    OR?: ConfigTemplateScalarWhereWithAggregatesInput[]
    NOT?: ConfigTemplateScalarWhereWithAggregatesInput | ConfigTemplateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ConfigTemplate"> | number
    name?: StringWithAggregatesFilter<"ConfigTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"ConfigTemplate"> | string | null
    category?: StringWithAggregatesFilter<"ConfigTemplate"> | string
    template?: JsonWithAggregatesFilter<"ConfigTemplate">
    isDefault?: BoolWithAggregatesFilter<"ConfigTemplate"> | boolean
    createdBy?: StringNullableWithAggregatesFilter<"ConfigTemplate"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ConfigTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConfigTemplate"> | Date | string
  }

  export type KioskWhereInput = {
    AND?: KioskWhereInput | KioskWhereInput[]
    OR?: KioskWhereInput[]
    NOT?: KioskWhereInput | KioskWhereInput[]
    id?: StringFilter<"Kiosk"> | string
    lastSeen?: DateTimeNullableFilter<"Kiosk"> | Date | string | null
    version?: StringNullableFilter<"Kiosk"> | string | null
    active?: BoolFilter<"Kiosk"> | boolean
    logoUrl?: StringNullableFilter<"Kiosk"> | string | null
    bgUrl?: StringNullableFilter<"Kiosk"> | string | null
    statusEnabled?: BoolFilter<"Kiosk"> | boolean
    currentStatus?: StringNullableFilter<"Kiosk"> | string | null
    openMsg?: StringNullableFilter<"Kiosk"> | string | null
    closedMsg?: StringNullableFilter<"Kiosk"> | string | null
    errorMsg?: StringNullableFilter<"Kiosk"> | string | null
    meetingMsg?: StringNullableFilter<"Kiosk"> | string | null
    brbMsg?: StringNullableFilter<"Kiosk"> | string | null
    lunchMsg?: StringNullableFilter<"Kiosk"> | string | null
    unavailableMsg?: StringNullableFilter<"Kiosk"> | string | null
    schedule?: JsonNullableFilter<"Kiosk">
    createdAt?: DateTimeFilter<"Kiosk"> | Date | string
    updatedAt?: DateTimeFilter<"Kiosk"> | Date | string
    activations?: KioskActivationListRelationFilter
    assetRegistry?: KioskAssetRegistryListRelationFilter
    syncFailures?: HelixSyncFailureListRelationFilter
    orgAssignment?: XOR<KioskOrganizationAssignmentNullableScalarRelationFilter, KioskOrganizationAssignmentWhereInput> | null
    metadataLogs?: KioskMetadataLogListRelationFilter
  }

  export type KioskOrderByWithRelationInput = {
    id?: SortOrder
    lastSeen?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    active?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    bgUrl?: SortOrderInput | SortOrder
    statusEnabled?: SortOrder
    currentStatus?: SortOrderInput | SortOrder
    openMsg?: SortOrderInput | SortOrder
    closedMsg?: SortOrderInput | SortOrder
    errorMsg?: SortOrderInput | SortOrder
    meetingMsg?: SortOrderInput | SortOrder
    brbMsg?: SortOrderInput | SortOrder
    lunchMsg?: SortOrderInput | SortOrder
    unavailableMsg?: SortOrderInput | SortOrder
    schedule?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    activations?: KioskActivationOrderByRelationAggregateInput
    assetRegistry?: KioskAssetRegistryOrderByRelationAggregateInput
    syncFailures?: HelixSyncFailureOrderByRelationAggregateInput
    orgAssignment?: KioskOrganizationAssignmentOrderByWithRelationInput
    metadataLogs?: KioskMetadataLogOrderByRelationAggregateInput
  }

  export type KioskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KioskWhereInput | KioskWhereInput[]
    OR?: KioskWhereInput[]
    NOT?: KioskWhereInput | KioskWhereInput[]
    lastSeen?: DateTimeNullableFilter<"Kiosk"> | Date | string | null
    version?: StringNullableFilter<"Kiosk"> | string | null
    active?: BoolFilter<"Kiosk"> | boolean
    logoUrl?: StringNullableFilter<"Kiosk"> | string | null
    bgUrl?: StringNullableFilter<"Kiosk"> | string | null
    statusEnabled?: BoolFilter<"Kiosk"> | boolean
    currentStatus?: StringNullableFilter<"Kiosk"> | string | null
    openMsg?: StringNullableFilter<"Kiosk"> | string | null
    closedMsg?: StringNullableFilter<"Kiosk"> | string | null
    errorMsg?: StringNullableFilter<"Kiosk"> | string | null
    meetingMsg?: StringNullableFilter<"Kiosk"> | string | null
    brbMsg?: StringNullableFilter<"Kiosk"> | string | null
    lunchMsg?: StringNullableFilter<"Kiosk"> | string | null
    unavailableMsg?: StringNullableFilter<"Kiosk"> | string | null
    schedule?: JsonNullableFilter<"Kiosk">
    createdAt?: DateTimeFilter<"Kiosk"> | Date | string
    updatedAt?: DateTimeFilter<"Kiosk"> | Date | string
    activations?: KioskActivationListRelationFilter
    assetRegistry?: KioskAssetRegistryListRelationFilter
    syncFailures?: HelixSyncFailureListRelationFilter
    orgAssignment?: XOR<KioskOrganizationAssignmentNullableScalarRelationFilter, KioskOrganizationAssignmentWhereInput> | null
    metadataLogs?: KioskMetadataLogListRelationFilter
  }, "id">

  export type KioskOrderByWithAggregationInput = {
    id?: SortOrder
    lastSeen?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    active?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    bgUrl?: SortOrderInput | SortOrder
    statusEnabled?: SortOrder
    currentStatus?: SortOrderInput | SortOrder
    openMsg?: SortOrderInput | SortOrder
    closedMsg?: SortOrderInput | SortOrder
    errorMsg?: SortOrderInput | SortOrder
    meetingMsg?: SortOrderInput | SortOrder
    brbMsg?: SortOrderInput | SortOrder
    lunchMsg?: SortOrderInput | SortOrder
    unavailableMsg?: SortOrderInput | SortOrder
    schedule?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KioskCountOrderByAggregateInput
    _max?: KioskMaxOrderByAggregateInput
    _min?: KioskMinOrderByAggregateInput
  }

  export type KioskScalarWhereWithAggregatesInput = {
    AND?: KioskScalarWhereWithAggregatesInput | KioskScalarWhereWithAggregatesInput[]
    OR?: KioskScalarWhereWithAggregatesInput[]
    NOT?: KioskScalarWhereWithAggregatesInput | KioskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Kiosk"> | string
    lastSeen?: DateTimeNullableWithAggregatesFilter<"Kiosk"> | Date | string | null
    version?: StringNullableWithAggregatesFilter<"Kiosk"> | string | null
    active?: BoolWithAggregatesFilter<"Kiosk"> | boolean
    logoUrl?: StringNullableWithAggregatesFilter<"Kiosk"> | string | null
    bgUrl?: StringNullableWithAggregatesFilter<"Kiosk"> | string | null
    statusEnabled?: BoolWithAggregatesFilter<"Kiosk"> | boolean
    currentStatus?: StringNullableWithAggregatesFilter<"Kiosk"> | string | null
    openMsg?: StringNullableWithAggregatesFilter<"Kiosk"> | string | null
    closedMsg?: StringNullableWithAggregatesFilter<"Kiosk"> | string | null
    errorMsg?: StringNullableWithAggregatesFilter<"Kiosk"> | string | null
    meetingMsg?: StringNullableWithAggregatesFilter<"Kiosk"> | string | null
    brbMsg?: StringNullableWithAggregatesFilter<"Kiosk"> | string | null
    lunchMsg?: StringNullableWithAggregatesFilter<"Kiosk"> | string | null
    unavailableMsg?: StringNullableWithAggregatesFilter<"Kiosk"> | string | null
    schedule?: JsonNullableWithAggregatesFilter<"Kiosk">
    createdAt?: DateTimeWithAggregatesFilter<"Kiosk"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Kiosk"> | Date | string
  }

  export type FeedbackWhereInput = {
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    id?: IntFilter<"Feedback"> | number
    name?: StringNullableFilter<"Feedback"> | string | null
    message?: StringNullableFilter<"Feedback"> | string | null
    timestamp?: DateTimeFilter<"Feedback"> | Date | string
    userId?: StringNullableFilter<"Feedback"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type FeedbackOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    userId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type FeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    name?: StringNullableFilter<"Feedback"> | string | null
    message?: StringNullableFilter<"Feedback"> | string | null
    timestamp?: DateTimeFilter<"Feedback"> | Date | string
    userId?: StringNullableFilter<"Feedback"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type FeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: FeedbackCountOrderByAggregateInput
    _avg?: FeedbackAvgOrderByAggregateInput
    _max?: FeedbackMaxOrderByAggregateInput
    _min?: FeedbackMinOrderByAggregateInput
    _sum?: FeedbackSumOrderByAggregateInput
  }

  export type FeedbackScalarWhereWithAggregatesInput = {
    AND?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    OR?: FeedbackScalarWhereWithAggregatesInput[]
    NOT?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Feedback"> | number
    name?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
    message?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"Feedback"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    message?: StringFilter<"Notification"> | string
    level?: StringFilter<"Notification"> | string
    active?: BoolFilter<"Notification"> | boolean
    type?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    message?: SortOrder
    level?: SortOrder
    active?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    message?: StringFilter<"Notification"> | string
    level?: StringFilter<"Notification"> | string
    active?: BoolFilter<"Notification"> | boolean
    type?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    message?: SortOrder
    level?: SortOrder
    active?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    message?: StringWithAggregatesFilter<"Notification"> | string
    level?: StringWithAggregatesFilter<"Notification"> | string
    active?: BoolWithAggregatesFilter<"Notification"> | boolean
    type?: StringWithAggregatesFilter<"Notification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type DirectoryIntegrationWhereInput = {
    AND?: DirectoryIntegrationWhereInput | DirectoryIntegrationWhereInput[]
    OR?: DirectoryIntegrationWhereInput[]
    NOT?: DirectoryIntegrationWhereInput | DirectoryIntegrationWhereInput[]
    id?: IntFilter<"DirectoryIntegration"> | number
    provider?: StringFilter<"DirectoryIntegration"> | string
    settings?: JsonNullableFilter<"DirectoryIntegration">
    enabled?: BoolFilter<"DirectoryIntegration"> | boolean
    createdAt?: DateTimeFilter<"DirectoryIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"DirectoryIntegration"> | Date | string
  }

  export type DirectoryIntegrationOrderByWithRelationInput = {
    id?: SortOrder
    provider?: SortOrder
    settings?: SortOrderInput | SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DirectoryIntegrationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DirectoryIntegrationWhereInput | DirectoryIntegrationWhereInput[]
    OR?: DirectoryIntegrationWhereInput[]
    NOT?: DirectoryIntegrationWhereInput | DirectoryIntegrationWhereInput[]
    provider?: StringFilter<"DirectoryIntegration"> | string
    settings?: JsonNullableFilter<"DirectoryIntegration">
    enabled?: BoolFilter<"DirectoryIntegration"> | boolean
    createdAt?: DateTimeFilter<"DirectoryIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"DirectoryIntegration"> | Date | string
  }, "id">

  export type DirectoryIntegrationOrderByWithAggregationInput = {
    id?: SortOrder
    provider?: SortOrder
    settings?: SortOrderInput | SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DirectoryIntegrationCountOrderByAggregateInput
    _avg?: DirectoryIntegrationAvgOrderByAggregateInput
    _max?: DirectoryIntegrationMaxOrderByAggregateInput
    _min?: DirectoryIntegrationMinOrderByAggregateInput
    _sum?: DirectoryIntegrationSumOrderByAggregateInput
  }

  export type DirectoryIntegrationScalarWhereWithAggregatesInput = {
    AND?: DirectoryIntegrationScalarWhereWithAggregatesInput | DirectoryIntegrationScalarWhereWithAggregatesInput[]
    OR?: DirectoryIntegrationScalarWhereWithAggregatesInput[]
    NOT?: DirectoryIntegrationScalarWhereWithAggregatesInput | DirectoryIntegrationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DirectoryIntegration"> | number
    provider?: StringWithAggregatesFilter<"DirectoryIntegration"> | string
    settings?: JsonNullableWithAggregatesFilter<"DirectoryIntegration">
    enabled?: BoolWithAggregatesFilter<"DirectoryIntegration"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DirectoryIntegration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DirectoryIntegration"> | Date | string
  }

  export type AssetWhereInput = {
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    id?: IntFilter<"Asset"> | number
    name?: StringFilter<"Asset"> | string
    type?: StringFilter<"Asset"> | string
    filename?: StringFilter<"Asset"> | string
    url?: StringFilter<"Asset"> | string
    sizeBytes?: IntNullableFilter<"Asset"> | number | null
    mimeType?: StringNullableFilter<"Asset"> | string | null
    uploadedAt?: DateTimeFilter<"Asset"> | Date | string
  }

  export type AssetOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    sizeBytes?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
  }

  export type AssetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    name?: StringFilter<"Asset"> | string
    type?: StringFilter<"Asset"> | string
    filename?: StringFilter<"Asset"> | string
    url?: StringFilter<"Asset"> | string
    sizeBytes?: IntNullableFilter<"Asset"> | number | null
    mimeType?: StringNullableFilter<"Asset"> | string | null
    uploadedAt?: DateTimeFilter<"Asset"> | Date | string
  }, "id">

  export type AssetOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    sizeBytes?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    _count?: AssetCountOrderByAggregateInput
    _avg?: AssetAvgOrderByAggregateInput
    _max?: AssetMaxOrderByAggregateInput
    _min?: AssetMinOrderByAggregateInput
    _sum?: AssetSumOrderByAggregateInput
  }

  export type AssetScalarWhereWithAggregatesInput = {
    AND?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    OR?: AssetScalarWhereWithAggregatesInput[]
    NOT?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Asset"> | number
    name?: StringWithAggregatesFilter<"Asset"> | string
    type?: StringWithAggregatesFilter<"Asset"> | string
    filename?: StringWithAggregatesFilter<"Asset"> | string
    url?: StringWithAggregatesFilter<"Asset"> | string
    sizeBytes?: IntNullableWithAggregatesFilter<"Asset"> | number | null
    mimeType?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    uploadedAt?: DateTimeWithAggregatesFilter<"Asset"> | Date | string
  }

  export type KioskActivationWhereInput = {
    AND?: KioskActivationWhereInput | KioskActivationWhereInput[]
    OR?: KioskActivationWhereInput[]
    NOT?: KioskActivationWhereInput | KioskActivationWhereInput[]
    id?: StringFilter<"KioskActivation"> | string
    code?: StringFilter<"KioskActivation"> | string
    qrCode?: StringFilter<"KioskActivation"> | string
    expiresAt?: DateTimeFilter<"KioskActivation"> | Date | string
    used?: BoolFilter<"KioskActivation"> | boolean
    usedAt?: DateTimeNullableFilter<"KioskActivation"> | Date | string | null
    createdAt?: DateTimeFilter<"KioskActivation"> | Date | string
    kioskId?: StringNullableFilter<"KioskActivation"> | string | null
    kiosk?: XOR<KioskNullableScalarRelationFilter, KioskWhereInput> | null
  }

  export type KioskActivationOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    qrCode?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    kioskId?: SortOrderInput | SortOrder
    kiosk?: KioskOrderByWithRelationInput
  }

  export type KioskActivationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KioskActivationWhereInput | KioskActivationWhereInput[]
    OR?: KioskActivationWhereInput[]
    NOT?: KioskActivationWhereInput | KioskActivationWhereInput[]
    code?: StringFilter<"KioskActivation"> | string
    qrCode?: StringFilter<"KioskActivation"> | string
    expiresAt?: DateTimeFilter<"KioskActivation"> | Date | string
    used?: BoolFilter<"KioskActivation"> | boolean
    usedAt?: DateTimeNullableFilter<"KioskActivation"> | Date | string | null
    createdAt?: DateTimeFilter<"KioskActivation"> | Date | string
    kioskId?: StringNullableFilter<"KioskActivation"> | string | null
    kiosk?: XOR<KioskNullableScalarRelationFilter, KioskWhereInput> | null
  }, "id">

  export type KioskActivationOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    qrCode?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    kioskId?: SortOrderInput | SortOrder
    _count?: KioskActivationCountOrderByAggregateInput
    _max?: KioskActivationMaxOrderByAggregateInput
    _min?: KioskActivationMinOrderByAggregateInput
  }

  export type KioskActivationScalarWhereWithAggregatesInput = {
    AND?: KioskActivationScalarWhereWithAggregatesInput | KioskActivationScalarWhereWithAggregatesInput[]
    OR?: KioskActivationScalarWhereWithAggregatesInput[]
    NOT?: KioskActivationScalarWhereWithAggregatesInput | KioskActivationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KioskActivation"> | string
    code?: StringWithAggregatesFilter<"KioskActivation"> | string
    qrCode?: StringWithAggregatesFilter<"KioskActivation"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"KioskActivation"> | Date | string
    used?: BoolWithAggregatesFilter<"KioskActivation"> | boolean
    usedAt?: DateTimeNullableWithAggregatesFilter<"KioskActivation"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"KioskActivation"> | Date | string
    kioskId?: StringNullableWithAggregatesFilter<"KioskActivation"> | string | null
  }

  export type SsoConfigurationWhereInput = {
    AND?: SsoConfigurationWhereInput | SsoConfigurationWhereInput[]
    OR?: SsoConfigurationWhereInput[]
    NOT?: SsoConfigurationWhereInput | SsoConfigurationWhereInput[]
    id?: IntFilter<"SsoConfiguration"> | number
    provider?: StringFilter<"SsoConfiguration"> | string
    enabled?: BoolFilter<"SsoConfiguration"> | boolean
    configuration?: JsonNullableFilter<"SsoConfiguration">
    updatedAt?: DateTimeFilter<"SsoConfiguration"> | Date | string
  }

  export type SsoConfigurationOrderByWithRelationInput = {
    id?: SortOrder
    provider?: SortOrder
    enabled?: SortOrder
    configuration?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
  }

  export type SsoConfigurationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SsoConfigurationWhereInput | SsoConfigurationWhereInput[]
    OR?: SsoConfigurationWhereInput[]
    NOT?: SsoConfigurationWhereInput | SsoConfigurationWhereInput[]
    provider?: StringFilter<"SsoConfiguration"> | string
    enabled?: BoolFilter<"SsoConfiguration"> | boolean
    configuration?: JsonNullableFilter<"SsoConfiguration">
    updatedAt?: DateTimeFilter<"SsoConfiguration"> | Date | string
  }, "id">

  export type SsoConfigurationOrderByWithAggregationInput = {
    id?: SortOrder
    provider?: SortOrder
    enabled?: SortOrder
    configuration?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: SsoConfigurationCountOrderByAggregateInput
    _avg?: SsoConfigurationAvgOrderByAggregateInput
    _max?: SsoConfigurationMaxOrderByAggregateInput
    _min?: SsoConfigurationMinOrderByAggregateInput
    _sum?: SsoConfigurationSumOrderByAggregateInput
  }

  export type SsoConfigurationScalarWhereWithAggregatesInput = {
    AND?: SsoConfigurationScalarWhereWithAggregatesInput | SsoConfigurationScalarWhereWithAggregatesInput[]
    OR?: SsoConfigurationScalarWhereWithAggregatesInput[]
    NOT?: SsoConfigurationScalarWhereWithAggregatesInput | SsoConfigurationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SsoConfiguration"> | number
    provider?: StringWithAggregatesFilter<"SsoConfiguration"> | string
    enabled?: BoolWithAggregatesFilter<"SsoConfiguration"> | boolean
    configuration?: JsonNullableWithAggregatesFilter<"SsoConfiguration">
    updatedAt?: DateTimeWithAggregatesFilter<"SsoConfiguration"> | Date | string
  }

  export type AdminPinWhereInput = {
    AND?: AdminPinWhereInput | AdminPinWhereInput[]
    OR?: AdminPinWhereInput[]
    NOT?: AdminPinWhereInput | AdminPinWhereInput[]
    id?: IntFilter<"AdminPin"> | number
    globalPin?: StringNullableFilter<"AdminPin"> | string | null
    kioskPins?: JsonNullableFilter<"AdminPin">
    updatedAt?: DateTimeFilter<"AdminPin"> | Date | string
  }

  export type AdminPinOrderByWithRelationInput = {
    id?: SortOrder
    globalPin?: SortOrderInput | SortOrder
    kioskPins?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
  }

  export type AdminPinWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AdminPinWhereInput | AdminPinWhereInput[]
    OR?: AdminPinWhereInput[]
    NOT?: AdminPinWhereInput | AdminPinWhereInput[]
    globalPin?: StringNullableFilter<"AdminPin"> | string | null
    kioskPins?: JsonNullableFilter<"AdminPin">
    updatedAt?: DateTimeFilter<"AdminPin"> | Date | string
  }, "id">

  export type AdminPinOrderByWithAggregationInput = {
    id?: SortOrder
    globalPin?: SortOrderInput | SortOrder
    kioskPins?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: AdminPinCountOrderByAggregateInput
    _avg?: AdminPinAvgOrderByAggregateInput
    _max?: AdminPinMaxOrderByAggregateInput
    _min?: AdminPinMinOrderByAggregateInput
    _sum?: AdminPinSumOrderByAggregateInput
  }

  export type AdminPinScalarWhereWithAggregatesInput = {
    AND?: AdminPinScalarWhereWithAggregatesInput | AdminPinScalarWhereWithAggregatesInput[]
    OR?: AdminPinScalarWhereWithAggregatesInput[]
    NOT?: AdminPinScalarWhereWithAggregatesInput | AdminPinScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AdminPin"> | number
    globalPin?: StringNullableWithAggregatesFilter<"AdminPin"> | string | null
    kioskPins?: JsonNullableWithAggregatesFilter<"AdminPin">
    updatedAt?: DateTimeWithAggregatesFilter<"AdminPin"> | Date | string
  }

  export type KbArticleWhereInput = {
    AND?: KbArticleWhereInput | KbArticleWhereInput[]
    OR?: KbArticleWhereInput[]
    NOT?: KbArticleWhereInput | KbArticleWhereInput[]
    id?: IntFilter<"KbArticle"> | number
    slug?: StringFilter<"KbArticle"> | string
    title?: StringFilter<"KbArticle"> | string
    createdAt?: DateTimeFilter<"KbArticle"> | Date | string
    updatedAt?: DateTimeFilter<"KbArticle"> | Date | string
    authorId?: StringNullableFilter<"KbArticle"> | string | null
    currentVersionId?: IntNullableFilter<"KbArticle"> | number | null
    isPublished?: BoolFilter<"KbArticle"> | boolean
    tags?: StringNullableListFilter<"KbArticle">
    author?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    versions?: KbArticleVersionListRelationFilter
    comments?: KbArticleCommentListRelationFilter
    currentVersion?: XOR<KbArticleVersionNullableScalarRelationFilter, KbArticleVersionWhereInput> | null
  }

  export type KbArticleOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrderInput | SortOrder
    currentVersionId?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    tags?: SortOrder
    author?: UserOrderByWithRelationInput
    versions?: KbArticleVersionOrderByRelationAggregateInput
    comments?: KbArticleCommentOrderByRelationAggregateInput
    currentVersion?: KbArticleVersionOrderByWithRelationInput
  }

  export type KbArticleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: KbArticleWhereInput | KbArticleWhereInput[]
    OR?: KbArticleWhereInput[]
    NOT?: KbArticleWhereInput | KbArticleWhereInput[]
    title?: StringFilter<"KbArticle"> | string
    createdAt?: DateTimeFilter<"KbArticle"> | Date | string
    updatedAt?: DateTimeFilter<"KbArticle"> | Date | string
    authorId?: StringNullableFilter<"KbArticle"> | string | null
    currentVersionId?: IntNullableFilter<"KbArticle"> | number | null
    isPublished?: BoolFilter<"KbArticle"> | boolean
    tags?: StringNullableListFilter<"KbArticle">
    author?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    versions?: KbArticleVersionListRelationFilter
    comments?: KbArticleCommentListRelationFilter
    currentVersion?: XOR<KbArticleVersionNullableScalarRelationFilter, KbArticleVersionWhereInput> | null
  }, "id" | "slug">

  export type KbArticleOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrderInput | SortOrder
    currentVersionId?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    tags?: SortOrder
    _count?: KbArticleCountOrderByAggregateInput
    _avg?: KbArticleAvgOrderByAggregateInput
    _max?: KbArticleMaxOrderByAggregateInput
    _min?: KbArticleMinOrderByAggregateInput
    _sum?: KbArticleSumOrderByAggregateInput
  }

  export type KbArticleScalarWhereWithAggregatesInput = {
    AND?: KbArticleScalarWhereWithAggregatesInput | KbArticleScalarWhereWithAggregatesInput[]
    OR?: KbArticleScalarWhereWithAggregatesInput[]
    NOT?: KbArticleScalarWhereWithAggregatesInput | KbArticleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"KbArticle"> | number
    slug?: StringWithAggregatesFilter<"KbArticle"> | string
    title?: StringWithAggregatesFilter<"KbArticle"> | string
    createdAt?: DateTimeWithAggregatesFilter<"KbArticle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KbArticle"> | Date | string
    authorId?: StringNullableWithAggregatesFilter<"KbArticle"> | string | null
    currentVersionId?: IntNullableWithAggregatesFilter<"KbArticle"> | number | null
    isPublished?: BoolWithAggregatesFilter<"KbArticle"> | boolean
    tags?: StringNullableListFilter<"KbArticle">
  }

  export type KbArticleVersionWhereInput = {
    AND?: KbArticleVersionWhereInput | KbArticleVersionWhereInput[]
    OR?: KbArticleVersionWhereInput[]
    NOT?: KbArticleVersionWhereInput | KbArticleVersionWhereInput[]
    id?: IntFilter<"KbArticleVersion"> | number
    articleId?: IntFilter<"KbArticleVersion"> | number
    content?: StringFilter<"KbArticleVersion"> | string
    summary?: StringNullableFilter<"KbArticleVersion"> | string | null
    createdAt?: DateTimeFilter<"KbArticleVersion"> | Date | string
    updatedAt?: DateTimeFilter<"KbArticleVersion"> | Date | string
    authorId?: StringNullableFilter<"KbArticleVersion"> | string | null
    version?: IntFilter<"KbArticleVersion"> | number
    isApproved?: BoolFilter<"KbArticleVersion"> | boolean
    article?: XOR<KbArticleScalarRelationFilter, KbArticleWhereInput>
    author?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    currentForArticle?: KbArticleListRelationFilter
  }

  export type KbArticleVersionOrderByWithRelationInput = {
    id?: SortOrder
    articleId?: SortOrder
    content?: SortOrder
    summary?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrderInput | SortOrder
    version?: SortOrder
    isApproved?: SortOrder
    article?: KbArticleOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    currentForArticle?: KbArticleOrderByRelationAggregateInput
  }

  export type KbArticleVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    articleId_version?: KbArticleVersionArticleIdVersionCompoundUniqueInput
    AND?: KbArticleVersionWhereInput | KbArticleVersionWhereInput[]
    OR?: KbArticleVersionWhereInput[]
    NOT?: KbArticleVersionWhereInput | KbArticleVersionWhereInput[]
    articleId?: IntFilter<"KbArticleVersion"> | number
    content?: StringFilter<"KbArticleVersion"> | string
    summary?: StringNullableFilter<"KbArticleVersion"> | string | null
    createdAt?: DateTimeFilter<"KbArticleVersion"> | Date | string
    updatedAt?: DateTimeFilter<"KbArticleVersion"> | Date | string
    authorId?: StringNullableFilter<"KbArticleVersion"> | string | null
    version?: IntFilter<"KbArticleVersion"> | number
    isApproved?: BoolFilter<"KbArticleVersion"> | boolean
    article?: XOR<KbArticleScalarRelationFilter, KbArticleWhereInput>
    author?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    currentForArticle?: KbArticleListRelationFilter
  }, "id" | "articleId_version">

  export type KbArticleVersionOrderByWithAggregationInput = {
    id?: SortOrder
    articleId?: SortOrder
    content?: SortOrder
    summary?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrderInput | SortOrder
    version?: SortOrder
    isApproved?: SortOrder
    _count?: KbArticleVersionCountOrderByAggregateInput
    _avg?: KbArticleVersionAvgOrderByAggregateInput
    _max?: KbArticleVersionMaxOrderByAggregateInput
    _min?: KbArticleVersionMinOrderByAggregateInput
    _sum?: KbArticleVersionSumOrderByAggregateInput
  }

  export type KbArticleVersionScalarWhereWithAggregatesInput = {
    AND?: KbArticleVersionScalarWhereWithAggregatesInput | KbArticleVersionScalarWhereWithAggregatesInput[]
    OR?: KbArticleVersionScalarWhereWithAggregatesInput[]
    NOT?: KbArticleVersionScalarWhereWithAggregatesInput | KbArticleVersionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"KbArticleVersion"> | number
    articleId?: IntWithAggregatesFilter<"KbArticleVersion"> | number
    content?: StringWithAggregatesFilter<"KbArticleVersion"> | string
    summary?: StringNullableWithAggregatesFilter<"KbArticleVersion"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"KbArticleVersion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KbArticleVersion"> | Date | string
    authorId?: StringNullableWithAggregatesFilter<"KbArticleVersion"> | string | null
    version?: IntWithAggregatesFilter<"KbArticleVersion"> | number
    isApproved?: BoolWithAggregatesFilter<"KbArticleVersion"> | boolean
  }

  export type KbArticleCommentWhereInput = {
    AND?: KbArticleCommentWhereInput | KbArticleCommentWhereInput[]
    OR?: KbArticleCommentWhereInput[]
    NOT?: KbArticleCommentWhereInput | KbArticleCommentWhereInput[]
    id?: IntFilter<"KbArticleComment"> | number
    articleId?: IntFilter<"KbArticleComment"> | number
    userId?: StringFilter<"KbArticleComment"> | string
    content?: StringFilter<"KbArticleComment"> | string
    createdAt?: DateTimeFilter<"KbArticleComment"> | Date | string
    updatedAt?: DateTimeFilter<"KbArticleComment"> | Date | string
    isDeleted?: BoolFilter<"KbArticleComment"> | boolean
    article?: XOR<KbArticleScalarRelationFilter, KbArticleWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type KbArticleCommentOrderByWithRelationInput = {
    id?: SortOrder
    articleId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    article?: KbArticleOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type KbArticleCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: KbArticleCommentWhereInput | KbArticleCommentWhereInput[]
    OR?: KbArticleCommentWhereInput[]
    NOT?: KbArticleCommentWhereInput | KbArticleCommentWhereInput[]
    articleId?: IntFilter<"KbArticleComment"> | number
    userId?: StringFilter<"KbArticleComment"> | string
    content?: StringFilter<"KbArticleComment"> | string
    createdAt?: DateTimeFilter<"KbArticleComment"> | Date | string
    updatedAt?: DateTimeFilter<"KbArticleComment"> | Date | string
    isDeleted?: BoolFilter<"KbArticleComment"> | boolean
    article?: XOR<KbArticleScalarRelationFilter, KbArticleWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type KbArticleCommentOrderByWithAggregationInput = {
    id?: SortOrder
    articleId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    _count?: KbArticleCommentCountOrderByAggregateInput
    _avg?: KbArticleCommentAvgOrderByAggregateInput
    _max?: KbArticleCommentMaxOrderByAggregateInput
    _min?: KbArticleCommentMinOrderByAggregateInput
    _sum?: KbArticleCommentSumOrderByAggregateInput
  }

  export type KbArticleCommentScalarWhereWithAggregatesInput = {
    AND?: KbArticleCommentScalarWhereWithAggregatesInput | KbArticleCommentScalarWhereWithAggregatesInput[]
    OR?: KbArticleCommentScalarWhereWithAggregatesInput[]
    NOT?: KbArticleCommentScalarWhereWithAggregatesInput | KbArticleCommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"KbArticleComment"> | number
    articleId?: IntWithAggregatesFilter<"KbArticleComment"> | number
    userId?: StringWithAggregatesFilter<"KbArticleComment"> | string
    content?: StringWithAggregatesFilter<"KbArticleComment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"KbArticleComment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KbArticleComment"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"KbArticleComment"> | boolean
  }

  export type SupportTicketWhereInput = {
    AND?: SupportTicketWhereInput | SupportTicketWhereInput[]
    OR?: SupportTicketWhereInput[]
    NOT?: SupportTicketWhereInput | SupportTicketWhereInput[]
    id?: IntFilter<"SupportTicket"> | number
    title?: StringFilter<"SupportTicket"> | string
    description?: StringFilter<"SupportTicket"> | string
    status?: StringFilter<"SupportTicket"> | string
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
    userId?: StringNullableFilter<"SupportTicket"> | string | null
    assigneeId?: StringNullableFilter<"SupportTicket"> | string | null
    vipPriorityScore?: IntNullableFilter<"SupportTicket"> | number | null
    vipTriggerSource?: StringNullableFilter<"SupportTicket"> | string | null
    users_support_tickets_assigneeIdTousers?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    users_support_tickets_userIdTousers?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    mailroomPackages?: MailroomPackageListRelationFilter
    assetHistory?: AssetTicketHistoryListRelationFilter
    ritms?: RITMListRelationFilter
  }

  export type SupportTicketOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    assigneeId?: SortOrderInput | SortOrder
    vipPriorityScore?: SortOrderInput | SortOrder
    vipTriggerSource?: SortOrderInput | SortOrder
    users_support_tickets_assigneeIdTousers?: UserOrderByWithRelationInput
    users_support_tickets_userIdTousers?: UserOrderByWithRelationInput
    mailroomPackages?: MailroomPackageOrderByRelationAggregateInput
    assetHistory?: AssetTicketHistoryOrderByRelationAggregateInput
    ritms?: RITMOrderByRelationAggregateInput
  }

  export type SupportTicketWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SupportTicketWhereInput | SupportTicketWhereInput[]
    OR?: SupportTicketWhereInput[]
    NOT?: SupportTicketWhereInput | SupportTicketWhereInput[]
    title?: StringFilter<"SupportTicket"> | string
    description?: StringFilter<"SupportTicket"> | string
    status?: StringFilter<"SupportTicket"> | string
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
    userId?: StringNullableFilter<"SupportTicket"> | string | null
    assigneeId?: StringNullableFilter<"SupportTicket"> | string | null
    vipPriorityScore?: IntNullableFilter<"SupportTicket"> | number | null
    vipTriggerSource?: StringNullableFilter<"SupportTicket"> | string | null
    users_support_tickets_assigneeIdTousers?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    users_support_tickets_userIdTousers?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    mailroomPackages?: MailroomPackageListRelationFilter
    assetHistory?: AssetTicketHistoryListRelationFilter
    ritms?: RITMListRelationFilter
  }, "id">

  export type SupportTicketOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    assigneeId?: SortOrderInput | SortOrder
    vipPriorityScore?: SortOrderInput | SortOrder
    vipTriggerSource?: SortOrderInput | SortOrder
    _count?: SupportTicketCountOrderByAggregateInput
    _avg?: SupportTicketAvgOrderByAggregateInput
    _max?: SupportTicketMaxOrderByAggregateInput
    _min?: SupportTicketMinOrderByAggregateInput
    _sum?: SupportTicketSumOrderByAggregateInput
  }

  export type SupportTicketScalarWhereWithAggregatesInput = {
    AND?: SupportTicketScalarWhereWithAggregatesInput | SupportTicketScalarWhereWithAggregatesInput[]
    OR?: SupportTicketScalarWhereWithAggregatesInput[]
    NOT?: SupportTicketScalarWhereWithAggregatesInput | SupportTicketScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SupportTicket"> | number
    title?: StringWithAggregatesFilter<"SupportTicket"> | string
    description?: StringWithAggregatesFilter<"SupportTicket"> | string
    status?: StringWithAggregatesFilter<"SupportTicket"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SupportTicket"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"SupportTicket"> | string | null
    assigneeId?: StringNullableWithAggregatesFilter<"SupportTicket"> | string | null
    vipPriorityScore?: IntNullableWithAggregatesFilter<"SupportTicket"> | number | null
    vipTriggerSource?: StringNullableWithAggregatesFilter<"SupportTicket"> | string | null
  }

  export type InventoryAssetWhereInput = {
    AND?: InventoryAssetWhereInput | InventoryAssetWhereInput[]
    OR?: InventoryAssetWhereInput[]
    NOT?: InventoryAssetWhereInput | InventoryAssetWhereInput[]
    id?: IntFilter<"InventoryAsset"> | number
    assetTag?: StringFilter<"InventoryAsset"> | string
    typeId?: IntNullableFilter<"InventoryAsset"> | number | null
    serialNumber?: StringNullableFilter<"InventoryAsset"> | string | null
    model?: StringNullableFilter<"InventoryAsset"> | string | null
    vendorId?: IntNullableFilter<"InventoryAsset"> | number | null
    purchaseDate?: DateTimeNullableFilter<"InventoryAsset"> | Date | string | null
    warrantyExpiry?: DateTimeNullableFilter<"InventoryAsset"> | Date | string | null
    assignedToUserId?: StringNullableFilter<"InventoryAsset"> | string | null
    assignedToOrgId?: IntNullableFilter<"InventoryAsset"> | number | null
    assignedToCustomerId?: IntNullableFilter<"InventoryAsset"> | number | null
    department?: StringNullableFilter<"InventoryAsset"> | string | null
    status?: StringNullableFilter<"InventoryAsset"> | string | null
    locationId?: IntNullableFilter<"InventoryAsset"> | number | null
    kioskId?: StringNullableFilter<"InventoryAsset"> | string | null
    customFields?: JsonNullableFilter<"InventoryAsset">
    notes?: StringNullableFilter<"InventoryAsset"> | string | null
    createdBy?: StringNullableFilter<"InventoryAsset"> | string | null
    updatedBy?: StringNullableFilter<"InventoryAsset"> | string | null
    createdAt?: DateTimeFilter<"InventoryAsset"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryAsset"> | Date | string
    serialNumberEnc?: StringNullableFilter<"InventoryAsset"> | string | null
    warrantyInfoEnc?: StringNullableFilter<"InventoryAsset"> | string | null
    purchaseInfoEnc?: StringNullableFilter<"InventoryAsset"> | string | null
    maintenanceNotesEnc?: StringNullableFilter<"InventoryAsset"> | string | null
    warrantyAlertDays?: IntNullableFilter<"InventoryAsset"> | number | null
    warrantyAlertEnabled?: BoolFilter<"InventoryAsset"> | boolean
    lastWarrantyAlertSent?: DateTimeNullableFilter<"InventoryAsset"> | Date | string | null
    importBatchId?: StringNullableFilter<"InventoryAsset"> | string | null
    importSource?: StringNullableFilter<"InventoryAsset"> | string | null
    importValidated?: BoolFilter<"InventoryAsset"> | boolean
    validationErrors?: StringNullableFilter<"InventoryAsset"> | string | null
    statusLogs?: AssetStatusLogListRelationFilter
    assignments?: AssetAssignmentListRelationFilter
    mailroomPackages?: MailroomPackageListRelationFilter
    ticketHistory?: AssetTicketHistoryListRelationFilter
    warrantyAlerts?: AssetWarrantyAlertListRelationFilter
    kioskRegistrations?: KioskAssetRegistryListRelationFilter
    validationLogs?: AssetValidationLogListRelationFilter
    syncFailures?: HelixSyncFailureListRelationFilter
    importBatch?: XOR<AssetImportBatchNullableScalarRelationFilter, AssetImportBatchWhereInput> | null
  }

  export type InventoryAssetOrderByWithRelationInput = {
    id?: SortOrder
    assetTag?: SortOrder
    typeId?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    vendorId?: SortOrderInput | SortOrder
    purchaseDate?: SortOrderInput | SortOrder
    warrantyExpiry?: SortOrderInput | SortOrder
    assignedToUserId?: SortOrderInput | SortOrder
    assignedToOrgId?: SortOrderInput | SortOrder
    assignedToCustomerId?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    kioskId?: SortOrderInput | SortOrder
    customFields?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serialNumberEnc?: SortOrderInput | SortOrder
    warrantyInfoEnc?: SortOrderInput | SortOrder
    purchaseInfoEnc?: SortOrderInput | SortOrder
    maintenanceNotesEnc?: SortOrderInput | SortOrder
    warrantyAlertDays?: SortOrderInput | SortOrder
    warrantyAlertEnabled?: SortOrder
    lastWarrantyAlertSent?: SortOrderInput | SortOrder
    importBatchId?: SortOrderInput | SortOrder
    importSource?: SortOrderInput | SortOrder
    importValidated?: SortOrder
    validationErrors?: SortOrderInput | SortOrder
    statusLogs?: AssetStatusLogOrderByRelationAggregateInput
    assignments?: AssetAssignmentOrderByRelationAggregateInput
    mailroomPackages?: MailroomPackageOrderByRelationAggregateInput
    ticketHistory?: AssetTicketHistoryOrderByRelationAggregateInput
    warrantyAlerts?: AssetWarrantyAlertOrderByRelationAggregateInput
    kioskRegistrations?: KioskAssetRegistryOrderByRelationAggregateInput
    validationLogs?: AssetValidationLogOrderByRelationAggregateInput
    syncFailures?: HelixSyncFailureOrderByRelationAggregateInput
    importBatch?: AssetImportBatchOrderByWithRelationInput
  }

  export type InventoryAssetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InventoryAssetWhereInput | InventoryAssetWhereInput[]
    OR?: InventoryAssetWhereInput[]
    NOT?: InventoryAssetWhereInput | InventoryAssetWhereInput[]
    assetTag?: StringFilter<"InventoryAsset"> | string
    typeId?: IntNullableFilter<"InventoryAsset"> | number | null
    serialNumber?: StringNullableFilter<"InventoryAsset"> | string | null
    model?: StringNullableFilter<"InventoryAsset"> | string | null
    vendorId?: IntNullableFilter<"InventoryAsset"> | number | null
    purchaseDate?: DateTimeNullableFilter<"InventoryAsset"> | Date | string | null
    warrantyExpiry?: DateTimeNullableFilter<"InventoryAsset"> | Date | string | null
    assignedToUserId?: StringNullableFilter<"InventoryAsset"> | string | null
    assignedToOrgId?: IntNullableFilter<"InventoryAsset"> | number | null
    assignedToCustomerId?: IntNullableFilter<"InventoryAsset"> | number | null
    department?: StringNullableFilter<"InventoryAsset"> | string | null
    status?: StringNullableFilter<"InventoryAsset"> | string | null
    locationId?: IntNullableFilter<"InventoryAsset"> | number | null
    kioskId?: StringNullableFilter<"InventoryAsset"> | string | null
    customFields?: JsonNullableFilter<"InventoryAsset">
    notes?: StringNullableFilter<"InventoryAsset"> | string | null
    createdBy?: StringNullableFilter<"InventoryAsset"> | string | null
    updatedBy?: StringNullableFilter<"InventoryAsset"> | string | null
    createdAt?: DateTimeFilter<"InventoryAsset"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryAsset"> | Date | string
    serialNumberEnc?: StringNullableFilter<"InventoryAsset"> | string | null
    warrantyInfoEnc?: StringNullableFilter<"InventoryAsset"> | string | null
    purchaseInfoEnc?: StringNullableFilter<"InventoryAsset"> | string | null
    maintenanceNotesEnc?: StringNullableFilter<"InventoryAsset"> | string | null
    warrantyAlertDays?: IntNullableFilter<"InventoryAsset"> | number | null
    warrantyAlertEnabled?: BoolFilter<"InventoryAsset"> | boolean
    lastWarrantyAlertSent?: DateTimeNullableFilter<"InventoryAsset"> | Date | string | null
    importBatchId?: StringNullableFilter<"InventoryAsset"> | string | null
    importSource?: StringNullableFilter<"InventoryAsset"> | string | null
    importValidated?: BoolFilter<"InventoryAsset"> | boolean
    validationErrors?: StringNullableFilter<"InventoryAsset"> | string | null
    statusLogs?: AssetStatusLogListRelationFilter
    assignments?: AssetAssignmentListRelationFilter
    mailroomPackages?: MailroomPackageListRelationFilter
    ticketHistory?: AssetTicketHistoryListRelationFilter
    warrantyAlerts?: AssetWarrantyAlertListRelationFilter
    kioskRegistrations?: KioskAssetRegistryListRelationFilter
    validationLogs?: AssetValidationLogListRelationFilter
    syncFailures?: HelixSyncFailureListRelationFilter
    importBatch?: XOR<AssetImportBatchNullableScalarRelationFilter, AssetImportBatchWhereInput> | null
  }, "id">

  export type InventoryAssetOrderByWithAggregationInput = {
    id?: SortOrder
    assetTag?: SortOrder
    typeId?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    vendorId?: SortOrderInput | SortOrder
    purchaseDate?: SortOrderInput | SortOrder
    warrantyExpiry?: SortOrderInput | SortOrder
    assignedToUserId?: SortOrderInput | SortOrder
    assignedToOrgId?: SortOrderInput | SortOrder
    assignedToCustomerId?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    kioskId?: SortOrderInput | SortOrder
    customFields?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serialNumberEnc?: SortOrderInput | SortOrder
    warrantyInfoEnc?: SortOrderInput | SortOrder
    purchaseInfoEnc?: SortOrderInput | SortOrder
    maintenanceNotesEnc?: SortOrderInput | SortOrder
    warrantyAlertDays?: SortOrderInput | SortOrder
    warrantyAlertEnabled?: SortOrder
    lastWarrantyAlertSent?: SortOrderInput | SortOrder
    importBatchId?: SortOrderInput | SortOrder
    importSource?: SortOrderInput | SortOrder
    importValidated?: SortOrder
    validationErrors?: SortOrderInput | SortOrder
    _count?: InventoryAssetCountOrderByAggregateInput
    _avg?: InventoryAssetAvgOrderByAggregateInput
    _max?: InventoryAssetMaxOrderByAggregateInput
    _min?: InventoryAssetMinOrderByAggregateInput
    _sum?: InventoryAssetSumOrderByAggregateInput
  }

  export type InventoryAssetScalarWhereWithAggregatesInput = {
    AND?: InventoryAssetScalarWhereWithAggregatesInput | InventoryAssetScalarWhereWithAggregatesInput[]
    OR?: InventoryAssetScalarWhereWithAggregatesInput[]
    NOT?: InventoryAssetScalarWhereWithAggregatesInput | InventoryAssetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InventoryAsset"> | number
    assetTag?: StringWithAggregatesFilter<"InventoryAsset"> | string
    typeId?: IntNullableWithAggregatesFilter<"InventoryAsset"> | number | null
    serialNumber?: StringNullableWithAggregatesFilter<"InventoryAsset"> | string | null
    model?: StringNullableWithAggregatesFilter<"InventoryAsset"> | string | null
    vendorId?: IntNullableWithAggregatesFilter<"InventoryAsset"> | number | null
    purchaseDate?: DateTimeNullableWithAggregatesFilter<"InventoryAsset"> | Date | string | null
    warrantyExpiry?: DateTimeNullableWithAggregatesFilter<"InventoryAsset"> | Date | string | null
    assignedToUserId?: StringNullableWithAggregatesFilter<"InventoryAsset"> | string | null
    assignedToOrgId?: IntNullableWithAggregatesFilter<"InventoryAsset"> | number | null
    assignedToCustomerId?: IntNullableWithAggregatesFilter<"InventoryAsset"> | number | null
    department?: StringNullableWithAggregatesFilter<"InventoryAsset"> | string | null
    status?: StringNullableWithAggregatesFilter<"InventoryAsset"> | string | null
    locationId?: IntNullableWithAggregatesFilter<"InventoryAsset"> | number | null
    kioskId?: StringNullableWithAggregatesFilter<"InventoryAsset"> | string | null
    customFields?: JsonNullableWithAggregatesFilter<"InventoryAsset">
    notes?: StringNullableWithAggregatesFilter<"InventoryAsset"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"InventoryAsset"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"InventoryAsset"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InventoryAsset"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InventoryAsset"> | Date | string
    serialNumberEnc?: StringNullableWithAggregatesFilter<"InventoryAsset"> | string | null
    warrantyInfoEnc?: StringNullableWithAggregatesFilter<"InventoryAsset"> | string | null
    purchaseInfoEnc?: StringNullableWithAggregatesFilter<"InventoryAsset"> | string | null
    maintenanceNotesEnc?: StringNullableWithAggregatesFilter<"InventoryAsset"> | string | null
    warrantyAlertDays?: IntNullableWithAggregatesFilter<"InventoryAsset"> | number | null
    warrantyAlertEnabled?: BoolWithAggregatesFilter<"InventoryAsset"> | boolean
    lastWarrantyAlertSent?: DateTimeNullableWithAggregatesFilter<"InventoryAsset"> | Date | string | null
    importBatchId?: StringNullableWithAggregatesFilter<"InventoryAsset"> | string | null
    importSource?: StringNullableWithAggregatesFilter<"InventoryAsset"> | string | null
    importValidated?: BoolWithAggregatesFilter<"InventoryAsset"> | boolean
    validationErrors?: StringNullableWithAggregatesFilter<"InventoryAsset"> | string | null
  }

  export type AssetStatusLogWhereInput = {
    AND?: AssetStatusLogWhereInput | AssetStatusLogWhereInput[]
    OR?: AssetStatusLogWhereInput[]
    NOT?: AssetStatusLogWhereInput | AssetStatusLogWhereInput[]
    id?: IntFilter<"AssetStatusLog"> | number
    assetId?: IntFilter<"AssetStatusLog"> | number
    previousStatus?: StringNullableFilter<"AssetStatusLog"> | string | null
    newStatus?: StringFilter<"AssetStatusLog"> | string
    changedByUserId?: StringNullableFilter<"AssetStatusLog"> | string | null
    notes?: StringNullableFilter<"AssetStatusLog"> | string | null
    timestamp?: DateTimeFilter<"AssetStatusLog"> | Date | string
    asset?: XOR<InventoryAssetScalarRelationFilter, InventoryAssetWhereInput>
  }

  export type AssetStatusLogOrderByWithRelationInput = {
    id?: SortOrder
    assetId?: SortOrder
    previousStatus?: SortOrderInput | SortOrder
    newStatus?: SortOrder
    changedByUserId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    asset?: InventoryAssetOrderByWithRelationInput
  }

  export type AssetStatusLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AssetStatusLogWhereInput | AssetStatusLogWhereInput[]
    OR?: AssetStatusLogWhereInput[]
    NOT?: AssetStatusLogWhereInput | AssetStatusLogWhereInput[]
    assetId?: IntFilter<"AssetStatusLog"> | number
    previousStatus?: StringNullableFilter<"AssetStatusLog"> | string | null
    newStatus?: StringFilter<"AssetStatusLog"> | string
    changedByUserId?: StringNullableFilter<"AssetStatusLog"> | string | null
    notes?: StringNullableFilter<"AssetStatusLog"> | string | null
    timestamp?: DateTimeFilter<"AssetStatusLog"> | Date | string
    asset?: XOR<InventoryAssetScalarRelationFilter, InventoryAssetWhereInput>
  }, "id">

  export type AssetStatusLogOrderByWithAggregationInput = {
    id?: SortOrder
    assetId?: SortOrder
    previousStatus?: SortOrderInput | SortOrder
    newStatus?: SortOrder
    changedByUserId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: AssetStatusLogCountOrderByAggregateInput
    _avg?: AssetStatusLogAvgOrderByAggregateInput
    _max?: AssetStatusLogMaxOrderByAggregateInput
    _min?: AssetStatusLogMinOrderByAggregateInput
    _sum?: AssetStatusLogSumOrderByAggregateInput
  }

  export type AssetStatusLogScalarWhereWithAggregatesInput = {
    AND?: AssetStatusLogScalarWhereWithAggregatesInput | AssetStatusLogScalarWhereWithAggregatesInput[]
    OR?: AssetStatusLogScalarWhereWithAggregatesInput[]
    NOT?: AssetStatusLogScalarWhereWithAggregatesInput | AssetStatusLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AssetStatusLog"> | number
    assetId?: IntWithAggregatesFilter<"AssetStatusLog"> | number
    previousStatus?: StringNullableWithAggregatesFilter<"AssetStatusLog"> | string | null
    newStatus?: StringWithAggregatesFilter<"AssetStatusLog"> | string
    changedByUserId?: StringNullableWithAggregatesFilter<"AssetStatusLog"> | string | null
    notes?: StringNullableWithAggregatesFilter<"AssetStatusLog"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"AssetStatusLog"> | Date | string
  }

  export type AssetAssignmentWhereInput = {
    AND?: AssetAssignmentWhereInput | AssetAssignmentWhereInput[]
    OR?: AssetAssignmentWhereInput[]
    NOT?: AssetAssignmentWhereInput | AssetAssignmentWhereInput[]
    id?: IntFilter<"AssetAssignment"> | number
    assetId?: IntFilter<"AssetAssignment"> | number
    userId?: StringNullableFilter<"AssetAssignment"> | string | null
    orgId?: IntNullableFilter<"AssetAssignment"> | number | null
    customerId?: IntNullableFilter<"AssetAssignment"> | number | null
    assignedBy?: StringNullableFilter<"AssetAssignment"> | string | null
    assignedDate?: DateTimeFilter<"AssetAssignment"> | Date | string
    expectedReturn?: DateTimeNullableFilter<"AssetAssignment"> | Date | string | null
    returnDate?: DateTimeNullableFilter<"AssetAssignment"> | Date | string | null
    managerId?: StringNullableFilter<"AssetAssignment"> | string | null
    asset?: XOR<InventoryAssetScalarRelationFilter, InventoryAssetWhereInput>
  }

  export type AssetAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    assetId?: SortOrder
    userId?: SortOrderInput | SortOrder
    orgId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    assignedBy?: SortOrderInput | SortOrder
    assignedDate?: SortOrder
    expectedReturn?: SortOrderInput | SortOrder
    returnDate?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    asset?: InventoryAssetOrderByWithRelationInput
  }

  export type AssetAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AssetAssignmentWhereInput | AssetAssignmentWhereInput[]
    OR?: AssetAssignmentWhereInput[]
    NOT?: AssetAssignmentWhereInput | AssetAssignmentWhereInput[]
    assetId?: IntFilter<"AssetAssignment"> | number
    userId?: StringNullableFilter<"AssetAssignment"> | string | null
    orgId?: IntNullableFilter<"AssetAssignment"> | number | null
    customerId?: IntNullableFilter<"AssetAssignment"> | number | null
    assignedBy?: StringNullableFilter<"AssetAssignment"> | string | null
    assignedDate?: DateTimeFilter<"AssetAssignment"> | Date | string
    expectedReturn?: DateTimeNullableFilter<"AssetAssignment"> | Date | string | null
    returnDate?: DateTimeNullableFilter<"AssetAssignment"> | Date | string | null
    managerId?: StringNullableFilter<"AssetAssignment"> | string | null
    asset?: XOR<InventoryAssetScalarRelationFilter, InventoryAssetWhereInput>
  }, "id">

  export type AssetAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    assetId?: SortOrder
    userId?: SortOrderInput | SortOrder
    orgId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    assignedBy?: SortOrderInput | SortOrder
    assignedDate?: SortOrder
    expectedReturn?: SortOrderInput | SortOrder
    returnDate?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    _count?: AssetAssignmentCountOrderByAggregateInput
    _avg?: AssetAssignmentAvgOrderByAggregateInput
    _max?: AssetAssignmentMaxOrderByAggregateInput
    _min?: AssetAssignmentMinOrderByAggregateInput
    _sum?: AssetAssignmentSumOrderByAggregateInput
  }

  export type AssetAssignmentScalarWhereWithAggregatesInput = {
    AND?: AssetAssignmentScalarWhereWithAggregatesInput | AssetAssignmentScalarWhereWithAggregatesInput[]
    OR?: AssetAssignmentScalarWhereWithAggregatesInput[]
    NOT?: AssetAssignmentScalarWhereWithAggregatesInput | AssetAssignmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AssetAssignment"> | number
    assetId?: IntWithAggregatesFilter<"AssetAssignment"> | number
    userId?: StringNullableWithAggregatesFilter<"AssetAssignment"> | string | null
    orgId?: IntNullableWithAggregatesFilter<"AssetAssignment"> | number | null
    customerId?: IntNullableWithAggregatesFilter<"AssetAssignment"> | number | null
    assignedBy?: StringNullableWithAggregatesFilter<"AssetAssignment"> | string | null
    assignedDate?: DateTimeWithAggregatesFilter<"AssetAssignment"> | Date | string
    expectedReturn?: DateTimeNullableWithAggregatesFilter<"AssetAssignment"> | Date | string | null
    returnDate?: DateTimeNullableWithAggregatesFilter<"AssetAssignment"> | Date | string | null
    managerId?: StringNullableWithAggregatesFilter<"AssetAssignment"> | string | null
  }

  export type AssetTicketHistoryWhereInput = {
    AND?: AssetTicketHistoryWhereInput | AssetTicketHistoryWhereInput[]
    OR?: AssetTicketHistoryWhereInput[]
    NOT?: AssetTicketHistoryWhereInput | AssetTicketHistoryWhereInput[]
    id?: IntFilter<"AssetTicketHistory"> | number
    assetId?: IntFilter<"AssetTicketHistory"> | number
    ticketId?: IntFilter<"AssetTicketHistory"> | number
    relationshipType?: StringFilter<"AssetTicketHistory"> | string
    createdAt?: DateTimeFilter<"AssetTicketHistory"> | Date | string
    endedAt?: DateTimeNullableFilter<"AssetTicketHistory"> | Date | string | null
    createdBy?: StringNullableFilter<"AssetTicketHistory"> | string | null
    notes?: StringNullableFilter<"AssetTicketHistory"> | string | null
    asset?: XOR<InventoryAssetScalarRelationFilter, InventoryAssetWhereInput>
    ticket?: XOR<SupportTicketScalarRelationFilter, SupportTicketWhereInput>
  }

  export type AssetTicketHistoryOrderByWithRelationInput = {
    id?: SortOrder
    assetId?: SortOrder
    ticketId?: SortOrder
    relationshipType?: SortOrder
    createdAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    asset?: InventoryAssetOrderByWithRelationInput
    ticket?: SupportTicketOrderByWithRelationInput
  }

  export type AssetTicketHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AssetTicketHistoryWhereInput | AssetTicketHistoryWhereInput[]
    OR?: AssetTicketHistoryWhereInput[]
    NOT?: AssetTicketHistoryWhereInput | AssetTicketHistoryWhereInput[]
    assetId?: IntFilter<"AssetTicketHistory"> | number
    ticketId?: IntFilter<"AssetTicketHistory"> | number
    relationshipType?: StringFilter<"AssetTicketHistory"> | string
    createdAt?: DateTimeFilter<"AssetTicketHistory"> | Date | string
    endedAt?: DateTimeNullableFilter<"AssetTicketHistory"> | Date | string | null
    createdBy?: StringNullableFilter<"AssetTicketHistory"> | string | null
    notes?: StringNullableFilter<"AssetTicketHistory"> | string | null
    asset?: XOR<InventoryAssetScalarRelationFilter, InventoryAssetWhereInput>
    ticket?: XOR<SupportTicketScalarRelationFilter, SupportTicketWhereInput>
  }, "id">

  export type AssetTicketHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    assetId?: SortOrder
    ticketId?: SortOrder
    relationshipType?: SortOrder
    createdAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: AssetTicketHistoryCountOrderByAggregateInput
    _avg?: AssetTicketHistoryAvgOrderByAggregateInput
    _max?: AssetTicketHistoryMaxOrderByAggregateInput
    _min?: AssetTicketHistoryMinOrderByAggregateInput
    _sum?: AssetTicketHistorySumOrderByAggregateInput
  }

  export type AssetTicketHistoryScalarWhereWithAggregatesInput = {
    AND?: AssetTicketHistoryScalarWhereWithAggregatesInput | AssetTicketHistoryScalarWhereWithAggregatesInput[]
    OR?: AssetTicketHistoryScalarWhereWithAggregatesInput[]
    NOT?: AssetTicketHistoryScalarWhereWithAggregatesInput | AssetTicketHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AssetTicketHistory"> | number
    assetId?: IntWithAggregatesFilter<"AssetTicketHistory"> | number
    ticketId?: IntWithAggregatesFilter<"AssetTicketHistory"> | number
    relationshipType?: StringWithAggregatesFilter<"AssetTicketHistory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AssetTicketHistory"> | Date | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"AssetTicketHistory"> | Date | string | null
    createdBy?: StringNullableWithAggregatesFilter<"AssetTicketHistory"> | string | null
    notes?: StringNullableWithAggregatesFilter<"AssetTicketHistory"> | string | null
  }

  export type AssetWarrantyAlertWhereInput = {
    AND?: AssetWarrantyAlertWhereInput | AssetWarrantyAlertWhereInput[]
    OR?: AssetWarrantyAlertWhereInput[]
    NOT?: AssetWarrantyAlertWhereInput | AssetWarrantyAlertWhereInput[]
    id?: IntFilter<"AssetWarrantyAlert"> | number
    assetId?: IntFilter<"AssetWarrantyAlert"> | number
    alertType?: StringFilter<"AssetWarrantyAlert"> | string
    alertDate?: DateTimeFilter<"AssetWarrantyAlert"> | Date | string
    expiryDate?: DateTimeFilter<"AssetWarrantyAlert"> | Date | string
    daysRemaining?: IntFilter<"AssetWarrantyAlert"> | number
    notificationSent?: BoolFilter<"AssetWarrantyAlert"> | boolean
    notificationSentAt?: DateTimeNullableFilter<"AssetWarrantyAlert"> | Date | string | null
    dismissed?: BoolFilter<"AssetWarrantyAlert"> | boolean
    dismissedBy?: StringNullableFilter<"AssetWarrantyAlert"> | string | null
    dismissedAt?: DateTimeNullableFilter<"AssetWarrantyAlert"> | Date | string | null
    asset?: XOR<InventoryAssetScalarRelationFilter, InventoryAssetWhereInput>
  }

  export type AssetWarrantyAlertOrderByWithRelationInput = {
    id?: SortOrder
    assetId?: SortOrder
    alertType?: SortOrder
    alertDate?: SortOrder
    expiryDate?: SortOrder
    daysRemaining?: SortOrder
    notificationSent?: SortOrder
    notificationSentAt?: SortOrderInput | SortOrder
    dismissed?: SortOrder
    dismissedBy?: SortOrderInput | SortOrder
    dismissedAt?: SortOrderInput | SortOrder
    asset?: InventoryAssetOrderByWithRelationInput
  }

  export type AssetWarrantyAlertWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AssetWarrantyAlertWhereInput | AssetWarrantyAlertWhereInput[]
    OR?: AssetWarrantyAlertWhereInput[]
    NOT?: AssetWarrantyAlertWhereInput | AssetWarrantyAlertWhereInput[]
    assetId?: IntFilter<"AssetWarrantyAlert"> | number
    alertType?: StringFilter<"AssetWarrantyAlert"> | string
    alertDate?: DateTimeFilter<"AssetWarrantyAlert"> | Date | string
    expiryDate?: DateTimeFilter<"AssetWarrantyAlert"> | Date | string
    daysRemaining?: IntFilter<"AssetWarrantyAlert"> | number
    notificationSent?: BoolFilter<"AssetWarrantyAlert"> | boolean
    notificationSentAt?: DateTimeNullableFilter<"AssetWarrantyAlert"> | Date | string | null
    dismissed?: BoolFilter<"AssetWarrantyAlert"> | boolean
    dismissedBy?: StringNullableFilter<"AssetWarrantyAlert"> | string | null
    dismissedAt?: DateTimeNullableFilter<"AssetWarrantyAlert"> | Date | string | null
    asset?: XOR<InventoryAssetScalarRelationFilter, InventoryAssetWhereInput>
  }, "id">

  export type AssetWarrantyAlertOrderByWithAggregationInput = {
    id?: SortOrder
    assetId?: SortOrder
    alertType?: SortOrder
    alertDate?: SortOrder
    expiryDate?: SortOrder
    daysRemaining?: SortOrder
    notificationSent?: SortOrder
    notificationSentAt?: SortOrderInput | SortOrder
    dismissed?: SortOrder
    dismissedBy?: SortOrderInput | SortOrder
    dismissedAt?: SortOrderInput | SortOrder
    _count?: AssetWarrantyAlertCountOrderByAggregateInput
    _avg?: AssetWarrantyAlertAvgOrderByAggregateInput
    _max?: AssetWarrantyAlertMaxOrderByAggregateInput
    _min?: AssetWarrantyAlertMinOrderByAggregateInput
    _sum?: AssetWarrantyAlertSumOrderByAggregateInput
  }

  export type AssetWarrantyAlertScalarWhereWithAggregatesInput = {
    AND?: AssetWarrantyAlertScalarWhereWithAggregatesInput | AssetWarrantyAlertScalarWhereWithAggregatesInput[]
    OR?: AssetWarrantyAlertScalarWhereWithAggregatesInput[]
    NOT?: AssetWarrantyAlertScalarWhereWithAggregatesInput | AssetWarrantyAlertScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AssetWarrantyAlert"> | number
    assetId?: IntWithAggregatesFilter<"AssetWarrantyAlert"> | number
    alertType?: StringWithAggregatesFilter<"AssetWarrantyAlert"> | string
    alertDate?: DateTimeWithAggregatesFilter<"AssetWarrantyAlert"> | Date | string
    expiryDate?: DateTimeWithAggregatesFilter<"AssetWarrantyAlert"> | Date | string
    daysRemaining?: IntWithAggregatesFilter<"AssetWarrantyAlert"> | number
    notificationSent?: BoolWithAggregatesFilter<"AssetWarrantyAlert"> | boolean
    notificationSentAt?: DateTimeNullableWithAggregatesFilter<"AssetWarrantyAlert"> | Date | string | null
    dismissed?: BoolWithAggregatesFilter<"AssetWarrantyAlert"> | boolean
    dismissedBy?: StringNullableWithAggregatesFilter<"AssetWarrantyAlert"> | string | null
    dismissedAt?: DateTimeNullableWithAggregatesFilter<"AssetWarrantyAlert"> | Date | string | null
  }

  export type AssetImportBatchWhereInput = {
    AND?: AssetImportBatchWhereInput | AssetImportBatchWhereInput[]
    OR?: AssetImportBatchWhereInput[]
    NOT?: AssetImportBatchWhereInput | AssetImportBatchWhereInput[]
    id?: StringFilter<"AssetImportBatch"> | string
    filename?: StringFilter<"AssetImportBatch"> | string
    importedBy?: StringFilter<"AssetImportBatch"> | string
    importDate?: DateTimeFilter<"AssetImportBatch"> | Date | string
    totalRecords?: IntFilter<"AssetImportBatch"> | number
    successfulRecords?: IntFilter<"AssetImportBatch"> | number
    failedRecords?: IntFilter<"AssetImportBatch"> | number
    validationStatus?: StringFilter<"AssetImportBatch"> | string
    validationErrors?: StringNullableFilter<"AssetImportBatch"> | string | null
    rollbackDate?: DateTimeNullableFilter<"AssetImportBatch"> | Date | string | null
    rollbackBy?: StringNullableFilter<"AssetImportBatch"> | string | null
    assets?: InventoryAssetListRelationFilter
    validationLogs?: AssetValidationLogListRelationFilter
  }

  export type AssetImportBatchOrderByWithRelationInput = {
    id?: SortOrder
    filename?: SortOrder
    importedBy?: SortOrder
    importDate?: SortOrder
    totalRecords?: SortOrder
    successfulRecords?: SortOrder
    failedRecords?: SortOrder
    validationStatus?: SortOrder
    validationErrors?: SortOrderInput | SortOrder
    rollbackDate?: SortOrderInput | SortOrder
    rollbackBy?: SortOrderInput | SortOrder
    assets?: InventoryAssetOrderByRelationAggregateInput
    validationLogs?: AssetValidationLogOrderByRelationAggregateInput
  }

  export type AssetImportBatchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssetImportBatchWhereInput | AssetImportBatchWhereInput[]
    OR?: AssetImportBatchWhereInput[]
    NOT?: AssetImportBatchWhereInput | AssetImportBatchWhereInput[]
    filename?: StringFilter<"AssetImportBatch"> | string
    importedBy?: StringFilter<"AssetImportBatch"> | string
    importDate?: DateTimeFilter<"AssetImportBatch"> | Date | string
    totalRecords?: IntFilter<"AssetImportBatch"> | number
    successfulRecords?: IntFilter<"AssetImportBatch"> | number
    failedRecords?: IntFilter<"AssetImportBatch"> | number
    validationStatus?: StringFilter<"AssetImportBatch"> | string
    validationErrors?: StringNullableFilter<"AssetImportBatch"> | string | null
    rollbackDate?: DateTimeNullableFilter<"AssetImportBatch"> | Date | string | null
    rollbackBy?: StringNullableFilter<"AssetImportBatch"> | string | null
    assets?: InventoryAssetListRelationFilter
    validationLogs?: AssetValidationLogListRelationFilter
  }, "id">

  export type AssetImportBatchOrderByWithAggregationInput = {
    id?: SortOrder
    filename?: SortOrder
    importedBy?: SortOrder
    importDate?: SortOrder
    totalRecords?: SortOrder
    successfulRecords?: SortOrder
    failedRecords?: SortOrder
    validationStatus?: SortOrder
    validationErrors?: SortOrderInput | SortOrder
    rollbackDate?: SortOrderInput | SortOrder
    rollbackBy?: SortOrderInput | SortOrder
    _count?: AssetImportBatchCountOrderByAggregateInput
    _avg?: AssetImportBatchAvgOrderByAggregateInput
    _max?: AssetImportBatchMaxOrderByAggregateInput
    _min?: AssetImportBatchMinOrderByAggregateInput
    _sum?: AssetImportBatchSumOrderByAggregateInput
  }

  export type AssetImportBatchScalarWhereWithAggregatesInput = {
    AND?: AssetImportBatchScalarWhereWithAggregatesInput | AssetImportBatchScalarWhereWithAggregatesInput[]
    OR?: AssetImportBatchScalarWhereWithAggregatesInput[]
    NOT?: AssetImportBatchScalarWhereWithAggregatesInput | AssetImportBatchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AssetImportBatch"> | string
    filename?: StringWithAggregatesFilter<"AssetImportBatch"> | string
    importedBy?: StringWithAggregatesFilter<"AssetImportBatch"> | string
    importDate?: DateTimeWithAggregatesFilter<"AssetImportBatch"> | Date | string
    totalRecords?: IntWithAggregatesFilter<"AssetImportBatch"> | number
    successfulRecords?: IntWithAggregatesFilter<"AssetImportBatch"> | number
    failedRecords?: IntWithAggregatesFilter<"AssetImportBatch"> | number
    validationStatus?: StringWithAggregatesFilter<"AssetImportBatch"> | string
    validationErrors?: StringNullableWithAggregatesFilter<"AssetImportBatch"> | string | null
    rollbackDate?: DateTimeNullableWithAggregatesFilter<"AssetImportBatch"> | Date | string | null
    rollbackBy?: StringNullableWithAggregatesFilter<"AssetImportBatch"> | string | null
  }

  export type AssetValidationLogWhereInput = {
    AND?: AssetValidationLogWhereInput | AssetValidationLogWhereInput[]
    OR?: AssetValidationLogWhereInput[]
    NOT?: AssetValidationLogWhereInput | AssetValidationLogWhereInput[]
    id?: IntFilter<"AssetValidationLog"> | number
    batchId?: StringFilter<"AssetValidationLog"> | string
    assetId?: IntNullableFilter<"AssetValidationLog"> | number | null
    rowNumber?: IntFilter<"AssetValidationLog"> | number
    validationLevel?: StringFilter<"AssetValidationLog"> | string
    fieldName?: StringNullableFilter<"AssetValidationLog"> | string | null
    message?: StringFilter<"AssetValidationLog"> | string
    rawData?: JsonNullableFilter<"AssetValidationLog">
    createdAt?: DateTimeFilter<"AssetValidationLog"> | Date | string
    batch?: XOR<AssetImportBatchScalarRelationFilter, AssetImportBatchWhereInput>
    asset?: XOR<InventoryAssetNullableScalarRelationFilter, InventoryAssetWhereInput> | null
  }

  export type AssetValidationLogOrderByWithRelationInput = {
    id?: SortOrder
    batchId?: SortOrder
    assetId?: SortOrderInput | SortOrder
    rowNumber?: SortOrder
    validationLevel?: SortOrder
    fieldName?: SortOrderInput | SortOrder
    message?: SortOrder
    rawData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    batch?: AssetImportBatchOrderByWithRelationInput
    asset?: InventoryAssetOrderByWithRelationInput
  }

  export type AssetValidationLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AssetValidationLogWhereInput | AssetValidationLogWhereInput[]
    OR?: AssetValidationLogWhereInput[]
    NOT?: AssetValidationLogWhereInput | AssetValidationLogWhereInput[]
    batchId?: StringFilter<"AssetValidationLog"> | string
    assetId?: IntNullableFilter<"AssetValidationLog"> | number | null
    rowNumber?: IntFilter<"AssetValidationLog"> | number
    validationLevel?: StringFilter<"AssetValidationLog"> | string
    fieldName?: StringNullableFilter<"AssetValidationLog"> | string | null
    message?: StringFilter<"AssetValidationLog"> | string
    rawData?: JsonNullableFilter<"AssetValidationLog">
    createdAt?: DateTimeFilter<"AssetValidationLog"> | Date | string
    batch?: XOR<AssetImportBatchScalarRelationFilter, AssetImportBatchWhereInput>
    asset?: XOR<InventoryAssetNullableScalarRelationFilter, InventoryAssetWhereInput> | null
  }, "id">

  export type AssetValidationLogOrderByWithAggregationInput = {
    id?: SortOrder
    batchId?: SortOrder
    assetId?: SortOrderInput | SortOrder
    rowNumber?: SortOrder
    validationLevel?: SortOrder
    fieldName?: SortOrderInput | SortOrder
    message?: SortOrder
    rawData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AssetValidationLogCountOrderByAggregateInput
    _avg?: AssetValidationLogAvgOrderByAggregateInput
    _max?: AssetValidationLogMaxOrderByAggregateInput
    _min?: AssetValidationLogMinOrderByAggregateInput
    _sum?: AssetValidationLogSumOrderByAggregateInput
  }

  export type AssetValidationLogScalarWhereWithAggregatesInput = {
    AND?: AssetValidationLogScalarWhereWithAggregatesInput | AssetValidationLogScalarWhereWithAggregatesInput[]
    OR?: AssetValidationLogScalarWhereWithAggregatesInput[]
    NOT?: AssetValidationLogScalarWhereWithAggregatesInput | AssetValidationLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AssetValidationLog"> | number
    batchId?: StringWithAggregatesFilter<"AssetValidationLog"> | string
    assetId?: IntNullableWithAggregatesFilter<"AssetValidationLog"> | number | null
    rowNumber?: IntWithAggregatesFilter<"AssetValidationLog"> | number
    validationLevel?: StringWithAggregatesFilter<"AssetValidationLog"> | string
    fieldName?: StringNullableWithAggregatesFilter<"AssetValidationLog"> | string | null
    message?: StringWithAggregatesFilter<"AssetValidationLog"> | string
    rawData?: JsonNullableWithAggregatesFilter<"AssetValidationLog">
    createdAt?: DateTimeWithAggregatesFilter<"AssetValidationLog"> | Date | string
  }

  export type KioskAssetRegistryWhereInput = {
    AND?: KioskAssetRegistryWhereInput | KioskAssetRegistryWhereInput[]
    OR?: KioskAssetRegistryWhereInput[]
    NOT?: KioskAssetRegistryWhereInput | KioskAssetRegistryWhereInput[]
    id?: IntFilter<"KioskAssetRegistry"> | number
    kioskId?: StringFilter<"KioskAssetRegistry"> | string
    assetId?: IntFilter<"KioskAssetRegistry"> | number
    registrationDate?: DateTimeFilter<"KioskAssetRegistry"> | Date | string
    lastCheckIn?: DateTimeNullableFilter<"KioskAssetRegistry"> | Date | string | null
    status?: StringFilter<"KioskAssetRegistry"> | string
    helixSyncStatus?: StringFilter<"KioskAssetRegistry"> | string
    helixLastSync?: DateTimeNullableFilter<"KioskAssetRegistry"> | Date | string | null
    helixErrorMessage?: StringNullableFilter<"KioskAssetRegistry"> | string | null
    encryptedMetadata?: StringNullableFilter<"KioskAssetRegistry"> | string | null
    createdBy?: StringNullableFilter<"KioskAssetRegistry"> | string | null
    updatedBy?: StringNullableFilter<"KioskAssetRegistry"> | string | null
    kiosk?: XOR<KioskScalarRelationFilter, KioskWhereInput>
    asset?: XOR<InventoryAssetScalarRelationFilter, InventoryAssetWhereInput>
  }

  export type KioskAssetRegistryOrderByWithRelationInput = {
    id?: SortOrder
    kioskId?: SortOrder
    assetId?: SortOrder
    registrationDate?: SortOrder
    lastCheckIn?: SortOrderInput | SortOrder
    status?: SortOrder
    helixSyncStatus?: SortOrder
    helixLastSync?: SortOrderInput | SortOrder
    helixErrorMessage?: SortOrderInput | SortOrder
    encryptedMetadata?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    kiosk?: KioskOrderByWithRelationInput
    asset?: InventoryAssetOrderByWithRelationInput
  }

  export type KioskAssetRegistryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    kioskId_assetId?: KioskAssetRegistryKioskIdAssetIdCompoundUniqueInput
    AND?: KioskAssetRegistryWhereInput | KioskAssetRegistryWhereInput[]
    OR?: KioskAssetRegistryWhereInput[]
    NOT?: KioskAssetRegistryWhereInput | KioskAssetRegistryWhereInput[]
    kioskId?: StringFilter<"KioskAssetRegistry"> | string
    assetId?: IntFilter<"KioskAssetRegistry"> | number
    registrationDate?: DateTimeFilter<"KioskAssetRegistry"> | Date | string
    lastCheckIn?: DateTimeNullableFilter<"KioskAssetRegistry"> | Date | string | null
    status?: StringFilter<"KioskAssetRegistry"> | string
    helixSyncStatus?: StringFilter<"KioskAssetRegistry"> | string
    helixLastSync?: DateTimeNullableFilter<"KioskAssetRegistry"> | Date | string | null
    helixErrorMessage?: StringNullableFilter<"KioskAssetRegistry"> | string | null
    encryptedMetadata?: StringNullableFilter<"KioskAssetRegistry"> | string | null
    createdBy?: StringNullableFilter<"KioskAssetRegistry"> | string | null
    updatedBy?: StringNullableFilter<"KioskAssetRegistry"> | string | null
    kiosk?: XOR<KioskScalarRelationFilter, KioskWhereInput>
    asset?: XOR<InventoryAssetScalarRelationFilter, InventoryAssetWhereInput>
  }, "id" | "kioskId_assetId">

  export type KioskAssetRegistryOrderByWithAggregationInput = {
    id?: SortOrder
    kioskId?: SortOrder
    assetId?: SortOrder
    registrationDate?: SortOrder
    lastCheckIn?: SortOrderInput | SortOrder
    status?: SortOrder
    helixSyncStatus?: SortOrder
    helixLastSync?: SortOrderInput | SortOrder
    helixErrorMessage?: SortOrderInput | SortOrder
    encryptedMetadata?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: KioskAssetRegistryCountOrderByAggregateInput
    _avg?: KioskAssetRegistryAvgOrderByAggregateInput
    _max?: KioskAssetRegistryMaxOrderByAggregateInput
    _min?: KioskAssetRegistryMinOrderByAggregateInput
    _sum?: KioskAssetRegistrySumOrderByAggregateInput
  }

  export type KioskAssetRegistryScalarWhereWithAggregatesInput = {
    AND?: KioskAssetRegistryScalarWhereWithAggregatesInput | KioskAssetRegistryScalarWhereWithAggregatesInput[]
    OR?: KioskAssetRegistryScalarWhereWithAggregatesInput[]
    NOT?: KioskAssetRegistryScalarWhereWithAggregatesInput | KioskAssetRegistryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"KioskAssetRegistry"> | number
    kioskId?: StringWithAggregatesFilter<"KioskAssetRegistry"> | string
    assetId?: IntWithAggregatesFilter<"KioskAssetRegistry"> | number
    registrationDate?: DateTimeWithAggregatesFilter<"KioskAssetRegistry"> | Date | string
    lastCheckIn?: DateTimeNullableWithAggregatesFilter<"KioskAssetRegistry"> | Date | string | null
    status?: StringWithAggregatesFilter<"KioskAssetRegistry"> | string
    helixSyncStatus?: StringWithAggregatesFilter<"KioskAssetRegistry"> | string
    helixLastSync?: DateTimeNullableWithAggregatesFilter<"KioskAssetRegistry"> | Date | string | null
    helixErrorMessage?: StringNullableWithAggregatesFilter<"KioskAssetRegistry"> | string | null
    encryptedMetadata?: StringNullableWithAggregatesFilter<"KioskAssetRegistry"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"KioskAssetRegistry"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"KioskAssetRegistry"> | string | null
  }

  export type HelixSyncFailureWhereInput = {
    AND?: HelixSyncFailureWhereInput | HelixSyncFailureWhereInput[]
    OR?: HelixSyncFailureWhereInput[]
    NOT?: HelixSyncFailureWhereInput | HelixSyncFailureWhereInput[]
    id?: IntFilter<"HelixSyncFailure"> | number
    kioskId?: StringFilter<"HelixSyncFailure"> | string
    assetId?: IntFilter<"HelixSyncFailure"> | number
    errorMessage?: StringFilter<"HelixSyncFailure"> | string
    metadata?: JsonNullableFilter<"HelixSyncFailure">
    retryCount?: IntFilter<"HelixSyncFailure"> | number
    nextRetryAt?: DateTimeFilter<"HelixSyncFailure"> | Date | string
    createdAt?: DateTimeFilter<"HelixSyncFailure"> | Date | string
    updatedAt?: DateTimeFilter<"HelixSyncFailure"> | Date | string
    kiosk?: XOR<KioskScalarRelationFilter, KioskWhereInput>
    asset?: XOR<InventoryAssetScalarRelationFilter, InventoryAssetWhereInput>
  }

  export type HelixSyncFailureOrderByWithRelationInput = {
    id?: SortOrder
    kioskId?: SortOrder
    assetId?: SortOrder
    errorMessage?: SortOrder
    metadata?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    nextRetryAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kiosk?: KioskOrderByWithRelationInput
    asset?: InventoryAssetOrderByWithRelationInput
  }

  export type HelixSyncFailureWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    kioskId_assetId?: HelixSyncFailureKioskIdAssetIdCompoundUniqueInput
    AND?: HelixSyncFailureWhereInput | HelixSyncFailureWhereInput[]
    OR?: HelixSyncFailureWhereInput[]
    NOT?: HelixSyncFailureWhereInput | HelixSyncFailureWhereInput[]
    kioskId?: StringFilter<"HelixSyncFailure"> | string
    assetId?: IntFilter<"HelixSyncFailure"> | number
    errorMessage?: StringFilter<"HelixSyncFailure"> | string
    metadata?: JsonNullableFilter<"HelixSyncFailure">
    retryCount?: IntFilter<"HelixSyncFailure"> | number
    nextRetryAt?: DateTimeFilter<"HelixSyncFailure"> | Date | string
    createdAt?: DateTimeFilter<"HelixSyncFailure"> | Date | string
    updatedAt?: DateTimeFilter<"HelixSyncFailure"> | Date | string
    kiosk?: XOR<KioskScalarRelationFilter, KioskWhereInput>
    asset?: XOR<InventoryAssetScalarRelationFilter, InventoryAssetWhereInput>
  }, "id" | "kioskId_assetId">

  export type HelixSyncFailureOrderByWithAggregationInput = {
    id?: SortOrder
    kioskId?: SortOrder
    assetId?: SortOrder
    errorMessage?: SortOrder
    metadata?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    nextRetryAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HelixSyncFailureCountOrderByAggregateInput
    _avg?: HelixSyncFailureAvgOrderByAggregateInput
    _max?: HelixSyncFailureMaxOrderByAggregateInput
    _min?: HelixSyncFailureMinOrderByAggregateInput
    _sum?: HelixSyncFailureSumOrderByAggregateInput
  }

  export type HelixSyncFailureScalarWhereWithAggregatesInput = {
    AND?: HelixSyncFailureScalarWhereWithAggregatesInput | HelixSyncFailureScalarWhereWithAggregatesInput[]
    OR?: HelixSyncFailureScalarWhereWithAggregatesInput[]
    NOT?: HelixSyncFailureScalarWhereWithAggregatesInput | HelixSyncFailureScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HelixSyncFailure"> | number
    kioskId?: StringWithAggregatesFilter<"HelixSyncFailure"> | string
    assetId?: IntWithAggregatesFilter<"HelixSyncFailure"> | number
    errorMessage?: StringWithAggregatesFilter<"HelixSyncFailure"> | string
    metadata?: JsonNullableWithAggregatesFilter<"HelixSyncFailure">
    retryCount?: IntWithAggregatesFilter<"HelixSyncFailure"> | number
    nextRetryAt?: DateTimeWithAggregatesFilter<"HelixSyncFailure"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"HelixSyncFailure"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HelixSyncFailure"> | Date | string
  }

  export type KioskOrganizationAssignmentWhereInput = {
    AND?: KioskOrganizationAssignmentWhereInput | KioskOrganizationAssignmentWhereInput[]
    OR?: KioskOrganizationAssignmentWhereInput[]
    NOT?: KioskOrganizationAssignmentWhereInput | KioskOrganizationAssignmentWhereInput[]
    id?: IntFilter<"KioskOrganizationAssignment"> | number
    kioskId?: StringFilter<"KioskOrganizationAssignment"> | string
    organizationId?: IntFilter<"KioskOrganizationAssignment"> | number
    department?: StringNullableFilter<"KioskOrganizationAssignment"> | string | null
    floor?: StringNullableFilter<"KioskOrganizationAssignment"> | string | null
    room?: StringNullableFilter<"KioskOrganizationAssignment"> | string | null
    building?: StringNullableFilter<"KioskOrganizationAssignment"> | string | null
    assignedBy?: StringNullableFilter<"KioskOrganizationAssignment"> | string | null
    assignmentMetadata?: JsonFilter<"KioskOrganizationAssignment">
    createdAt?: DateTimeFilter<"KioskOrganizationAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"KioskOrganizationAssignment"> | Date | string
    kiosk?: XOR<KioskScalarRelationFilter, KioskWhereInput>
  }

  export type KioskOrganizationAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    kioskId?: SortOrder
    organizationId?: SortOrder
    department?: SortOrderInput | SortOrder
    floor?: SortOrderInput | SortOrder
    room?: SortOrderInput | SortOrder
    building?: SortOrderInput | SortOrder
    assignedBy?: SortOrderInput | SortOrder
    assignmentMetadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kiosk?: KioskOrderByWithRelationInput
  }

  export type KioskOrganizationAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    kioskId?: string
    AND?: KioskOrganizationAssignmentWhereInput | KioskOrganizationAssignmentWhereInput[]
    OR?: KioskOrganizationAssignmentWhereInput[]
    NOT?: KioskOrganizationAssignmentWhereInput | KioskOrganizationAssignmentWhereInput[]
    organizationId?: IntFilter<"KioskOrganizationAssignment"> | number
    department?: StringNullableFilter<"KioskOrganizationAssignment"> | string | null
    floor?: StringNullableFilter<"KioskOrganizationAssignment"> | string | null
    room?: StringNullableFilter<"KioskOrganizationAssignment"> | string | null
    building?: StringNullableFilter<"KioskOrganizationAssignment"> | string | null
    assignedBy?: StringNullableFilter<"KioskOrganizationAssignment"> | string | null
    assignmentMetadata?: JsonFilter<"KioskOrganizationAssignment">
    createdAt?: DateTimeFilter<"KioskOrganizationAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"KioskOrganizationAssignment"> | Date | string
    kiosk?: XOR<KioskScalarRelationFilter, KioskWhereInput>
  }, "id" | "kioskId">

  export type KioskOrganizationAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    kioskId?: SortOrder
    organizationId?: SortOrder
    department?: SortOrderInput | SortOrder
    floor?: SortOrderInput | SortOrder
    room?: SortOrderInput | SortOrder
    building?: SortOrderInput | SortOrder
    assignedBy?: SortOrderInput | SortOrder
    assignmentMetadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KioskOrganizationAssignmentCountOrderByAggregateInput
    _avg?: KioskOrganizationAssignmentAvgOrderByAggregateInput
    _max?: KioskOrganizationAssignmentMaxOrderByAggregateInput
    _min?: KioskOrganizationAssignmentMinOrderByAggregateInput
    _sum?: KioskOrganizationAssignmentSumOrderByAggregateInput
  }

  export type KioskOrganizationAssignmentScalarWhereWithAggregatesInput = {
    AND?: KioskOrganizationAssignmentScalarWhereWithAggregatesInput | KioskOrganizationAssignmentScalarWhereWithAggregatesInput[]
    OR?: KioskOrganizationAssignmentScalarWhereWithAggregatesInput[]
    NOT?: KioskOrganizationAssignmentScalarWhereWithAggregatesInput | KioskOrganizationAssignmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"KioskOrganizationAssignment"> | number
    kioskId?: StringWithAggregatesFilter<"KioskOrganizationAssignment"> | string
    organizationId?: IntWithAggregatesFilter<"KioskOrganizationAssignment"> | number
    department?: StringNullableWithAggregatesFilter<"KioskOrganizationAssignment"> | string | null
    floor?: StringNullableWithAggregatesFilter<"KioskOrganizationAssignment"> | string | null
    room?: StringNullableWithAggregatesFilter<"KioskOrganizationAssignment"> | string | null
    building?: StringNullableWithAggregatesFilter<"KioskOrganizationAssignment"> | string | null
    assignedBy?: StringNullableWithAggregatesFilter<"KioskOrganizationAssignment"> | string | null
    assignmentMetadata?: JsonWithAggregatesFilter<"KioskOrganizationAssignment">
    createdAt?: DateTimeWithAggregatesFilter<"KioskOrganizationAssignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KioskOrganizationAssignment"> | Date | string
  }

  export type KioskMetadataLogWhereInput = {
    AND?: KioskMetadataLogWhereInput | KioskMetadataLogWhereInput[]
    OR?: KioskMetadataLogWhereInput[]
    NOT?: KioskMetadataLogWhereInput | KioskMetadataLogWhereInput[]
    id?: IntFilter<"KioskMetadataLog"> | number
    kioskId?: StringFilter<"KioskMetadataLog"> | string
    metadataType?: StringFilter<"KioskMetadataLog"> | string
    encryptedMetadata?: StringNullableFilter<"KioskMetadataLog"> | string | null
    collectionTimestamp?: DateTimeFilter<"KioskMetadataLog"> | Date | string
    kiosk?: XOR<KioskScalarRelationFilter, KioskWhereInput>
  }

  export type KioskMetadataLogOrderByWithRelationInput = {
    id?: SortOrder
    kioskId?: SortOrder
    metadataType?: SortOrder
    encryptedMetadata?: SortOrderInput | SortOrder
    collectionTimestamp?: SortOrder
    kiosk?: KioskOrderByWithRelationInput
  }

  export type KioskMetadataLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: KioskMetadataLogWhereInput | KioskMetadataLogWhereInput[]
    OR?: KioskMetadataLogWhereInput[]
    NOT?: KioskMetadataLogWhereInput | KioskMetadataLogWhereInput[]
    kioskId?: StringFilter<"KioskMetadataLog"> | string
    metadataType?: StringFilter<"KioskMetadataLog"> | string
    encryptedMetadata?: StringNullableFilter<"KioskMetadataLog"> | string | null
    collectionTimestamp?: DateTimeFilter<"KioskMetadataLog"> | Date | string
    kiosk?: XOR<KioskScalarRelationFilter, KioskWhereInput>
  }, "id">

  export type KioskMetadataLogOrderByWithAggregationInput = {
    id?: SortOrder
    kioskId?: SortOrder
    metadataType?: SortOrder
    encryptedMetadata?: SortOrderInput | SortOrder
    collectionTimestamp?: SortOrder
    _count?: KioskMetadataLogCountOrderByAggregateInput
    _avg?: KioskMetadataLogAvgOrderByAggregateInput
    _max?: KioskMetadataLogMaxOrderByAggregateInput
    _min?: KioskMetadataLogMinOrderByAggregateInput
    _sum?: KioskMetadataLogSumOrderByAggregateInput
  }

  export type KioskMetadataLogScalarWhereWithAggregatesInput = {
    AND?: KioskMetadataLogScalarWhereWithAggregatesInput | KioskMetadataLogScalarWhereWithAggregatesInput[]
    OR?: KioskMetadataLogScalarWhereWithAggregatesInput[]
    NOT?: KioskMetadataLogScalarWhereWithAggregatesInput | KioskMetadataLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"KioskMetadataLog"> | number
    kioskId?: StringWithAggregatesFilter<"KioskMetadataLog"> | string
    metadataType?: StringWithAggregatesFilter<"KioskMetadataLog"> | string
    encryptedMetadata?: StringNullableWithAggregatesFilter<"KioskMetadataLog"> | string | null
    collectionTimestamp?: DateTimeWithAggregatesFilter<"KioskMetadataLog"> | Date | string
  }

  export type XpEventWhereInput = {
    AND?: XpEventWhereInput | XpEventWhereInput[]
    OR?: XpEventWhereInput[]
    NOT?: XpEventWhereInput | XpEventWhereInput[]
    id?: IntFilter<"XpEvent"> | number
    userId?: StringFilter<"XpEvent"> | string
    amount?: IntFilter<"XpEvent"> | number
    reason?: StringNullableFilter<"XpEvent"> | string | null
    createdAt?: DateTimeFilter<"XpEvent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type XpEventOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type XpEventWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: XpEventWhereInput | XpEventWhereInput[]
    OR?: XpEventWhereInput[]
    NOT?: XpEventWhereInput | XpEventWhereInput[]
    userId?: StringFilter<"XpEvent"> | string
    amount?: IntFilter<"XpEvent"> | number
    reason?: StringNullableFilter<"XpEvent"> | string | null
    createdAt?: DateTimeFilter<"XpEvent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type XpEventOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: XpEventCountOrderByAggregateInput
    _avg?: XpEventAvgOrderByAggregateInput
    _max?: XpEventMaxOrderByAggregateInput
    _min?: XpEventMinOrderByAggregateInput
    _sum?: XpEventSumOrderByAggregateInput
  }

  export type XpEventScalarWhereWithAggregatesInput = {
    AND?: XpEventScalarWhereWithAggregatesInput | XpEventScalarWhereWithAggregatesInput[]
    OR?: XpEventScalarWhereWithAggregatesInput[]
    NOT?: XpEventScalarWhereWithAggregatesInput | XpEventScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"XpEvent"> | number
    userId?: StringWithAggregatesFilter<"XpEvent"> | string
    amount?: IntWithAggregatesFilter<"XpEvent"> | number
    reason?: StringNullableWithAggregatesFilter<"XpEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"XpEvent"> | Date | string
  }

  export type LeaderboardWhereInput = {
    AND?: LeaderboardWhereInput | LeaderboardWhereInput[]
    OR?: LeaderboardWhereInput[]
    NOT?: LeaderboardWhereInput | LeaderboardWhereInput[]
    userId?: StringFilter<"Leaderboard"> | string
    xpTotal?: IntFilter<"Leaderboard"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LeaderboardOrderByWithRelationInput = {
    userId?: SortOrder
    xpTotal?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LeaderboardWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: LeaderboardWhereInput | LeaderboardWhereInput[]
    OR?: LeaderboardWhereInput[]
    NOT?: LeaderboardWhereInput | LeaderboardWhereInput[]
    xpTotal?: IntFilter<"Leaderboard"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "userId">

  export type LeaderboardOrderByWithAggregationInput = {
    userId?: SortOrder
    xpTotal?: SortOrder
    _count?: LeaderboardCountOrderByAggregateInput
    _avg?: LeaderboardAvgOrderByAggregateInput
    _max?: LeaderboardMaxOrderByAggregateInput
    _min?: LeaderboardMinOrderByAggregateInput
    _sum?: LeaderboardSumOrderByAggregateInput
  }

  export type LeaderboardScalarWhereWithAggregatesInput = {
    AND?: LeaderboardScalarWhereWithAggregatesInput | LeaderboardScalarWhereWithAggregatesInput[]
    OR?: LeaderboardScalarWhereWithAggregatesInput[]
    NOT?: LeaderboardScalarWhereWithAggregatesInput | LeaderboardScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"Leaderboard"> | string
    xpTotal?: IntWithAggregatesFilter<"Leaderboard"> | number
  }

  export type ScimMappingWhereInput = {
    AND?: ScimMappingWhereInput | ScimMappingWhereInput[]
    OR?: ScimMappingWhereInput[]
    NOT?: ScimMappingWhereInput | ScimMappingWhereInput[]
    id?: StringFilter<"ScimMapping"> | string
    externalId?: StringNullableFilter<"ScimMapping"> | string | null
    userId?: StringFilter<"ScimMapping"> | string
    provider?: StringNullableFilter<"ScimMapping"> | string | null
    syncTime?: DateTimeNullableFilter<"ScimMapping"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ScimMappingOrderByWithRelationInput = {
    id?: SortOrder
    externalId?: SortOrderInput | SortOrder
    userId?: SortOrder
    provider?: SortOrderInput | SortOrder
    syncTime?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ScimMappingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScimMappingWhereInput | ScimMappingWhereInput[]
    OR?: ScimMappingWhereInput[]
    NOT?: ScimMappingWhereInput | ScimMappingWhereInput[]
    externalId?: StringNullableFilter<"ScimMapping"> | string | null
    userId?: StringFilter<"ScimMapping"> | string
    provider?: StringNullableFilter<"ScimMapping"> | string | null
    syncTime?: DateTimeNullableFilter<"ScimMapping"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ScimMappingOrderByWithAggregationInput = {
    id?: SortOrder
    externalId?: SortOrderInput | SortOrder
    userId?: SortOrder
    provider?: SortOrderInput | SortOrder
    syncTime?: SortOrderInput | SortOrder
    _count?: ScimMappingCountOrderByAggregateInput
    _max?: ScimMappingMaxOrderByAggregateInput
    _min?: ScimMappingMinOrderByAggregateInput
  }

  export type ScimMappingScalarWhereWithAggregatesInput = {
    AND?: ScimMappingScalarWhereWithAggregatesInput | ScimMappingScalarWhereWithAggregatesInput[]
    OR?: ScimMappingScalarWhereWithAggregatesInput[]
    NOT?: ScimMappingScalarWhereWithAggregatesInput | ScimMappingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScimMapping"> | string
    externalId?: StringNullableWithAggregatesFilter<"ScimMapping"> | string | null
    userId?: StringWithAggregatesFilter<"ScimMapping"> | string
    provider?: StringNullableWithAggregatesFilter<"ScimMapping"> | string | null
    syncTime?: DateTimeNullableWithAggregatesFilter<"ScimMapping"> | Date | string | null
  }

  export type ScimLogWhereInput = {
    AND?: ScimLogWhereInput | ScimLogWhereInput[]
    OR?: ScimLogWhereInput[]
    NOT?: ScimLogWhereInput | ScimLogWhereInput[]
    id?: StringFilter<"ScimLog"> | string
    operation?: StringFilter<"ScimLog"> | string
    entityType?: StringFilter<"ScimLog"> | string
    entityId?: StringNullableFilter<"ScimLog"> | string | null
    statusCode?: IntFilter<"ScimLog"> | number
    message?: StringNullableFilter<"ScimLog"> | string | null
    requestBody?: JsonNullableFilter<"ScimLog">
    responseBody?: JsonNullableFilter<"ScimLog">
    userAgent?: StringNullableFilter<"ScimLog"> | string | null
    ipAddress?: StringNullableFilter<"ScimLog"> | string | null
    duration?: IntNullableFilter<"ScimLog"> | number | null
    createdAt?: DateTimeFilter<"ScimLog"> | Date | string
  }

  export type ScimLogOrderByWithRelationInput = {
    id?: SortOrder
    operation?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    statusCode?: SortOrder
    message?: SortOrderInput | SortOrder
    requestBody?: SortOrderInput | SortOrder
    responseBody?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type ScimLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScimLogWhereInput | ScimLogWhereInput[]
    OR?: ScimLogWhereInput[]
    NOT?: ScimLogWhereInput | ScimLogWhereInput[]
    operation?: StringFilter<"ScimLog"> | string
    entityType?: StringFilter<"ScimLog"> | string
    entityId?: StringNullableFilter<"ScimLog"> | string | null
    statusCode?: IntFilter<"ScimLog"> | number
    message?: StringNullableFilter<"ScimLog"> | string | null
    requestBody?: JsonNullableFilter<"ScimLog">
    responseBody?: JsonNullableFilter<"ScimLog">
    userAgent?: StringNullableFilter<"ScimLog"> | string | null
    ipAddress?: StringNullableFilter<"ScimLog"> | string | null
    duration?: IntNullableFilter<"ScimLog"> | number | null
    createdAt?: DateTimeFilter<"ScimLog"> | Date | string
  }, "id">

  export type ScimLogOrderByWithAggregationInput = {
    id?: SortOrder
    operation?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    statusCode?: SortOrder
    message?: SortOrderInput | SortOrder
    requestBody?: SortOrderInput | SortOrder
    responseBody?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ScimLogCountOrderByAggregateInput
    _avg?: ScimLogAvgOrderByAggregateInput
    _max?: ScimLogMaxOrderByAggregateInput
    _min?: ScimLogMinOrderByAggregateInput
    _sum?: ScimLogSumOrderByAggregateInput
  }

  export type ScimLogScalarWhereWithAggregatesInput = {
    AND?: ScimLogScalarWhereWithAggregatesInput | ScimLogScalarWhereWithAggregatesInput[]
    OR?: ScimLogScalarWhereWithAggregatesInput[]
    NOT?: ScimLogScalarWhereWithAggregatesInput | ScimLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScimLog"> | string
    operation?: StringWithAggregatesFilter<"ScimLog"> | string
    entityType?: StringWithAggregatesFilter<"ScimLog"> | string
    entityId?: StringNullableWithAggregatesFilter<"ScimLog"> | string | null
    statusCode?: IntWithAggregatesFilter<"ScimLog"> | number
    message?: StringNullableWithAggregatesFilter<"ScimLog"> | string | null
    requestBody?: JsonNullableWithAggregatesFilter<"ScimLog">
    responseBody?: JsonNullableWithAggregatesFilter<"ScimLog">
    userAgent?: StringNullableWithAggregatesFilter<"ScimLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"ScimLog"> | string | null
    duration?: IntNullableWithAggregatesFilter<"ScimLog"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ScimLog"> | Date | string
  }

  export type MailroomPackageWhereInput = {
    AND?: MailroomPackageWhereInput | MailroomPackageWhereInput[]
    OR?: MailroomPackageWhereInput[]
    NOT?: MailroomPackageWhereInput | MailroomPackageWhereInput[]
    id?: IntFilter<"MailroomPackage"> | number
    trackingNumber?: StringFilter<"MailroomPackage"> | string
    carrier?: StringFilter<"MailroomPackage"> | string
    sender?: StringNullableFilter<"MailroomPackage"> | string | null
    recipientId?: StringFilter<"MailroomPackage"> | string
    department?: StringNullableFilter<"MailroomPackage"> | string | null
    packageType?: StringNullableFilter<"MailroomPackage"> | string | null
    status?: StringFilter<"MailroomPackage"> | string
    assignedLocation?: StringNullableFilter<"MailroomPackage"> | string | null
    linkedTicketId?: IntNullableFilter<"MailroomPackage"> | number | null
    linkedAssetId?: IntNullableFilter<"MailroomPackage"> | number | null
    flags?: StringNullableListFilter<"MailroomPackage">
    intakePhotoUrl?: StringNullableFilter<"MailroomPackage"> | string | null
    deliveryPhotoUrl?: StringNullableFilter<"MailroomPackage"> | string | null
    signatureUrl?: StringNullableFilter<"MailroomPackage"> | string | null
    intakeLocation?: StringNullableFilter<"MailroomPackage"> | string | null
    deliveryLocation?: StringNullableFilter<"MailroomPackage"> | string | null
    createdAt?: DateTimeFilter<"MailroomPackage"> | Date | string
    updatedAt?: DateTimeFilter<"MailroomPackage"> | Date | string
    recipient?: XOR<UserScalarRelationFilter, UserWhereInput>
    ticket?: XOR<SupportTicketNullableScalarRelationFilter, SupportTicketWhereInput> | null
    asset?: XOR<InventoryAssetNullableScalarRelationFilter, InventoryAssetWhereInput> | null
    deliveryEvents?: DeliveryEventListRelationFilter
    proxyAuthorizations?: ProxyAuthorizationListRelationFilter
  }

  export type MailroomPackageOrderByWithRelationInput = {
    id?: SortOrder
    trackingNumber?: SortOrder
    carrier?: SortOrder
    sender?: SortOrderInput | SortOrder
    recipientId?: SortOrder
    department?: SortOrderInput | SortOrder
    packageType?: SortOrderInput | SortOrder
    status?: SortOrder
    assignedLocation?: SortOrderInput | SortOrder
    linkedTicketId?: SortOrderInput | SortOrder
    linkedAssetId?: SortOrderInput | SortOrder
    flags?: SortOrder
    intakePhotoUrl?: SortOrderInput | SortOrder
    deliveryPhotoUrl?: SortOrderInput | SortOrder
    signatureUrl?: SortOrderInput | SortOrder
    intakeLocation?: SortOrderInput | SortOrder
    deliveryLocation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    recipient?: UserOrderByWithRelationInput
    ticket?: SupportTicketOrderByWithRelationInput
    asset?: InventoryAssetOrderByWithRelationInput
    deliveryEvents?: DeliveryEventOrderByRelationAggregateInput
    proxyAuthorizations?: ProxyAuthorizationOrderByRelationAggregateInput
  }

  export type MailroomPackageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MailroomPackageWhereInput | MailroomPackageWhereInput[]
    OR?: MailroomPackageWhereInput[]
    NOT?: MailroomPackageWhereInput | MailroomPackageWhereInput[]
    trackingNumber?: StringFilter<"MailroomPackage"> | string
    carrier?: StringFilter<"MailroomPackage"> | string
    sender?: StringNullableFilter<"MailroomPackage"> | string | null
    recipientId?: StringFilter<"MailroomPackage"> | string
    department?: StringNullableFilter<"MailroomPackage"> | string | null
    packageType?: StringNullableFilter<"MailroomPackage"> | string | null
    status?: StringFilter<"MailroomPackage"> | string
    assignedLocation?: StringNullableFilter<"MailroomPackage"> | string | null
    linkedTicketId?: IntNullableFilter<"MailroomPackage"> | number | null
    linkedAssetId?: IntNullableFilter<"MailroomPackage"> | number | null
    flags?: StringNullableListFilter<"MailroomPackage">
    intakePhotoUrl?: StringNullableFilter<"MailroomPackage"> | string | null
    deliveryPhotoUrl?: StringNullableFilter<"MailroomPackage"> | string | null
    signatureUrl?: StringNullableFilter<"MailroomPackage"> | string | null
    intakeLocation?: StringNullableFilter<"MailroomPackage"> | string | null
    deliveryLocation?: StringNullableFilter<"MailroomPackage"> | string | null
    createdAt?: DateTimeFilter<"MailroomPackage"> | Date | string
    updatedAt?: DateTimeFilter<"MailroomPackage"> | Date | string
    recipient?: XOR<UserScalarRelationFilter, UserWhereInput>
    ticket?: XOR<SupportTicketNullableScalarRelationFilter, SupportTicketWhereInput> | null
    asset?: XOR<InventoryAssetNullableScalarRelationFilter, InventoryAssetWhereInput> | null
    deliveryEvents?: DeliveryEventListRelationFilter
    proxyAuthorizations?: ProxyAuthorizationListRelationFilter
  }, "id">

  export type MailroomPackageOrderByWithAggregationInput = {
    id?: SortOrder
    trackingNumber?: SortOrder
    carrier?: SortOrder
    sender?: SortOrderInput | SortOrder
    recipientId?: SortOrder
    department?: SortOrderInput | SortOrder
    packageType?: SortOrderInput | SortOrder
    status?: SortOrder
    assignedLocation?: SortOrderInput | SortOrder
    linkedTicketId?: SortOrderInput | SortOrder
    linkedAssetId?: SortOrderInput | SortOrder
    flags?: SortOrder
    intakePhotoUrl?: SortOrderInput | SortOrder
    deliveryPhotoUrl?: SortOrderInput | SortOrder
    signatureUrl?: SortOrderInput | SortOrder
    intakeLocation?: SortOrderInput | SortOrder
    deliveryLocation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MailroomPackageCountOrderByAggregateInput
    _avg?: MailroomPackageAvgOrderByAggregateInput
    _max?: MailroomPackageMaxOrderByAggregateInput
    _min?: MailroomPackageMinOrderByAggregateInput
    _sum?: MailroomPackageSumOrderByAggregateInput
  }

  export type MailroomPackageScalarWhereWithAggregatesInput = {
    AND?: MailroomPackageScalarWhereWithAggregatesInput | MailroomPackageScalarWhereWithAggregatesInput[]
    OR?: MailroomPackageScalarWhereWithAggregatesInput[]
    NOT?: MailroomPackageScalarWhereWithAggregatesInput | MailroomPackageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MailroomPackage"> | number
    trackingNumber?: StringWithAggregatesFilter<"MailroomPackage"> | string
    carrier?: StringWithAggregatesFilter<"MailroomPackage"> | string
    sender?: StringNullableWithAggregatesFilter<"MailroomPackage"> | string | null
    recipientId?: StringWithAggregatesFilter<"MailroomPackage"> | string
    department?: StringNullableWithAggregatesFilter<"MailroomPackage"> | string | null
    packageType?: StringNullableWithAggregatesFilter<"MailroomPackage"> | string | null
    status?: StringWithAggregatesFilter<"MailroomPackage"> | string
    assignedLocation?: StringNullableWithAggregatesFilter<"MailroomPackage"> | string | null
    linkedTicketId?: IntNullableWithAggregatesFilter<"MailroomPackage"> | number | null
    linkedAssetId?: IntNullableWithAggregatesFilter<"MailroomPackage"> | number | null
    flags?: StringNullableListFilter<"MailroomPackage">
    intakePhotoUrl?: StringNullableWithAggregatesFilter<"MailroomPackage"> | string | null
    deliveryPhotoUrl?: StringNullableWithAggregatesFilter<"MailroomPackage"> | string | null
    signatureUrl?: StringNullableWithAggregatesFilter<"MailroomPackage"> | string | null
    intakeLocation?: StringNullableWithAggregatesFilter<"MailroomPackage"> | string | null
    deliveryLocation?: StringNullableWithAggregatesFilter<"MailroomPackage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MailroomPackage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MailroomPackage"> | Date | string
  }

  export type DeliveryEventWhereInput = {
    AND?: DeliveryEventWhereInput | DeliveryEventWhereInput[]
    OR?: DeliveryEventWhereInput[]
    NOT?: DeliveryEventWhereInput | DeliveryEventWhereInput[]
    id?: IntFilter<"DeliveryEvent"> | number
    packageId?: IntFilter<"DeliveryEvent"> | number
    eventType?: StringFilter<"DeliveryEvent"> | string
    performedBy?: StringFilter<"DeliveryEvent"> | string
    location?: StringNullableFilter<"DeliveryEvent"> | string | null
    timestamp?: DateTimeFilter<"DeliveryEvent"> | Date | string
    photoUrl?: StringNullableFilter<"DeliveryEvent"> | string | null
    signatureBlob?: BytesNullableFilter<"DeliveryEvent"> | Uint8Array | null
    package?: XOR<MailroomPackageScalarRelationFilter, MailroomPackageWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DeliveryEventOrderByWithRelationInput = {
    id?: SortOrder
    packageId?: SortOrder
    eventType?: SortOrder
    performedBy?: SortOrder
    location?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    photoUrl?: SortOrderInput | SortOrder
    signatureBlob?: SortOrderInput | SortOrder
    package?: MailroomPackageOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type DeliveryEventWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DeliveryEventWhereInput | DeliveryEventWhereInput[]
    OR?: DeliveryEventWhereInput[]
    NOT?: DeliveryEventWhereInput | DeliveryEventWhereInput[]
    packageId?: IntFilter<"DeliveryEvent"> | number
    eventType?: StringFilter<"DeliveryEvent"> | string
    performedBy?: StringFilter<"DeliveryEvent"> | string
    location?: StringNullableFilter<"DeliveryEvent"> | string | null
    timestamp?: DateTimeFilter<"DeliveryEvent"> | Date | string
    photoUrl?: StringNullableFilter<"DeliveryEvent"> | string | null
    signatureBlob?: BytesNullableFilter<"DeliveryEvent"> | Uint8Array | null
    package?: XOR<MailroomPackageScalarRelationFilter, MailroomPackageWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type DeliveryEventOrderByWithAggregationInput = {
    id?: SortOrder
    packageId?: SortOrder
    eventType?: SortOrder
    performedBy?: SortOrder
    location?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    photoUrl?: SortOrderInput | SortOrder
    signatureBlob?: SortOrderInput | SortOrder
    _count?: DeliveryEventCountOrderByAggregateInput
    _avg?: DeliveryEventAvgOrderByAggregateInput
    _max?: DeliveryEventMaxOrderByAggregateInput
    _min?: DeliveryEventMinOrderByAggregateInput
    _sum?: DeliveryEventSumOrderByAggregateInput
  }

  export type DeliveryEventScalarWhereWithAggregatesInput = {
    AND?: DeliveryEventScalarWhereWithAggregatesInput | DeliveryEventScalarWhereWithAggregatesInput[]
    OR?: DeliveryEventScalarWhereWithAggregatesInput[]
    NOT?: DeliveryEventScalarWhereWithAggregatesInput | DeliveryEventScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DeliveryEvent"> | number
    packageId?: IntWithAggregatesFilter<"DeliveryEvent"> | number
    eventType?: StringWithAggregatesFilter<"DeliveryEvent"> | string
    performedBy?: StringWithAggregatesFilter<"DeliveryEvent"> | string
    location?: StringNullableWithAggregatesFilter<"DeliveryEvent"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"DeliveryEvent"> | Date | string
    photoUrl?: StringNullableWithAggregatesFilter<"DeliveryEvent"> | string | null
    signatureBlob?: BytesNullableWithAggregatesFilter<"DeliveryEvent"> | Uint8Array | null
  }

  export type ProxyAuthorizationWhereInput = {
    AND?: ProxyAuthorizationWhereInput | ProxyAuthorizationWhereInput[]
    OR?: ProxyAuthorizationWhereInput[]
    NOT?: ProxyAuthorizationWhereInput | ProxyAuthorizationWhereInput[]
    id?: IntFilter<"ProxyAuthorization"> | number
    recipientId?: StringFilter<"ProxyAuthorization"> | string
    proxyId?: StringFilter<"ProxyAuthorization"> | string
    packageId?: IntFilter<"ProxyAuthorization"> | number
    expiration?: DateTimeNullableFilter<"ProxyAuthorization"> | Date | string | null
    status?: StringFilter<"ProxyAuthorization"> | string
    recipient?: XOR<UserScalarRelationFilter, UserWhereInput>
    proxy?: XOR<UserScalarRelationFilter, UserWhereInput>
    package?: XOR<MailroomPackageScalarRelationFilter, MailroomPackageWhereInput>
  }

  export type ProxyAuthorizationOrderByWithRelationInput = {
    id?: SortOrder
    recipientId?: SortOrder
    proxyId?: SortOrder
    packageId?: SortOrder
    expiration?: SortOrderInput | SortOrder
    status?: SortOrder
    recipient?: UserOrderByWithRelationInput
    proxy?: UserOrderByWithRelationInput
    package?: MailroomPackageOrderByWithRelationInput
  }

  export type ProxyAuthorizationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProxyAuthorizationWhereInput | ProxyAuthorizationWhereInput[]
    OR?: ProxyAuthorizationWhereInput[]
    NOT?: ProxyAuthorizationWhereInput | ProxyAuthorizationWhereInput[]
    recipientId?: StringFilter<"ProxyAuthorization"> | string
    proxyId?: StringFilter<"ProxyAuthorization"> | string
    packageId?: IntFilter<"ProxyAuthorization"> | number
    expiration?: DateTimeNullableFilter<"ProxyAuthorization"> | Date | string | null
    status?: StringFilter<"ProxyAuthorization"> | string
    recipient?: XOR<UserScalarRelationFilter, UserWhereInput>
    proxy?: XOR<UserScalarRelationFilter, UserWhereInput>
    package?: XOR<MailroomPackageScalarRelationFilter, MailroomPackageWhereInput>
  }, "id">

  export type ProxyAuthorizationOrderByWithAggregationInput = {
    id?: SortOrder
    recipientId?: SortOrder
    proxyId?: SortOrder
    packageId?: SortOrder
    expiration?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: ProxyAuthorizationCountOrderByAggregateInput
    _avg?: ProxyAuthorizationAvgOrderByAggregateInput
    _max?: ProxyAuthorizationMaxOrderByAggregateInput
    _min?: ProxyAuthorizationMinOrderByAggregateInput
    _sum?: ProxyAuthorizationSumOrderByAggregateInput
  }

  export type ProxyAuthorizationScalarWhereWithAggregatesInput = {
    AND?: ProxyAuthorizationScalarWhereWithAggregatesInput | ProxyAuthorizationScalarWhereWithAggregatesInput[]
    OR?: ProxyAuthorizationScalarWhereWithAggregatesInput[]
    NOT?: ProxyAuthorizationScalarWhereWithAggregatesInput | ProxyAuthorizationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProxyAuthorization"> | number
    recipientId?: StringWithAggregatesFilter<"ProxyAuthorization"> | string
    proxyId?: StringWithAggregatesFilter<"ProxyAuthorization"> | string
    packageId?: IntWithAggregatesFilter<"ProxyAuthorization"> | number
    expiration?: DateTimeNullableWithAggregatesFilter<"ProxyAuthorization"> | Date | string | null
    status?: StringWithAggregatesFilter<"ProxyAuthorization"> | string
  }

  export type RequestCatalogItemWhereInput = {
    AND?: RequestCatalogItemWhereInput | RequestCatalogItemWhereInput[]
    OR?: RequestCatalogItemWhereInput[]
    NOT?: RequestCatalogItemWhereInput | RequestCatalogItemWhereInput[]
    id?: IntFilter<"RequestCatalogItem"> | number
    name?: StringFilter<"RequestCatalogItem"> | string
    formSchema?: JsonNullableFilter<"RequestCatalogItem">
    workflowId?: IntNullableFilter<"RequestCatalogItem"> | number | null
    ritms?: RITMListRelationFilter
  }

  export type RequestCatalogItemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    formSchema?: SortOrderInput | SortOrder
    workflowId?: SortOrderInput | SortOrder
    ritms?: RITMOrderByRelationAggregateInput
  }

  export type RequestCatalogItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RequestCatalogItemWhereInput | RequestCatalogItemWhereInput[]
    OR?: RequestCatalogItemWhereInput[]
    NOT?: RequestCatalogItemWhereInput | RequestCatalogItemWhereInput[]
    name?: StringFilter<"RequestCatalogItem"> | string
    formSchema?: JsonNullableFilter<"RequestCatalogItem">
    workflowId?: IntNullableFilter<"RequestCatalogItem"> | number | null
    ritms?: RITMListRelationFilter
  }, "id">

  export type RequestCatalogItemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    formSchema?: SortOrderInput | SortOrder
    workflowId?: SortOrderInput | SortOrder
    _count?: RequestCatalogItemCountOrderByAggregateInput
    _avg?: RequestCatalogItemAvgOrderByAggregateInput
    _max?: RequestCatalogItemMaxOrderByAggregateInput
    _min?: RequestCatalogItemMinOrderByAggregateInput
    _sum?: RequestCatalogItemSumOrderByAggregateInput
  }

  export type RequestCatalogItemScalarWhereWithAggregatesInput = {
    AND?: RequestCatalogItemScalarWhereWithAggregatesInput | RequestCatalogItemScalarWhereWithAggregatesInput[]
    OR?: RequestCatalogItemScalarWhereWithAggregatesInput[]
    NOT?: RequestCatalogItemScalarWhereWithAggregatesInput | RequestCatalogItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RequestCatalogItem"> | number
    name?: StringWithAggregatesFilter<"RequestCatalogItem"> | string
    formSchema?: JsonNullableWithAggregatesFilter<"RequestCatalogItem">
    workflowId?: IntNullableWithAggregatesFilter<"RequestCatalogItem"> | number | null
  }

  export type RITMWhereInput = {
    AND?: RITMWhereInput | RITMWhereInput[]
    OR?: RITMWhereInput[]
    NOT?: RITMWhereInput | RITMWhereInput[]
    id?: IntFilter<"RITM"> | number
    reqId?: IntFilter<"RITM"> | number
    catalogItemId?: IntFilter<"RITM"> | number
    status?: StringFilter<"RITM"> | string
    ticket?: XOR<SupportTicketScalarRelationFilter, SupportTicketWhereInput>
    catalogItem?: XOR<RequestCatalogItemScalarRelationFilter, RequestCatalogItemWhereInput>
  }

  export type RITMOrderByWithRelationInput = {
    id?: SortOrder
    reqId?: SortOrder
    catalogItemId?: SortOrder
    status?: SortOrder
    ticket?: SupportTicketOrderByWithRelationInput
    catalogItem?: RequestCatalogItemOrderByWithRelationInput
  }

  export type RITMWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RITMWhereInput | RITMWhereInput[]
    OR?: RITMWhereInput[]
    NOT?: RITMWhereInput | RITMWhereInput[]
    reqId?: IntFilter<"RITM"> | number
    catalogItemId?: IntFilter<"RITM"> | number
    status?: StringFilter<"RITM"> | string
    ticket?: XOR<SupportTicketScalarRelationFilter, SupportTicketWhereInput>
    catalogItem?: XOR<RequestCatalogItemScalarRelationFilter, RequestCatalogItemWhereInput>
  }, "id">

  export type RITMOrderByWithAggregationInput = {
    id?: SortOrder
    reqId?: SortOrder
    catalogItemId?: SortOrder
    status?: SortOrder
    _count?: RITMCountOrderByAggregateInput
    _avg?: RITMAvgOrderByAggregateInput
    _max?: RITMMaxOrderByAggregateInput
    _min?: RITMMinOrderByAggregateInput
    _sum?: RITMSumOrderByAggregateInput
  }

  export type RITMScalarWhereWithAggregatesInput = {
    AND?: RITMScalarWhereWithAggregatesInput | RITMScalarWhereWithAggregatesInput[]
    OR?: RITMScalarWhereWithAggregatesInput[]
    NOT?: RITMScalarWhereWithAggregatesInput | RITMScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RITM"> | number
    reqId?: IntWithAggregatesFilter<"RITM"> | number
    catalogItemId?: IntWithAggregatesFilter<"RITM"> | number
    status?: StringWithAggregatesFilter<"RITM"> | string
  }

  export type VipProxyWhereInput = {
    AND?: VipProxyWhereInput | VipProxyWhereInput[]
    OR?: VipProxyWhereInput[]
    NOT?: VipProxyWhereInput | VipProxyWhereInput[]
    id?: IntFilter<"VipProxy"> | number
    vipId?: StringFilter<"VipProxy"> | string
    proxyId?: StringFilter<"VipProxy"> | string
    createdAt?: DateTimeFilter<"VipProxy"> | Date | string
    expiresAt?: DateTimeNullableFilter<"VipProxy"> | Date | string | null
    vip?: XOR<UserScalarRelationFilter, UserWhereInput>
    proxy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type VipProxyOrderByWithRelationInput = {
    id?: SortOrder
    vipId?: SortOrder
    proxyId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    vip?: UserOrderByWithRelationInput
    proxy?: UserOrderByWithRelationInput
  }

  export type VipProxyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VipProxyWhereInput | VipProxyWhereInput[]
    OR?: VipProxyWhereInput[]
    NOT?: VipProxyWhereInput | VipProxyWhereInput[]
    vipId?: StringFilter<"VipProxy"> | string
    proxyId?: StringFilter<"VipProxy"> | string
    createdAt?: DateTimeFilter<"VipProxy"> | Date | string
    expiresAt?: DateTimeNullableFilter<"VipProxy"> | Date | string | null
    vip?: XOR<UserScalarRelationFilter, UserWhereInput>
    proxy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type VipProxyOrderByWithAggregationInput = {
    id?: SortOrder
    vipId?: SortOrder
    proxyId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: VipProxyCountOrderByAggregateInput
    _avg?: VipProxyAvgOrderByAggregateInput
    _max?: VipProxyMaxOrderByAggregateInput
    _min?: VipProxyMinOrderByAggregateInput
    _sum?: VipProxySumOrderByAggregateInput
  }

  export type VipProxyScalarWhereWithAggregatesInput = {
    AND?: VipProxyScalarWhereWithAggregatesInput | VipProxyScalarWhereWithAggregatesInput[]
    OR?: VipProxyScalarWhereWithAggregatesInput[]
    NOT?: VipProxyScalarWhereWithAggregatesInput | VipProxyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VipProxy"> | number
    vipId?: StringWithAggregatesFilter<"VipProxy"> | string
    proxyId?: StringWithAggregatesFilter<"VipProxy"> | string
    createdAt?: DateTimeWithAggregatesFilter<"VipProxy"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"VipProxy"> | Date | string | null
  }

  export type VipSlaHistoryWhereInput = {
    AND?: VipSlaHistoryWhereInput | VipSlaHistoryWhereInput[]
    OR?: VipSlaHistoryWhereInput[]
    NOT?: VipSlaHistoryWhereInput | VipSlaHistoryWhereInput[]
    id?: IntFilter<"VipSlaHistory"> | number
    userId?: StringFilter<"VipSlaHistory"> | string
    sla?: JsonFilter<"VipSlaHistory">
    effectiveAt?: DateTimeFilter<"VipSlaHistory"> | Date | string
    endedAt?: DateTimeNullableFilter<"VipSlaHistory"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type VipSlaHistoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    sla?: SortOrder
    effectiveAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type VipSlaHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VipSlaHistoryWhereInput | VipSlaHistoryWhereInput[]
    OR?: VipSlaHistoryWhereInput[]
    NOT?: VipSlaHistoryWhereInput | VipSlaHistoryWhereInput[]
    userId?: StringFilter<"VipSlaHistory"> | string
    sla?: JsonFilter<"VipSlaHistory">
    effectiveAt?: DateTimeFilter<"VipSlaHistory"> | Date | string
    endedAt?: DateTimeNullableFilter<"VipSlaHistory"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type VipSlaHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    sla?: SortOrder
    effectiveAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    _count?: VipSlaHistoryCountOrderByAggregateInput
    _avg?: VipSlaHistoryAvgOrderByAggregateInput
    _max?: VipSlaHistoryMaxOrderByAggregateInput
    _min?: VipSlaHistoryMinOrderByAggregateInput
    _sum?: VipSlaHistorySumOrderByAggregateInput
  }

  export type VipSlaHistoryScalarWhereWithAggregatesInput = {
    AND?: VipSlaHistoryScalarWhereWithAggregatesInput | VipSlaHistoryScalarWhereWithAggregatesInput[]
    OR?: VipSlaHistoryScalarWhereWithAggregatesInput[]
    NOT?: VipSlaHistoryScalarWhereWithAggregatesInput | VipSlaHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VipSlaHistory"> | number
    userId?: StringWithAggregatesFilter<"VipSlaHistory"> | string
    sla?: JsonWithAggregatesFilter<"VipSlaHistory">
    effectiveAt?: DateTimeWithAggregatesFilter<"VipSlaHistory"> | Date | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"VipSlaHistory"> | Date | string | null
  }

  export type AgentAvailabilityWhereInput = {
    AND?: AgentAvailabilityWhereInput | AgentAvailabilityWhereInput[]
    OR?: AgentAvailabilityWhereInput[]
    NOT?: AgentAvailabilityWhereInput | AgentAvailabilityWhereInput[]
    id?: StringFilter<"AgentAvailability"> | string
    userId?: StringFilter<"AgentAvailability"> | string
    queueName?: StringFilter<"AgentAvailability"> | string
    isAvailable?: BoolFilter<"AgentAvailability"> | boolean
    maxCapacity?: IntFilter<"AgentAvailability"> | number
    currentLoad?: IntFilter<"AgentAvailability"> | number
    status?: StringFilter<"AgentAvailability"> | string
    lastUpdated?: DateTimeFilter<"AgentAvailability"> | Date | string
    createdAt?: DateTimeFilter<"AgentAvailability"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AgentAvailabilityOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    queueName?: SortOrder
    isAvailable?: SortOrder
    maxCapacity?: SortOrder
    currentLoad?: SortOrder
    status?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AgentAvailabilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_queueName?: AgentAvailabilityUserIdQueueNameCompoundUniqueInput
    AND?: AgentAvailabilityWhereInput | AgentAvailabilityWhereInput[]
    OR?: AgentAvailabilityWhereInput[]
    NOT?: AgentAvailabilityWhereInput | AgentAvailabilityWhereInput[]
    userId?: StringFilter<"AgentAvailability"> | string
    queueName?: StringFilter<"AgentAvailability"> | string
    isAvailable?: BoolFilter<"AgentAvailability"> | boolean
    maxCapacity?: IntFilter<"AgentAvailability"> | number
    currentLoad?: IntFilter<"AgentAvailability"> | number
    status?: StringFilter<"AgentAvailability"> | string
    lastUpdated?: DateTimeFilter<"AgentAvailability"> | Date | string
    createdAt?: DateTimeFilter<"AgentAvailability"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_queueName">

  export type AgentAvailabilityOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    queueName?: SortOrder
    isAvailable?: SortOrder
    maxCapacity?: SortOrder
    currentLoad?: SortOrder
    status?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    _count?: AgentAvailabilityCountOrderByAggregateInput
    _avg?: AgentAvailabilityAvgOrderByAggregateInput
    _max?: AgentAvailabilityMaxOrderByAggregateInput
    _min?: AgentAvailabilityMinOrderByAggregateInput
    _sum?: AgentAvailabilitySumOrderByAggregateInput
  }

  export type AgentAvailabilityScalarWhereWithAggregatesInput = {
    AND?: AgentAvailabilityScalarWhereWithAggregatesInput | AgentAvailabilityScalarWhereWithAggregatesInput[]
    OR?: AgentAvailabilityScalarWhereWithAggregatesInput[]
    NOT?: AgentAvailabilityScalarWhereWithAggregatesInput | AgentAvailabilityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgentAvailability"> | string
    userId?: StringWithAggregatesFilter<"AgentAvailability"> | string
    queueName?: StringWithAggregatesFilter<"AgentAvailability"> | string
    isAvailable?: BoolWithAggregatesFilter<"AgentAvailability"> | boolean
    maxCapacity?: IntWithAggregatesFilter<"AgentAvailability"> | number
    currentLoad?: IntWithAggregatesFilter<"AgentAvailability"> | number
    status?: StringWithAggregatesFilter<"AgentAvailability"> | string
    lastUpdated?: DateTimeWithAggregatesFilter<"AgentAvailability"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AgentAvailability"> | Date | string
  }

  export type QueueMetricsWhereInput = {
    AND?: QueueMetricsWhereInput | QueueMetricsWhereInput[]
    OR?: QueueMetricsWhereInput[]
    NOT?: QueueMetricsWhereInput | QueueMetricsWhereInput[]
    id?: StringFilter<"QueueMetrics"> | string
    queueName?: StringFilter<"QueueMetrics"> | string
    totalAgents?: IntFilter<"QueueMetrics"> | number
    availableAgents?: IntFilter<"QueueMetrics"> | number
    totalTickets?: IntFilter<"QueueMetrics"> | number
    openTickets?: IntFilter<"QueueMetrics"> | number
    avgResponseTime?: FloatFilter<"QueueMetrics"> | number
    avgResolutionTime?: FloatFilter<"QueueMetrics"> | number
    slaBreaches?: IntFilter<"QueueMetrics"> | number
    highPriorityTickets?: IntFilter<"QueueMetrics"> | number
    capacityUtilization?: FloatFilter<"QueueMetrics"> | number
    averageWaitTime?: FloatFilter<"QueueMetrics"> | number
    thresholdWarning?: BoolFilter<"QueueMetrics"> | boolean
    thresholdCritical?: BoolFilter<"QueueMetrics"> | boolean
    lastCalculated?: DateTimeFilter<"QueueMetrics"> | Date | string
  }

  export type QueueMetricsOrderByWithRelationInput = {
    id?: SortOrder
    queueName?: SortOrder
    totalAgents?: SortOrder
    availableAgents?: SortOrder
    totalTickets?: SortOrder
    openTickets?: SortOrder
    avgResponseTime?: SortOrder
    avgResolutionTime?: SortOrder
    slaBreaches?: SortOrder
    highPriorityTickets?: SortOrder
    capacityUtilization?: SortOrder
    averageWaitTime?: SortOrder
    thresholdWarning?: SortOrder
    thresholdCritical?: SortOrder
    lastCalculated?: SortOrder
  }

  export type QueueMetricsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    queueName?: string
    AND?: QueueMetricsWhereInput | QueueMetricsWhereInput[]
    OR?: QueueMetricsWhereInput[]
    NOT?: QueueMetricsWhereInput | QueueMetricsWhereInput[]
    totalAgents?: IntFilter<"QueueMetrics"> | number
    availableAgents?: IntFilter<"QueueMetrics"> | number
    totalTickets?: IntFilter<"QueueMetrics"> | number
    openTickets?: IntFilter<"QueueMetrics"> | number
    avgResponseTime?: FloatFilter<"QueueMetrics"> | number
    avgResolutionTime?: FloatFilter<"QueueMetrics"> | number
    slaBreaches?: IntFilter<"QueueMetrics"> | number
    highPriorityTickets?: IntFilter<"QueueMetrics"> | number
    capacityUtilization?: FloatFilter<"QueueMetrics"> | number
    averageWaitTime?: FloatFilter<"QueueMetrics"> | number
    thresholdWarning?: BoolFilter<"QueueMetrics"> | boolean
    thresholdCritical?: BoolFilter<"QueueMetrics"> | boolean
    lastCalculated?: DateTimeFilter<"QueueMetrics"> | Date | string
  }, "id" | "queueName">

  export type QueueMetricsOrderByWithAggregationInput = {
    id?: SortOrder
    queueName?: SortOrder
    totalAgents?: SortOrder
    availableAgents?: SortOrder
    totalTickets?: SortOrder
    openTickets?: SortOrder
    avgResponseTime?: SortOrder
    avgResolutionTime?: SortOrder
    slaBreaches?: SortOrder
    highPriorityTickets?: SortOrder
    capacityUtilization?: SortOrder
    averageWaitTime?: SortOrder
    thresholdWarning?: SortOrder
    thresholdCritical?: SortOrder
    lastCalculated?: SortOrder
    _count?: QueueMetricsCountOrderByAggregateInput
    _avg?: QueueMetricsAvgOrderByAggregateInput
    _max?: QueueMetricsMaxOrderByAggregateInput
    _min?: QueueMetricsMinOrderByAggregateInput
    _sum?: QueueMetricsSumOrderByAggregateInput
  }

  export type QueueMetricsScalarWhereWithAggregatesInput = {
    AND?: QueueMetricsScalarWhereWithAggregatesInput | QueueMetricsScalarWhereWithAggregatesInput[]
    OR?: QueueMetricsScalarWhereWithAggregatesInput[]
    NOT?: QueueMetricsScalarWhereWithAggregatesInput | QueueMetricsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QueueMetrics"> | string
    queueName?: StringWithAggregatesFilter<"QueueMetrics"> | string
    totalAgents?: IntWithAggregatesFilter<"QueueMetrics"> | number
    availableAgents?: IntWithAggregatesFilter<"QueueMetrics"> | number
    totalTickets?: IntWithAggregatesFilter<"QueueMetrics"> | number
    openTickets?: IntWithAggregatesFilter<"QueueMetrics"> | number
    avgResponseTime?: FloatWithAggregatesFilter<"QueueMetrics"> | number
    avgResolutionTime?: FloatWithAggregatesFilter<"QueueMetrics"> | number
    slaBreaches?: IntWithAggregatesFilter<"QueueMetrics"> | number
    highPriorityTickets?: IntWithAggregatesFilter<"QueueMetrics"> | number
    capacityUtilization?: FloatWithAggregatesFilter<"QueueMetrics"> | number
    averageWaitTime?: FloatWithAggregatesFilter<"QueueMetrics"> | number
    thresholdWarning?: BoolWithAggregatesFilter<"QueueMetrics"> | boolean
    thresholdCritical?: BoolWithAggregatesFilter<"QueueMetrics"> | boolean
    lastCalculated?: DateTimeWithAggregatesFilter<"QueueMetrics"> | Date | string
  }

  export type QueueAlertWhereInput = {
    AND?: QueueAlertWhereInput | QueueAlertWhereInput[]
    OR?: QueueAlertWhereInput[]
    NOT?: QueueAlertWhereInput | QueueAlertWhereInput[]
    id?: StringFilter<"QueueAlert"> | string
    queueName?: StringFilter<"QueueAlert"> | string
    alertType?: StringFilter<"QueueAlert"> | string
    message?: StringFilter<"QueueAlert"> | string
    isActive?: BoolFilter<"QueueAlert"> | boolean
    alertedAt?: DateTimeFilter<"QueueAlert"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"QueueAlert"> | Date | string | null
    notifiedUsers?: StringNullableListFilter<"QueueAlert">
  }

  export type QueueAlertOrderByWithRelationInput = {
    id?: SortOrder
    queueName?: SortOrder
    alertType?: SortOrder
    message?: SortOrder
    isActive?: SortOrder
    alertedAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    notifiedUsers?: SortOrder
  }

  export type QueueAlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QueueAlertWhereInput | QueueAlertWhereInput[]
    OR?: QueueAlertWhereInput[]
    NOT?: QueueAlertWhereInput | QueueAlertWhereInput[]
    queueName?: StringFilter<"QueueAlert"> | string
    alertType?: StringFilter<"QueueAlert"> | string
    message?: StringFilter<"QueueAlert"> | string
    isActive?: BoolFilter<"QueueAlert"> | boolean
    alertedAt?: DateTimeFilter<"QueueAlert"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"QueueAlert"> | Date | string | null
    notifiedUsers?: StringNullableListFilter<"QueueAlert">
  }, "id">

  export type QueueAlertOrderByWithAggregationInput = {
    id?: SortOrder
    queueName?: SortOrder
    alertType?: SortOrder
    message?: SortOrder
    isActive?: SortOrder
    alertedAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    notifiedUsers?: SortOrder
    _count?: QueueAlertCountOrderByAggregateInput
    _max?: QueueAlertMaxOrderByAggregateInput
    _min?: QueueAlertMinOrderByAggregateInput
  }

  export type QueueAlertScalarWhereWithAggregatesInput = {
    AND?: QueueAlertScalarWhereWithAggregatesInput | QueueAlertScalarWhereWithAggregatesInput[]
    OR?: QueueAlertScalarWhereWithAggregatesInput[]
    NOT?: QueueAlertScalarWhereWithAggregatesInput | QueueAlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QueueAlert"> | string
    queueName?: StringWithAggregatesFilter<"QueueAlert"> | string
    alertType?: StringWithAggregatesFilter<"QueueAlert"> | string
    message?: StringWithAggregatesFilter<"QueueAlert"> | string
    isActive?: BoolWithAggregatesFilter<"QueueAlert"> | boolean
    alertedAt?: DateTimeWithAggregatesFilter<"QueueAlert"> | Date | string
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"QueueAlert"> | Date | string | null
    notifiedUsers?: StringNullableListFilter<"QueueAlert">
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentCreateNestedManyWithoutUserInput
    xpEvents?: XpEventCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingUncheckedCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentUncheckedCreateNestedManyWithoutUserInput
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventUncheckedCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyUncheckedCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyUncheckedCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryUncheckedCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUncheckedUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUncheckedUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUncheckedUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUncheckedUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUncheckedUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUncheckedUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RoleCreateInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionCreateNestedManyWithoutRoleInput
    users?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
    users?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUpdateManyWithoutRoleNestedInput
    users?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
    users?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionCreateInput = {
    name: string
    description?: string | null
    resource?: string | null
    action?: string | null
    createdAt?: Date | string
    roles?: RolePermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    resource?: string | null
    action?: string | null
    createdAt?: Date | string
    roles?: RolePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: RolePermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    resource?: string | null
    action?: string | null
    createdAt?: Date | string
  }

  export type PermissionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateInput = {
    assignedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    user: UserCreateNestedOneWithoutRolesInput
  }

  export type UserRoleUncheckedCreateInput = {
    userId: string
    roleId: number
    assignedAt?: Date | string
  }

  export type UserRoleUpdateInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
  }

  export type UserRoleUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateManyInput = {
    userId: string
    roleId: number
    assignedAt?: Date | string
  }

  export type UserRoleUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateInput = {
    assignedAt?: Date | string
    permission: PermissionCreateNestedOneWithoutRolesInput
    role: RoleCreateNestedOneWithoutPermissionsInput
  }

  export type RolePermissionUncheckedCreateInput = {
    roleId: number
    permissionId: number
    assignedAt?: Date | string
  }

  export type RolePermissionUpdateInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permission?: PermissionUpdateOneRequiredWithoutRolesNestedInput
    role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyInput = {
    roleId: number
    permissionId: number
    assignedAt?: Date | string
  }

  export type RolePermissionUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasskeyCreateInput = {
    credentialId: string
    publicKey: string
    counter?: number
    transports?: string | null
    deviceType?: string | null
    backedUp?: boolean
    createdAt?: Date | string
    lastUsed?: Date | string | null
    user: UserCreateNestedOneWithoutPasskeysInput
  }

  export type PasskeyUncheckedCreateInput = {
    id?: number
    userId: string
    credentialId: string
    publicKey: string
    counter?: number
    transports?: string | null
    deviceType?: string | null
    backedUp?: boolean
    createdAt?: Date | string
    lastUsed?: Date | string | null
  }

  export type PasskeyUpdateInput = {
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    transports?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    backedUp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPasskeysNestedInput
  }

  export type PasskeyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    transports?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    backedUp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasskeyCreateManyInput = {
    id?: number
    userId: string
    credentialId: string
    publicKey: string
    counter?: number
    transports?: string | null
    deviceType?: string | null
    backedUp?: boolean
    createdAt?: Date | string
    lastUsed?: Date | string | null
  }

  export type PasskeyUpdateManyMutationInput = {
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    transports?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    backedUp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasskeyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    transports?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    backedUp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LogCreateInput = {
    ticketId?: string | null
    name?: string | null
    email?: string | null
    title?: string | null
    system?: string | null
    urgency?: string | null
    timestamp?: Date | string
    emailStatus?: string | null
    user?: UserCreateNestedOneWithoutLogsInput
  }

  export type LogUncheckedCreateInput = {
    id?: number
    ticketId?: string | null
    name?: string | null
    email?: string | null
    title?: string | null
    system?: string | null
    urgency?: string | null
    timestamp?: Date | string
    emailStatus?: string | null
    userId?: string | null
  }

  export type LogUpdateInput = {
    ticketId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    emailStatus?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutLogsNestedInput
  }

  export type LogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    emailStatus?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogCreateManyInput = {
    id?: number
    ticketId?: string | null
    name?: string | null
    email?: string | null
    title?: string | null
    system?: string | null
    urgency?: string | null
    timestamp?: Date | string
    emailStatus?: string | null
    userId?: string | null
  }

  export type LogUpdateManyMutationInput = {
    ticketId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    emailStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    emailStatus?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConfigCreateInput = {
    key: string
    value?: string | null
    valueType?: string | null
    description?: string | null
    isPublic?: boolean
    category?: string | null
    subcategory?: string | null
    isUIEditable?: boolean
    isRequired?: boolean
    defaultValue?: string | null
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    displayOrder?: number | null
    helpText?: string | null
    isAdvanced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    history?: ConfigHistoryCreateNestedManyWithoutConfigInput
  }

  export type ConfigUncheckedCreateInput = {
    key: string
    value?: string | null
    valueType?: string | null
    description?: string | null
    isPublic?: boolean
    category?: string | null
    subcategory?: string | null
    isUIEditable?: boolean
    isRequired?: boolean
    defaultValue?: string | null
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    displayOrder?: number | null
    helpText?: string | null
    isAdvanced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
    history?: ConfigHistoryUncheckedCreateNestedManyWithoutConfigInput
  }

  export type ConfigUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    valueType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    isUIEditable?: BoolFieldUpdateOperationsInput | boolean
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    isAdvanced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    history?: ConfigHistoryUpdateManyWithoutConfigNestedInput
  }

  export type ConfigUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    valueType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    isUIEditable?: BoolFieldUpdateOperationsInput | boolean
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    isAdvanced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    history?: ConfigHistoryUncheckedUpdateManyWithoutConfigNestedInput
  }

  export type ConfigCreateManyInput = {
    key: string
    value?: string | null
    valueType?: string | null
    description?: string | null
    isPublic?: boolean
    category?: string | null
    subcategory?: string | null
    isUIEditable?: boolean
    isRequired?: boolean
    defaultValue?: string | null
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    displayOrder?: number | null
    helpText?: string | null
    isAdvanced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type ConfigUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    valueType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    isUIEditable?: BoolFieldUpdateOperationsInput | boolean
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    isAdvanced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConfigUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    valueType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    isUIEditable?: BoolFieldUpdateOperationsInput | boolean
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    isAdvanced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConfigHistoryCreateInput = {
    oldValue?: string | null
    newValue?: string | null
    changedBy?: string | null
    changeReason?: string | null
    createdAt?: Date | string
    config: ConfigCreateNestedOneWithoutHistoryInput
  }

  export type ConfigHistoryUncheckedCreateInput = {
    id?: number
    configKey: string
    oldValue?: string | null
    newValue?: string | null
    changedBy?: string | null
    changeReason?: string | null
    createdAt?: Date | string
  }

  export type ConfigHistoryUpdateInput = {
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    config?: ConfigUpdateOneRequiredWithoutHistoryNestedInput
  }

  export type ConfigHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    configKey?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigHistoryCreateManyInput = {
    id?: number
    configKey: string
    oldValue?: string | null
    newValue?: string | null
    changedBy?: string | null
    changeReason?: string | null
    createdAt?: Date | string
  }

  export type ConfigHistoryUpdateManyMutationInput = {
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    configKey?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigTemplateCreateInput = {
    name: string
    description?: string | null
    category: string
    template: JsonNullValueInput | InputJsonValue
    isDefault?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfigTemplateUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    category: string
    template: JsonNullValueInput | InputJsonValue
    isDefault?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfigTemplateUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    template?: JsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigTemplateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    template?: JsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigTemplateCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    category: string
    template: JsonNullValueInput | InputJsonValue
    isDefault?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfigTemplateUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    template?: JsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigTemplateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    template?: JsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KioskCreateInput = {
    id: string
    lastSeen?: Date | string | null
    version?: string | null
    active?: boolean
    logoUrl?: string | null
    bgUrl?: string | null
    statusEnabled?: boolean
    currentStatus?: string | null
    openMsg?: string | null
    closedMsg?: string | null
    errorMsg?: string | null
    meetingMsg?: string | null
    brbMsg?: string | null
    lunchMsg?: string | null
    unavailableMsg?: string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    activations?: KioskActivationCreateNestedManyWithoutKioskInput
    assetRegistry?: KioskAssetRegistryCreateNestedManyWithoutKioskInput
    syncFailures?: HelixSyncFailureCreateNestedManyWithoutKioskInput
    orgAssignment?: KioskOrganizationAssignmentCreateNestedOneWithoutKioskInput
    metadataLogs?: KioskMetadataLogCreateNestedManyWithoutKioskInput
  }

  export type KioskUncheckedCreateInput = {
    id: string
    lastSeen?: Date | string | null
    version?: string | null
    active?: boolean
    logoUrl?: string | null
    bgUrl?: string | null
    statusEnabled?: boolean
    currentStatus?: string | null
    openMsg?: string | null
    closedMsg?: string | null
    errorMsg?: string | null
    meetingMsg?: string | null
    brbMsg?: string | null
    lunchMsg?: string | null
    unavailableMsg?: string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    activations?: KioskActivationUncheckedCreateNestedManyWithoutKioskInput
    assetRegistry?: KioskAssetRegistryUncheckedCreateNestedManyWithoutKioskInput
    syncFailures?: HelixSyncFailureUncheckedCreateNestedManyWithoutKioskInput
    orgAssignment?: KioskOrganizationAssignmentUncheckedCreateNestedOneWithoutKioskInput
    metadataLogs?: KioskMetadataLogUncheckedCreateNestedManyWithoutKioskInput
  }

  export type KioskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statusEnabled?: BoolFieldUpdateOperationsInput | boolean
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    openMsg?: NullableStringFieldUpdateOperationsInput | string | null
    closedMsg?: NullableStringFieldUpdateOperationsInput | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    meetingMsg?: NullableStringFieldUpdateOperationsInput | string | null
    brbMsg?: NullableStringFieldUpdateOperationsInput | string | null
    lunchMsg?: NullableStringFieldUpdateOperationsInput | string | null
    unavailableMsg?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activations?: KioskActivationUpdateManyWithoutKioskNestedInput
    assetRegistry?: KioskAssetRegistryUpdateManyWithoutKioskNestedInput
    syncFailures?: HelixSyncFailureUpdateManyWithoutKioskNestedInput
    orgAssignment?: KioskOrganizationAssignmentUpdateOneWithoutKioskNestedInput
    metadataLogs?: KioskMetadataLogUpdateManyWithoutKioskNestedInput
  }

  export type KioskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statusEnabled?: BoolFieldUpdateOperationsInput | boolean
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    openMsg?: NullableStringFieldUpdateOperationsInput | string | null
    closedMsg?: NullableStringFieldUpdateOperationsInput | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    meetingMsg?: NullableStringFieldUpdateOperationsInput | string | null
    brbMsg?: NullableStringFieldUpdateOperationsInput | string | null
    lunchMsg?: NullableStringFieldUpdateOperationsInput | string | null
    unavailableMsg?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activations?: KioskActivationUncheckedUpdateManyWithoutKioskNestedInput
    assetRegistry?: KioskAssetRegistryUncheckedUpdateManyWithoutKioskNestedInput
    syncFailures?: HelixSyncFailureUncheckedUpdateManyWithoutKioskNestedInput
    orgAssignment?: KioskOrganizationAssignmentUncheckedUpdateOneWithoutKioskNestedInput
    metadataLogs?: KioskMetadataLogUncheckedUpdateManyWithoutKioskNestedInput
  }

  export type KioskCreateManyInput = {
    id: string
    lastSeen?: Date | string | null
    version?: string | null
    active?: boolean
    logoUrl?: string | null
    bgUrl?: string | null
    statusEnabled?: boolean
    currentStatus?: string | null
    openMsg?: string | null
    closedMsg?: string | null
    errorMsg?: string | null
    meetingMsg?: string | null
    brbMsg?: string | null
    lunchMsg?: string | null
    unavailableMsg?: string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KioskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statusEnabled?: BoolFieldUpdateOperationsInput | boolean
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    openMsg?: NullableStringFieldUpdateOperationsInput | string | null
    closedMsg?: NullableStringFieldUpdateOperationsInput | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    meetingMsg?: NullableStringFieldUpdateOperationsInput | string | null
    brbMsg?: NullableStringFieldUpdateOperationsInput | string | null
    lunchMsg?: NullableStringFieldUpdateOperationsInput | string | null
    unavailableMsg?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KioskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statusEnabled?: BoolFieldUpdateOperationsInput | boolean
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    openMsg?: NullableStringFieldUpdateOperationsInput | string | null
    closedMsg?: NullableStringFieldUpdateOperationsInput | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    meetingMsg?: NullableStringFieldUpdateOperationsInput | string | null
    brbMsg?: NullableStringFieldUpdateOperationsInput | string | null
    lunchMsg?: NullableStringFieldUpdateOperationsInput | string | null
    unavailableMsg?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackCreateInput = {
    name?: string | null
    message?: string | null
    timestamp?: Date | string
    user?: UserCreateNestedOneWithoutFeedbackInput
  }

  export type FeedbackUncheckedCreateInput = {
    id?: number
    name?: string | null
    message?: string | null
    timestamp?: Date | string
    userId?: string | null
  }

  export type FeedbackUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FeedbackCreateManyInput = {
    id?: number
    name?: string | null
    message?: string | null
    timestamp?: Date | string
    userId?: string | null
  }

  export type FeedbackUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateInput = {
    message: string
    level?: string
    active?: boolean
    type?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    message: string
    level?: string
    active?: boolean
    type?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    message?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: number
    message: string
    level?: string
    active?: boolean
    type?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    message?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectoryIntegrationCreateInput = {
    provider: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DirectoryIntegrationUncheckedCreateInput = {
    id?: number
    provider: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DirectoryIntegrationUpdateInput = {
    provider?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectoryIntegrationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    provider?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectoryIntegrationCreateManyInput = {
    id?: number
    provider: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DirectoryIntegrationUpdateManyMutationInput = {
    provider?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectoryIntegrationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    provider?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCreateInput = {
    name: string
    type: string
    filename: string
    url: string
    sizeBytes?: number | null
    mimeType?: string | null
    uploadedAt?: Date | string
  }

  export type AssetUncheckedCreateInput = {
    id?: number
    name: string
    type: string
    filename: string
    url: string
    sizeBytes?: number | null
    mimeType?: string | null
    uploadedAt?: Date | string
  }

  export type AssetUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCreateManyInput = {
    id?: number
    name: string
    type: string
    filename: string
    url: string
    sizeBytes?: number | null
    mimeType?: string | null
    uploadedAt?: Date | string
  }

  export type AssetUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KioskActivationCreateInput = {
    id: string
    code: string
    qrCode: string
    expiresAt: Date | string
    used?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
    kiosk?: KioskCreateNestedOneWithoutActivationsInput
  }

  export type KioskActivationUncheckedCreateInput = {
    id: string
    code: string
    qrCode: string
    expiresAt: Date | string
    used?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
    kioskId?: string | null
  }

  export type KioskActivationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    qrCode?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kiosk?: KioskUpdateOneWithoutActivationsNestedInput
  }

  export type KioskActivationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    qrCode?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KioskActivationCreateManyInput = {
    id: string
    code: string
    qrCode: string
    expiresAt: Date | string
    used?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
    kioskId?: string | null
  }

  export type KioskActivationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    qrCode?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KioskActivationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    qrCode?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kioskId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SsoConfigurationCreateInput = {
    provider: string
    enabled?: boolean
    configuration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type SsoConfigurationUncheckedCreateInput = {
    id?: number
    provider: string
    enabled?: boolean
    configuration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type SsoConfigurationUpdateInput = {
    provider?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    configuration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SsoConfigurationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    provider?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    configuration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SsoConfigurationCreateManyInput = {
    id?: number
    provider: string
    enabled?: boolean
    configuration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type SsoConfigurationUpdateManyMutationInput = {
    provider?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    configuration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SsoConfigurationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    provider?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    configuration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminPinCreateInput = {
    globalPin?: string | null
    kioskPins?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type AdminPinUncheckedCreateInput = {
    id?: number
    globalPin?: string | null
    kioskPins?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type AdminPinUpdateInput = {
    globalPin?: NullableStringFieldUpdateOperationsInput | string | null
    kioskPins?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminPinUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    globalPin?: NullableStringFieldUpdateOperationsInput | string | null
    kioskPins?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminPinCreateManyInput = {
    id?: number
    globalPin?: string | null
    kioskPins?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type AdminPinUpdateManyMutationInput = {
    globalPin?: NullableStringFieldUpdateOperationsInput | string | null
    kioskPins?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminPinUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    globalPin?: NullableStringFieldUpdateOperationsInput | string | null
    kioskPins?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KbArticleCreateInput = {
    slug: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isPublished?: boolean
    tags?: KbArticleCreatetagsInput | string[]
    author?: UserCreateNestedOneWithoutKbArticlesAuthoredInput
    versions?: KbArticleVersionCreateNestedManyWithoutArticleInput
    comments?: KbArticleCommentCreateNestedManyWithoutArticleInput
    currentVersion?: KbArticleVersionCreateNestedOneWithoutCurrentForArticleInput
  }

  export type KbArticleUncheckedCreateInput = {
    id?: number
    slug: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId?: string | null
    currentVersionId?: number | null
    isPublished?: boolean
    tags?: KbArticleCreatetagsInput | string[]
    versions?: KbArticleVersionUncheckedCreateNestedManyWithoutArticleInput
    comments?: KbArticleCommentUncheckedCreateNestedManyWithoutArticleInput
  }

  export type KbArticleUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    tags?: KbArticleUpdatetagsInput | string[]
    author?: UserUpdateOneWithoutKbArticlesAuthoredNestedInput
    versions?: KbArticleVersionUpdateManyWithoutArticleNestedInput
    comments?: KbArticleCommentUpdateManyWithoutArticleNestedInput
    currentVersion?: KbArticleVersionUpdateOneWithoutCurrentForArticleNestedInput
  }

  export type KbArticleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    currentVersionId?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    tags?: KbArticleUpdatetagsInput | string[]
    versions?: KbArticleVersionUncheckedUpdateManyWithoutArticleNestedInput
    comments?: KbArticleCommentUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type KbArticleCreateManyInput = {
    id?: number
    slug: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId?: string | null
    currentVersionId?: number | null
    isPublished?: boolean
    tags?: KbArticleCreatetagsInput | string[]
  }

  export type KbArticleUpdateManyMutationInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    tags?: KbArticleUpdatetagsInput | string[]
  }

  export type KbArticleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    currentVersionId?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    tags?: KbArticleUpdatetagsInput | string[]
  }

  export type KbArticleVersionCreateInput = {
    content: string
    summary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: number
    isApproved?: boolean
    article: KbArticleCreateNestedOneWithoutVersionsInput
    author?: UserCreateNestedOneWithoutKbArticleVersionsAuthoredInput
    currentForArticle?: KbArticleCreateNestedManyWithoutCurrentVersionInput
  }

  export type KbArticleVersionUncheckedCreateInput = {
    id?: number
    articleId: number
    content: string
    summary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId?: string | null
    version?: number
    isApproved?: boolean
    currentForArticle?: KbArticleUncheckedCreateNestedManyWithoutCurrentVersionInput
  }

  export type KbArticleVersionUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    article?: KbArticleUpdateOneRequiredWithoutVersionsNestedInput
    author?: UserUpdateOneWithoutKbArticleVersionsAuthoredNestedInput
    currentForArticle?: KbArticleUpdateManyWithoutCurrentVersionNestedInput
  }

  export type KbArticleVersionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    currentForArticle?: KbArticleUncheckedUpdateManyWithoutCurrentVersionNestedInput
  }

  export type KbArticleVersionCreateManyInput = {
    id?: number
    articleId: number
    content: string
    summary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId?: string | null
    version?: number
    isApproved?: boolean
  }

  export type KbArticleVersionUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type KbArticleVersionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type KbArticleCommentCreateInput = {
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    article: KbArticleCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutKbArticleCommentsInput
  }

  export type KbArticleCommentUncheckedCreateInput = {
    id?: number
    articleId: number
    userId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type KbArticleCommentUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    article?: KbArticleUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutKbArticleCommentsNestedInput
  }

  export type KbArticleCommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type KbArticleCommentCreateManyInput = {
    id?: number
    articleId: number
    userId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type KbArticleCommentUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type KbArticleCommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SupportTicketCreateInput = {
    title: string
    description: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vipPriorityScore?: number | null
    vipTriggerSource?: string | null
    users_support_tickets_assigneeIdTousers?: UserCreateNestedOneWithoutSupport_tickets_support_tickets_assigneeIdTousersInput
    users_support_tickets_userIdTousers?: UserCreateNestedOneWithoutSupport_tickets_support_tickets_userIdTousersInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutTicketInput
    assetHistory?: AssetTicketHistoryCreateNestedManyWithoutTicketInput
    ritms?: RITMCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    assigneeId?: string | null
    vipPriorityScore?: number | null
    vipTriggerSource?: string | null
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutTicketInput
    assetHistory?: AssetTicketHistoryUncheckedCreateNestedManyWithoutTicketInput
    ritms?: RITMUncheckedCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vipPriorityScore?: NullableIntFieldUpdateOperationsInput | number | null
    vipTriggerSource?: NullableStringFieldUpdateOperationsInput | string | null
    users_support_tickets_assigneeIdTousers?: UserUpdateOneWithoutSupport_tickets_support_tickets_assigneeIdTousersNestedInput
    users_support_tickets_userIdTousers?: UserUpdateOneWithoutSupport_tickets_support_tickets_userIdTousersNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutTicketNestedInput
    assetHistory?: AssetTicketHistoryUpdateManyWithoutTicketNestedInput
    ritms?: RITMUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    vipPriorityScore?: NullableIntFieldUpdateOperationsInput | number | null
    vipTriggerSource?: NullableStringFieldUpdateOperationsInput | string | null
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutTicketNestedInput
    assetHistory?: AssetTicketHistoryUncheckedUpdateManyWithoutTicketNestedInput
    ritms?: RITMUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketCreateManyInput = {
    id?: number
    title: string
    description: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    assigneeId?: string | null
    vipPriorityScore?: number | null
    vipTriggerSource?: string | null
  }

  export type SupportTicketUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vipPriorityScore?: NullableIntFieldUpdateOperationsInput | number | null
    vipTriggerSource?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupportTicketUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    vipPriorityScore?: NullableIntFieldUpdateOperationsInput | number | null
    vipTriggerSource?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryAssetCreateInput = {
    assetTag: string
    typeId?: number | null
    serialNumber?: string | null
    model?: string | null
    vendorId?: number | null
    purchaseDate?: Date | string | null
    warrantyExpiry?: Date | string | null
    assignedToUserId?: string | null
    assignedToOrgId?: number | null
    assignedToCustomerId?: number | null
    department?: string | null
    status?: string | null
    locationId?: number | null
    kioskId?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serialNumberEnc?: string | null
    warrantyInfoEnc?: string | null
    purchaseInfoEnc?: string | null
    maintenanceNotesEnc?: string | null
    warrantyAlertDays?: number | null
    warrantyAlertEnabled?: boolean
    lastWarrantyAlertSent?: Date | string | null
    importSource?: string | null
    importValidated?: boolean
    validationErrors?: string | null
    statusLogs?: AssetStatusLogCreateNestedManyWithoutAssetInput
    assignments?: AssetAssignmentCreateNestedManyWithoutAssetInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutAssetInput
    ticketHistory?: AssetTicketHistoryCreateNestedManyWithoutAssetInput
    warrantyAlerts?: AssetWarrantyAlertCreateNestedManyWithoutAssetInput
    kioskRegistrations?: KioskAssetRegistryCreateNestedManyWithoutAssetInput
    validationLogs?: AssetValidationLogCreateNestedManyWithoutAssetInput
    syncFailures?: HelixSyncFailureCreateNestedManyWithoutAssetInput
    importBatch?: AssetImportBatchCreateNestedOneWithoutAssetsInput
  }

  export type InventoryAssetUncheckedCreateInput = {
    id?: number
    assetTag: string
    typeId?: number | null
    serialNumber?: string | null
    model?: string | null
    vendorId?: number | null
    purchaseDate?: Date | string | null
    warrantyExpiry?: Date | string | null
    assignedToUserId?: string | null
    assignedToOrgId?: number | null
    assignedToCustomerId?: number | null
    department?: string | null
    status?: string | null
    locationId?: number | null
    kioskId?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serialNumberEnc?: string | null
    warrantyInfoEnc?: string | null
    purchaseInfoEnc?: string | null
    maintenanceNotesEnc?: string | null
    warrantyAlertDays?: number | null
    warrantyAlertEnabled?: boolean
    lastWarrantyAlertSent?: Date | string | null
    importBatchId?: string | null
    importSource?: string | null
    importValidated?: boolean
    validationErrors?: string | null
    statusLogs?: AssetStatusLogUncheckedCreateNestedManyWithoutAssetInput
    assignments?: AssetAssignmentUncheckedCreateNestedManyWithoutAssetInput
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutAssetInput
    ticketHistory?: AssetTicketHistoryUncheckedCreateNestedManyWithoutAssetInput
    warrantyAlerts?: AssetWarrantyAlertUncheckedCreateNestedManyWithoutAssetInput
    kioskRegistrations?: KioskAssetRegistryUncheckedCreateNestedManyWithoutAssetInput
    validationLogs?: AssetValidationLogUncheckedCreateNestedManyWithoutAssetInput
    syncFailures?: HelixSyncFailureUncheckedCreateNestedManyWithoutAssetInput
  }

  export type InventoryAssetUpdateInput = {
    assetTag?: StringFieldUpdateOperationsInput | string
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToOrgId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedToCustomerId?: NullableIntFieldUpdateOperationsInput | number | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    kioskId?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serialNumberEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyAlertDays?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyAlertEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastWarrantyAlertSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importSource?: NullableStringFieldUpdateOperationsInput | string | null
    importValidated?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableStringFieldUpdateOperationsInput | string | null
    statusLogs?: AssetStatusLogUpdateManyWithoutAssetNestedInput
    assignments?: AssetAssignmentUpdateManyWithoutAssetNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutAssetNestedInput
    ticketHistory?: AssetTicketHistoryUpdateManyWithoutAssetNestedInput
    warrantyAlerts?: AssetWarrantyAlertUpdateManyWithoutAssetNestedInput
    kioskRegistrations?: KioskAssetRegistryUpdateManyWithoutAssetNestedInput
    validationLogs?: AssetValidationLogUpdateManyWithoutAssetNestedInput
    syncFailures?: HelixSyncFailureUpdateManyWithoutAssetNestedInput
    importBatch?: AssetImportBatchUpdateOneWithoutAssetsNestedInput
  }

  export type InventoryAssetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetTag?: StringFieldUpdateOperationsInput | string
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToOrgId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedToCustomerId?: NullableIntFieldUpdateOperationsInput | number | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    kioskId?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serialNumberEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyAlertDays?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyAlertEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastWarrantyAlertSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    importSource?: NullableStringFieldUpdateOperationsInput | string | null
    importValidated?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableStringFieldUpdateOperationsInput | string | null
    statusLogs?: AssetStatusLogUncheckedUpdateManyWithoutAssetNestedInput
    assignments?: AssetAssignmentUncheckedUpdateManyWithoutAssetNestedInput
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutAssetNestedInput
    ticketHistory?: AssetTicketHistoryUncheckedUpdateManyWithoutAssetNestedInput
    warrantyAlerts?: AssetWarrantyAlertUncheckedUpdateManyWithoutAssetNestedInput
    kioskRegistrations?: KioskAssetRegistryUncheckedUpdateManyWithoutAssetNestedInput
    validationLogs?: AssetValidationLogUncheckedUpdateManyWithoutAssetNestedInput
    syncFailures?: HelixSyncFailureUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type InventoryAssetCreateManyInput = {
    id?: number
    assetTag: string
    typeId?: number | null
    serialNumber?: string | null
    model?: string | null
    vendorId?: number | null
    purchaseDate?: Date | string | null
    warrantyExpiry?: Date | string | null
    assignedToUserId?: string | null
    assignedToOrgId?: number | null
    assignedToCustomerId?: number | null
    department?: string | null
    status?: string | null
    locationId?: number | null
    kioskId?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serialNumberEnc?: string | null
    warrantyInfoEnc?: string | null
    purchaseInfoEnc?: string | null
    maintenanceNotesEnc?: string | null
    warrantyAlertDays?: number | null
    warrantyAlertEnabled?: boolean
    lastWarrantyAlertSent?: Date | string | null
    importBatchId?: string | null
    importSource?: string | null
    importValidated?: boolean
    validationErrors?: string | null
  }

  export type InventoryAssetUpdateManyMutationInput = {
    assetTag?: StringFieldUpdateOperationsInput | string
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToOrgId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedToCustomerId?: NullableIntFieldUpdateOperationsInput | number | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    kioskId?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serialNumberEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyAlertDays?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyAlertEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastWarrantyAlertSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importSource?: NullableStringFieldUpdateOperationsInput | string | null
    importValidated?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryAssetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetTag?: StringFieldUpdateOperationsInput | string
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToOrgId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedToCustomerId?: NullableIntFieldUpdateOperationsInput | number | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    kioskId?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serialNumberEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyAlertDays?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyAlertEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastWarrantyAlertSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    importSource?: NullableStringFieldUpdateOperationsInput | string | null
    importValidated?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetStatusLogCreateInput = {
    previousStatus?: string | null
    newStatus: string
    changedByUserId?: string | null
    notes?: string | null
    timestamp?: Date | string
    asset: InventoryAssetCreateNestedOneWithoutStatusLogsInput
  }

  export type AssetStatusLogUncheckedCreateInput = {
    id?: number
    assetId: number
    previousStatus?: string | null
    newStatus: string
    changedByUserId?: string | null
    notes?: string | null
    timestamp?: Date | string
  }

  export type AssetStatusLogUpdateInput = {
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    changedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    asset?: InventoryAssetUpdateOneRequiredWithoutStatusLogsNestedInput
  }

  export type AssetStatusLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetId?: IntFieldUpdateOperationsInput | number
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    changedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetStatusLogCreateManyInput = {
    id?: number
    assetId: number
    previousStatus?: string | null
    newStatus: string
    changedByUserId?: string | null
    notes?: string | null
    timestamp?: Date | string
  }

  export type AssetStatusLogUpdateManyMutationInput = {
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    changedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetStatusLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetId?: IntFieldUpdateOperationsInput | number
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    changedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetAssignmentCreateInput = {
    userId?: string | null
    orgId?: number | null
    customerId?: number | null
    assignedBy?: string | null
    assignedDate?: Date | string
    expectedReturn?: Date | string | null
    returnDate?: Date | string | null
    managerId?: string | null
    asset: InventoryAssetCreateNestedOneWithoutAssignmentsInput
  }

  export type AssetAssignmentUncheckedCreateInput = {
    id?: number
    assetId: number
    userId?: string | null
    orgId?: number | null
    customerId?: number | null
    assignedBy?: string | null
    assignedDate?: Date | string
    expectedReturn?: Date | string | null
    returnDate?: Date | string | null
    managerId?: string | null
  }

  export type AssetAssignmentUpdateInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedReturn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    asset?: InventoryAssetUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type AssetAssignmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetId?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedReturn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetAssignmentCreateManyInput = {
    id?: number
    assetId: number
    userId?: string | null
    orgId?: number | null
    customerId?: number | null
    assignedBy?: string | null
    assignedDate?: Date | string
    expectedReturn?: Date | string | null
    returnDate?: Date | string | null
    managerId?: string | null
  }

  export type AssetAssignmentUpdateManyMutationInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedReturn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetAssignmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetId?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedReturn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetTicketHistoryCreateInput = {
    relationshipType: string
    createdAt?: Date | string
    endedAt?: Date | string | null
    createdBy?: string | null
    notes?: string | null
    asset: InventoryAssetCreateNestedOneWithoutTicketHistoryInput
    ticket: SupportTicketCreateNestedOneWithoutAssetHistoryInput
  }

  export type AssetTicketHistoryUncheckedCreateInput = {
    id?: number
    assetId: number
    ticketId: number
    relationshipType: string
    createdAt?: Date | string
    endedAt?: Date | string | null
    createdBy?: string | null
    notes?: string | null
  }

  export type AssetTicketHistoryUpdateInput = {
    relationshipType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    asset?: InventoryAssetUpdateOneRequiredWithoutTicketHistoryNestedInput
    ticket?: SupportTicketUpdateOneRequiredWithoutAssetHistoryNestedInput
  }

  export type AssetTicketHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetId?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    relationshipType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetTicketHistoryCreateManyInput = {
    id?: number
    assetId: number
    ticketId: number
    relationshipType: string
    createdAt?: Date | string
    endedAt?: Date | string | null
    createdBy?: string | null
    notes?: string | null
  }

  export type AssetTicketHistoryUpdateManyMutationInput = {
    relationshipType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetTicketHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetId?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    relationshipType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetWarrantyAlertCreateInput = {
    alertType: string
    alertDate?: Date | string
    expiryDate: Date | string
    daysRemaining: number
    notificationSent?: boolean
    notificationSentAt?: Date | string | null
    dismissed?: boolean
    dismissedBy?: string | null
    dismissedAt?: Date | string | null
    asset: InventoryAssetCreateNestedOneWithoutWarrantyAlertsInput
  }

  export type AssetWarrantyAlertUncheckedCreateInput = {
    id?: number
    assetId: number
    alertType: string
    alertDate?: Date | string
    expiryDate: Date | string
    daysRemaining: number
    notificationSent?: boolean
    notificationSentAt?: Date | string | null
    dismissed?: boolean
    dismissedBy?: string | null
    dismissedAt?: Date | string | null
  }

  export type AssetWarrantyAlertUpdateInput = {
    alertType?: StringFieldUpdateOperationsInput | string
    alertDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    daysRemaining?: IntFieldUpdateOperationsInput | number
    notificationSent?: BoolFieldUpdateOperationsInput | boolean
    notificationSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissed?: BoolFieldUpdateOperationsInput | boolean
    dismissedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    asset?: InventoryAssetUpdateOneRequiredWithoutWarrantyAlertsNestedInput
  }

  export type AssetWarrantyAlertUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetId?: IntFieldUpdateOperationsInput | number
    alertType?: StringFieldUpdateOperationsInput | string
    alertDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    daysRemaining?: IntFieldUpdateOperationsInput | number
    notificationSent?: BoolFieldUpdateOperationsInput | boolean
    notificationSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissed?: BoolFieldUpdateOperationsInput | boolean
    dismissedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssetWarrantyAlertCreateManyInput = {
    id?: number
    assetId: number
    alertType: string
    alertDate?: Date | string
    expiryDate: Date | string
    daysRemaining: number
    notificationSent?: boolean
    notificationSentAt?: Date | string | null
    dismissed?: boolean
    dismissedBy?: string | null
    dismissedAt?: Date | string | null
  }

  export type AssetWarrantyAlertUpdateManyMutationInput = {
    alertType?: StringFieldUpdateOperationsInput | string
    alertDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    daysRemaining?: IntFieldUpdateOperationsInput | number
    notificationSent?: BoolFieldUpdateOperationsInput | boolean
    notificationSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissed?: BoolFieldUpdateOperationsInput | boolean
    dismissedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssetWarrantyAlertUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetId?: IntFieldUpdateOperationsInput | number
    alertType?: StringFieldUpdateOperationsInput | string
    alertDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    daysRemaining?: IntFieldUpdateOperationsInput | number
    notificationSent?: BoolFieldUpdateOperationsInput | boolean
    notificationSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissed?: BoolFieldUpdateOperationsInput | boolean
    dismissedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssetImportBatchCreateInput = {
    id?: string
    filename: string
    importedBy: string
    importDate?: Date | string
    totalRecords?: number
    successfulRecords?: number
    failedRecords?: number
    validationStatus?: string
    validationErrors?: string | null
    rollbackDate?: Date | string | null
    rollbackBy?: string | null
    assets?: InventoryAssetCreateNestedManyWithoutImportBatchInput
    validationLogs?: AssetValidationLogCreateNestedManyWithoutBatchInput
  }

  export type AssetImportBatchUncheckedCreateInput = {
    id?: string
    filename: string
    importedBy: string
    importDate?: Date | string
    totalRecords?: number
    successfulRecords?: number
    failedRecords?: number
    validationStatus?: string
    validationErrors?: string | null
    rollbackDate?: Date | string | null
    rollbackBy?: string | null
    assets?: InventoryAssetUncheckedCreateNestedManyWithoutImportBatchInput
    validationLogs?: AssetValidationLogUncheckedCreateNestedManyWithoutBatchInput
  }

  export type AssetImportBatchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    importedBy?: StringFieldUpdateOperationsInput | string
    importDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalRecords?: IntFieldUpdateOperationsInput | number
    successfulRecords?: IntFieldUpdateOperationsInput | number
    failedRecords?: IntFieldUpdateOperationsInput | number
    validationStatus?: StringFieldUpdateOperationsInput | string
    validationErrors?: NullableStringFieldUpdateOperationsInput | string | null
    rollbackDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackBy?: NullableStringFieldUpdateOperationsInput | string | null
    assets?: InventoryAssetUpdateManyWithoutImportBatchNestedInput
    validationLogs?: AssetValidationLogUpdateManyWithoutBatchNestedInput
  }

  export type AssetImportBatchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    importedBy?: StringFieldUpdateOperationsInput | string
    importDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalRecords?: IntFieldUpdateOperationsInput | number
    successfulRecords?: IntFieldUpdateOperationsInput | number
    failedRecords?: IntFieldUpdateOperationsInput | number
    validationStatus?: StringFieldUpdateOperationsInput | string
    validationErrors?: NullableStringFieldUpdateOperationsInput | string | null
    rollbackDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackBy?: NullableStringFieldUpdateOperationsInput | string | null
    assets?: InventoryAssetUncheckedUpdateManyWithoutImportBatchNestedInput
    validationLogs?: AssetValidationLogUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type AssetImportBatchCreateManyInput = {
    id?: string
    filename: string
    importedBy: string
    importDate?: Date | string
    totalRecords?: number
    successfulRecords?: number
    failedRecords?: number
    validationStatus?: string
    validationErrors?: string | null
    rollbackDate?: Date | string | null
    rollbackBy?: string | null
  }

  export type AssetImportBatchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    importedBy?: StringFieldUpdateOperationsInput | string
    importDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalRecords?: IntFieldUpdateOperationsInput | number
    successfulRecords?: IntFieldUpdateOperationsInput | number
    failedRecords?: IntFieldUpdateOperationsInput | number
    validationStatus?: StringFieldUpdateOperationsInput | string
    validationErrors?: NullableStringFieldUpdateOperationsInput | string | null
    rollbackDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetImportBatchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    importedBy?: StringFieldUpdateOperationsInput | string
    importDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalRecords?: IntFieldUpdateOperationsInput | number
    successfulRecords?: IntFieldUpdateOperationsInput | number
    failedRecords?: IntFieldUpdateOperationsInput | number
    validationStatus?: StringFieldUpdateOperationsInput | string
    validationErrors?: NullableStringFieldUpdateOperationsInput | string | null
    rollbackDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetValidationLogCreateInput = {
    rowNumber: number
    validationLevel: string
    fieldName?: string | null
    message: string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    batch: AssetImportBatchCreateNestedOneWithoutValidationLogsInput
    asset?: InventoryAssetCreateNestedOneWithoutValidationLogsInput
  }

  export type AssetValidationLogUncheckedCreateInput = {
    id?: number
    batchId: string
    assetId?: number | null
    rowNumber: number
    validationLevel: string
    fieldName?: string | null
    message: string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AssetValidationLogUpdateInput = {
    rowNumber?: IntFieldUpdateOperationsInput | number
    validationLevel?: StringFieldUpdateOperationsInput | string
    fieldName?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: AssetImportBatchUpdateOneRequiredWithoutValidationLogsNestedInput
    asset?: InventoryAssetUpdateOneWithoutValidationLogsNestedInput
  }

  export type AssetValidationLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    batchId?: StringFieldUpdateOperationsInput | string
    assetId?: NullableIntFieldUpdateOperationsInput | number | null
    rowNumber?: IntFieldUpdateOperationsInput | number
    validationLevel?: StringFieldUpdateOperationsInput | string
    fieldName?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetValidationLogCreateManyInput = {
    id?: number
    batchId: string
    assetId?: number | null
    rowNumber: number
    validationLevel: string
    fieldName?: string | null
    message: string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AssetValidationLogUpdateManyMutationInput = {
    rowNumber?: IntFieldUpdateOperationsInput | number
    validationLevel?: StringFieldUpdateOperationsInput | string
    fieldName?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetValidationLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    batchId?: StringFieldUpdateOperationsInput | string
    assetId?: NullableIntFieldUpdateOperationsInput | number | null
    rowNumber?: IntFieldUpdateOperationsInput | number
    validationLevel?: StringFieldUpdateOperationsInput | string
    fieldName?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KioskAssetRegistryCreateInput = {
    registrationDate?: Date | string
    lastCheckIn?: Date | string | null
    status?: string
    helixSyncStatus?: string
    helixLastSync?: Date | string | null
    helixErrorMessage?: string | null
    encryptedMetadata?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    kiosk: KioskCreateNestedOneWithoutAssetRegistryInput
    asset: InventoryAssetCreateNestedOneWithoutKioskRegistrationsInput
  }

  export type KioskAssetRegistryUncheckedCreateInput = {
    id?: number
    kioskId: string
    assetId: number
    registrationDate?: Date | string
    lastCheckIn?: Date | string | null
    status?: string
    helixSyncStatus?: string
    helixLastSync?: Date | string | null
    helixErrorMessage?: string | null
    encryptedMetadata?: string | null
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type KioskAssetRegistryUpdateInput = {
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    helixSyncStatus?: StringFieldUpdateOperationsInput | string
    helixLastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    helixErrorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    kiosk?: KioskUpdateOneRequiredWithoutAssetRegistryNestedInput
    asset?: InventoryAssetUpdateOneRequiredWithoutKioskRegistrationsNestedInput
  }

  export type KioskAssetRegistryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    kioskId?: StringFieldUpdateOperationsInput | string
    assetId?: IntFieldUpdateOperationsInput | number
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    helixSyncStatus?: StringFieldUpdateOperationsInput | string
    helixLastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    helixErrorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KioskAssetRegistryCreateManyInput = {
    id?: number
    kioskId: string
    assetId: number
    registrationDate?: Date | string
    lastCheckIn?: Date | string | null
    status?: string
    helixSyncStatus?: string
    helixLastSync?: Date | string | null
    helixErrorMessage?: string | null
    encryptedMetadata?: string | null
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type KioskAssetRegistryUpdateManyMutationInput = {
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    helixSyncStatus?: StringFieldUpdateOperationsInput | string
    helixLastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    helixErrorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KioskAssetRegistryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    kioskId?: StringFieldUpdateOperationsInput | string
    assetId?: IntFieldUpdateOperationsInput | number
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    helixSyncStatus?: StringFieldUpdateOperationsInput | string
    helixLastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    helixErrorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HelixSyncFailureCreateInput = {
    errorMessage: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: number
    nextRetryAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    kiosk: KioskCreateNestedOneWithoutSyncFailuresInput
    asset: InventoryAssetCreateNestedOneWithoutSyncFailuresInput
  }

  export type HelixSyncFailureUncheckedCreateInput = {
    id?: number
    kioskId: string
    assetId: number
    errorMessage: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: number
    nextRetryAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HelixSyncFailureUpdateInput = {
    errorMessage?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kiosk?: KioskUpdateOneRequiredWithoutSyncFailuresNestedInput
    asset?: InventoryAssetUpdateOneRequiredWithoutSyncFailuresNestedInput
  }

  export type HelixSyncFailureUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    kioskId?: StringFieldUpdateOperationsInput | string
    assetId?: IntFieldUpdateOperationsInput | number
    errorMessage?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelixSyncFailureCreateManyInput = {
    id?: number
    kioskId: string
    assetId: number
    errorMessage: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: number
    nextRetryAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HelixSyncFailureUpdateManyMutationInput = {
    errorMessage?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelixSyncFailureUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    kioskId?: StringFieldUpdateOperationsInput | string
    assetId?: IntFieldUpdateOperationsInput | number
    errorMessage?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KioskOrganizationAssignmentCreateInput = {
    organizationId: number
    department?: string | null
    floor?: string | null
    room?: string | null
    building?: string | null
    assignedBy?: string | null
    assignmentMetadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    kiosk: KioskCreateNestedOneWithoutOrgAssignmentInput
  }

  export type KioskOrganizationAssignmentUncheckedCreateInput = {
    id?: number
    kioskId: string
    organizationId: number
    department?: string | null
    floor?: string | null
    room?: string | null
    building?: string | null
    assignedBy?: string | null
    assignmentMetadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KioskOrganizationAssignmentUpdateInput = {
    organizationId?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assignmentMetadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kiosk?: KioskUpdateOneRequiredWithoutOrgAssignmentNestedInput
  }

  export type KioskOrganizationAssignmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    kioskId?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assignmentMetadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KioskOrganizationAssignmentCreateManyInput = {
    id?: number
    kioskId: string
    organizationId: number
    department?: string | null
    floor?: string | null
    room?: string | null
    building?: string | null
    assignedBy?: string | null
    assignmentMetadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KioskOrganizationAssignmentUpdateManyMutationInput = {
    organizationId?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assignmentMetadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KioskOrganizationAssignmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    kioskId?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assignmentMetadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KioskMetadataLogCreateInput = {
    metadataType: string
    encryptedMetadata?: string | null
    collectionTimestamp?: Date | string
    kiosk: KioskCreateNestedOneWithoutMetadataLogsInput
  }

  export type KioskMetadataLogUncheckedCreateInput = {
    id?: number
    kioskId: string
    metadataType: string
    encryptedMetadata?: string | null
    collectionTimestamp?: Date | string
  }

  export type KioskMetadataLogUpdateInput = {
    metadataType?: StringFieldUpdateOperationsInput | string
    encryptedMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    collectionTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kiosk?: KioskUpdateOneRequiredWithoutMetadataLogsNestedInput
  }

  export type KioskMetadataLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    kioskId?: StringFieldUpdateOperationsInput | string
    metadataType?: StringFieldUpdateOperationsInput | string
    encryptedMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    collectionTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KioskMetadataLogCreateManyInput = {
    id?: number
    kioskId: string
    metadataType: string
    encryptedMetadata?: string | null
    collectionTimestamp?: Date | string
  }

  export type KioskMetadataLogUpdateManyMutationInput = {
    metadataType?: StringFieldUpdateOperationsInput | string
    encryptedMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    collectionTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KioskMetadataLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    kioskId?: StringFieldUpdateOperationsInput | string
    metadataType?: StringFieldUpdateOperationsInput | string
    encryptedMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    collectionTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XpEventCreateInput = {
    amount: number
    reason?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutXpEventsInput
  }

  export type XpEventUncheckedCreateInput = {
    id?: number
    userId: string
    amount: number
    reason?: string | null
    createdAt?: Date | string
  }

  export type XpEventUpdateInput = {
    amount?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutXpEventsNestedInput
  }

  export type XpEventUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XpEventCreateManyInput = {
    id?: number
    userId: string
    amount: number
    reason?: string | null
    createdAt?: Date | string
  }

  export type XpEventUpdateManyMutationInput = {
    amount?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XpEventUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardCreateInput = {
    xpTotal?: number
    user: UserCreateNestedOneWithoutLeaderboardInput
  }

  export type LeaderboardUncheckedCreateInput = {
    userId: string
    xpTotal?: number
  }

  export type LeaderboardUpdateInput = {
    xpTotal?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutLeaderboardNestedInput
  }

  export type LeaderboardUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    xpTotal?: IntFieldUpdateOperationsInput | number
  }

  export type LeaderboardCreateManyInput = {
    userId: string
    xpTotal?: number
  }

  export type LeaderboardUpdateManyMutationInput = {
    xpTotal?: IntFieldUpdateOperationsInput | number
  }

  export type LeaderboardUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    xpTotal?: IntFieldUpdateOperationsInput | number
  }

  export type ScimMappingCreateInput = {
    id?: string
    externalId?: string | null
    provider?: string | null
    syncTime?: Date | string | null
    user: UserCreateNestedOneWithoutScimMappingsInput
  }

  export type ScimMappingUncheckedCreateInput = {
    id?: string
    externalId?: string | null
    userId: string
    provider?: string | null
    syncTime?: Date | string | null
  }

  export type ScimMappingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    syncTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutScimMappingsNestedInput
  }

  export type ScimMappingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    syncTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ScimMappingCreateManyInput = {
    id?: string
    externalId?: string | null
    userId: string
    provider?: string | null
    syncTime?: Date | string | null
  }

  export type ScimMappingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    syncTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ScimMappingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    syncTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ScimLogCreateInput = {
    id?: string
    operation: string
    entityType: string
    entityId?: string | null
    statusCode: number
    message?: string | null
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: string | null
    ipAddress?: string | null
    duration?: number | null
    createdAt?: Date | string
  }

  export type ScimLogUncheckedCreateInput = {
    id?: string
    operation: string
    entityType: string
    entityId?: string | null
    statusCode: number
    message?: string | null
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: string | null
    ipAddress?: string | null
    duration?: number | null
    createdAt?: Date | string
  }

  export type ScimLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    operation?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScimLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    operation?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScimLogCreateManyInput = {
    id?: string
    operation: string
    entityType: string
    entityId?: string | null
    statusCode: number
    message?: string | null
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: string | null
    ipAddress?: string | null
    duration?: number | null
    createdAt?: Date | string
  }

  export type ScimLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    operation?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScimLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    operation?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MailroomPackageCreateInput = {
    trackingNumber: string
    carrier: string
    sender?: string | null
    department?: string | null
    packageType?: string | null
    status: string
    assignedLocation?: string | null
    flags?: MailroomPackageCreateflagsInput | string[]
    intakePhotoUrl?: string | null
    deliveryPhotoUrl?: string | null
    signatureUrl?: string | null
    intakeLocation?: string | null
    deliveryLocation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recipient: UserCreateNestedOneWithoutMailroomPackagesInput
    ticket?: SupportTicketCreateNestedOneWithoutMailroomPackagesInput
    asset?: InventoryAssetCreateNestedOneWithoutMailroomPackagesInput
    deliveryEvents?: DeliveryEventCreateNestedManyWithoutPackageInput
    proxyAuthorizations?: ProxyAuthorizationCreateNestedManyWithoutPackageInput
  }

  export type MailroomPackageUncheckedCreateInput = {
    id?: number
    trackingNumber: string
    carrier: string
    sender?: string | null
    recipientId: string
    department?: string | null
    packageType?: string | null
    status: string
    assignedLocation?: string | null
    linkedTicketId?: number | null
    linkedAssetId?: number | null
    flags?: MailroomPackageCreateflagsInput | string[]
    intakePhotoUrl?: string | null
    deliveryPhotoUrl?: string | null
    signatureUrl?: string | null
    intakeLocation?: string | null
    deliveryLocation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveryEvents?: DeliveryEventUncheckedCreateNestedManyWithoutPackageInput
    proxyAuthorizations?: ProxyAuthorizationUncheckedCreateNestedManyWithoutPackageInput
  }

  export type MailroomPackageUpdateInput = {
    trackingNumber?: StringFieldUpdateOperationsInput | string
    carrier?: StringFieldUpdateOperationsInput | string
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    packageType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    assignedLocation?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: MailroomPackageUpdateflagsInput | string[]
    intakePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    intakeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryLocation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: UserUpdateOneRequiredWithoutMailroomPackagesNestedInput
    ticket?: SupportTicketUpdateOneWithoutMailroomPackagesNestedInput
    asset?: InventoryAssetUpdateOneWithoutMailroomPackagesNestedInput
    deliveryEvents?: DeliveryEventUpdateManyWithoutPackageNestedInput
    proxyAuthorizations?: ProxyAuthorizationUpdateManyWithoutPackageNestedInput
  }

  export type MailroomPackageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackingNumber?: StringFieldUpdateOperationsInput | string
    carrier?: StringFieldUpdateOperationsInput | string
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    recipientId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    packageType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    assignedLocation?: NullableStringFieldUpdateOperationsInput | string | null
    linkedTicketId?: NullableIntFieldUpdateOperationsInput | number | null
    linkedAssetId?: NullableIntFieldUpdateOperationsInput | number | null
    flags?: MailroomPackageUpdateflagsInput | string[]
    intakePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    intakeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryLocation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryEvents?: DeliveryEventUncheckedUpdateManyWithoutPackageNestedInput
    proxyAuthorizations?: ProxyAuthorizationUncheckedUpdateManyWithoutPackageNestedInput
  }

  export type MailroomPackageCreateManyInput = {
    id?: number
    trackingNumber: string
    carrier: string
    sender?: string | null
    recipientId: string
    department?: string | null
    packageType?: string | null
    status: string
    assignedLocation?: string | null
    linkedTicketId?: number | null
    linkedAssetId?: number | null
    flags?: MailroomPackageCreateflagsInput | string[]
    intakePhotoUrl?: string | null
    deliveryPhotoUrl?: string | null
    signatureUrl?: string | null
    intakeLocation?: string | null
    deliveryLocation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MailroomPackageUpdateManyMutationInput = {
    trackingNumber?: StringFieldUpdateOperationsInput | string
    carrier?: StringFieldUpdateOperationsInput | string
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    packageType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    assignedLocation?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: MailroomPackageUpdateflagsInput | string[]
    intakePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    intakeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryLocation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MailroomPackageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackingNumber?: StringFieldUpdateOperationsInput | string
    carrier?: StringFieldUpdateOperationsInput | string
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    recipientId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    packageType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    assignedLocation?: NullableStringFieldUpdateOperationsInput | string | null
    linkedTicketId?: NullableIntFieldUpdateOperationsInput | number | null
    linkedAssetId?: NullableIntFieldUpdateOperationsInput | number | null
    flags?: MailroomPackageUpdateflagsInput | string[]
    intakePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    intakeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryLocation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryEventCreateInput = {
    eventType: string
    location?: string | null
    timestamp?: Date | string
    photoUrl?: string | null
    signatureBlob?: Uint8Array | null
    package: MailroomPackageCreateNestedOneWithoutDeliveryEventsInput
    user: UserCreateNestedOneWithoutDeliveryEventsInput
  }

  export type DeliveryEventUncheckedCreateInput = {
    id?: number
    packageId: number
    eventType: string
    performedBy: string
    location?: string | null
    timestamp?: Date | string
    photoUrl?: string | null
    signatureBlob?: Uint8Array | null
  }

  export type DeliveryEventUpdateInput = {
    eventType?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatureBlob?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    package?: MailroomPackageUpdateOneRequiredWithoutDeliveryEventsNestedInput
    user?: UserUpdateOneRequiredWithoutDeliveryEventsNestedInput
  }

  export type DeliveryEventUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    packageId?: IntFieldUpdateOperationsInput | number
    eventType?: StringFieldUpdateOperationsInput | string
    performedBy?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatureBlob?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type DeliveryEventCreateManyInput = {
    id?: number
    packageId: number
    eventType: string
    performedBy: string
    location?: string | null
    timestamp?: Date | string
    photoUrl?: string | null
    signatureBlob?: Uint8Array | null
  }

  export type DeliveryEventUpdateManyMutationInput = {
    eventType?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatureBlob?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type DeliveryEventUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    packageId?: IntFieldUpdateOperationsInput | number
    eventType?: StringFieldUpdateOperationsInput | string
    performedBy?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatureBlob?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type ProxyAuthorizationCreateInput = {
    expiration?: Date | string | null
    status: string
    recipient: UserCreateNestedOneWithoutProxyAuthorizationsAsRecipientInput
    proxy: UserCreateNestedOneWithoutProxyAuthorizationsAsProxyInput
    package: MailroomPackageCreateNestedOneWithoutProxyAuthorizationsInput
  }

  export type ProxyAuthorizationUncheckedCreateInput = {
    id?: number
    recipientId: string
    proxyId: string
    packageId: number
    expiration?: Date | string | null
    status: string
  }

  export type ProxyAuthorizationUpdateInput = {
    expiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    recipient?: UserUpdateOneRequiredWithoutProxyAuthorizationsAsRecipientNestedInput
    proxy?: UserUpdateOneRequiredWithoutProxyAuthorizationsAsProxyNestedInput
    package?: MailroomPackageUpdateOneRequiredWithoutProxyAuthorizationsNestedInput
  }

  export type ProxyAuthorizationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    recipientId?: StringFieldUpdateOperationsInput | string
    proxyId?: StringFieldUpdateOperationsInput | string
    packageId?: IntFieldUpdateOperationsInput | number
    expiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ProxyAuthorizationCreateManyInput = {
    id?: number
    recipientId: string
    proxyId: string
    packageId: number
    expiration?: Date | string | null
    status: string
  }

  export type ProxyAuthorizationUpdateManyMutationInput = {
    expiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ProxyAuthorizationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    recipientId?: StringFieldUpdateOperationsInput | string
    proxyId?: StringFieldUpdateOperationsInput | string
    packageId?: IntFieldUpdateOperationsInput | number
    expiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type RequestCatalogItemCreateInput = {
    name: string
    formSchema?: NullableJsonNullValueInput | InputJsonValue
    workflowId?: number | null
    ritms?: RITMCreateNestedManyWithoutCatalogItemInput
  }

  export type RequestCatalogItemUncheckedCreateInput = {
    id?: number
    name: string
    formSchema?: NullableJsonNullValueInput | InputJsonValue
    workflowId?: number | null
    ritms?: RITMUncheckedCreateNestedManyWithoutCatalogItemInput
  }

  export type RequestCatalogItemUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    formSchema?: NullableJsonNullValueInput | InputJsonValue
    workflowId?: NullableIntFieldUpdateOperationsInput | number | null
    ritms?: RITMUpdateManyWithoutCatalogItemNestedInput
  }

  export type RequestCatalogItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    formSchema?: NullableJsonNullValueInput | InputJsonValue
    workflowId?: NullableIntFieldUpdateOperationsInput | number | null
    ritms?: RITMUncheckedUpdateManyWithoutCatalogItemNestedInput
  }

  export type RequestCatalogItemCreateManyInput = {
    id?: number
    name: string
    formSchema?: NullableJsonNullValueInput | InputJsonValue
    workflowId?: number | null
  }

  export type RequestCatalogItemUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    formSchema?: NullableJsonNullValueInput | InputJsonValue
    workflowId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RequestCatalogItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    formSchema?: NullableJsonNullValueInput | InputJsonValue
    workflowId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RITMCreateInput = {
    status?: string
    ticket: SupportTicketCreateNestedOneWithoutRitmsInput
    catalogItem: RequestCatalogItemCreateNestedOneWithoutRitmsInput
  }

  export type RITMUncheckedCreateInput = {
    id?: number
    reqId: number
    catalogItemId: number
    status?: string
  }

  export type RITMUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
    ticket?: SupportTicketUpdateOneRequiredWithoutRitmsNestedInput
    catalogItem?: RequestCatalogItemUpdateOneRequiredWithoutRitmsNestedInput
  }

  export type RITMUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    reqId?: IntFieldUpdateOperationsInput | number
    catalogItemId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type RITMCreateManyInput = {
    id?: number
    reqId: number
    catalogItemId: number
    status?: string
  }

  export type RITMUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
  }

  export type RITMUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reqId?: IntFieldUpdateOperationsInput | number
    catalogItemId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type VipProxyCreateInput = {
    createdAt?: Date | string
    expiresAt?: Date | string | null
    vip: UserCreateNestedOneWithoutVipProxiesAsVipInput
    proxy: UserCreateNestedOneWithoutVipProxiesAsProxyInput
  }

  export type VipProxyUncheckedCreateInput = {
    id?: number
    vipId: string
    proxyId: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type VipProxyUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vip?: UserUpdateOneRequiredWithoutVipProxiesAsVipNestedInput
    proxy?: UserUpdateOneRequiredWithoutVipProxiesAsProxyNestedInput
  }

  export type VipProxyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    vipId?: StringFieldUpdateOperationsInput | string
    proxyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VipProxyCreateManyInput = {
    id?: number
    vipId: string
    proxyId: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type VipProxyUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VipProxyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    vipId?: StringFieldUpdateOperationsInput | string
    proxyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VipSlaHistoryCreateInput = {
    sla: JsonNullValueInput | InputJsonValue
    effectiveAt?: Date | string
    endedAt?: Date | string | null
    user: UserCreateNestedOneWithoutVipSlaHistoryInput
  }

  export type VipSlaHistoryUncheckedCreateInput = {
    id?: number
    userId: string
    sla: JsonNullValueInput | InputJsonValue
    effectiveAt?: Date | string
    endedAt?: Date | string | null
  }

  export type VipSlaHistoryUpdateInput = {
    sla?: JsonNullValueInput | InputJsonValue
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutVipSlaHistoryNestedInput
  }

  export type VipSlaHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    sla?: JsonNullValueInput | InputJsonValue
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VipSlaHistoryCreateManyInput = {
    id?: number
    userId: string
    sla: JsonNullValueInput | InputJsonValue
    effectiveAt?: Date | string
    endedAt?: Date | string | null
  }

  export type VipSlaHistoryUpdateManyMutationInput = {
    sla?: JsonNullValueInput | InputJsonValue
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VipSlaHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    sla?: JsonNullValueInput | InputJsonValue
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AgentAvailabilityCreateInput = {
    id?: string
    queueName: string
    isAvailable?: boolean
    maxCapacity?: number
    currentLoad?: number
    status?: string
    lastUpdated?: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAgentAvailabilityInput
  }

  export type AgentAvailabilityUncheckedCreateInput = {
    id?: string
    userId: string
    queueName: string
    isAvailable?: boolean
    maxCapacity?: number
    currentLoad?: number
    status?: string
    lastUpdated?: Date | string
    createdAt?: Date | string
  }

  export type AgentAvailabilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    queueName?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentLoad?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgentAvailabilityNestedInput
  }

  export type AgentAvailabilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    queueName?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentLoad?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentAvailabilityCreateManyInput = {
    id?: string
    userId: string
    queueName: string
    isAvailable?: boolean
    maxCapacity?: number
    currentLoad?: number
    status?: string
    lastUpdated?: Date | string
    createdAt?: Date | string
  }

  export type AgentAvailabilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    queueName?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentLoad?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentAvailabilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    queueName?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentLoad?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueueMetricsCreateInput = {
    id?: string
    queueName: string
    totalAgents?: number
    availableAgents?: number
    totalTickets?: number
    openTickets?: number
    avgResponseTime?: number
    avgResolutionTime?: number
    slaBreaches?: number
    highPriorityTickets?: number
    capacityUtilization?: number
    averageWaitTime?: number
    thresholdWarning?: boolean
    thresholdCritical?: boolean
    lastCalculated?: Date | string
  }

  export type QueueMetricsUncheckedCreateInput = {
    id?: string
    queueName: string
    totalAgents?: number
    availableAgents?: number
    totalTickets?: number
    openTickets?: number
    avgResponseTime?: number
    avgResolutionTime?: number
    slaBreaches?: number
    highPriorityTickets?: number
    capacityUtilization?: number
    averageWaitTime?: number
    thresholdWarning?: boolean
    thresholdCritical?: boolean
    lastCalculated?: Date | string
  }

  export type QueueMetricsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    queueName?: StringFieldUpdateOperationsInput | string
    totalAgents?: IntFieldUpdateOperationsInput | number
    availableAgents?: IntFieldUpdateOperationsInput | number
    totalTickets?: IntFieldUpdateOperationsInput | number
    openTickets?: IntFieldUpdateOperationsInput | number
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    avgResolutionTime?: FloatFieldUpdateOperationsInput | number
    slaBreaches?: IntFieldUpdateOperationsInput | number
    highPriorityTickets?: IntFieldUpdateOperationsInput | number
    capacityUtilization?: FloatFieldUpdateOperationsInput | number
    averageWaitTime?: FloatFieldUpdateOperationsInput | number
    thresholdWarning?: BoolFieldUpdateOperationsInput | boolean
    thresholdCritical?: BoolFieldUpdateOperationsInput | boolean
    lastCalculated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueueMetricsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    queueName?: StringFieldUpdateOperationsInput | string
    totalAgents?: IntFieldUpdateOperationsInput | number
    availableAgents?: IntFieldUpdateOperationsInput | number
    totalTickets?: IntFieldUpdateOperationsInput | number
    openTickets?: IntFieldUpdateOperationsInput | number
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    avgResolutionTime?: FloatFieldUpdateOperationsInput | number
    slaBreaches?: IntFieldUpdateOperationsInput | number
    highPriorityTickets?: IntFieldUpdateOperationsInput | number
    capacityUtilization?: FloatFieldUpdateOperationsInput | number
    averageWaitTime?: FloatFieldUpdateOperationsInput | number
    thresholdWarning?: BoolFieldUpdateOperationsInput | boolean
    thresholdCritical?: BoolFieldUpdateOperationsInput | boolean
    lastCalculated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueueMetricsCreateManyInput = {
    id?: string
    queueName: string
    totalAgents?: number
    availableAgents?: number
    totalTickets?: number
    openTickets?: number
    avgResponseTime?: number
    avgResolutionTime?: number
    slaBreaches?: number
    highPriorityTickets?: number
    capacityUtilization?: number
    averageWaitTime?: number
    thresholdWarning?: boolean
    thresholdCritical?: boolean
    lastCalculated?: Date | string
  }

  export type QueueMetricsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    queueName?: StringFieldUpdateOperationsInput | string
    totalAgents?: IntFieldUpdateOperationsInput | number
    availableAgents?: IntFieldUpdateOperationsInput | number
    totalTickets?: IntFieldUpdateOperationsInput | number
    openTickets?: IntFieldUpdateOperationsInput | number
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    avgResolutionTime?: FloatFieldUpdateOperationsInput | number
    slaBreaches?: IntFieldUpdateOperationsInput | number
    highPriorityTickets?: IntFieldUpdateOperationsInput | number
    capacityUtilization?: FloatFieldUpdateOperationsInput | number
    averageWaitTime?: FloatFieldUpdateOperationsInput | number
    thresholdWarning?: BoolFieldUpdateOperationsInput | boolean
    thresholdCritical?: BoolFieldUpdateOperationsInput | boolean
    lastCalculated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueueMetricsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    queueName?: StringFieldUpdateOperationsInput | string
    totalAgents?: IntFieldUpdateOperationsInput | number
    availableAgents?: IntFieldUpdateOperationsInput | number
    totalTickets?: IntFieldUpdateOperationsInput | number
    openTickets?: IntFieldUpdateOperationsInput | number
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    avgResolutionTime?: FloatFieldUpdateOperationsInput | number
    slaBreaches?: IntFieldUpdateOperationsInput | number
    highPriorityTickets?: IntFieldUpdateOperationsInput | number
    capacityUtilization?: FloatFieldUpdateOperationsInput | number
    averageWaitTime?: FloatFieldUpdateOperationsInput | number
    thresholdWarning?: BoolFieldUpdateOperationsInput | boolean
    thresholdCritical?: BoolFieldUpdateOperationsInput | boolean
    lastCalculated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueueAlertCreateInput = {
    id?: string
    queueName: string
    alertType: string
    message: string
    isActive?: boolean
    alertedAt?: Date | string
    resolvedAt?: Date | string | null
    notifiedUsers?: QueueAlertCreatenotifiedUsersInput | string[]
  }

  export type QueueAlertUncheckedCreateInput = {
    id?: string
    queueName: string
    alertType: string
    message: string
    isActive?: boolean
    alertedAt?: Date | string
    resolvedAt?: Date | string | null
    notifiedUsers?: QueueAlertCreatenotifiedUsersInput | string[]
  }

  export type QueueAlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    queueName?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    alertedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notifiedUsers?: QueueAlertUpdatenotifiedUsersInput | string[]
  }

  export type QueueAlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    queueName?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    alertedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notifiedUsers?: QueueAlertUpdatenotifiedUsersInput | string[]
  }

  export type QueueAlertCreateManyInput = {
    id?: string
    queueName: string
    alertType: string
    message: string
    isActive?: boolean
    alertedAt?: Date | string
    resolvedAt?: Date | string | null
    notifiedUsers?: QueueAlertCreatenotifiedUsersInput | string[]
  }

  export type QueueAlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    queueName?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    alertedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notifiedUsers?: QueueAlertUpdatenotifiedUsersInput | string[]
  }

  export type QueueAlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    queueName?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    alertedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notifiedUsers?: QueueAlertUpdatenotifiedUsersInput | string[]
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FeedbackListRelationFilter = {
    every?: FeedbackWhereInput
    some?: FeedbackWhereInput
    none?: FeedbackWhereInput
  }

  export type LogListRelationFilter = {
    every?: LogWhereInput
    some?: LogWhereInput
    none?: LogWhereInput
  }

  export type PasskeyListRelationFilter = {
    every?: PasskeyWhereInput
    some?: PasskeyWhereInput
    none?: PasskeyWhereInput
  }

  export type SupportTicketListRelationFilter = {
    every?: SupportTicketWhereInput
    some?: SupportTicketWhereInput
    none?: SupportTicketWhereInput
  }

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput
    some?: UserRoleWhereInput
    none?: UserRoleWhereInput
  }

  export type ScimMappingListRelationFilter = {
    every?: ScimMappingWhereInput
    some?: ScimMappingWhereInput
    none?: ScimMappingWhereInput
  }

  export type KbArticleListRelationFilter = {
    every?: KbArticleWhereInput
    some?: KbArticleWhereInput
    none?: KbArticleWhereInput
  }

  export type KbArticleVersionListRelationFilter = {
    every?: KbArticleVersionWhereInput
    some?: KbArticleVersionWhereInput
    none?: KbArticleVersionWhereInput
  }

  export type KbArticleCommentListRelationFilter = {
    every?: KbArticleCommentWhereInput
    some?: KbArticleCommentWhereInput
    none?: KbArticleCommentWhereInput
  }

  export type XpEventListRelationFilter = {
    every?: XpEventWhereInput
    some?: XpEventWhereInput
    none?: XpEventWhereInput
  }

  export type LeaderboardNullableScalarRelationFilter = {
    is?: LeaderboardWhereInput | null
    isNot?: LeaderboardWhereInput | null
  }

  export type MailroomPackageListRelationFilter = {
    every?: MailroomPackageWhereInput
    some?: MailroomPackageWhereInput
    none?: MailroomPackageWhereInput
  }

  export type DeliveryEventListRelationFilter = {
    every?: DeliveryEventWhereInput
    some?: DeliveryEventWhereInput
    none?: DeliveryEventWhereInput
  }

  export type ProxyAuthorizationListRelationFilter = {
    every?: ProxyAuthorizationWhereInput
    some?: ProxyAuthorizationWhereInput
    none?: ProxyAuthorizationWhereInput
  }

  export type VipProxyListRelationFilter = {
    every?: VipProxyWhereInput
    some?: VipProxyWhereInput
    none?: VipProxyWhereInput
  }

  export type VipSlaHistoryListRelationFilter = {
    every?: VipSlaHistoryWhereInput
    some?: VipSlaHistoryWhereInput
    none?: VipSlaHistoryWhereInput
  }

  export type AgentAvailabilityListRelationFilter = {
    every?: AgentAvailabilityWhereInput
    some?: AgentAvailabilityWhereInput
    none?: AgentAvailabilityWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type FeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasskeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupportTicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScimMappingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KbArticleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KbArticleVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KbArticleCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type XpEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MailroomPackageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeliveryEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProxyAuthorizationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VipProxyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VipSlaHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentAvailabilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    disabled?: SortOrder
    isDefault?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorBackupCodes?: SortOrder
    twoFactorVerified?: SortOrder
    samlNameId?: SortOrder
    samlSessionIndex?: SortOrder
    scimExternalId?: SortOrder
    department?: SortOrder
    lastSamlLogin?: SortOrder
    isVip?: SortOrder
    vipLevel?: SortOrder
    vipSlaOverride?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    disabled?: SortOrder
    isDefault?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorVerified?: SortOrder
    samlNameId?: SortOrder
    samlSessionIndex?: SortOrder
    scimExternalId?: SortOrder
    department?: SortOrder
    lastSamlLogin?: SortOrder
    isVip?: SortOrder
    vipLevel?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    disabled?: SortOrder
    isDefault?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorVerified?: SortOrder
    samlNameId?: SortOrder
    samlSessionIndex?: SortOrder
    scimExternalId?: SortOrder
    department?: SortOrder
    lastSamlLogin?: SortOrder
    isVip?: SortOrder
    vipLevel?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type RolePermissionListRelationFilter = {
    every?: RolePermissionWhereInput
    some?: RolePermissionWhereInput
    none?: RolePermissionWhereInput
  }

  export type RolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserRoleUserIdRoleIdCompoundUniqueInput = {
    userId: string
    roleId: number
  }

  export type UserRoleCountOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
  }

  export type UserRoleAvgOrderByAggregateInput = {
    roleId?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
  }

  export type UserRoleSumOrderByAggregateInput = {
    roleId?: SortOrder
  }

  export type PermissionScalarRelationFilter = {
    is?: PermissionWhereInput
    isNot?: PermissionWhereInput
  }

  export type RolePermissionRoleIdPermissionIdCompoundUniqueInput = {
    roleId: number
    permissionId: number
  }

  export type RolePermissionCountOrderByAggregateInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
    assignedAt?: SortOrder
  }

  export type RolePermissionAvgOrderByAggregateInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type RolePermissionMaxOrderByAggregateInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
    assignedAt?: SortOrder
  }

  export type RolePermissionMinOrderByAggregateInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
    assignedAt?: SortOrder
  }

  export type RolePermissionSumOrderByAggregateInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type PasskeyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    credentialId?: SortOrder
    publicKey?: SortOrder
    counter?: SortOrder
    transports?: SortOrder
    deviceType?: SortOrder
    backedUp?: SortOrder
    createdAt?: SortOrder
    lastUsed?: SortOrder
  }

  export type PasskeyAvgOrderByAggregateInput = {
    id?: SortOrder
    counter?: SortOrder
  }

  export type PasskeyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    credentialId?: SortOrder
    publicKey?: SortOrder
    counter?: SortOrder
    transports?: SortOrder
    deviceType?: SortOrder
    backedUp?: SortOrder
    createdAt?: SortOrder
    lastUsed?: SortOrder
  }

  export type PasskeyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    credentialId?: SortOrder
    publicKey?: SortOrder
    counter?: SortOrder
    transports?: SortOrder
    deviceType?: SortOrder
    backedUp?: SortOrder
    createdAt?: SortOrder
    lastUsed?: SortOrder
  }

  export type PasskeySumOrderByAggregateInput = {
    id?: SortOrder
    counter?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type LogCountOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    title?: SortOrder
    system?: SortOrder
    urgency?: SortOrder
    timestamp?: SortOrder
    emailStatus?: SortOrder
    userId?: SortOrder
  }

  export type LogAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LogMaxOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    title?: SortOrder
    system?: SortOrder
    urgency?: SortOrder
    timestamp?: SortOrder
    emailStatus?: SortOrder
    userId?: SortOrder
  }

  export type LogMinOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    title?: SortOrder
    system?: SortOrder
    urgency?: SortOrder
    timestamp?: SortOrder
    emailStatus?: SortOrder
    userId?: SortOrder
  }

  export type LogSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ConfigHistoryListRelationFilter = {
    every?: ConfigHistoryWhereInput
    some?: ConfigHistoryWhereInput
    none?: ConfigHistoryWhereInput
  }

  export type ConfigHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConfigCountOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    valueType?: SortOrder
    description?: SortOrder
    isPublic?: SortOrder
    category?: SortOrder
    subcategory?: SortOrder
    isUIEditable?: SortOrder
    isRequired?: SortOrder
    defaultValue?: SortOrder
    validationRules?: SortOrder
    displayOrder?: SortOrder
    helpText?: SortOrder
    isAdvanced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ConfigAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type ConfigMaxOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    valueType?: SortOrder
    description?: SortOrder
    isPublic?: SortOrder
    category?: SortOrder
    subcategory?: SortOrder
    isUIEditable?: SortOrder
    isRequired?: SortOrder
    defaultValue?: SortOrder
    displayOrder?: SortOrder
    helpText?: SortOrder
    isAdvanced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ConfigMinOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    valueType?: SortOrder
    description?: SortOrder
    isPublic?: SortOrder
    category?: SortOrder
    subcategory?: SortOrder
    isUIEditable?: SortOrder
    isRequired?: SortOrder
    defaultValue?: SortOrder
    displayOrder?: SortOrder
    helpText?: SortOrder
    isAdvanced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ConfigSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ConfigScalarRelationFilter = {
    is?: ConfigWhereInput
    isNot?: ConfigWhereInput
  }

  export type ConfigHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    configKey?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    changedBy?: SortOrder
    changeReason?: SortOrder
    createdAt?: SortOrder
  }

  export type ConfigHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ConfigHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    configKey?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    changedBy?: SortOrder
    changeReason?: SortOrder
    createdAt?: SortOrder
  }

  export type ConfigHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    configKey?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    changedBy?: SortOrder
    changeReason?: SortOrder
    createdAt?: SortOrder
  }

  export type ConfigHistorySumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ConfigTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    template?: SortOrder
    isDefault?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfigTemplateAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ConfigTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isDefault?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfigTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isDefault?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfigTemplateSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type KioskActivationListRelationFilter = {
    every?: KioskActivationWhereInput
    some?: KioskActivationWhereInput
    none?: KioskActivationWhereInput
  }

  export type KioskAssetRegistryListRelationFilter = {
    every?: KioskAssetRegistryWhereInput
    some?: KioskAssetRegistryWhereInput
    none?: KioskAssetRegistryWhereInput
  }

  export type HelixSyncFailureListRelationFilter = {
    every?: HelixSyncFailureWhereInput
    some?: HelixSyncFailureWhereInput
    none?: HelixSyncFailureWhereInput
  }

  export type KioskOrganizationAssignmentNullableScalarRelationFilter = {
    is?: KioskOrganizationAssignmentWhereInput | null
    isNot?: KioskOrganizationAssignmentWhereInput | null
  }

  export type KioskMetadataLogListRelationFilter = {
    every?: KioskMetadataLogWhereInput
    some?: KioskMetadataLogWhereInput
    none?: KioskMetadataLogWhereInput
  }

  export type KioskActivationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KioskAssetRegistryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HelixSyncFailureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KioskMetadataLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KioskCountOrderByAggregateInput = {
    id?: SortOrder
    lastSeen?: SortOrder
    version?: SortOrder
    active?: SortOrder
    logoUrl?: SortOrder
    bgUrl?: SortOrder
    statusEnabled?: SortOrder
    currentStatus?: SortOrder
    openMsg?: SortOrder
    closedMsg?: SortOrder
    errorMsg?: SortOrder
    meetingMsg?: SortOrder
    brbMsg?: SortOrder
    lunchMsg?: SortOrder
    unavailableMsg?: SortOrder
    schedule?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KioskMaxOrderByAggregateInput = {
    id?: SortOrder
    lastSeen?: SortOrder
    version?: SortOrder
    active?: SortOrder
    logoUrl?: SortOrder
    bgUrl?: SortOrder
    statusEnabled?: SortOrder
    currentStatus?: SortOrder
    openMsg?: SortOrder
    closedMsg?: SortOrder
    errorMsg?: SortOrder
    meetingMsg?: SortOrder
    brbMsg?: SortOrder
    lunchMsg?: SortOrder
    unavailableMsg?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KioskMinOrderByAggregateInput = {
    id?: SortOrder
    lastSeen?: SortOrder
    version?: SortOrder
    active?: SortOrder
    logoUrl?: SortOrder
    bgUrl?: SortOrder
    statusEnabled?: SortOrder
    currentStatus?: SortOrder
    openMsg?: SortOrder
    closedMsg?: SortOrder
    errorMsg?: SortOrder
    meetingMsg?: SortOrder
    brbMsg?: SortOrder
    lunchMsg?: SortOrder
    unavailableMsg?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    userId?: SortOrder
  }

  export type FeedbackAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    userId?: SortOrder
  }

  export type FeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    userId?: SortOrder
  }

  export type FeedbackSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    level?: SortOrder
    active?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    level?: SortOrder
    active?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    level?: SortOrder
    active?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DirectoryIntegrationCountOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    settings?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DirectoryIntegrationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DirectoryIntegrationMaxOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DirectoryIntegrationMinOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DirectoryIntegrationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AssetCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    sizeBytes?: SortOrder
    mimeType?: SortOrder
    uploadedAt?: SortOrder
  }

  export type AssetAvgOrderByAggregateInput = {
    id?: SortOrder
    sizeBytes?: SortOrder
  }

  export type AssetMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    sizeBytes?: SortOrder
    mimeType?: SortOrder
    uploadedAt?: SortOrder
  }

  export type AssetMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    sizeBytes?: SortOrder
    mimeType?: SortOrder
    uploadedAt?: SortOrder
  }

  export type AssetSumOrderByAggregateInput = {
    id?: SortOrder
    sizeBytes?: SortOrder
  }

  export type KioskNullableScalarRelationFilter = {
    is?: KioskWhereInput | null
    isNot?: KioskWhereInput | null
  }

  export type KioskActivationCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    qrCode?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
    kioskId?: SortOrder
  }

  export type KioskActivationMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    qrCode?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
    kioskId?: SortOrder
  }

  export type KioskActivationMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    qrCode?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
    kioskId?: SortOrder
  }

  export type SsoConfigurationCountOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    enabled?: SortOrder
    configuration?: SortOrder
    updatedAt?: SortOrder
  }

  export type SsoConfigurationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SsoConfigurationMaxOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    enabled?: SortOrder
    updatedAt?: SortOrder
  }

  export type SsoConfigurationMinOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    enabled?: SortOrder
    updatedAt?: SortOrder
  }

  export type SsoConfigurationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AdminPinCountOrderByAggregateInput = {
    id?: SortOrder
    globalPin?: SortOrder
    kioskPins?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminPinAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AdminPinMaxOrderByAggregateInput = {
    id?: SortOrder
    globalPin?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminPinMinOrderByAggregateInput = {
    id?: SortOrder
    globalPin?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminPinSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type KbArticleVersionNullableScalarRelationFilter = {
    is?: KbArticleVersionWhereInput | null
    isNot?: KbArticleVersionWhereInput | null
  }

  export type KbArticleCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    currentVersionId?: SortOrder
    isPublished?: SortOrder
    tags?: SortOrder
  }

  export type KbArticleAvgOrderByAggregateInput = {
    id?: SortOrder
    currentVersionId?: SortOrder
  }

  export type KbArticleMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    currentVersionId?: SortOrder
    isPublished?: SortOrder
  }

  export type KbArticleMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    currentVersionId?: SortOrder
    isPublished?: SortOrder
  }

  export type KbArticleSumOrderByAggregateInput = {
    id?: SortOrder
    currentVersionId?: SortOrder
  }

  export type KbArticleScalarRelationFilter = {
    is?: KbArticleWhereInput
    isNot?: KbArticleWhereInput
  }

  export type KbArticleVersionArticleIdVersionCompoundUniqueInput = {
    articleId: number
    version: number
  }

  export type KbArticleVersionCountOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    content?: SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    version?: SortOrder
    isApproved?: SortOrder
  }

  export type KbArticleVersionAvgOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    version?: SortOrder
  }

  export type KbArticleVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    content?: SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    version?: SortOrder
    isApproved?: SortOrder
  }

  export type KbArticleVersionMinOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    content?: SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    version?: SortOrder
    isApproved?: SortOrder
  }

  export type KbArticleVersionSumOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    version?: SortOrder
  }

  export type KbArticleCommentCountOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type KbArticleCommentAvgOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
  }

  export type KbArticleCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type KbArticleCommentMinOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type KbArticleCommentSumOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
  }

  export type AssetTicketHistoryListRelationFilter = {
    every?: AssetTicketHistoryWhereInput
    some?: AssetTicketHistoryWhereInput
    none?: AssetTicketHistoryWhereInput
  }

  export type RITMListRelationFilter = {
    every?: RITMWhereInput
    some?: RITMWhereInput
    none?: RITMWhereInput
  }

  export type AssetTicketHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RITMOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupportTicketCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    assigneeId?: SortOrder
    vipPriorityScore?: SortOrder
    vipTriggerSource?: SortOrder
  }

  export type SupportTicketAvgOrderByAggregateInput = {
    id?: SortOrder
    vipPriorityScore?: SortOrder
  }

  export type SupportTicketMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    assigneeId?: SortOrder
    vipPriorityScore?: SortOrder
    vipTriggerSource?: SortOrder
  }

  export type SupportTicketMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    assigneeId?: SortOrder
    vipPriorityScore?: SortOrder
    vipTriggerSource?: SortOrder
  }

  export type SupportTicketSumOrderByAggregateInput = {
    id?: SortOrder
    vipPriorityScore?: SortOrder
  }

  export type AssetStatusLogListRelationFilter = {
    every?: AssetStatusLogWhereInput
    some?: AssetStatusLogWhereInput
    none?: AssetStatusLogWhereInput
  }

  export type AssetAssignmentListRelationFilter = {
    every?: AssetAssignmentWhereInput
    some?: AssetAssignmentWhereInput
    none?: AssetAssignmentWhereInput
  }

  export type AssetWarrantyAlertListRelationFilter = {
    every?: AssetWarrantyAlertWhereInput
    some?: AssetWarrantyAlertWhereInput
    none?: AssetWarrantyAlertWhereInput
  }

  export type AssetValidationLogListRelationFilter = {
    every?: AssetValidationLogWhereInput
    some?: AssetValidationLogWhereInput
    none?: AssetValidationLogWhereInput
  }

  export type AssetImportBatchNullableScalarRelationFilter = {
    is?: AssetImportBatchWhereInput | null
    isNot?: AssetImportBatchWhereInput | null
  }

  export type AssetStatusLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssetAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssetWarrantyAlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssetValidationLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryAssetCountOrderByAggregateInput = {
    id?: SortOrder
    assetTag?: SortOrder
    typeId?: SortOrder
    serialNumber?: SortOrder
    model?: SortOrder
    vendorId?: SortOrder
    purchaseDate?: SortOrder
    warrantyExpiry?: SortOrder
    assignedToUserId?: SortOrder
    assignedToOrgId?: SortOrder
    assignedToCustomerId?: SortOrder
    department?: SortOrder
    status?: SortOrder
    locationId?: SortOrder
    kioskId?: SortOrder
    customFields?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serialNumberEnc?: SortOrder
    warrantyInfoEnc?: SortOrder
    purchaseInfoEnc?: SortOrder
    maintenanceNotesEnc?: SortOrder
    warrantyAlertDays?: SortOrder
    warrantyAlertEnabled?: SortOrder
    lastWarrantyAlertSent?: SortOrder
    importBatchId?: SortOrder
    importSource?: SortOrder
    importValidated?: SortOrder
    validationErrors?: SortOrder
  }

  export type InventoryAssetAvgOrderByAggregateInput = {
    id?: SortOrder
    typeId?: SortOrder
    vendorId?: SortOrder
    assignedToOrgId?: SortOrder
    assignedToCustomerId?: SortOrder
    locationId?: SortOrder
    warrantyAlertDays?: SortOrder
  }

  export type InventoryAssetMaxOrderByAggregateInput = {
    id?: SortOrder
    assetTag?: SortOrder
    typeId?: SortOrder
    serialNumber?: SortOrder
    model?: SortOrder
    vendorId?: SortOrder
    purchaseDate?: SortOrder
    warrantyExpiry?: SortOrder
    assignedToUserId?: SortOrder
    assignedToOrgId?: SortOrder
    assignedToCustomerId?: SortOrder
    department?: SortOrder
    status?: SortOrder
    locationId?: SortOrder
    kioskId?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serialNumberEnc?: SortOrder
    warrantyInfoEnc?: SortOrder
    purchaseInfoEnc?: SortOrder
    maintenanceNotesEnc?: SortOrder
    warrantyAlertDays?: SortOrder
    warrantyAlertEnabled?: SortOrder
    lastWarrantyAlertSent?: SortOrder
    importBatchId?: SortOrder
    importSource?: SortOrder
    importValidated?: SortOrder
    validationErrors?: SortOrder
  }

  export type InventoryAssetMinOrderByAggregateInput = {
    id?: SortOrder
    assetTag?: SortOrder
    typeId?: SortOrder
    serialNumber?: SortOrder
    model?: SortOrder
    vendorId?: SortOrder
    purchaseDate?: SortOrder
    warrantyExpiry?: SortOrder
    assignedToUserId?: SortOrder
    assignedToOrgId?: SortOrder
    assignedToCustomerId?: SortOrder
    department?: SortOrder
    status?: SortOrder
    locationId?: SortOrder
    kioskId?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serialNumberEnc?: SortOrder
    warrantyInfoEnc?: SortOrder
    purchaseInfoEnc?: SortOrder
    maintenanceNotesEnc?: SortOrder
    warrantyAlertDays?: SortOrder
    warrantyAlertEnabled?: SortOrder
    lastWarrantyAlertSent?: SortOrder
    importBatchId?: SortOrder
    importSource?: SortOrder
    importValidated?: SortOrder
    validationErrors?: SortOrder
  }

  export type InventoryAssetSumOrderByAggregateInput = {
    id?: SortOrder
    typeId?: SortOrder
    vendorId?: SortOrder
    assignedToOrgId?: SortOrder
    assignedToCustomerId?: SortOrder
    locationId?: SortOrder
    warrantyAlertDays?: SortOrder
  }

  export type InventoryAssetScalarRelationFilter = {
    is?: InventoryAssetWhereInput
    isNot?: InventoryAssetWhereInput
  }

  export type AssetStatusLogCountOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    previousStatus?: SortOrder
    newStatus?: SortOrder
    changedByUserId?: SortOrder
    notes?: SortOrder
    timestamp?: SortOrder
  }

  export type AssetStatusLogAvgOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
  }

  export type AssetStatusLogMaxOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    previousStatus?: SortOrder
    newStatus?: SortOrder
    changedByUserId?: SortOrder
    notes?: SortOrder
    timestamp?: SortOrder
  }

  export type AssetStatusLogMinOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    previousStatus?: SortOrder
    newStatus?: SortOrder
    changedByUserId?: SortOrder
    notes?: SortOrder
    timestamp?: SortOrder
  }

  export type AssetStatusLogSumOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
  }

  export type AssetAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    customerId?: SortOrder
    assignedBy?: SortOrder
    assignedDate?: SortOrder
    expectedReturn?: SortOrder
    returnDate?: SortOrder
    managerId?: SortOrder
  }

  export type AssetAssignmentAvgOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    orgId?: SortOrder
    customerId?: SortOrder
  }

  export type AssetAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    customerId?: SortOrder
    assignedBy?: SortOrder
    assignedDate?: SortOrder
    expectedReturn?: SortOrder
    returnDate?: SortOrder
    managerId?: SortOrder
  }

  export type AssetAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    customerId?: SortOrder
    assignedBy?: SortOrder
    assignedDate?: SortOrder
    expectedReturn?: SortOrder
    returnDate?: SortOrder
    managerId?: SortOrder
  }

  export type AssetAssignmentSumOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    orgId?: SortOrder
    customerId?: SortOrder
  }

  export type SupportTicketScalarRelationFilter = {
    is?: SupportTicketWhereInput
    isNot?: SupportTicketWhereInput
  }

  export type AssetTicketHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    ticketId?: SortOrder
    relationshipType?: SortOrder
    createdAt?: SortOrder
    endedAt?: SortOrder
    createdBy?: SortOrder
    notes?: SortOrder
  }

  export type AssetTicketHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    ticketId?: SortOrder
  }

  export type AssetTicketHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    ticketId?: SortOrder
    relationshipType?: SortOrder
    createdAt?: SortOrder
    endedAt?: SortOrder
    createdBy?: SortOrder
    notes?: SortOrder
  }

  export type AssetTicketHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    ticketId?: SortOrder
    relationshipType?: SortOrder
    createdAt?: SortOrder
    endedAt?: SortOrder
    createdBy?: SortOrder
    notes?: SortOrder
  }

  export type AssetTicketHistorySumOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    ticketId?: SortOrder
  }

  export type AssetWarrantyAlertCountOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    alertType?: SortOrder
    alertDate?: SortOrder
    expiryDate?: SortOrder
    daysRemaining?: SortOrder
    notificationSent?: SortOrder
    notificationSentAt?: SortOrder
    dismissed?: SortOrder
    dismissedBy?: SortOrder
    dismissedAt?: SortOrder
  }

  export type AssetWarrantyAlertAvgOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    daysRemaining?: SortOrder
  }

  export type AssetWarrantyAlertMaxOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    alertType?: SortOrder
    alertDate?: SortOrder
    expiryDate?: SortOrder
    daysRemaining?: SortOrder
    notificationSent?: SortOrder
    notificationSentAt?: SortOrder
    dismissed?: SortOrder
    dismissedBy?: SortOrder
    dismissedAt?: SortOrder
  }

  export type AssetWarrantyAlertMinOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    alertType?: SortOrder
    alertDate?: SortOrder
    expiryDate?: SortOrder
    daysRemaining?: SortOrder
    notificationSent?: SortOrder
    notificationSentAt?: SortOrder
    dismissed?: SortOrder
    dismissedBy?: SortOrder
    dismissedAt?: SortOrder
  }

  export type AssetWarrantyAlertSumOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    daysRemaining?: SortOrder
  }

  export type InventoryAssetListRelationFilter = {
    every?: InventoryAssetWhereInput
    some?: InventoryAssetWhereInput
    none?: InventoryAssetWhereInput
  }

  export type InventoryAssetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssetImportBatchCountOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    importedBy?: SortOrder
    importDate?: SortOrder
    totalRecords?: SortOrder
    successfulRecords?: SortOrder
    failedRecords?: SortOrder
    validationStatus?: SortOrder
    validationErrors?: SortOrder
    rollbackDate?: SortOrder
    rollbackBy?: SortOrder
  }

  export type AssetImportBatchAvgOrderByAggregateInput = {
    totalRecords?: SortOrder
    successfulRecords?: SortOrder
    failedRecords?: SortOrder
  }

  export type AssetImportBatchMaxOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    importedBy?: SortOrder
    importDate?: SortOrder
    totalRecords?: SortOrder
    successfulRecords?: SortOrder
    failedRecords?: SortOrder
    validationStatus?: SortOrder
    validationErrors?: SortOrder
    rollbackDate?: SortOrder
    rollbackBy?: SortOrder
  }

  export type AssetImportBatchMinOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    importedBy?: SortOrder
    importDate?: SortOrder
    totalRecords?: SortOrder
    successfulRecords?: SortOrder
    failedRecords?: SortOrder
    validationStatus?: SortOrder
    validationErrors?: SortOrder
    rollbackDate?: SortOrder
    rollbackBy?: SortOrder
  }

  export type AssetImportBatchSumOrderByAggregateInput = {
    totalRecords?: SortOrder
    successfulRecords?: SortOrder
    failedRecords?: SortOrder
  }

  export type AssetImportBatchScalarRelationFilter = {
    is?: AssetImportBatchWhereInput
    isNot?: AssetImportBatchWhereInput
  }

  export type InventoryAssetNullableScalarRelationFilter = {
    is?: InventoryAssetWhereInput | null
    isNot?: InventoryAssetWhereInput | null
  }

  export type AssetValidationLogCountOrderByAggregateInput = {
    id?: SortOrder
    batchId?: SortOrder
    assetId?: SortOrder
    rowNumber?: SortOrder
    validationLevel?: SortOrder
    fieldName?: SortOrder
    message?: SortOrder
    rawData?: SortOrder
    createdAt?: SortOrder
  }

  export type AssetValidationLogAvgOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    rowNumber?: SortOrder
  }

  export type AssetValidationLogMaxOrderByAggregateInput = {
    id?: SortOrder
    batchId?: SortOrder
    assetId?: SortOrder
    rowNumber?: SortOrder
    validationLevel?: SortOrder
    fieldName?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type AssetValidationLogMinOrderByAggregateInput = {
    id?: SortOrder
    batchId?: SortOrder
    assetId?: SortOrder
    rowNumber?: SortOrder
    validationLevel?: SortOrder
    fieldName?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type AssetValidationLogSumOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    rowNumber?: SortOrder
  }

  export type KioskScalarRelationFilter = {
    is?: KioskWhereInput
    isNot?: KioskWhereInput
  }

  export type KioskAssetRegistryKioskIdAssetIdCompoundUniqueInput = {
    kioskId: string
    assetId: number
  }

  export type KioskAssetRegistryCountOrderByAggregateInput = {
    id?: SortOrder
    kioskId?: SortOrder
    assetId?: SortOrder
    registrationDate?: SortOrder
    lastCheckIn?: SortOrder
    status?: SortOrder
    helixSyncStatus?: SortOrder
    helixLastSync?: SortOrder
    helixErrorMessage?: SortOrder
    encryptedMetadata?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type KioskAssetRegistryAvgOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
  }

  export type KioskAssetRegistryMaxOrderByAggregateInput = {
    id?: SortOrder
    kioskId?: SortOrder
    assetId?: SortOrder
    registrationDate?: SortOrder
    lastCheckIn?: SortOrder
    status?: SortOrder
    helixSyncStatus?: SortOrder
    helixLastSync?: SortOrder
    helixErrorMessage?: SortOrder
    encryptedMetadata?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type KioskAssetRegistryMinOrderByAggregateInput = {
    id?: SortOrder
    kioskId?: SortOrder
    assetId?: SortOrder
    registrationDate?: SortOrder
    lastCheckIn?: SortOrder
    status?: SortOrder
    helixSyncStatus?: SortOrder
    helixLastSync?: SortOrder
    helixErrorMessage?: SortOrder
    encryptedMetadata?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type KioskAssetRegistrySumOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
  }

  export type HelixSyncFailureKioskIdAssetIdCompoundUniqueInput = {
    kioskId: string
    assetId: number
  }

  export type HelixSyncFailureCountOrderByAggregateInput = {
    id?: SortOrder
    kioskId?: SortOrder
    assetId?: SortOrder
    errorMessage?: SortOrder
    metadata?: SortOrder
    retryCount?: SortOrder
    nextRetryAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HelixSyncFailureAvgOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    retryCount?: SortOrder
  }

  export type HelixSyncFailureMaxOrderByAggregateInput = {
    id?: SortOrder
    kioskId?: SortOrder
    assetId?: SortOrder
    errorMessage?: SortOrder
    retryCount?: SortOrder
    nextRetryAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HelixSyncFailureMinOrderByAggregateInput = {
    id?: SortOrder
    kioskId?: SortOrder
    assetId?: SortOrder
    errorMessage?: SortOrder
    retryCount?: SortOrder
    nextRetryAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HelixSyncFailureSumOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    retryCount?: SortOrder
  }

  export type KioskOrganizationAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    kioskId?: SortOrder
    organizationId?: SortOrder
    department?: SortOrder
    floor?: SortOrder
    room?: SortOrder
    building?: SortOrder
    assignedBy?: SortOrder
    assignmentMetadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KioskOrganizationAssignmentAvgOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
  }

  export type KioskOrganizationAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    kioskId?: SortOrder
    organizationId?: SortOrder
    department?: SortOrder
    floor?: SortOrder
    room?: SortOrder
    building?: SortOrder
    assignedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KioskOrganizationAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    kioskId?: SortOrder
    organizationId?: SortOrder
    department?: SortOrder
    floor?: SortOrder
    room?: SortOrder
    building?: SortOrder
    assignedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KioskOrganizationAssignmentSumOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
  }

  export type KioskMetadataLogCountOrderByAggregateInput = {
    id?: SortOrder
    kioskId?: SortOrder
    metadataType?: SortOrder
    encryptedMetadata?: SortOrder
    collectionTimestamp?: SortOrder
  }

  export type KioskMetadataLogAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type KioskMetadataLogMaxOrderByAggregateInput = {
    id?: SortOrder
    kioskId?: SortOrder
    metadataType?: SortOrder
    encryptedMetadata?: SortOrder
    collectionTimestamp?: SortOrder
  }

  export type KioskMetadataLogMinOrderByAggregateInput = {
    id?: SortOrder
    kioskId?: SortOrder
    metadataType?: SortOrder
    encryptedMetadata?: SortOrder
    collectionTimestamp?: SortOrder
  }

  export type KioskMetadataLogSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type XpEventCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type XpEventAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
  }

  export type XpEventMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type XpEventMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type XpEventSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
  }

  export type LeaderboardCountOrderByAggregateInput = {
    userId?: SortOrder
    xpTotal?: SortOrder
  }

  export type LeaderboardAvgOrderByAggregateInput = {
    xpTotal?: SortOrder
  }

  export type LeaderboardMaxOrderByAggregateInput = {
    userId?: SortOrder
    xpTotal?: SortOrder
  }

  export type LeaderboardMinOrderByAggregateInput = {
    userId?: SortOrder
    xpTotal?: SortOrder
  }

  export type LeaderboardSumOrderByAggregateInput = {
    xpTotal?: SortOrder
  }

  export type ScimMappingCountOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    syncTime?: SortOrder
  }

  export type ScimMappingMaxOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    syncTime?: SortOrder
  }

  export type ScimMappingMinOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    syncTime?: SortOrder
  }

  export type ScimLogCountOrderByAggregateInput = {
    id?: SortOrder
    operation?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    statusCode?: SortOrder
    message?: SortOrder
    requestBody?: SortOrder
    responseBody?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
  }

  export type ScimLogAvgOrderByAggregateInput = {
    statusCode?: SortOrder
    duration?: SortOrder
  }

  export type ScimLogMaxOrderByAggregateInput = {
    id?: SortOrder
    operation?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    statusCode?: SortOrder
    message?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
  }

  export type ScimLogMinOrderByAggregateInput = {
    id?: SortOrder
    operation?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    statusCode?: SortOrder
    message?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
  }

  export type ScimLogSumOrderByAggregateInput = {
    statusCode?: SortOrder
    duration?: SortOrder
  }

  export type SupportTicketNullableScalarRelationFilter = {
    is?: SupportTicketWhereInput | null
    isNot?: SupportTicketWhereInput | null
  }

  export type MailroomPackageCountOrderByAggregateInput = {
    id?: SortOrder
    trackingNumber?: SortOrder
    carrier?: SortOrder
    sender?: SortOrder
    recipientId?: SortOrder
    department?: SortOrder
    packageType?: SortOrder
    status?: SortOrder
    assignedLocation?: SortOrder
    linkedTicketId?: SortOrder
    linkedAssetId?: SortOrder
    flags?: SortOrder
    intakePhotoUrl?: SortOrder
    deliveryPhotoUrl?: SortOrder
    signatureUrl?: SortOrder
    intakeLocation?: SortOrder
    deliveryLocation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MailroomPackageAvgOrderByAggregateInput = {
    id?: SortOrder
    linkedTicketId?: SortOrder
    linkedAssetId?: SortOrder
  }

  export type MailroomPackageMaxOrderByAggregateInput = {
    id?: SortOrder
    trackingNumber?: SortOrder
    carrier?: SortOrder
    sender?: SortOrder
    recipientId?: SortOrder
    department?: SortOrder
    packageType?: SortOrder
    status?: SortOrder
    assignedLocation?: SortOrder
    linkedTicketId?: SortOrder
    linkedAssetId?: SortOrder
    intakePhotoUrl?: SortOrder
    deliveryPhotoUrl?: SortOrder
    signatureUrl?: SortOrder
    intakeLocation?: SortOrder
    deliveryLocation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MailroomPackageMinOrderByAggregateInput = {
    id?: SortOrder
    trackingNumber?: SortOrder
    carrier?: SortOrder
    sender?: SortOrder
    recipientId?: SortOrder
    department?: SortOrder
    packageType?: SortOrder
    status?: SortOrder
    assignedLocation?: SortOrder
    linkedTicketId?: SortOrder
    linkedAssetId?: SortOrder
    intakePhotoUrl?: SortOrder
    deliveryPhotoUrl?: SortOrder
    signatureUrl?: SortOrder
    intakeLocation?: SortOrder
    deliveryLocation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MailroomPackageSumOrderByAggregateInput = {
    id?: SortOrder
    linkedTicketId?: SortOrder
    linkedAssetId?: SortOrder
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type MailroomPackageScalarRelationFilter = {
    is?: MailroomPackageWhereInput
    isNot?: MailroomPackageWhereInput
  }

  export type DeliveryEventCountOrderByAggregateInput = {
    id?: SortOrder
    packageId?: SortOrder
    eventType?: SortOrder
    performedBy?: SortOrder
    location?: SortOrder
    timestamp?: SortOrder
    photoUrl?: SortOrder
    signatureBlob?: SortOrder
  }

  export type DeliveryEventAvgOrderByAggregateInput = {
    id?: SortOrder
    packageId?: SortOrder
  }

  export type DeliveryEventMaxOrderByAggregateInput = {
    id?: SortOrder
    packageId?: SortOrder
    eventType?: SortOrder
    performedBy?: SortOrder
    location?: SortOrder
    timestamp?: SortOrder
    photoUrl?: SortOrder
    signatureBlob?: SortOrder
  }

  export type DeliveryEventMinOrderByAggregateInput = {
    id?: SortOrder
    packageId?: SortOrder
    eventType?: SortOrder
    performedBy?: SortOrder
    location?: SortOrder
    timestamp?: SortOrder
    photoUrl?: SortOrder
    signatureBlob?: SortOrder
  }

  export type DeliveryEventSumOrderByAggregateInput = {
    id?: SortOrder
    packageId?: SortOrder
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type ProxyAuthorizationCountOrderByAggregateInput = {
    id?: SortOrder
    recipientId?: SortOrder
    proxyId?: SortOrder
    packageId?: SortOrder
    expiration?: SortOrder
    status?: SortOrder
  }

  export type ProxyAuthorizationAvgOrderByAggregateInput = {
    id?: SortOrder
    packageId?: SortOrder
  }

  export type ProxyAuthorizationMaxOrderByAggregateInput = {
    id?: SortOrder
    recipientId?: SortOrder
    proxyId?: SortOrder
    packageId?: SortOrder
    expiration?: SortOrder
    status?: SortOrder
  }

  export type ProxyAuthorizationMinOrderByAggregateInput = {
    id?: SortOrder
    recipientId?: SortOrder
    proxyId?: SortOrder
    packageId?: SortOrder
    expiration?: SortOrder
    status?: SortOrder
  }

  export type ProxyAuthorizationSumOrderByAggregateInput = {
    id?: SortOrder
    packageId?: SortOrder
  }

  export type RequestCatalogItemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    formSchema?: SortOrder
    workflowId?: SortOrder
  }

  export type RequestCatalogItemAvgOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
  }

  export type RequestCatalogItemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    workflowId?: SortOrder
  }

  export type RequestCatalogItemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    workflowId?: SortOrder
  }

  export type RequestCatalogItemSumOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
  }

  export type RequestCatalogItemScalarRelationFilter = {
    is?: RequestCatalogItemWhereInput
    isNot?: RequestCatalogItemWhereInput
  }

  export type RITMCountOrderByAggregateInput = {
    id?: SortOrder
    reqId?: SortOrder
    catalogItemId?: SortOrder
    status?: SortOrder
  }

  export type RITMAvgOrderByAggregateInput = {
    id?: SortOrder
    reqId?: SortOrder
    catalogItemId?: SortOrder
  }

  export type RITMMaxOrderByAggregateInput = {
    id?: SortOrder
    reqId?: SortOrder
    catalogItemId?: SortOrder
    status?: SortOrder
  }

  export type RITMMinOrderByAggregateInput = {
    id?: SortOrder
    reqId?: SortOrder
    catalogItemId?: SortOrder
    status?: SortOrder
  }

  export type RITMSumOrderByAggregateInput = {
    id?: SortOrder
    reqId?: SortOrder
    catalogItemId?: SortOrder
  }

  export type VipProxyCountOrderByAggregateInput = {
    id?: SortOrder
    vipId?: SortOrder
    proxyId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type VipProxyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VipProxyMaxOrderByAggregateInput = {
    id?: SortOrder
    vipId?: SortOrder
    proxyId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type VipProxyMinOrderByAggregateInput = {
    id?: SortOrder
    vipId?: SortOrder
    proxyId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type VipProxySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VipSlaHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sla?: SortOrder
    effectiveAt?: SortOrder
    endedAt?: SortOrder
  }

  export type VipSlaHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VipSlaHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    effectiveAt?: SortOrder
    endedAt?: SortOrder
  }

  export type VipSlaHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    effectiveAt?: SortOrder
    endedAt?: SortOrder
  }

  export type VipSlaHistorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AgentAvailabilityUserIdQueueNameCompoundUniqueInput = {
    userId: string
    queueName: string
  }

  export type AgentAvailabilityCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    queueName?: SortOrder
    isAvailable?: SortOrder
    maxCapacity?: SortOrder
    currentLoad?: SortOrder
    status?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
  }

  export type AgentAvailabilityAvgOrderByAggregateInput = {
    maxCapacity?: SortOrder
    currentLoad?: SortOrder
  }

  export type AgentAvailabilityMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    queueName?: SortOrder
    isAvailable?: SortOrder
    maxCapacity?: SortOrder
    currentLoad?: SortOrder
    status?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
  }

  export type AgentAvailabilityMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    queueName?: SortOrder
    isAvailable?: SortOrder
    maxCapacity?: SortOrder
    currentLoad?: SortOrder
    status?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
  }

  export type AgentAvailabilitySumOrderByAggregateInput = {
    maxCapacity?: SortOrder
    currentLoad?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type QueueMetricsCountOrderByAggregateInput = {
    id?: SortOrder
    queueName?: SortOrder
    totalAgents?: SortOrder
    availableAgents?: SortOrder
    totalTickets?: SortOrder
    openTickets?: SortOrder
    avgResponseTime?: SortOrder
    avgResolutionTime?: SortOrder
    slaBreaches?: SortOrder
    highPriorityTickets?: SortOrder
    capacityUtilization?: SortOrder
    averageWaitTime?: SortOrder
    thresholdWarning?: SortOrder
    thresholdCritical?: SortOrder
    lastCalculated?: SortOrder
  }

  export type QueueMetricsAvgOrderByAggregateInput = {
    totalAgents?: SortOrder
    availableAgents?: SortOrder
    totalTickets?: SortOrder
    openTickets?: SortOrder
    avgResponseTime?: SortOrder
    avgResolutionTime?: SortOrder
    slaBreaches?: SortOrder
    highPriorityTickets?: SortOrder
    capacityUtilization?: SortOrder
    averageWaitTime?: SortOrder
  }

  export type QueueMetricsMaxOrderByAggregateInput = {
    id?: SortOrder
    queueName?: SortOrder
    totalAgents?: SortOrder
    availableAgents?: SortOrder
    totalTickets?: SortOrder
    openTickets?: SortOrder
    avgResponseTime?: SortOrder
    avgResolutionTime?: SortOrder
    slaBreaches?: SortOrder
    highPriorityTickets?: SortOrder
    capacityUtilization?: SortOrder
    averageWaitTime?: SortOrder
    thresholdWarning?: SortOrder
    thresholdCritical?: SortOrder
    lastCalculated?: SortOrder
  }

  export type QueueMetricsMinOrderByAggregateInput = {
    id?: SortOrder
    queueName?: SortOrder
    totalAgents?: SortOrder
    availableAgents?: SortOrder
    totalTickets?: SortOrder
    openTickets?: SortOrder
    avgResponseTime?: SortOrder
    avgResolutionTime?: SortOrder
    slaBreaches?: SortOrder
    highPriorityTickets?: SortOrder
    capacityUtilization?: SortOrder
    averageWaitTime?: SortOrder
    thresholdWarning?: SortOrder
    thresholdCritical?: SortOrder
    lastCalculated?: SortOrder
  }

  export type QueueMetricsSumOrderByAggregateInput = {
    totalAgents?: SortOrder
    availableAgents?: SortOrder
    totalTickets?: SortOrder
    openTickets?: SortOrder
    avgResponseTime?: SortOrder
    avgResolutionTime?: SortOrder
    slaBreaches?: SortOrder
    highPriorityTickets?: SortOrder
    capacityUtilization?: SortOrder
    averageWaitTime?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type QueueAlertCountOrderByAggregateInput = {
    id?: SortOrder
    queueName?: SortOrder
    alertType?: SortOrder
    message?: SortOrder
    isActive?: SortOrder
    alertedAt?: SortOrder
    resolvedAt?: SortOrder
    notifiedUsers?: SortOrder
  }

  export type QueueAlertMaxOrderByAggregateInput = {
    id?: SortOrder
    queueName?: SortOrder
    alertType?: SortOrder
    message?: SortOrder
    isActive?: SortOrder
    alertedAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type QueueAlertMinOrderByAggregateInput = {
    id?: SortOrder
    queueName?: SortOrder
    alertType?: SortOrder
    message?: SortOrder
    isActive?: SortOrder
    alertedAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type FeedbackCreateNestedManyWithoutUserInput = {
    create?: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput> | FeedbackCreateWithoutUserInput[] | FeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutUserInput | FeedbackCreateOrConnectWithoutUserInput[]
    createMany?: FeedbackCreateManyUserInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type LogCreateNestedManyWithoutUserInput = {
    create?: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput> | LogCreateWithoutUserInput[] | LogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUserInput | LogCreateOrConnectWithoutUserInput[]
    createMany?: LogCreateManyUserInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type PasskeyCreateNestedManyWithoutUserInput = {
    create?: XOR<PasskeyCreateWithoutUserInput, PasskeyUncheckedCreateWithoutUserInput> | PasskeyCreateWithoutUserInput[] | PasskeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasskeyCreateOrConnectWithoutUserInput | PasskeyCreateOrConnectWithoutUserInput[]
    createMany?: PasskeyCreateManyUserInputEnvelope
    connect?: PasskeyWhereUniqueInput | PasskeyWhereUniqueInput[]
  }

  export type SupportTicketCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput = {
    create?: XOR<SupportTicketCreateWithoutUsers_support_tickets_assigneeIdTousersInput, SupportTicketUncheckedCreateWithoutUsers_support_tickets_assigneeIdTousersInput> | SupportTicketCreateWithoutUsers_support_tickets_assigneeIdTousersInput[] | SupportTicketUncheckedCreateWithoutUsers_support_tickets_assigneeIdTousersInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUsers_support_tickets_assigneeIdTousersInput | SupportTicketCreateOrConnectWithoutUsers_support_tickets_assigneeIdTousersInput[]
    createMany?: SupportTicketCreateManyUsers_support_tickets_assigneeIdTousersInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type SupportTicketCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput = {
    create?: XOR<SupportTicketCreateWithoutUsers_support_tickets_userIdTousersInput, SupportTicketUncheckedCreateWithoutUsers_support_tickets_userIdTousersInput> | SupportTicketCreateWithoutUsers_support_tickets_userIdTousersInput[] | SupportTicketUncheckedCreateWithoutUsers_support_tickets_userIdTousersInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUsers_support_tickets_userIdTousersInput | SupportTicketCreateOrConnectWithoutUsers_support_tickets_userIdTousersInput[]
    createMany?: SupportTicketCreateManyUsers_support_tickets_userIdTousersInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type UserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type ScimMappingCreateNestedManyWithoutUserInput = {
    create?: XOR<ScimMappingCreateWithoutUserInput, ScimMappingUncheckedCreateWithoutUserInput> | ScimMappingCreateWithoutUserInput[] | ScimMappingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScimMappingCreateOrConnectWithoutUserInput | ScimMappingCreateOrConnectWithoutUserInput[]
    createMany?: ScimMappingCreateManyUserInputEnvelope
    connect?: ScimMappingWhereUniqueInput | ScimMappingWhereUniqueInput[]
  }

  export type KbArticleCreateNestedManyWithoutAuthorInput = {
    create?: XOR<KbArticleCreateWithoutAuthorInput, KbArticleUncheckedCreateWithoutAuthorInput> | KbArticleCreateWithoutAuthorInput[] | KbArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: KbArticleCreateOrConnectWithoutAuthorInput | KbArticleCreateOrConnectWithoutAuthorInput[]
    createMany?: KbArticleCreateManyAuthorInputEnvelope
    connect?: KbArticleWhereUniqueInput | KbArticleWhereUniqueInput[]
  }

  export type KbArticleVersionCreateNestedManyWithoutAuthorInput = {
    create?: XOR<KbArticleVersionCreateWithoutAuthorInput, KbArticleVersionUncheckedCreateWithoutAuthorInput> | KbArticleVersionCreateWithoutAuthorInput[] | KbArticleVersionUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: KbArticleVersionCreateOrConnectWithoutAuthorInput | KbArticleVersionCreateOrConnectWithoutAuthorInput[]
    createMany?: KbArticleVersionCreateManyAuthorInputEnvelope
    connect?: KbArticleVersionWhereUniqueInput | KbArticleVersionWhereUniqueInput[]
  }

  export type KbArticleCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<KbArticleCommentCreateWithoutUserInput, KbArticleCommentUncheckedCreateWithoutUserInput> | KbArticleCommentCreateWithoutUserInput[] | KbArticleCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: KbArticleCommentCreateOrConnectWithoutUserInput | KbArticleCommentCreateOrConnectWithoutUserInput[]
    createMany?: KbArticleCommentCreateManyUserInputEnvelope
    connect?: KbArticleCommentWhereUniqueInput | KbArticleCommentWhereUniqueInput[]
  }

  export type XpEventCreateNestedManyWithoutUserInput = {
    create?: XOR<XpEventCreateWithoutUserInput, XpEventUncheckedCreateWithoutUserInput> | XpEventCreateWithoutUserInput[] | XpEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: XpEventCreateOrConnectWithoutUserInput | XpEventCreateOrConnectWithoutUserInput[]
    createMany?: XpEventCreateManyUserInputEnvelope
    connect?: XpEventWhereUniqueInput | XpEventWhereUniqueInput[]
  }

  export type LeaderboardCreateNestedOneWithoutUserInput = {
    create?: XOR<LeaderboardCreateWithoutUserInput, LeaderboardUncheckedCreateWithoutUserInput>
    connectOrCreate?: LeaderboardCreateOrConnectWithoutUserInput
    connect?: LeaderboardWhereUniqueInput
  }

  export type MailroomPackageCreateNestedManyWithoutRecipientInput = {
    create?: XOR<MailroomPackageCreateWithoutRecipientInput, MailroomPackageUncheckedCreateWithoutRecipientInput> | MailroomPackageCreateWithoutRecipientInput[] | MailroomPackageUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: MailroomPackageCreateOrConnectWithoutRecipientInput | MailroomPackageCreateOrConnectWithoutRecipientInput[]
    createMany?: MailroomPackageCreateManyRecipientInputEnvelope
    connect?: MailroomPackageWhereUniqueInput | MailroomPackageWhereUniqueInput[]
  }

  export type DeliveryEventCreateNestedManyWithoutUserInput = {
    create?: XOR<DeliveryEventCreateWithoutUserInput, DeliveryEventUncheckedCreateWithoutUserInput> | DeliveryEventCreateWithoutUserInput[] | DeliveryEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeliveryEventCreateOrConnectWithoutUserInput | DeliveryEventCreateOrConnectWithoutUserInput[]
    createMany?: DeliveryEventCreateManyUserInputEnvelope
    connect?: DeliveryEventWhereUniqueInput | DeliveryEventWhereUniqueInput[]
  }

  export type ProxyAuthorizationCreateNestedManyWithoutRecipientInput = {
    create?: XOR<ProxyAuthorizationCreateWithoutRecipientInput, ProxyAuthorizationUncheckedCreateWithoutRecipientInput> | ProxyAuthorizationCreateWithoutRecipientInput[] | ProxyAuthorizationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: ProxyAuthorizationCreateOrConnectWithoutRecipientInput | ProxyAuthorizationCreateOrConnectWithoutRecipientInput[]
    createMany?: ProxyAuthorizationCreateManyRecipientInputEnvelope
    connect?: ProxyAuthorizationWhereUniqueInput | ProxyAuthorizationWhereUniqueInput[]
  }

  export type ProxyAuthorizationCreateNestedManyWithoutProxyInput = {
    create?: XOR<ProxyAuthorizationCreateWithoutProxyInput, ProxyAuthorizationUncheckedCreateWithoutProxyInput> | ProxyAuthorizationCreateWithoutProxyInput[] | ProxyAuthorizationUncheckedCreateWithoutProxyInput[]
    connectOrCreate?: ProxyAuthorizationCreateOrConnectWithoutProxyInput | ProxyAuthorizationCreateOrConnectWithoutProxyInput[]
    createMany?: ProxyAuthorizationCreateManyProxyInputEnvelope
    connect?: ProxyAuthorizationWhereUniqueInput | ProxyAuthorizationWhereUniqueInput[]
  }

  export type VipProxyCreateNestedManyWithoutVipInput = {
    create?: XOR<VipProxyCreateWithoutVipInput, VipProxyUncheckedCreateWithoutVipInput> | VipProxyCreateWithoutVipInput[] | VipProxyUncheckedCreateWithoutVipInput[]
    connectOrCreate?: VipProxyCreateOrConnectWithoutVipInput | VipProxyCreateOrConnectWithoutVipInput[]
    createMany?: VipProxyCreateManyVipInputEnvelope
    connect?: VipProxyWhereUniqueInput | VipProxyWhereUniqueInput[]
  }

  export type VipProxyCreateNestedManyWithoutProxyInput = {
    create?: XOR<VipProxyCreateWithoutProxyInput, VipProxyUncheckedCreateWithoutProxyInput> | VipProxyCreateWithoutProxyInput[] | VipProxyUncheckedCreateWithoutProxyInput[]
    connectOrCreate?: VipProxyCreateOrConnectWithoutProxyInput | VipProxyCreateOrConnectWithoutProxyInput[]
    createMany?: VipProxyCreateManyProxyInputEnvelope
    connect?: VipProxyWhereUniqueInput | VipProxyWhereUniqueInput[]
  }

  export type VipSlaHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<VipSlaHistoryCreateWithoutUserInput, VipSlaHistoryUncheckedCreateWithoutUserInput> | VipSlaHistoryCreateWithoutUserInput[] | VipSlaHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VipSlaHistoryCreateOrConnectWithoutUserInput | VipSlaHistoryCreateOrConnectWithoutUserInput[]
    createMany?: VipSlaHistoryCreateManyUserInputEnvelope
    connect?: VipSlaHistoryWhereUniqueInput | VipSlaHistoryWhereUniqueInput[]
  }

  export type AgentAvailabilityCreateNestedManyWithoutUserInput = {
    create?: XOR<AgentAvailabilityCreateWithoutUserInput, AgentAvailabilityUncheckedCreateWithoutUserInput> | AgentAvailabilityCreateWithoutUserInput[] | AgentAvailabilityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AgentAvailabilityCreateOrConnectWithoutUserInput | AgentAvailabilityCreateOrConnectWithoutUserInput[]
    createMany?: AgentAvailabilityCreateManyUserInputEnvelope
    connect?: AgentAvailabilityWhereUniqueInput | AgentAvailabilityWhereUniqueInput[]
  }

  export type FeedbackUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput> | FeedbackCreateWithoutUserInput[] | FeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutUserInput | FeedbackCreateOrConnectWithoutUserInput[]
    createMany?: FeedbackCreateManyUserInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type LogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput> | LogCreateWithoutUserInput[] | LogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUserInput | LogCreateOrConnectWithoutUserInput[]
    createMany?: LogCreateManyUserInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type PasskeyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasskeyCreateWithoutUserInput, PasskeyUncheckedCreateWithoutUserInput> | PasskeyCreateWithoutUserInput[] | PasskeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasskeyCreateOrConnectWithoutUserInput | PasskeyCreateOrConnectWithoutUserInput[]
    createMany?: PasskeyCreateManyUserInputEnvelope
    connect?: PasskeyWhereUniqueInput | PasskeyWhereUniqueInput[]
  }

  export type SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput = {
    create?: XOR<SupportTicketCreateWithoutUsers_support_tickets_assigneeIdTousersInput, SupportTicketUncheckedCreateWithoutUsers_support_tickets_assigneeIdTousersInput> | SupportTicketCreateWithoutUsers_support_tickets_assigneeIdTousersInput[] | SupportTicketUncheckedCreateWithoutUsers_support_tickets_assigneeIdTousersInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUsers_support_tickets_assigneeIdTousersInput | SupportTicketCreateOrConnectWithoutUsers_support_tickets_assigneeIdTousersInput[]
    createMany?: SupportTicketCreateManyUsers_support_tickets_assigneeIdTousersInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput = {
    create?: XOR<SupportTicketCreateWithoutUsers_support_tickets_userIdTousersInput, SupportTicketUncheckedCreateWithoutUsers_support_tickets_userIdTousersInput> | SupportTicketCreateWithoutUsers_support_tickets_userIdTousersInput[] | SupportTicketUncheckedCreateWithoutUsers_support_tickets_userIdTousersInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUsers_support_tickets_userIdTousersInput | SupportTicketCreateOrConnectWithoutUsers_support_tickets_userIdTousersInput[]
    createMany?: SupportTicketCreateManyUsers_support_tickets_userIdTousersInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type ScimMappingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ScimMappingCreateWithoutUserInput, ScimMappingUncheckedCreateWithoutUserInput> | ScimMappingCreateWithoutUserInput[] | ScimMappingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScimMappingCreateOrConnectWithoutUserInput | ScimMappingCreateOrConnectWithoutUserInput[]
    createMany?: ScimMappingCreateManyUserInputEnvelope
    connect?: ScimMappingWhereUniqueInput | ScimMappingWhereUniqueInput[]
  }

  export type KbArticleUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<KbArticleCreateWithoutAuthorInput, KbArticleUncheckedCreateWithoutAuthorInput> | KbArticleCreateWithoutAuthorInput[] | KbArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: KbArticleCreateOrConnectWithoutAuthorInput | KbArticleCreateOrConnectWithoutAuthorInput[]
    createMany?: KbArticleCreateManyAuthorInputEnvelope
    connect?: KbArticleWhereUniqueInput | KbArticleWhereUniqueInput[]
  }

  export type KbArticleVersionUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<KbArticleVersionCreateWithoutAuthorInput, KbArticleVersionUncheckedCreateWithoutAuthorInput> | KbArticleVersionCreateWithoutAuthorInput[] | KbArticleVersionUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: KbArticleVersionCreateOrConnectWithoutAuthorInput | KbArticleVersionCreateOrConnectWithoutAuthorInput[]
    createMany?: KbArticleVersionCreateManyAuthorInputEnvelope
    connect?: KbArticleVersionWhereUniqueInput | KbArticleVersionWhereUniqueInput[]
  }

  export type KbArticleCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<KbArticleCommentCreateWithoutUserInput, KbArticleCommentUncheckedCreateWithoutUserInput> | KbArticleCommentCreateWithoutUserInput[] | KbArticleCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: KbArticleCommentCreateOrConnectWithoutUserInput | KbArticleCommentCreateOrConnectWithoutUserInput[]
    createMany?: KbArticleCommentCreateManyUserInputEnvelope
    connect?: KbArticleCommentWhereUniqueInput | KbArticleCommentWhereUniqueInput[]
  }

  export type XpEventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<XpEventCreateWithoutUserInput, XpEventUncheckedCreateWithoutUserInput> | XpEventCreateWithoutUserInput[] | XpEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: XpEventCreateOrConnectWithoutUserInput | XpEventCreateOrConnectWithoutUserInput[]
    createMany?: XpEventCreateManyUserInputEnvelope
    connect?: XpEventWhereUniqueInput | XpEventWhereUniqueInput[]
  }

  export type LeaderboardUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<LeaderboardCreateWithoutUserInput, LeaderboardUncheckedCreateWithoutUserInput>
    connectOrCreate?: LeaderboardCreateOrConnectWithoutUserInput
    connect?: LeaderboardWhereUniqueInput
  }

  export type MailroomPackageUncheckedCreateNestedManyWithoutRecipientInput = {
    create?: XOR<MailroomPackageCreateWithoutRecipientInput, MailroomPackageUncheckedCreateWithoutRecipientInput> | MailroomPackageCreateWithoutRecipientInput[] | MailroomPackageUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: MailroomPackageCreateOrConnectWithoutRecipientInput | MailroomPackageCreateOrConnectWithoutRecipientInput[]
    createMany?: MailroomPackageCreateManyRecipientInputEnvelope
    connect?: MailroomPackageWhereUniqueInput | MailroomPackageWhereUniqueInput[]
  }

  export type DeliveryEventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DeliveryEventCreateWithoutUserInput, DeliveryEventUncheckedCreateWithoutUserInput> | DeliveryEventCreateWithoutUserInput[] | DeliveryEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeliveryEventCreateOrConnectWithoutUserInput | DeliveryEventCreateOrConnectWithoutUserInput[]
    createMany?: DeliveryEventCreateManyUserInputEnvelope
    connect?: DeliveryEventWhereUniqueInput | DeliveryEventWhereUniqueInput[]
  }

  export type ProxyAuthorizationUncheckedCreateNestedManyWithoutRecipientInput = {
    create?: XOR<ProxyAuthorizationCreateWithoutRecipientInput, ProxyAuthorizationUncheckedCreateWithoutRecipientInput> | ProxyAuthorizationCreateWithoutRecipientInput[] | ProxyAuthorizationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: ProxyAuthorizationCreateOrConnectWithoutRecipientInput | ProxyAuthorizationCreateOrConnectWithoutRecipientInput[]
    createMany?: ProxyAuthorizationCreateManyRecipientInputEnvelope
    connect?: ProxyAuthorizationWhereUniqueInput | ProxyAuthorizationWhereUniqueInput[]
  }

  export type ProxyAuthorizationUncheckedCreateNestedManyWithoutProxyInput = {
    create?: XOR<ProxyAuthorizationCreateWithoutProxyInput, ProxyAuthorizationUncheckedCreateWithoutProxyInput> | ProxyAuthorizationCreateWithoutProxyInput[] | ProxyAuthorizationUncheckedCreateWithoutProxyInput[]
    connectOrCreate?: ProxyAuthorizationCreateOrConnectWithoutProxyInput | ProxyAuthorizationCreateOrConnectWithoutProxyInput[]
    createMany?: ProxyAuthorizationCreateManyProxyInputEnvelope
    connect?: ProxyAuthorizationWhereUniqueInput | ProxyAuthorizationWhereUniqueInput[]
  }

  export type VipProxyUncheckedCreateNestedManyWithoutVipInput = {
    create?: XOR<VipProxyCreateWithoutVipInput, VipProxyUncheckedCreateWithoutVipInput> | VipProxyCreateWithoutVipInput[] | VipProxyUncheckedCreateWithoutVipInput[]
    connectOrCreate?: VipProxyCreateOrConnectWithoutVipInput | VipProxyCreateOrConnectWithoutVipInput[]
    createMany?: VipProxyCreateManyVipInputEnvelope
    connect?: VipProxyWhereUniqueInput | VipProxyWhereUniqueInput[]
  }

  export type VipProxyUncheckedCreateNestedManyWithoutProxyInput = {
    create?: XOR<VipProxyCreateWithoutProxyInput, VipProxyUncheckedCreateWithoutProxyInput> | VipProxyCreateWithoutProxyInput[] | VipProxyUncheckedCreateWithoutProxyInput[]
    connectOrCreate?: VipProxyCreateOrConnectWithoutProxyInput | VipProxyCreateOrConnectWithoutProxyInput[]
    createMany?: VipProxyCreateManyProxyInputEnvelope
    connect?: VipProxyWhereUniqueInput | VipProxyWhereUniqueInput[]
  }

  export type VipSlaHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<VipSlaHistoryCreateWithoutUserInput, VipSlaHistoryUncheckedCreateWithoutUserInput> | VipSlaHistoryCreateWithoutUserInput[] | VipSlaHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VipSlaHistoryCreateOrConnectWithoutUserInput | VipSlaHistoryCreateOrConnectWithoutUserInput[]
    createMany?: VipSlaHistoryCreateManyUserInputEnvelope
    connect?: VipSlaHistoryWhereUniqueInput | VipSlaHistoryWhereUniqueInput[]
  }

  export type AgentAvailabilityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AgentAvailabilityCreateWithoutUserInput, AgentAvailabilityUncheckedCreateWithoutUserInput> | AgentAvailabilityCreateWithoutUserInput[] | AgentAvailabilityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AgentAvailabilityCreateOrConnectWithoutUserInput | AgentAvailabilityCreateOrConnectWithoutUserInput[]
    createMany?: AgentAvailabilityCreateManyUserInputEnvelope
    connect?: AgentAvailabilityWhereUniqueInput | AgentAvailabilityWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type FeedbackUpdateManyWithoutUserNestedInput = {
    create?: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput> | FeedbackCreateWithoutUserInput[] | FeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutUserInput | FeedbackCreateOrConnectWithoutUserInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutUserInput | FeedbackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FeedbackCreateManyUserInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutUserInput | FeedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutUserInput | FeedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type LogUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput> | LogCreateWithoutUserInput[] | LogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUserInput | LogCreateOrConnectWithoutUserInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutUserInput | LogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogCreateManyUserInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutUserInput | LogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogUpdateManyWithWhereWithoutUserInput | LogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type PasskeyUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasskeyCreateWithoutUserInput, PasskeyUncheckedCreateWithoutUserInput> | PasskeyCreateWithoutUserInput[] | PasskeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasskeyCreateOrConnectWithoutUserInput | PasskeyCreateOrConnectWithoutUserInput[]
    upsert?: PasskeyUpsertWithWhereUniqueWithoutUserInput | PasskeyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasskeyCreateManyUserInputEnvelope
    set?: PasskeyWhereUniqueInput | PasskeyWhereUniqueInput[]
    disconnect?: PasskeyWhereUniqueInput | PasskeyWhereUniqueInput[]
    delete?: PasskeyWhereUniqueInput | PasskeyWhereUniqueInput[]
    connect?: PasskeyWhereUniqueInput | PasskeyWhereUniqueInput[]
    update?: PasskeyUpdateWithWhereUniqueWithoutUserInput | PasskeyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasskeyUpdateManyWithWhereWithoutUserInput | PasskeyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasskeyScalarWhereInput | PasskeyScalarWhereInput[]
  }

  export type SupportTicketUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput = {
    create?: XOR<SupportTicketCreateWithoutUsers_support_tickets_assigneeIdTousersInput, SupportTicketUncheckedCreateWithoutUsers_support_tickets_assigneeIdTousersInput> | SupportTicketCreateWithoutUsers_support_tickets_assigneeIdTousersInput[] | SupportTicketUncheckedCreateWithoutUsers_support_tickets_assigneeIdTousersInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUsers_support_tickets_assigneeIdTousersInput | SupportTicketCreateOrConnectWithoutUsers_support_tickets_assigneeIdTousersInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutUsers_support_tickets_assigneeIdTousersInput | SupportTicketUpsertWithWhereUniqueWithoutUsers_support_tickets_assigneeIdTousersInput[]
    createMany?: SupportTicketCreateManyUsers_support_tickets_assigneeIdTousersInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutUsers_support_tickets_assigneeIdTousersInput | SupportTicketUpdateWithWhereUniqueWithoutUsers_support_tickets_assigneeIdTousersInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutUsers_support_tickets_assigneeIdTousersInput | SupportTicketUpdateManyWithWhereWithoutUsers_support_tickets_assigneeIdTousersInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type SupportTicketUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput = {
    create?: XOR<SupportTicketCreateWithoutUsers_support_tickets_userIdTousersInput, SupportTicketUncheckedCreateWithoutUsers_support_tickets_userIdTousersInput> | SupportTicketCreateWithoutUsers_support_tickets_userIdTousersInput[] | SupportTicketUncheckedCreateWithoutUsers_support_tickets_userIdTousersInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUsers_support_tickets_userIdTousersInput | SupportTicketCreateOrConnectWithoutUsers_support_tickets_userIdTousersInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutUsers_support_tickets_userIdTousersInput | SupportTicketUpsertWithWhereUniqueWithoutUsers_support_tickets_userIdTousersInput[]
    createMany?: SupportTicketCreateManyUsers_support_tickets_userIdTousersInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutUsers_support_tickets_userIdTousersInput | SupportTicketUpdateWithWhereUniqueWithoutUsers_support_tickets_userIdTousersInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutUsers_support_tickets_userIdTousersInput | SupportTicketUpdateManyWithWhereWithoutUsers_support_tickets_userIdTousersInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type UserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type ScimMappingUpdateManyWithoutUserNestedInput = {
    create?: XOR<ScimMappingCreateWithoutUserInput, ScimMappingUncheckedCreateWithoutUserInput> | ScimMappingCreateWithoutUserInput[] | ScimMappingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScimMappingCreateOrConnectWithoutUserInput | ScimMappingCreateOrConnectWithoutUserInput[]
    upsert?: ScimMappingUpsertWithWhereUniqueWithoutUserInput | ScimMappingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ScimMappingCreateManyUserInputEnvelope
    set?: ScimMappingWhereUniqueInput | ScimMappingWhereUniqueInput[]
    disconnect?: ScimMappingWhereUniqueInput | ScimMappingWhereUniqueInput[]
    delete?: ScimMappingWhereUniqueInput | ScimMappingWhereUniqueInput[]
    connect?: ScimMappingWhereUniqueInput | ScimMappingWhereUniqueInput[]
    update?: ScimMappingUpdateWithWhereUniqueWithoutUserInput | ScimMappingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ScimMappingUpdateManyWithWhereWithoutUserInput | ScimMappingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ScimMappingScalarWhereInput | ScimMappingScalarWhereInput[]
  }

  export type KbArticleUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<KbArticleCreateWithoutAuthorInput, KbArticleUncheckedCreateWithoutAuthorInput> | KbArticleCreateWithoutAuthorInput[] | KbArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: KbArticleCreateOrConnectWithoutAuthorInput | KbArticleCreateOrConnectWithoutAuthorInput[]
    upsert?: KbArticleUpsertWithWhereUniqueWithoutAuthorInput | KbArticleUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: KbArticleCreateManyAuthorInputEnvelope
    set?: KbArticleWhereUniqueInput | KbArticleWhereUniqueInput[]
    disconnect?: KbArticleWhereUniqueInput | KbArticleWhereUniqueInput[]
    delete?: KbArticleWhereUniqueInput | KbArticleWhereUniqueInput[]
    connect?: KbArticleWhereUniqueInput | KbArticleWhereUniqueInput[]
    update?: KbArticleUpdateWithWhereUniqueWithoutAuthorInput | KbArticleUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: KbArticleUpdateManyWithWhereWithoutAuthorInput | KbArticleUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: KbArticleScalarWhereInput | KbArticleScalarWhereInput[]
  }

  export type KbArticleVersionUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<KbArticleVersionCreateWithoutAuthorInput, KbArticleVersionUncheckedCreateWithoutAuthorInput> | KbArticleVersionCreateWithoutAuthorInput[] | KbArticleVersionUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: KbArticleVersionCreateOrConnectWithoutAuthorInput | KbArticleVersionCreateOrConnectWithoutAuthorInput[]
    upsert?: KbArticleVersionUpsertWithWhereUniqueWithoutAuthorInput | KbArticleVersionUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: KbArticleVersionCreateManyAuthorInputEnvelope
    set?: KbArticleVersionWhereUniqueInput | KbArticleVersionWhereUniqueInput[]
    disconnect?: KbArticleVersionWhereUniqueInput | KbArticleVersionWhereUniqueInput[]
    delete?: KbArticleVersionWhereUniqueInput | KbArticleVersionWhereUniqueInput[]
    connect?: KbArticleVersionWhereUniqueInput | KbArticleVersionWhereUniqueInput[]
    update?: KbArticleVersionUpdateWithWhereUniqueWithoutAuthorInput | KbArticleVersionUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: KbArticleVersionUpdateManyWithWhereWithoutAuthorInput | KbArticleVersionUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: KbArticleVersionScalarWhereInput | KbArticleVersionScalarWhereInput[]
  }

  export type KbArticleCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<KbArticleCommentCreateWithoutUserInput, KbArticleCommentUncheckedCreateWithoutUserInput> | KbArticleCommentCreateWithoutUserInput[] | KbArticleCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: KbArticleCommentCreateOrConnectWithoutUserInput | KbArticleCommentCreateOrConnectWithoutUserInput[]
    upsert?: KbArticleCommentUpsertWithWhereUniqueWithoutUserInput | KbArticleCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: KbArticleCommentCreateManyUserInputEnvelope
    set?: KbArticleCommentWhereUniqueInput | KbArticleCommentWhereUniqueInput[]
    disconnect?: KbArticleCommentWhereUniqueInput | KbArticleCommentWhereUniqueInput[]
    delete?: KbArticleCommentWhereUniqueInput | KbArticleCommentWhereUniqueInput[]
    connect?: KbArticleCommentWhereUniqueInput | KbArticleCommentWhereUniqueInput[]
    update?: KbArticleCommentUpdateWithWhereUniqueWithoutUserInput | KbArticleCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: KbArticleCommentUpdateManyWithWhereWithoutUserInput | KbArticleCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: KbArticleCommentScalarWhereInput | KbArticleCommentScalarWhereInput[]
  }

  export type XpEventUpdateManyWithoutUserNestedInput = {
    create?: XOR<XpEventCreateWithoutUserInput, XpEventUncheckedCreateWithoutUserInput> | XpEventCreateWithoutUserInput[] | XpEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: XpEventCreateOrConnectWithoutUserInput | XpEventCreateOrConnectWithoutUserInput[]
    upsert?: XpEventUpsertWithWhereUniqueWithoutUserInput | XpEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: XpEventCreateManyUserInputEnvelope
    set?: XpEventWhereUniqueInput | XpEventWhereUniqueInput[]
    disconnect?: XpEventWhereUniqueInput | XpEventWhereUniqueInput[]
    delete?: XpEventWhereUniqueInput | XpEventWhereUniqueInput[]
    connect?: XpEventWhereUniqueInput | XpEventWhereUniqueInput[]
    update?: XpEventUpdateWithWhereUniqueWithoutUserInput | XpEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: XpEventUpdateManyWithWhereWithoutUserInput | XpEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: XpEventScalarWhereInput | XpEventScalarWhereInput[]
  }

  export type LeaderboardUpdateOneWithoutUserNestedInput = {
    create?: XOR<LeaderboardCreateWithoutUserInput, LeaderboardUncheckedCreateWithoutUserInput>
    connectOrCreate?: LeaderboardCreateOrConnectWithoutUserInput
    upsert?: LeaderboardUpsertWithoutUserInput
    disconnect?: LeaderboardWhereInput | boolean
    delete?: LeaderboardWhereInput | boolean
    connect?: LeaderboardWhereUniqueInput
    update?: XOR<XOR<LeaderboardUpdateToOneWithWhereWithoutUserInput, LeaderboardUpdateWithoutUserInput>, LeaderboardUncheckedUpdateWithoutUserInput>
  }

  export type MailroomPackageUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<MailroomPackageCreateWithoutRecipientInput, MailroomPackageUncheckedCreateWithoutRecipientInput> | MailroomPackageCreateWithoutRecipientInput[] | MailroomPackageUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: MailroomPackageCreateOrConnectWithoutRecipientInput | MailroomPackageCreateOrConnectWithoutRecipientInput[]
    upsert?: MailroomPackageUpsertWithWhereUniqueWithoutRecipientInput | MailroomPackageUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: MailroomPackageCreateManyRecipientInputEnvelope
    set?: MailroomPackageWhereUniqueInput | MailroomPackageWhereUniqueInput[]
    disconnect?: MailroomPackageWhereUniqueInput | MailroomPackageWhereUniqueInput[]
    delete?: MailroomPackageWhereUniqueInput | MailroomPackageWhereUniqueInput[]
    connect?: MailroomPackageWhereUniqueInput | MailroomPackageWhereUniqueInput[]
    update?: MailroomPackageUpdateWithWhereUniqueWithoutRecipientInput | MailroomPackageUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: MailroomPackageUpdateManyWithWhereWithoutRecipientInput | MailroomPackageUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: MailroomPackageScalarWhereInput | MailroomPackageScalarWhereInput[]
  }

  export type DeliveryEventUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeliveryEventCreateWithoutUserInput, DeliveryEventUncheckedCreateWithoutUserInput> | DeliveryEventCreateWithoutUserInput[] | DeliveryEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeliveryEventCreateOrConnectWithoutUserInput | DeliveryEventCreateOrConnectWithoutUserInput[]
    upsert?: DeliveryEventUpsertWithWhereUniqueWithoutUserInput | DeliveryEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeliveryEventCreateManyUserInputEnvelope
    set?: DeliveryEventWhereUniqueInput | DeliveryEventWhereUniqueInput[]
    disconnect?: DeliveryEventWhereUniqueInput | DeliveryEventWhereUniqueInput[]
    delete?: DeliveryEventWhereUniqueInput | DeliveryEventWhereUniqueInput[]
    connect?: DeliveryEventWhereUniqueInput | DeliveryEventWhereUniqueInput[]
    update?: DeliveryEventUpdateWithWhereUniqueWithoutUserInput | DeliveryEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeliveryEventUpdateManyWithWhereWithoutUserInput | DeliveryEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeliveryEventScalarWhereInput | DeliveryEventScalarWhereInput[]
  }

  export type ProxyAuthorizationUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<ProxyAuthorizationCreateWithoutRecipientInput, ProxyAuthorizationUncheckedCreateWithoutRecipientInput> | ProxyAuthorizationCreateWithoutRecipientInput[] | ProxyAuthorizationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: ProxyAuthorizationCreateOrConnectWithoutRecipientInput | ProxyAuthorizationCreateOrConnectWithoutRecipientInput[]
    upsert?: ProxyAuthorizationUpsertWithWhereUniqueWithoutRecipientInput | ProxyAuthorizationUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: ProxyAuthorizationCreateManyRecipientInputEnvelope
    set?: ProxyAuthorizationWhereUniqueInput | ProxyAuthorizationWhereUniqueInput[]
    disconnect?: ProxyAuthorizationWhereUniqueInput | ProxyAuthorizationWhereUniqueInput[]
    delete?: ProxyAuthorizationWhereUniqueInput | ProxyAuthorizationWhereUniqueInput[]
    connect?: ProxyAuthorizationWhereUniqueInput | ProxyAuthorizationWhereUniqueInput[]
    update?: ProxyAuthorizationUpdateWithWhereUniqueWithoutRecipientInput | ProxyAuthorizationUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: ProxyAuthorizationUpdateManyWithWhereWithoutRecipientInput | ProxyAuthorizationUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: ProxyAuthorizationScalarWhereInput | ProxyAuthorizationScalarWhereInput[]
  }

  export type ProxyAuthorizationUpdateManyWithoutProxyNestedInput = {
    create?: XOR<ProxyAuthorizationCreateWithoutProxyInput, ProxyAuthorizationUncheckedCreateWithoutProxyInput> | ProxyAuthorizationCreateWithoutProxyInput[] | ProxyAuthorizationUncheckedCreateWithoutProxyInput[]
    connectOrCreate?: ProxyAuthorizationCreateOrConnectWithoutProxyInput | ProxyAuthorizationCreateOrConnectWithoutProxyInput[]
    upsert?: ProxyAuthorizationUpsertWithWhereUniqueWithoutProxyInput | ProxyAuthorizationUpsertWithWhereUniqueWithoutProxyInput[]
    createMany?: ProxyAuthorizationCreateManyProxyInputEnvelope
    set?: ProxyAuthorizationWhereUniqueInput | ProxyAuthorizationWhereUniqueInput[]
    disconnect?: ProxyAuthorizationWhereUniqueInput | ProxyAuthorizationWhereUniqueInput[]
    delete?: ProxyAuthorizationWhereUniqueInput | ProxyAuthorizationWhereUniqueInput[]
    connect?: ProxyAuthorizationWhereUniqueInput | ProxyAuthorizationWhereUniqueInput[]
    update?: ProxyAuthorizationUpdateWithWhereUniqueWithoutProxyInput | ProxyAuthorizationUpdateWithWhereUniqueWithoutProxyInput[]
    updateMany?: ProxyAuthorizationUpdateManyWithWhereWithoutProxyInput | ProxyAuthorizationUpdateManyWithWhereWithoutProxyInput[]
    deleteMany?: ProxyAuthorizationScalarWhereInput | ProxyAuthorizationScalarWhereInput[]
  }

  export type VipProxyUpdateManyWithoutVipNestedInput = {
    create?: XOR<VipProxyCreateWithoutVipInput, VipProxyUncheckedCreateWithoutVipInput> | VipProxyCreateWithoutVipInput[] | VipProxyUncheckedCreateWithoutVipInput[]
    connectOrCreate?: VipProxyCreateOrConnectWithoutVipInput | VipProxyCreateOrConnectWithoutVipInput[]
    upsert?: VipProxyUpsertWithWhereUniqueWithoutVipInput | VipProxyUpsertWithWhereUniqueWithoutVipInput[]
    createMany?: VipProxyCreateManyVipInputEnvelope
    set?: VipProxyWhereUniqueInput | VipProxyWhereUniqueInput[]
    disconnect?: VipProxyWhereUniqueInput | VipProxyWhereUniqueInput[]
    delete?: VipProxyWhereUniqueInput | VipProxyWhereUniqueInput[]
    connect?: VipProxyWhereUniqueInput | VipProxyWhereUniqueInput[]
    update?: VipProxyUpdateWithWhereUniqueWithoutVipInput | VipProxyUpdateWithWhereUniqueWithoutVipInput[]
    updateMany?: VipProxyUpdateManyWithWhereWithoutVipInput | VipProxyUpdateManyWithWhereWithoutVipInput[]
    deleteMany?: VipProxyScalarWhereInput | VipProxyScalarWhereInput[]
  }

  export type VipProxyUpdateManyWithoutProxyNestedInput = {
    create?: XOR<VipProxyCreateWithoutProxyInput, VipProxyUncheckedCreateWithoutProxyInput> | VipProxyCreateWithoutProxyInput[] | VipProxyUncheckedCreateWithoutProxyInput[]
    connectOrCreate?: VipProxyCreateOrConnectWithoutProxyInput | VipProxyCreateOrConnectWithoutProxyInput[]
    upsert?: VipProxyUpsertWithWhereUniqueWithoutProxyInput | VipProxyUpsertWithWhereUniqueWithoutProxyInput[]
    createMany?: VipProxyCreateManyProxyInputEnvelope
    set?: VipProxyWhereUniqueInput | VipProxyWhereUniqueInput[]
    disconnect?: VipProxyWhereUniqueInput | VipProxyWhereUniqueInput[]
    delete?: VipProxyWhereUniqueInput | VipProxyWhereUniqueInput[]
    connect?: VipProxyWhereUniqueInput | VipProxyWhereUniqueInput[]
    update?: VipProxyUpdateWithWhereUniqueWithoutProxyInput | VipProxyUpdateWithWhereUniqueWithoutProxyInput[]
    updateMany?: VipProxyUpdateManyWithWhereWithoutProxyInput | VipProxyUpdateManyWithWhereWithoutProxyInput[]
    deleteMany?: VipProxyScalarWhereInput | VipProxyScalarWhereInput[]
  }

  export type VipSlaHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<VipSlaHistoryCreateWithoutUserInput, VipSlaHistoryUncheckedCreateWithoutUserInput> | VipSlaHistoryCreateWithoutUserInput[] | VipSlaHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VipSlaHistoryCreateOrConnectWithoutUserInput | VipSlaHistoryCreateOrConnectWithoutUserInput[]
    upsert?: VipSlaHistoryUpsertWithWhereUniqueWithoutUserInput | VipSlaHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VipSlaHistoryCreateManyUserInputEnvelope
    set?: VipSlaHistoryWhereUniqueInput | VipSlaHistoryWhereUniqueInput[]
    disconnect?: VipSlaHistoryWhereUniqueInput | VipSlaHistoryWhereUniqueInput[]
    delete?: VipSlaHistoryWhereUniqueInput | VipSlaHistoryWhereUniqueInput[]
    connect?: VipSlaHistoryWhereUniqueInput | VipSlaHistoryWhereUniqueInput[]
    update?: VipSlaHistoryUpdateWithWhereUniqueWithoutUserInput | VipSlaHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VipSlaHistoryUpdateManyWithWhereWithoutUserInput | VipSlaHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VipSlaHistoryScalarWhereInput | VipSlaHistoryScalarWhereInput[]
  }

  export type AgentAvailabilityUpdateManyWithoutUserNestedInput = {
    create?: XOR<AgentAvailabilityCreateWithoutUserInput, AgentAvailabilityUncheckedCreateWithoutUserInput> | AgentAvailabilityCreateWithoutUserInput[] | AgentAvailabilityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AgentAvailabilityCreateOrConnectWithoutUserInput | AgentAvailabilityCreateOrConnectWithoutUserInput[]
    upsert?: AgentAvailabilityUpsertWithWhereUniqueWithoutUserInput | AgentAvailabilityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AgentAvailabilityCreateManyUserInputEnvelope
    set?: AgentAvailabilityWhereUniqueInput | AgentAvailabilityWhereUniqueInput[]
    disconnect?: AgentAvailabilityWhereUniqueInput | AgentAvailabilityWhereUniqueInput[]
    delete?: AgentAvailabilityWhereUniqueInput | AgentAvailabilityWhereUniqueInput[]
    connect?: AgentAvailabilityWhereUniqueInput | AgentAvailabilityWhereUniqueInput[]
    update?: AgentAvailabilityUpdateWithWhereUniqueWithoutUserInput | AgentAvailabilityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AgentAvailabilityUpdateManyWithWhereWithoutUserInput | AgentAvailabilityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AgentAvailabilityScalarWhereInput | AgentAvailabilityScalarWhereInput[]
  }

  export type FeedbackUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput> | FeedbackCreateWithoutUserInput[] | FeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutUserInput | FeedbackCreateOrConnectWithoutUserInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutUserInput | FeedbackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FeedbackCreateManyUserInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutUserInput | FeedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutUserInput | FeedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type LogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput> | LogCreateWithoutUserInput[] | LogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUserInput | LogCreateOrConnectWithoutUserInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutUserInput | LogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogCreateManyUserInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutUserInput | LogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogUpdateManyWithWhereWithoutUserInput | LogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type PasskeyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasskeyCreateWithoutUserInput, PasskeyUncheckedCreateWithoutUserInput> | PasskeyCreateWithoutUserInput[] | PasskeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasskeyCreateOrConnectWithoutUserInput | PasskeyCreateOrConnectWithoutUserInput[]
    upsert?: PasskeyUpsertWithWhereUniqueWithoutUserInput | PasskeyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasskeyCreateManyUserInputEnvelope
    set?: PasskeyWhereUniqueInput | PasskeyWhereUniqueInput[]
    disconnect?: PasskeyWhereUniqueInput | PasskeyWhereUniqueInput[]
    delete?: PasskeyWhereUniqueInput | PasskeyWhereUniqueInput[]
    connect?: PasskeyWhereUniqueInput | PasskeyWhereUniqueInput[]
    update?: PasskeyUpdateWithWhereUniqueWithoutUserInput | PasskeyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasskeyUpdateManyWithWhereWithoutUserInput | PasskeyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasskeyScalarWhereInput | PasskeyScalarWhereInput[]
  }

  export type SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput = {
    create?: XOR<SupportTicketCreateWithoutUsers_support_tickets_assigneeIdTousersInput, SupportTicketUncheckedCreateWithoutUsers_support_tickets_assigneeIdTousersInput> | SupportTicketCreateWithoutUsers_support_tickets_assigneeIdTousersInput[] | SupportTicketUncheckedCreateWithoutUsers_support_tickets_assigneeIdTousersInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUsers_support_tickets_assigneeIdTousersInput | SupportTicketCreateOrConnectWithoutUsers_support_tickets_assigneeIdTousersInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutUsers_support_tickets_assigneeIdTousersInput | SupportTicketUpsertWithWhereUniqueWithoutUsers_support_tickets_assigneeIdTousersInput[]
    createMany?: SupportTicketCreateManyUsers_support_tickets_assigneeIdTousersInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutUsers_support_tickets_assigneeIdTousersInput | SupportTicketUpdateWithWhereUniqueWithoutUsers_support_tickets_assigneeIdTousersInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutUsers_support_tickets_assigneeIdTousersInput | SupportTicketUpdateManyWithWhereWithoutUsers_support_tickets_assigneeIdTousersInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput = {
    create?: XOR<SupportTicketCreateWithoutUsers_support_tickets_userIdTousersInput, SupportTicketUncheckedCreateWithoutUsers_support_tickets_userIdTousersInput> | SupportTicketCreateWithoutUsers_support_tickets_userIdTousersInput[] | SupportTicketUncheckedCreateWithoutUsers_support_tickets_userIdTousersInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUsers_support_tickets_userIdTousersInput | SupportTicketCreateOrConnectWithoutUsers_support_tickets_userIdTousersInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutUsers_support_tickets_userIdTousersInput | SupportTicketUpsertWithWhereUniqueWithoutUsers_support_tickets_userIdTousersInput[]
    createMany?: SupportTicketCreateManyUsers_support_tickets_userIdTousersInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutUsers_support_tickets_userIdTousersInput | SupportTicketUpdateWithWhereUniqueWithoutUsers_support_tickets_userIdTousersInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutUsers_support_tickets_userIdTousersInput | SupportTicketUpdateManyWithWhereWithoutUsers_support_tickets_userIdTousersInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type ScimMappingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ScimMappingCreateWithoutUserInput, ScimMappingUncheckedCreateWithoutUserInput> | ScimMappingCreateWithoutUserInput[] | ScimMappingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScimMappingCreateOrConnectWithoutUserInput | ScimMappingCreateOrConnectWithoutUserInput[]
    upsert?: ScimMappingUpsertWithWhereUniqueWithoutUserInput | ScimMappingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ScimMappingCreateManyUserInputEnvelope
    set?: ScimMappingWhereUniqueInput | ScimMappingWhereUniqueInput[]
    disconnect?: ScimMappingWhereUniqueInput | ScimMappingWhereUniqueInput[]
    delete?: ScimMappingWhereUniqueInput | ScimMappingWhereUniqueInput[]
    connect?: ScimMappingWhereUniqueInput | ScimMappingWhereUniqueInput[]
    update?: ScimMappingUpdateWithWhereUniqueWithoutUserInput | ScimMappingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ScimMappingUpdateManyWithWhereWithoutUserInput | ScimMappingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ScimMappingScalarWhereInput | ScimMappingScalarWhereInput[]
  }

  export type KbArticleUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<KbArticleCreateWithoutAuthorInput, KbArticleUncheckedCreateWithoutAuthorInput> | KbArticleCreateWithoutAuthorInput[] | KbArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: KbArticleCreateOrConnectWithoutAuthorInput | KbArticleCreateOrConnectWithoutAuthorInput[]
    upsert?: KbArticleUpsertWithWhereUniqueWithoutAuthorInput | KbArticleUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: KbArticleCreateManyAuthorInputEnvelope
    set?: KbArticleWhereUniqueInput | KbArticleWhereUniqueInput[]
    disconnect?: KbArticleWhereUniqueInput | KbArticleWhereUniqueInput[]
    delete?: KbArticleWhereUniqueInput | KbArticleWhereUniqueInput[]
    connect?: KbArticleWhereUniqueInput | KbArticleWhereUniqueInput[]
    update?: KbArticleUpdateWithWhereUniqueWithoutAuthorInput | KbArticleUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: KbArticleUpdateManyWithWhereWithoutAuthorInput | KbArticleUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: KbArticleScalarWhereInput | KbArticleScalarWhereInput[]
  }

  export type KbArticleVersionUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<KbArticleVersionCreateWithoutAuthorInput, KbArticleVersionUncheckedCreateWithoutAuthorInput> | KbArticleVersionCreateWithoutAuthorInput[] | KbArticleVersionUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: KbArticleVersionCreateOrConnectWithoutAuthorInput | KbArticleVersionCreateOrConnectWithoutAuthorInput[]
    upsert?: KbArticleVersionUpsertWithWhereUniqueWithoutAuthorInput | KbArticleVersionUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: KbArticleVersionCreateManyAuthorInputEnvelope
    set?: KbArticleVersionWhereUniqueInput | KbArticleVersionWhereUniqueInput[]
    disconnect?: KbArticleVersionWhereUniqueInput | KbArticleVersionWhereUniqueInput[]
    delete?: KbArticleVersionWhereUniqueInput | KbArticleVersionWhereUniqueInput[]
    connect?: KbArticleVersionWhereUniqueInput | KbArticleVersionWhereUniqueInput[]
    update?: KbArticleVersionUpdateWithWhereUniqueWithoutAuthorInput | KbArticleVersionUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: KbArticleVersionUpdateManyWithWhereWithoutAuthorInput | KbArticleVersionUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: KbArticleVersionScalarWhereInput | KbArticleVersionScalarWhereInput[]
  }

  export type KbArticleCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<KbArticleCommentCreateWithoutUserInput, KbArticleCommentUncheckedCreateWithoutUserInput> | KbArticleCommentCreateWithoutUserInput[] | KbArticleCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: KbArticleCommentCreateOrConnectWithoutUserInput | KbArticleCommentCreateOrConnectWithoutUserInput[]
    upsert?: KbArticleCommentUpsertWithWhereUniqueWithoutUserInput | KbArticleCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: KbArticleCommentCreateManyUserInputEnvelope
    set?: KbArticleCommentWhereUniqueInput | KbArticleCommentWhereUniqueInput[]
    disconnect?: KbArticleCommentWhereUniqueInput | KbArticleCommentWhereUniqueInput[]
    delete?: KbArticleCommentWhereUniqueInput | KbArticleCommentWhereUniqueInput[]
    connect?: KbArticleCommentWhereUniqueInput | KbArticleCommentWhereUniqueInput[]
    update?: KbArticleCommentUpdateWithWhereUniqueWithoutUserInput | KbArticleCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: KbArticleCommentUpdateManyWithWhereWithoutUserInput | KbArticleCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: KbArticleCommentScalarWhereInput | KbArticleCommentScalarWhereInput[]
  }

  export type XpEventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<XpEventCreateWithoutUserInput, XpEventUncheckedCreateWithoutUserInput> | XpEventCreateWithoutUserInput[] | XpEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: XpEventCreateOrConnectWithoutUserInput | XpEventCreateOrConnectWithoutUserInput[]
    upsert?: XpEventUpsertWithWhereUniqueWithoutUserInput | XpEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: XpEventCreateManyUserInputEnvelope
    set?: XpEventWhereUniqueInput | XpEventWhereUniqueInput[]
    disconnect?: XpEventWhereUniqueInput | XpEventWhereUniqueInput[]
    delete?: XpEventWhereUniqueInput | XpEventWhereUniqueInput[]
    connect?: XpEventWhereUniqueInput | XpEventWhereUniqueInput[]
    update?: XpEventUpdateWithWhereUniqueWithoutUserInput | XpEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: XpEventUpdateManyWithWhereWithoutUserInput | XpEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: XpEventScalarWhereInput | XpEventScalarWhereInput[]
  }

  export type LeaderboardUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<LeaderboardCreateWithoutUserInput, LeaderboardUncheckedCreateWithoutUserInput>
    connectOrCreate?: LeaderboardCreateOrConnectWithoutUserInput
    upsert?: LeaderboardUpsertWithoutUserInput
    disconnect?: LeaderboardWhereInput | boolean
    delete?: LeaderboardWhereInput | boolean
    connect?: LeaderboardWhereUniqueInput
    update?: XOR<XOR<LeaderboardUpdateToOneWithWhereWithoutUserInput, LeaderboardUpdateWithoutUserInput>, LeaderboardUncheckedUpdateWithoutUserInput>
  }

  export type MailroomPackageUncheckedUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<MailroomPackageCreateWithoutRecipientInput, MailroomPackageUncheckedCreateWithoutRecipientInput> | MailroomPackageCreateWithoutRecipientInput[] | MailroomPackageUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: MailroomPackageCreateOrConnectWithoutRecipientInput | MailroomPackageCreateOrConnectWithoutRecipientInput[]
    upsert?: MailroomPackageUpsertWithWhereUniqueWithoutRecipientInput | MailroomPackageUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: MailroomPackageCreateManyRecipientInputEnvelope
    set?: MailroomPackageWhereUniqueInput | MailroomPackageWhereUniqueInput[]
    disconnect?: MailroomPackageWhereUniqueInput | MailroomPackageWhereUniqueInput[]
    delete?: MailroomPackageWhereUniqueInput | MailroomPackageWhereUniqueInput[]
    connect?: MailroomPackageWhereUniqueInput | MailroomPackageWhereUniqueInput[]
    update?: MailroomPackageUpdateWithWhereUniqueWithoutRecipientInput | MailroomPackageUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: MailroomPackageUpdateManyWithWhereWithoutRecipientInput | MailroomPackageUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: MailroomPackageScalarWhereInput | MailroomPackageScalarWhereInput[]
  }

  export type DeliveryEventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeliveryEventCreateWithoutUserInput, DeliveryEventUncheckedCreateWithoutUserInput> | DeliveryEventCreateWithoutUserInput[] | DeliveryEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeliveryEventCreateOrConnectWithoutUserInput | DeliveryEventCreateOrConnectWithoutUserInput[]
    upsert?: DeliveryEventUpsertWithWhereUniqueWithoutUserInput | DeliveryEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeliveryEventCreateManyUserInputEnvelope
    set?: DeliveryEventWhereUniqueInput | DeliveryEventWhereUniqueInput[]
    disconnect?: DeliveryEventWhereUniqueInput | DeliveryEventWhereUniqueInput[]
    delete?: DeliveryEventWhereUniqueInput | DeliveryEventWhereUniqueInput[]
    connect?: DeliveryEventWhereUniqueInput | DeliveryEventWhereUniqueInput[]
    update?: DeliveryEventUpdateWithWhereUniqueWithoutUserInput | DeliveryEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeliveryEventUpdateManyWithWhereWithoutUserInput | DeliveryEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeliveryEventScalarWhereInput | DeliveryEventScalarWhereInput[]
  }

  export type ProxyAuthorizationUncheckedUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<ProxyAuthorizationCreateWithoutRecipientInput, ProxyAuthorizationUncheckedCreateWithoutRecipientInput> | ProxyAuthorizationCreateWithoutRecipientInput[] | ProxyAuthorizationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: ProxyAuthorizationCreateOrConnectWithoutRecipientInput | ProxyAuthorizationCreateOrConnectWithoutRecipientInput[]
    upsert?: ProxyAuthorizationUpsertWithWhereUniqueWithoutRecipientInput | ProxyAuthorizationUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: ProxyAuthorizationCreateManyRecipientInputEnvelope
    set?: ProxyAuthorizationWhereUniqueInput | ProxyAuthorizationWhereUniqueInput[]
    disconnect?: ProxyAuthorizationWhereUniqueInput | ProxyAuthorizationWhereUniqueInput[]
    delete?: ProxyAuthorizationWhereUniqueInput | ProxyAuthorizationWhereUniqueInput[]
    connect?: ProxyAuthorizationWhereUniqueInput | ProxyAuthorizationWhereUniqueInput[]
    update?: ProxyAuthorizationUpdateWithWhereUniqueWithoutRecipientInput | ProxyAuthorizationUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: ProxyAuthorizationUpdateManyWithWhereWithoutRecipientInput | ProxyAuthorizationUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: ProxyAuthorizationScalarWhereInput | ProxyAuthorizationScalarWhereInput[]
  }

  export type ProxyAuthorizationUncheckedUpdateManyWithoutProxyNestedInput = {
    create?: XOR<ProxyAuthorizationCreateWithoutProxyInput, ProxyAuthorizationUncheckedCreateWithoutProxyInput> | ProxyAuthorizationCreateWithoutProxyInput[] | ProxyAuthorizationUncheckedCreateWithoutProxyInput[]
    connectOrCreate?: ProxyAuthorizationCreateOrConnectWithoutProxyInput | ProxyAuthorizationCreateOrConnectWithoutProxyInput[]
    upsert?: ProxyAuthorizationUpsertWithWhereUniqueWithoutProxyInput | ProxyAuthorizationUpsertWithWhereUniqueWithoutProxyInput[]
    createMany?: ProxyAuthorizationCreateManyProxyInputEnvelope
    set?: ProxyAuthorizationWhereUniqueInput | ProxyAuthorizationWhereUniqueInput[]
    disconnect?: ProxyAuthorizationWhereUniqueInput | ProxyAuthorizationWhereUniqueInput[]
    delete?: ProxyAuthorizationWhereUniqueInput | ProxyAuthorizationWhereUniqueInput[]
    connect?: ProxyAuthorizationWhereUniqueInput | ProxyAuthorizationWhereUniqueInput[]
    update?: ProxyAuthorizationUpdateWithWhereUniqueWithoutProxyInput | ProxyAuthorizationUpdateWithWhereUniqueWithoutProxyInput[]
    updateMany?: ProxyAuthorizationUpdateManyWithWhereWithoutProxyInput | ProxyAuthorizationUpdateManyWithWhereWithoutProxyInput[]
    deleteMany?: ProxyAuthorizationScalarWhereInput | ProxyAuthorizationScalarWhereInput[]
  }

  export type VipProxyUncheckedUpdateManyWithoutVipNestedInput = {
    create?: XOR<VipProxyCreateWithoutVipInput, VipProxyUncheckedCreateWithoutVipInput> | VipProxyCreateWithoutVipInput[] | VipProxyUncheckedCreateWithoutVipInput[]
    connectOrCreate?: VipProxyCreateOrConnectWithoutVipInput | VipProxyCreateOrConnectWithoutVipInput[]
    upsert?: VipProxyUpsertWithWhereUniqueWithoutVipInput | VipProxyUpsertWithWhereUniqueWithoutVipInput[]
    createMany?: VipProxyCreateManyVipInputEnvelope
    set?: VipProxyWhereUniqueInput | VipProxyWhereUniqueInput[]
    disconnect?: VipProxyWhereUniqueInput | VipProxyWhereUniqueInput[]
    delete?: VipProxyWhereUniqueInput | VipProxyWhereUniqueInput[]
    connect?: VipProxyWhereUniqueInput | VipProxyWhereUniqueInput[]
    update?: VipProxyUpdateWithWhereUniqueWithoutVipInput | VipProxyUpdateWithWhereUniqueWithoutVipInput[]
    updateMany?: VipProxyUpdateManyWithWhereWithoutVipInput | VipProxyUpdateManyWithWhereWithoutVipInput[]
    deleteMany?: VipProxyScalarWhereInput | VipProxyScalarWhereInput[]
  }

  export type VipProxyUncheckedUpdateManyWithoutProxyNestedInput = {
    create?: XOR<VipProxyCreateWithoutProxyInput, VipProxyUncheckedCreateWithoutProxyInput> | VipProxyCreateWithoutProxyInput[] | VipProxyUncheckedCreateWithoutProxyInput[]
    connectOrCreate?: VipProxyCreateOrConnectWithoutProxyInput | VipProxyCreateOrConnectWithoutProxyInput[]
    upsert?: VipProxyUpsertWithWhereUniqueWithoutProxyInput | VipProxyUpsertWithWhereUniqueWithoutProxyInput[]
    createMany?: VipProxyCreateManyProxyInputEnvelope
    set?: VipProxyWhereUniqueInput | VipProxyWhereUniqueInput[]
    disconnect?: VipProxyWhereUniqueInput | VipProxyWhereUniqueInput[]
    delete?: VipProxyWhereUniqueInput | VipProxyWhereUniqueInput[]
    connect?: VipProxyWhereUniqueInput | VipProxyWhereUniqueInput[]
    update?: VipProxyUpdateWithWhereUniqueWithoutProxyInput | VipProxyUpdateWithWhereUniqueWithoutProxyInput[]
    updateMany?: VipProxyUpdateManyWithWhereWithoutProxyInput | VipProxyUpdateManyWithWhereWithoutProxyInput[]
    deleteMany?: VipProxyScalarWhereInput | VipProxyScalarWhereInput[]
  }

  export type VipSlaHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<VipSlaHistoryCreateWithoutUserInput, VipSlaHistoryUncheckedCreateWithoutUserInput> | VipSlaHistoryCreateWithoutUserInput[] | VipSlaHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VipSlaHistoryCreateOrConnectWithoutUserInput | VipSlaHistoryCreateOrConnectWithoutUserInput[]
    upsert?: VipSlaHistoryUpsertWithWhereUniqueWithoutUserInput | VipSlaHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VipSlaHistoryCreateManyUserInputEnvelope
    set?: VipSlaHistoryWhereUniqueInput | VipSlaHistoryWhereUniqueInput[]
    disconnect?: VipSlaHistoryWhereUniqueInput | VipSlaHistoryWhereUniqueInput[]
    delete?: VipSlaHistoryWhereUniqueInput | VipSlaHistoryWhereUniqueInput[]
    connect?: VipSlaHistoryWhereUniqueInput | VipSlaHistoryWhereUniqueInput[]
    update?: VipSlaHistoryUpdateWithWhereUniqueWithoutUserInput | VipSlaHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VipSlaHistoryUpdateManyWithWhereWithoutUserInput | VipSlaHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VipSlaHistoryScalarWhereInput | VipSlaHistoryScalarWhereInput[]
  }

  export type AgentAvailabilityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AgentAvailabilityCreateWithoutUserInput, AgentAvailabilityUncheckedCreateWithoutUserInput> | AgentAvailabilityCreateWithoutUserInput[] | AgentAvailabilityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AgentAvailabilityCreateOrConnectWithoutUserInput | AgentAvailabilityCreateOrConnectWithoutUserInput[]
    upsert?: AgentAvailabilityUpsertWithWhereUniqueWithoutUserInput | AgentAvailabilityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AgentAvailabilityCreateManyUserInputEnvelope
    set?: AgentAvailabilityWhereUniqueInput | AgentAvailabilityWhereUniqueInput[]
    disconnect?: AgentAvailabilityWhereUniqueInput | AgentAvailabilityWhereUniqueInput[]
    delete?: AgentAvailabilityWhereUniqueInput | AgentAvailabilityWhereUniqueInput[]
    connect?: AgentAvailabilityWhereUniqueInput | AgentAvailabilityWhereUniqueInput[]
    update?: AgentAvailabilityUpdateWithWhereUniqueWithoutUserInput | AgentAvailabilityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AgentAvailabilityUpdateManyWithWhereWithoutUserInput | AgentAvailabilityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AgentAvailabilityScalarWhereInput | AgentAvailabilityScalarWhereInput[]
  }

  export type RolePermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type RolePermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type RolePermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRolesInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    connect?: UserWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    upsert?: UserUpsertWithoutRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRolesInput, UserUpdateWithoutRolesInput>, UserUncheckedUpdateWithoutRolesInput>
  }

  export type PermissionCreateNestedOneWithoutRolesInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput
    connect?: PermissionWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput
    connect?: RoleWhereUniqueInput
  }

  export type PermissionUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput
    upsert?: PermissionUpsertWithoutRolesInput
    connect?: PermissionWhereUniqueInput
    update?: XOR<XOR<PermissionUpdateToOneWithWhereWithoutRolesInput, PermissionUpdateWithoutRolesInput>, PermissionUncheckedUpdateWithoutRolesInput>
  }

  export type RoleUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput
    upsert?: RoleUpsertWithoutPermissionsInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutPermissionsInput, RoleUpdateWithoutPermissionsInput>, RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type UserCreateNestedOneWithoutPasskeysInput = {
    create?: XOR<UserCreateWithoutPasskeysInput, UserUncheckedCreateWithoutPasskeysInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasskeysInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPasskeysNestedInput = {
    create?: XOR<UserCreateWithoutPasskeysInput, UserUncheckedCreateWithoutPasskeysInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasskeysInput
    upsert?: UserUpsertWithoutPasskeysInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasskeysInput, UserUpdateWithoutPasskeysInput>, UserUncheckedUpdateWithoutPasskeysInput>
  }

  export type UserCreateNestedOneWithoutLogsInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutLogsNestedInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    upsert?: UserUpsertWithoutLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLogsInput, UserUpdateWithoutLogsInput>, UserUncheckedUpdateWithoutLogsInput>
  }

  export type ConfigHistoryCreateNestedManyWithoutConfigInput = {
    create?: XOR<ConfigHistoryCreateWithoutConfigInput, ConfigHistoryUncheckedCreateWithoutConfigInput> | ConfigHistoryCreateWithoutConfigInput[] | ConfigHistoryUncheckedCreateWithoutConfigInput[]
    connectOrCreate?: ConfigHistoryCreateOrConnectWithoutConfigInput | ConfigHistoryCreateOrConnectWithoutConfigInput[]
    createMany?: ConfigHistoryCreateManyConfigInputEnvelope
    connect?: ConfigHistoryWhereUniqueInput | ConfigHistoryWhereUniqueInput[]
  }

  export type ConfigHistoryUncheckedCreateNestedManyWithoutConfigInput = {
    create?: XOR<ConfigHistoryCreateWithoutConfigInput, ConfigHistoryUncheckedCreateWithoutConfigInput> | ConfigHistoryCreateWithoutConfigInput[] | ConfigHistoryUncheckedCreateWithoutConfigInput[]
    connectOrCreate?: ConfigHistoryCreateOrConnectWithoutConfigInput | ConfigHistoryCreateOrConnectWithoutConfigInput[]
    createMany?: ConfigHistoryCreateManyConfigInputEnvelope
    connect?: ConfigHistoryWhereUniqueInput | ConfigHistoryWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ConfigHistoryUpdateManyWithoutConfigNestedInput = {
    create?: XOR<ConfigHistoryCreateWithoutConfigInput, ConfigHistoryUncheckedCreateWithoutConfigInput> | ConfigHistoryCreateWithoutConfigInput[] | ConfigHistoryUncheckedCreateWithoutConfigInput[]
    connectOrCreate?: ConfigHistoryCreateOrConnectWithoutConfigInput | ConfigHistoryCreateOrConnectWithoutConfigInput[]
    upsert?: ConfigHistoryUpsertWithWhereUniqueWithoutConfigInput | ConfigHistoryUpsertWithWhereUniqueWithoutConfigInput[]
    createMany?: ConfigHistoryCreateManyConfigInputEnvelope
    set?: ConfigHistoryWhereUniqueInput | ConfigHistoryWhereUniqueInput[]
    disconnect?: ConfigHistoryWhereUniqueInput | ConfigHistoryWhereUniqueInput[]
    delete?: ConfigHistoryWhereUniqueInput | ConfigHistoryWhereUniqueInput[]
    connect?: ConfigHistoryWhereUniqueInput | ConfigHistoryWhereUniqueInput[]
    update?: ConfigHistoryUpdateWithWhereUniqueWithoutConfigInput | ConfigHistoryUpdateWithWhereUniqueWithoutConfigInput[]
    updateMany?: ConfigHistoryUpdateManyWithWhereWithoutConfigInput | ConfigHistoryUpdateManyWithWhereWithoutConfigInput[]
    deleteMany?: ConfigHistoryScalarWhereInput | ConfigHistoryScalarWhereInput[]
  }

  export type ConfigHistoryUncheckedUpdateManyWithoutConfigNestedInput = {
    create?: XOR<ConfigHistoryCreateWithoutConfigInput, ConfigHistoryUncheckedCreateWithoutConfigInput> | ConfigHistoryCreateWithoutConfigInput[] | ConfigHistoryUncheckedCreateWithoutConfigInput[]
    connectOrCreate?: ConfigHistoryCreateOrConnectWithoutConfigInput | ConfigHistoryCreateOrConnectWithoutConfigInput[]
    upsert?: ConfigHistoryUpsertWithWhereUniqueWithoutConfigInput | ConfigHistoryUpsertWithWhereUniqueWithoutConfigInput[]
    createMany?: ConfigHistoryCreateManyConfigInputEnvelope
    set?: ConfigHistoryWhereUniqueInput | ConfigHistoryWhereUniqueInput[]
    disconnect?: ConfigHistoryWhereUniqueInput | ConfigHistoryWhereUniqueInput[]
    delete?: ConfigHistoryWhereUniqueInput | ConfigHistoryWhereUniqueInput[]
    connect?: ConfigHistoryWhereUniqueInput | ConfigHistoryWhereUniqueInput[]
    update?: ConfigHistoryUpdateWithWhereUniqueWithoutConfigInput | ConfigHistoryUpdateWithWhereUniqueWithoutConfigInput[]
    updateMany?: ConfigHistoryUpdateManyWithWhereWithoutConfigInput | ConfigHistoryUpdateManyWithWhereWithoutConfigInput[]
    deleteMany?: ConfigHistoryScalarWhereInput | ConfigHistoryScalarWhereInput[]
  }

  export type ConfigCreateNestedOneWithoutHistoryInput = {
    create?: XOR<ConfigCreateWithoutHistoryInput, ConfigUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: ConfigCreateOrConnectWithoutHistoryInput
    connect?: ConfigWhereUniqueInput
  }

  export type ConfigUpdateOneRequiredWithoutHistoryNestedInput = {
    create?: XOR<ConfigCreateWithoutHistoryInput, ConfigUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: ConfigCreateOrConnectWithoutHistoryInput
    upsert?: ConfigUpsertWithoutHistoryInput
    connect?: ConfigWhereUniqueInput
    update?: XOR<XOR<ConfigUpdateToOneWithWhereWithoutHistoryInput, ConfigUpdateWithoutHistoryInput>, ConfigUncheckedUpdateWithoutHistoryInput>
  }

  export type KioskActivationCreateNestedManyWithoutKioskInput = {
    create?: XOR<KioskActivationCreateWithoutKioskInput, KioskActivationUncheckedCreateWithoutKioskInput> | KioskActivationCreateWithoutKioskInput[] | KioskActivationUncheckedCreateWithoutKioskInput[]
    connectOrCreate?: KioskActivationCreateOrConnectWithoutKioskInput | KioskActivationCreateOrConnectWithoutKioskInput[]
    createMany?: KioskActivationCreateManyKioskInputEnvelope
    connect?: KioskActivationWhereUniqueInput | KioskActivationWhereUniqueInput[]
  }

  export type KioskAssetRegistryCreateNestedManyWithoutKioskInput = {
    create?: XOR<KioskAssetRegistryCreateWithoutKioskInput, KioskAssetRegistryUncheckedCreateWithoutKioskInput> | KioskAssetRegistryCreateWithoutKioskInput[] | KioskAssetRegistryUncheckedCreateWithoutKioskInput[]
    connectOrCreate?: KioskAssetRegistryCreateOrConnectWithoutKioskInput | KioskAssetRegistryCreateOrConnectWithoutKioskInput[]
    createMany?: KioskAssetRegistryCreateManyKioskInputEnvelope
    connect?: KioskAssetRegistryWhereUniqueInput | KioskAssetRegistryWhereUniqueInput[]
  }

  export type HelixSyncFailureCreateNestedManyWithoutKioskInput = {
    create?: XOR<HelixSyncFailureCreateWithoutKioskInput, HelixSyncFailureUncheckedCreateWithoutKioskInput> | HelixSyncFailureCreateWithoutKioskInput[] | HelixSyncFailureUncheckedCreateWithoutKioskInput[]
    connectOrCreate?: HelixSyncFailureCreateOrConnectWithoutKioskInput | HelixSyncFailureCreateOrConnectWithoutKioskInput[]
    createMany?: HelixSyncFailureCreateManyKioskInputEnvelope
    connect?: HelixSyncFailureWhereUniqueInput | HelixSyncFailureWhereUniqueInput[]
  }

  export type KioskOrganizationAssignmentCreateNestedOneWithoutKioskInput = {
    create?: XOR<KioskOrganizationAssignmentCreateWithoutKioskInput, KioskOrganizationAssignmentUncheckedCreateWithoutKioskInput>
    connectOrCreate?: KioskOrganizationAssignmentCreateOrConnectWithoutKioskInput
    connect?: KioskOrganizationAssignmentWhereUniqueInput
  }

  export type KioskMetadataLogCreateNestedManyWithoutKioskInput = {
    create?: XOR<KioskMetadataLogCreateWithoutKioskInput, KioskMetadataLogUncheckedCreateWithoutKioskInput> | KioskMetadataLogCreateWithoutKioskInput[] | KioskMetadataLogUncheckedCreateWithoutKioskInput[]
    connectOrCreate?: KioskMetadataLogCreateOrConnectWithoutKioskInput | KioskMetadataLogCreateOrConnectWithoutKioskInput[]
    createMany?: KioskMetadataLogCreateManyKioskInputEnvelope
    connect?: KioskMetadataLogWhereUniqueInput | KioskMetadataLogWhereUniqueInput[]
  }

  export type KioskActivationUncheckedCreateNestedManyWithoutKioskInput = {
    create?: XOR<KioskActivationCreateWithoutKioskInput, KioskActivationUncheckedCreateWithoutKioskInput> | KioskActivationCreateWithoutKioskInput[] | KioskActivationUncheckedCreateWithoutKioskInput[]
    connectOrCreate?: KioskActivationCreateOrConnectWithoutKioskInput | KioskActivationCreateOrConnectWithoutKioskInput[]
    createMany?: KioskActivationCreateManyKioskInputEnvelope
    connect?: KioskActivationWhereUniqueInput | KioskActivationWhereUniqueInput[]
  }

  export type KioskAssetRegistryUncheckedCreateNestedManyWithoutKioskInput = {
    create?: XOR<KioskAssetRegistryCreateWithoutKioskInput, KioskAssetRegistryUncheckedCreateWithoutKioskInput> | KioskAssetRegistryCreateWithoutKioskInput[] | KioskAssetRegistryUncheckedCreateWithoutKioskInput[]
    connectOrCreate?: KioskAssetRegistryCreateOrConnectWithoutKioskInput | KioskAssetRegistryCreateOrConnectWithoutKioskInput[]
    createMany?: KioskAssetRegistryCreateManyKioskInputEnvelope
    connect?: KioskAssetRegistryWhereUniqueInput | KioskAssetRegistryWhereUniqueInput[]
  }

  export type HelixSyncFailureUncheckedCreateNestedManyWithoutKioskInput = {
    create?: XOR<HelixSyncFailureCreateWithoutKioskInput, HelixSyncFailureUncheckedCreateWithoutKioskInput> | HelixSyncFailureCreateWithoutKioskInput[] | HelixSyncFailureUncheckedCreateWithoutKioskInput[]
    connectOrCreate?: HelixSyncFailureCreateOrConnectWithoutKioskInput | HelixSyncFailureCreateOrConnectWithoutKioskInput[]
    createMany?: HelixSyncFailureCreateManyKioskInputEnvelope
    connect?: HelixSyncFailureWhereUniqueInput | HelixSyncFailureWhereUniqueInput[]
  }

  export type KioskOrganizationAssignmentUncheckedCreateNestedOneWithoutKioskInput = {
    create?: XOR<KioskOrganizationAssignmentCreateWithoutKioskInput, KioskOrganizationAssignmentUncheckedCreateWithoutKioskInput>
    connectOrCreate?: KioskOrganizationAssignmentCreateOrConnectWithoutKioskInput
    connect?: KioskOrganizationAssignmentWhereUniqueInput
  }

  export type KioskMetadataLogUncheckedCreateNestedManyWithoutKioskInput = {
    create?: XOR<KioskMetadataLogCreateWithoutKioskInput, KioskMetadataLogUncheckedCreateWithoutKioskInput> | KioskMetadataLogCreateWithoutKioskInput[] | KioskMetadataLogUncheckedCreateWithoutKioskInput[]
    connectOrCreate?: KioskMetadataLogCreateOrConnectWithoutKioskInput | KioskMetadataLogCreateOrConnectWithoutKioskInput[]
    createMany?: KioskMetadataLogCreateManyKioskInputEnvelope
    connect?: KioskMetadataLogWhereUniqueInput | KioskMetadataLogWhereUniqueInput[]
  }

  export type KioskActivationUpdateManyWithoutKioskNestedInput = {
    create?: XOR<KioskActivationCreateWithoutKioskInput, KioskActivationUncheckedCreateWithoutKioskInput> | KioskActivationCreateWithoutKioskInput[] | KioskActivationUncheckedCreateWithoutKioskInput[]
    connectOrCreate?: KioskActivationCreateOrConnectWithoutKioskInput | KioskActivationCreateOrConnectWithoutKioskInput[]
    upsert?: KioskActivationUpsertWithWhereUniqueWithoutKioskInput | KioskActivationUpsertWithWhereUniqueWithoutKioskInput[]
    createMany?: KioskActivationCreateManyKioskInputEnvelope
    set?: KioskActivationWhereUniqueInput | KioskActivationWhereUniqueInput[]
    disconnect?: KioskActivationWhereUniqueInput | KioskActivationWhereUniqueInput[]
    delete?: KioskActivationWhereUniqueInput | KioskActivationWhereUniqueInput[]
    connect?: KioskActivationWhereUniqueInput | KioskActivationWhereUniqueInput[]
    update?: KioskActivationUpdateWithWhereUniqueWithoutKioskInput | KioskActivationUpdateWithWhereUniqueWithoutKioskInput[]
    updateMany?: KioskActivationUpdateManyWithWhereWithoutKioskInput | KioskActivationUpdateManyWithWhereWithoutKioskInput[]
    deleteMany?: KioskActivationScalarWhereInput | KioskActivationScalarWhereInput[]
  }

  export type KioskAssetRegistryUpdateManyWithoutKioskNestedInput = {
    create?: XOR<KioskAssetRegistryCreateWithoutKioskInput, KioskAssetRegistryUncheckedCreateWithoutKioskInput> | KioskAssetRegistryCreateWithoutKioskInput[] | KioskAssetRegistryUncheckedCreateWithoutKioskInput[]
    connectOrCreate?: KioskAssetRegistryCreateOrConnectWithoutKioskInput | KioskAssetRegistryCreateOrConnectWithoutKioskInput[]
    upsert?: KioskAssetRegistryUpsertWithWhereUniqueWithoutKioskInput | KioskAssetRegistryUpsertWithWhereUniqueWithoutKioskInput[]
    createMany?: KioskAssetRegistryCreateManyKioskInputEnvelope
    set?: KioskAssetRegistryWhereUniqueInput | KioskAssetRegistryWhereUniqueInput[]
    disconnect?: KioskAssetRegistryWhereUniqueInput | KioskAssetRegistryWhereUniqueInput[]
    delete?: KioskAssetRegistryWhereUniqueInput | KioskAssetRegistryWhereUniqueInput[]
    connect?: KioskAssetRegistryWhereUniqueInput | KioskAssetRegistryWhereUniqueInput[]
    update?: KioskAssetRegistryUpdateWithWhereUniqueWithoutKioskInput | KioskAssetRegistryUpdateWithWhereUniqueWithoutKioskInput[]
    updateMany?: KioskAssetRegistryUpdateManyWithWhereWithoutKioskInput | KioskAssetRegistryUpdateManyWithWhereWithoutKioskInput[]
    deleteMany?: KioskAssetRegistryScalarWhereInput | KioskAssetRegistryScalarWhereInput[]
  }

  export type HelixSyncFailureUpdateManyWithoutKioskNestedInput = {
    create?: XOR<HelixSyncFailureCreateWithoutKioskInput, HelixSyncFailureUncheckedCreateWithoutKioskInput> | HelixSyncFailureCreateWithoutKioskInput[] | HelixSyncFailureUncheckedCreateWithoutKioskInput[]
    connectOrCreate?: HelixSyncFailureCreateOrConnectWithoutKioskInput | HelixSyncFailureCreateOrConnectWithoutKioskInput[]
    upsert?: HelixSyncFailureUpsertWithWhereUniqueWithoutKioskInput | HelixSyncFailureUpsertWithWhereUniqueWithoutKioskInput[]
    createMany?: HelixSyncFailureCreateManyKioskInputEnvelope
    set?: HelixSyncFailureWhereUniqueInput | HelixSyncFailureWhereUniqueInput[]
    disconnect?: HelixSyncFailureWhereUniqueInput | HelixSyncFailureWhereUniqueInput[]
    delete?: HelixSyncFailureWhereUniqueInput | HelixSyncFailureWhereUniqueInput[]
    connect?: HelixSyncFailureWhereUniqueInput | HelixSyncFailureWhereUniqueInput[]
    update?: HelixSyncFailureUpdateWithWhereUniqueWithoutKioskInput | HelixSyncFailureUpdateWithWhereUniqueWithoutKioskInput[]
    updateMany?: HelixSyncFailureUpdateManyWithWhereWithoutKioskInput | HelixSyncFailureUpdateManyWithWhereWithoutKioskInput[]
    deleteMany?: HelixSyncFailureScalarWhereInput | HelixSyncFailureScalarWhereInput[]
  }

  export type KioskOrganizationAssignmentUpdateOneWithoutKioskNestedInput = {
    create?: XOR<KioskOrganizationAssignmentCreateWithoutKioskInput, KioskOrganizationAssignmentUncheckedCreateWithoutKioskInput>
    connectOrCreate?: KioskOrganizationAssignmentCreateOrConnectWithoutKioskInput
    upsert?: KioskOrganizationAssignmentUpsertWithoutKioskInput
    disconnect?: KioskOrganizationAssignmentWhereInput | boolean
    delete?: KioskOrganizationAssignmentWhereInput | boolean
    connect?: KioskOrganizationAssignmentWhereUniqueInput
    update?: XOR<XOR<KioskOrganizationAssignmentUpdateToOneWithWhereWithoutKioskInput, KioskOrganizationAssignmentUpdateWithoutKioskInput>, KioskOrganizationAssignmentUncheckedUpdateWithoutKioskInput>
  }

  export type KioskMetadataLogUpdateManyWithoutKioskNestedInput = {
    create?: XOR<KioskMetadataLogCreateWithoutKioskInput, KioskMetadataLogUncheckedCreateWithoutKioskInput> | KioskMetadataLogCreateWithoutKioskInput[] | KioskMetadataLogUncheckedCreateWithoutKioskInput[]
    connectOrCreate?: KioskMetadataLogCreateOrConnectWithoutKioskInput | KioskMetadataLogCreateOrConnectWithoutKioskInput[]
    upsert?: KioskMetadataLogUpsertWithWhereUniqueWithoutKioskInput | KioskMetadataLogUpsertWithWhereUniqueWithoutKioskInput[]
    createMany?: KioskMetadataLogCreateManyKioskInputEnvelope
    set?: KioskMetadataLogWhereUniqueInput | KioskMetadataLogWhereUniqueInput[]
    disconnect?: KioskMetadataLogWhereUniqueInput | KioskMetadataLogWhereUniqueInput[]
    delete?: KioskMetadataLogWhereUniqueInput | KioskMetadataLogWhereUniqueInput[]
    connect?: KioskMetadataLogWhereUniqueInput | KioskMetadataLogWhereUniqueInput[]
    update?: KioskMetadataLogUpdateWithWhereUniqueWithoutKioskInput | KioskMetadataLogUpdateWithWhereUniqueWithoutKioskInput[]
    updateMany?: KioskMetadataLogUpdateManyWithWhereWithoutKioskInput | KioskMetadataLogUpdateManyWithWhereWithoutKioskInput[]
    deleteMany?: KioskMetadataLogScalarWhereInput | KioskMetadataLogScalarWhereInput[]
  }

  export type KioskActivationUncheckedUpdateManyWithoutKioskNestedInput = {
    create?: XOR<KioskActivationCreateWithoutKioskInput, KioskActivationUncheckedCreateWithoutKioskInput> | KioskActivationCreateWithoutKioskInput[] | KioskActivationUncheckedCreateWithoutKioskInput[]
    connectOrCreate?: KioskActivationCreateOrConnectWithoutKioskInput | KioskActivationCreateOrConnectWithoutKioskInput[]
    upsert?: KioskActivationUpsertWithWhereUniqueWithoutKioskInput | KioskActivationUpsertWithWhereUniqueWithoutKioskInput[]
    createMany?: KioskActivationCreateManyKioskInputEnvelope
    set?: KioskActivationWhereUniqueInput | KioskActivationWhereUniqueInput[]
    disconnect?: KioskActivationWhereUniqueInput | KioskActivationWhereUniqueInput[]
    delete?: KioskActivationWhereUniqueInput | KioskActivationWhereUniqueInput[]
    connect?: KioskActivationWhereUniqueInput | KioskActivationWhereUniqueInput[]
    update?: KioskActivationUpdateWithWhereUniqueWithoutKioskInput | KioskActivationUpdateWithWhereUniqueWithoutKioskInput[]
    updateMany?: KioskActivationUpdateManyWithWhereWithoutKioskInput | KioskActivationUpdateManyWithWhereWithoutKioskInput[]
    deleteMany?: KioskActivationScalarWhereInput | KioskActivationScalarWhereInput[]
  }

  export type KioskAssetRegistryUncheckedUpdateManyWithoutKioskNestedInput = {
    create?: XOR<KioskAssetRegistryCreateWithoutKioskInput, KioskAssetRegistryUncheckedCreateWithoutKioskInput> | KioskAssetRegistryCreateWithoutKioskInput[] | KioskAssetRegistryUncheckedCreateWithoutKioskInput[]
    connectOrCreate?: KioskAssetRegistryCreateOrConnectWithoutKioskInput | KioskAssetRegistryCreateOrConnectWithoutKioskInput[]
    upsert?: KioskAssetRegistryUpsertWithWhereUniqueWithoutKioskInput | KioskAssetRegistryUpsertWithWhereUniqueWithoutKioskInput[]
    createMany?: KioskAssetRegistryCreateManyKioskInputEnvelope
    set?: KioskAssetRegistryWhereUniqueInput | KioskAssetRegistryWhereUniqueInput[]
    disconnect?: KioskAssetRegistryWhereUniqueInput | KioskAssetRegistryWhereUniqueInput[]
    delete?: KioskAssetRegistryWhereUniqueInput | KioskAssetRegistryWhereUniqueInput[]
    connect?: KioskAssetRegistryWhereUniqueInput | KioskAssetRegistryWhereUniqueInput[]
    update?: KioskAssetRegistryUpdateWithWhereUniqueWithoutKioskInput | KioskAssetRegistryUpdateWithWhereUniqueWithoutKioskInput[]
    updateMany?: KioskAssetRegistryUpdateManyWithWhereWithoutKioskInput | KioskAssetRegistryUpdateManyWithWhereWithoutKioskInput[]
    deleteMany?: KioskAssetRegistryScalarWhereInput | KioskAssetRegistryScalarWhereInput[]
  }

  export type HelixSyncFailureUncheckedUpdateManyWithoutKioskNestedInput = {
    create?: XOR<HelixSyncFailureCreateWithoutKioskInput, HelixSyncFailureUncheckedCreateWithoutKioskInput> | HelixSyncFailureCreateWithoutKioskInput[] | HelixSyncFailureUncheckedCreateWithoutKioskInput[]
    connectOrCreate?: HelixSyncFailureCreateOrConnectWithoutKioskInput | HelixSyncFailureCreateOrConnectWithoutKioskInput[]
    upsert?: HelixSyncFailureUpsertWithWhereUniqueWithoutKioskInput | HelixSyncFailureUpsertWithWhereUniqueWithoutKioskInput[]
    createMany?: HelixSyncFailureCreateManyKioskInputEnvelope
    set?: HelixSyncFailureWhereUniqueInput | HelixSyncFailureWhereUniqueInput[]
    disconnect?: HelixSyncFailureWhereUniqueInput | HelixSyncFailureWhereUniqueInput[]
    delete?: HelixSyncFailureWhereUniqueInput | HelixSyncFailureWhereUniqueInput[]
    connect?: HelixSyncFailureWhereUniqueInput | HelixSyncFailureWhereUniqueInput[]
    update?: HelixSyncFailureUpdateWithWhereUniqueWithoutKioskInput | HelixSyncFailureUpdateWithWhereUniqueWithoutKioskInput[]
    updateMany?: HelixSyncFailureUpdateManyWithWhereWithoutKioskInput | HelixSyncFailureUpdateManyWithWhereWithoutKioskInput[]
    deleteMany?: HelixSyncFailureScalarWhereInput | HelixSyncFailureScalarWhereInput[]
  }

  export type KioskOrganizationAssignmentUncheckedUpdateOneWithoutKioskNestedInput = {
    create?: XOR<KioskOrganizationAssignmentCreateWithoutKioskInput, KioskOrganizationAssignmentUncheckedCreateWithoutKioskInput>
    connectOrCreate?: KioskOrganizationAssignmentCreateOrConnectWithoutKioskInput
    upsert?: KioskOrganizationAssignmentUpsertWithoutKioskInput
    disconnect?: KioskOrganizationAssignmentWhereInput | boolean
    delete?: KioskOrganizationAssignmentWhereInput | boolean
    connect?: KioskOrganizationAssignmentWhereUniqueInput
    update?: XOR<XOR<KioskOrganizationAssignmentUpdateToOneWithWhereWithoutKioskInput, KioskOrganizationAssignmentUpdateWithoutKioskInput>, KioskOrganizationAssignmentUncheckedUpdateWithoutKioskInput>
  }

  export type KioskMetadataLogUncheckedUpdateManyWithoutKioskNestedInput = {
    create?: XOR<KioskMetadataLogCreateWithoutKioskInput, KioskMetadataLogUncheckedCreateWithoutKioskInput> | KioskMetadataLogCreateWithoutKioskInput[] | KioskMetadataLogUncheckedCreateWithoutKioskInput[]
    connectOrCreate?: KioskMetadataLogCreateOrConnectWithoutKioskInput | KioskMetadataLogCreateOrConnectWithoutKioskInput[]
    upsert?: KioskMetadataLogUpsertWithWhereUniqueWithoutKioskInput | KioskMetadataLogUpsertWithWhereUniqueWithoutKioskInput[]
    createMany?: KioskMetadataLogCreateManyKioskInputEnvelope
    set?: KioskMetadataLogWhereUniqueInput | KioskMetadataLogWhereUniqueInput[]
    disconnect?: KioskMetadataLogWhereUniqueInput | KioskMetadataLogWhereUniqueInput[]
    delete?: KioskMetadataLogWhereUniqueInput | KioskMetadataLogWhereUniqueInput[]
    connect?: KioskMetadataLogWhereUniqueInput | KioskMetadataLogWhereUniqueInput[]
    update?: KioskMetadataLogUpdateWithWhereUniqueWithoutKioskInput | KioskMetadataLogUpdateWithWhereUniqueWithoutKioskInput[]
    updateMany?: KioskMetadataLogUpdateManyWithWhereWithoutKioskInput | KioskMetadataLogUpdateManyWithWhereWithoutKioskInput[]
    deleteMany?: KioskMetadataLogScalarWhereInput | KioskMetadataLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutFeedbackInput = {
    create?: XOR<UserCreateWithoutFeedbackInput, UserUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbackInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutFeedbackNestedInput = {
    create?: XOR<UserCreateWithoutFeedbackInput, UserUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbackInput
    upsert?: UserUpsertWithoutFeedbackInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFeedbackInput, UserUpdateWithoutFeedbackInput>, UserUncheckedUpdateWithoutFeedbackInput>
  }

  export type KioskCreateNestedOneWithoutActivationsInput = {
    create?: XOR<KioskCreateWithoutActivationsInput, KioskUncheckedCreateWithoutActivationsInput>
    connectOrCreate?: KioskCreateOrConnectWithoutActivationsInput
    connect?: KioskWhereUniqueInput
  }

  export type KioskUpdateOneWithoutActivationsNestedInput = {
    create?: XOR<KioskCreateWithoutActivationsInput, KioskUncheckedCreateWithoutActivationsInput>
    connectOrCreate?: KioskCreateOrConnectWithoutActivationsInput
    upsert?: KioskUpsertWithoutActivationsInput
    disconnect?: KioskWhereInput | boolean
    delete?: KioskWhereInput | boolean
    connect?: KioskWhereUniqueInput
    update?: XOR<XOR<KioskUpdateToOneWithWhereWithoutActivationsInput, KioskUpdateWithoutActivationsInput>, KioskUncheckedUpdateWithoutActivationsInput>
  }

  export type KbArticleCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutKbArticlesAuthoredInput = {
    create?: XOR<UserCreateWithoutKbArticlesAuthoredInput, UserUncheckedCreateWithoutKbArticlesAuthoredInput>
    connectOrCreate?: UserCreateOrConnectWithoutKbArticlesAuthoredInput
    connect?: UserWhereUniqueInput
  }

  export type KbArticleVersionCreateNestedManyWithoutArticleInput = {
    create?: XOR<KbArticleVersionCreateWithoutArticleInput, KbArticleVersionUncheckedCreateWithoutArticleInput> | KbArticleVersionCreateWithoutArticleInput[] | KbArticleVersionUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: KbArticleVersionCreateOrConnectWithoutArticleInput | KbArticleVersionCreateOrConnectWithoutArticleInput[]
    createMany?: KbArticleVersionCreateManyArticleInputEnvelope
    connect?: KbArticleVersionWhereUniqueInput | KbArticleVersionWhereUniqueInput[]
  }

  export type KbArticleCommentCreateNestedManyWithoutArticleInput = {
    create?: XOR<KbArticleCommentCreateWithoutArticleInput, KbArticleCommentUncheckedCreateWithoutArticleInput> | KbArticleCommentCreateWithoutArticleInput[] | KbArticleCommentUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: KbArticleCommentCreateOrConnectWithoutArticleInput | KbArticleCommentCreateOrConnectWithoutArticleInput[]
    createMany?: KbArticleCommentCreateManyArticleInputEnvelope
    connect?: KbArticleCommentWhereUniqueInput | KbArticleCommentWhereUniqueInput[]
  }

  export type KbArticleVersionCreateNestedOneWithoutCurrentForArticleInput = {
    create?: XOR<KbArticleVersionCreateWithoutCurrentForArticleInput, KbArticleVersionUncheckedCreateWithoutCurrentForArticleInput>
    connectOrCreate?: KbArticleVersionCreateOrConnectWithoutCurrentForArticleInput
    connect?: KbArticleVersionWhereUniqueInput
  }

  export type KbArticleVersionUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<KbArticleVersionCreateWithoutArticleInput, KbArticleVersionUncheckedCreateWithoutArticleInput> | KbArticleVersionCreateWithoutArticleInput[] | KbArticleVersionUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: KbArticleVersionCreateOrConnectWithoutArticleInput | KbArticleVersionCreateOrConnectWithoutArticleInput[]
    createMany?: KbArticleVersionCreateManyArticleInputEnvelope
    connect?: KbArticleVersionWhereUniqueInput | KbArticleVersionWhereUniqueInput[]
  }

  export type KbArticleCommentUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<KbArticleCommentCreateWithoutArticleInput, KbArticleCommentUncheckedCreateWithoutArticleInput> | KbArticleCommentCreateWithoutArticleInput[] | KbArticleCommentUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: KbArticleCommentCreateOrConnectWithoutArticleInput | KbArticleCommentCreateOrConnectWithoutArticleInput[]
    createMany?: KbArticleCommentCreateManyArticleInputEnvelope
    connect?: KbArticleCommentWhereUniqueInput | KbArticleCommentWhereUniqueInput[]
  }

  export type KbArticleUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneWithoutKbArticlesAuthoredNestedInput = {
    create?: XOR<UserCreateWithoutKbArticlesAuthoredInput, UserUncheckedCreateWithoutKbArticlesAuthoredInput>
    connectOrCreate?: UserCreateOrConnectWithoutKbArticlesAuthoredInput
    upsert?: UserUpsertWithoutKbArticlesAuthoredInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutKbArticlesAuthoredInput, UserUpdateWithoutKbArticlesAuthoredInput>, UserUncheckedUpdateWithoutKbArticlesAuthoredInput>
  }

  export type KbArticleVersionUpdateManyWithoutArticleNestedInput = {
    create?: XOR<KbArticleVersionCreateWithoutArticleInput, KbArticleVersionUncheckedCreateWithoutArticleInput> | KbArticleVersionCreateWithoutArticleInput[] | KbArticleVersionUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: KbArticleVersionCreateOrConnectWithoutArticleInput | KbArticleVersionCreateOrConnectWithoutArticleInput[]
    upsert?: KbArticleVersionUpsertWithWhereUniqueWithoutArticleInput | KbArticleVersionUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: KbArticleVersionCreateManyArticleInputEnvelope
    set?: KbArticleVersionWhereUniqueInput | KbArticleVersionWhereUniqueInput[]
    disconnect?: KbArticleVersionWhereUniqueInput | KbArticleVersionWhereUniqueInput[]
    delete?: KbArticleVersionWhereUniqueInput | KbArticleVersionWhereUniqueInput[]
    connect?: KbArticleVersionWhereUniqueInput | KbArticleVersionWhereUniqueInput[]
    update?: KbArticleVersionUpdateWithWhereUniqueWithoutArticleInput | KbArticleVersionUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: KbArticleVersionUpdateManyWithWhereWithoutArticleInput | KbArticleVersionUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: KbArticleVersionScalarWhereInput | KbArticleVersionScalarWhereInput[]
  }

  export type KbArticleCommentUpdateManyWithoutArticleNestedInput = {
    create?: XOR<KbArticleCommentCreateWithoutArticleInput, KbArticleCommentUncheckedCreateWithoutArticleInput> | KbArticleCommentCreateWithoutArticleInput[] | KbArticleCommentUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: KbArticleCommentCreateOrConnectWithoutArticleInput | KbArticleCommentCreateOrConnectWithoutArticleInput[]
    upsert?: KbArticleCommentUpsertWithWhereUniqueWithoutArticleInput | KbArticleCommentUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: KbArticleCommentCreateManyArticleInputEnvelope
    set?: KbArticleCommentWhereUniqueInput | KbArticleCommentWhereUniqueInput[]
    disconnect?: KbArticleCommentWhereUniqueInput | KbArticleCommentWhereUniqueInput[]
    delete?: KbArticleCommentWhereUniqueInput | KbArticleCommentWhereUniqueInput[]
    connect?: KbArticleCommentWhereUniqueInput | KbArticleCommentWhereUniqueInput[]
    update?: KbArticleCommentUpdateWithWhereUniqueWithoutArticleInput | KbArticleCommentUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: KbArticleCommentUpdateManyWithWhereWithoutArticleInput | KbArticleCommentUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: KbArticleCommentScalarWhereInput | KbArticleCommentScalarWhereInput[]
  }

  export type KbArticleVersionUpdateOneWithoutCurrentForArticleNestedInput = {
    create?: XOR<KbArticleVersionCreateWithoutCurrentForArticleInput, KbArticleVersionUncheckedCreateWithoutCurrentForArticleInput>
    connectOrCreate?: KbArticleVersionCreateOrConnectWithoutCurrentForArticleInput
    upsert?: KbArticleVersionUpsertWithoutCurrentForArticleInput
    disconnect?: KbArticleVersionWhereInput | boolean
    delete?: KbArticleVersionWhereInput | boolean
    connect?: KbArticleVersionWhereUniqueInput
    update?: XOR<XOR<KbArticleVersionUpdateToOneWithWhereWithoutCurrentForArticleInput, KbArticleVersionUpdateWithoutCurrentForArticleInput>, KbArticleVersionUncheckedUpdateWithoutCurrentForArticleInput>
  }

  export type KbArticleVersionUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<KbArticleVersionCreateWithoutArticleInput, KbArticleVersionUncheckedCreateWithoutArticleInput> | KbArticleVersionCreateWithoutArticleInput[] | KbArticleVersionUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: KbArticleVersionCreateOrConnectWithoutArticleInput | KbArticleVersionCreateOrConnectWithoutArticleInput[]
    upsert?: KbArticleVersionUpsertWithWhereUniqueWithoutArticleInput | KbArticleVersionUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: KbArticleVersionCreateManyArticleInputEnvelope
    set?: KbArticleVersionWhereUniqueInput | KbArticleVersionWhereUniqueInput[]
    disconnect?: KbArticleVersionWhereUniqueInput | KbArticleVersionWhereUniqueInput[]
    delete?: KbArticleVersionWhereUniqueInput | KbArticleVersionWhereUniqueInput[]
    connect?: KbArticleVersionWhereUniqueInput | KbArticleVersionWhereUniqueInput[]
    update?: KbArticleVersionUpdateWithWhereUniqueWithoutArticleInput | KbArticleVersionUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: KbArticleVersionUpdateManyWithWhereWithoutArticleInput | KbArticleVersionUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: KbArticleVersionScalarWhereInput | KbArticleVersionScalarWhereInput[]
  }

  export type KbArticleCommentUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<KbArticleCommentCreateWithoutArticleInput, KbArticleCommentUncheckedCreateWithoutArticleInput> | KbArticleCommentCreateWithoutArticleInput[] | KbArticleCommentUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: KbArticleCommentCreateOrConnectWithoutArticleInput | KbArticleCommentCreateOrConnectWithoutArticleInput[]
    upsert?: KbArticleCommentUpsertWithWhereUniqueWithoutArticleInput | KbArticleCommentUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: KbArticleCommentCreateManyArticleInputEnvelope
    set?: KbArticleCommentWhereUniqueInput | KbArticleCommentWhereUniqueInput[]
    disconnect?: KbArticleCommentWhereUniqueInput | KbArticleCommentWhereUniqueInput[]
    delete?: KbArticleCommentWhereUniqueInput | KbArticleCommentWhereUniqueInput[]
    connect?: KbArticleCommentWhereUniqueInput | KbArticleCommentWhereUniqueInput[]
    update?: KbArticleCommentUpdateWithWhereUniqueWithoutArticleInput | KbArticleCommentUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: KbArticleCommentUpdateManyWithWhereWithoutArticleInput | KbArticleCommentUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: KbArticleCommentScalarWhereInput | KbArticleCommentScalarWhereInput[]
  }

  export type KbArticleCreateNestedOneWithoutVersionsInput = {
    create?: XOR<KbArticleCreateWithoutVersionsInput, KbArticleUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: KbArticleCreateOrConnectWithoutVersionsInput
    connect?: KbArticleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutKbArticleVersionsAuthoredInput = {
    create?: XOR<UserCreateWithoutKbArticleVersionsAuthoredInput, UserUncheckedCreateWithoutKbArticleVersionsAuthoredInput>
    connectOrCreate?: UserCreateOrConnectWithoutKbArticleVersionsAuthoredInput
    connect?: UserWhereUniqueInput
  }

  export type KbArticleCreateNestedManyWithoutCurrentVersionInput = {
    create?: XOR<KbArticleCreateWithoutCurrentVersionInput, KbArticleUncheckedCreateWithoutCurrentVersionInput> | KbArticleCreateWithoutCurrentVersionInput[] | KbArticleUncheckedCreateWithoutCurrentVersionInput[]
    connectOrCreate?: KbArticleCreateOrConnectWithoutCurrentVersionInput | KbArticleCreateOrConnectWithoutCurrentVersionInput[]
    createMany?: KbArticleCreateManyCurrentVersionInputEnvelope
    connect?: KbArticleWhereUniqueInput | KbArticleWhereUniqueInput[]
  }

  export type KbArticleUncheckedCreateNestedManyWithoutCurrentVersionInput = {
    create?: XOR<KbArticleCreateWithoutCurrentVersionInput, KbArticleUncheckedCreateWithoutCurrentVersionInput> | KbArticleCreateWithoutCurrentVersionInput[] | KbArticleUncheckedCreateWithoutCurrentVersionInput[]
    connectOrCreate?: KbArticleCreateOrConnectWithoutCurrentVersionInput | KbArticleCreateOrConnectWithoutCurrentVersionInput[]
    createMany?: KbArticleCreateManyCurrentVersionInputEnvelope
    connect?: KbArticleWhereUniqueInput | KbArticleWhereUniqueInput[]
  }

  export type KbArticleUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<KbArticleCreateWithoutVersionsInput, KbArticleUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: KbArticleCreateOrConnectWithoutVersionsInput
    upsert?: KbArticleUpsertWithoutVersionsInput
    connect?: KbArticleWhereUniqueInput
    update?: XOR<XOR<KbArticleUpdateToOneWithWhereWithoutVersionsInput, KbArticleUpdateWithoutVersionsInput>, KbArticleUncheckedUpdateWithoutVersionsInput>
  }

  export type UserUpdateOneWithoutKbArticleVersionsAuthoredNestedInput = {
    create?: XOR<UserCreateWithoutKbArticleVersionsAuthoredInput, UserUncheckedCreateWithoutKbArticleVersionsAuthoredInput>
    connectOrCreate?: UserCreateOrConnectWithoutKbArticleVersionsAuthoredInput
    upsert?: UserUpsertWithoutKbArticleVersionsAuthoredInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutKbArticleVersionsAuthoredInput, UserUpdateWithoutKbArticleVersionsAuthoredInput>, UserUncheckedUpdateWithoutKbArticleVersionsAuthoredInput>
  }

  export type KbArticleUpdateManyWithoutCurrentVersionNestedInput = {
    create?: XOR<KbArticleCreateWithoutCurrentVersionInput, KbArticleUncheckedCreateWithoutCurrentVersionInput> | KbArticleCreateWithoutCurrentVersionInput[] | KbArticleUncheckedCreateWithoutCurrentVersionInput[]
    connectOrCreate?: KbArticleCreateOrConnectWithoutCurrentVersionInput | KbArticleCreateOrConnectWithoutCurrentVersionInput[]
    upsert?: KbArticleUpsertWithWhereUniqueWithoutCurrentVersionInput | KbArticleUpsertWithWhereUniqueWithoutCurrentVersionInput[]
    createMany?: KbArticleCreateManyCurrentVersionInputEnvelope
    set?: KbArticleWhereUniqueInput | KbArticleWhereUniqueInput[]
    disconnect?: KbArticleWhereUniqueInput | KbArticleWhereUniqueInput[]
    delete?: KbArticleWhereUniqueInput | KbArticleWhereUniqueInput[]
    connect?: KbArticleWhereUniqueInput | KbArticleWhereUniqueInput[]
    update?: KbArticleUpdateWithWhereUniqueWithoutCurrentVersionInput | KbArticleUpdateWithWhereUniqueWithoutCurrentVersionInput[]
    updateMany?: KbArticleUpdateManyWithWhereWithoutCurrentVersionInput | KbArticleUpdateManyWithWhereWithoutCurrentVersionInput[]
    deleteMany?: KbArticleScalarWhereInput | KbArticleScalarWhereInput[]
  }

  export type KbArticleUncheckedUpdateManyWithoutCurrentVersionNestedInput = {
    create?: XOR<KbArticleCreateWithoutCurrentVersionInput, KbArticleUncheckedCreateWithoutCurrentVersionInput> | KbArticleCreateWithoutCurrentVersionInput[] | KbArticleUncheckedCreateWithoutCurrentVersionInput[]
    connectOrCreate?: KbArticleCreateOrConnectWithoutCurrentVersionInput | KbArticleCreateOrConnectWithoutCurrentVersionInput[]
    upsert?: KbArticleUpsertWithWhereUniqueWithoutCurrentVersionInput | KbArticleUpsertWithWhereUniqueWithoutCurrentVersionInput[]
    createMany?: KbArticleCreateManyCurrentVersionInputEnvelope
    set?: KbArticleWhereUniqueInput | KbArticleWhereUniqueInput[]
    disconnect?: KbArticleWhereUniqueInput | KbArticleWhereUniqueInput[]
    delete?: KbArticleWhereUniqueInput | KbArticleWhereUniqueInput[]
    connect?: KbArticleWhereUniqueInput | KbArticleWhereUniqueInput[]
    update?: KbArticleUpdateWithWhereUniqueWithoutCurrentVersionInput | KbArticleUpdateWithWhereUniqueWithoutCurrentVersionInput[]
    updateMany?: KbArticleUpdateManyWithWhereWithoutCurrentVersionInput | KbArticleUpdateManyWithWhereWithoutCurrentVersionInput[]
    deleteMany?: KbArticleScalarWhereInput | KbArticleScalarWhereInput[]
  }

  export type KbArticleCreateNestedOneWithoutCommentsInput = {
    create?: XOR<KbArticleCreateWithoutCommentsInput, KbArticleUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: KbArticleCreateOrConnectWithoutCommentsInput
    connect?: KbArticleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutKbArticleCommentsInput = {
    create?: XOR<UserCreateWithoutKbArticleCommentsInput, UserUncheckedCreateWithoutKbArticleCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutKbArticleCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type KbArticleUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<KbArticleCreateWithoutCommentsInput, KbArticleUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: KbArticleCreateOrConnectWithoutCommentsInput
    upsert?: KbArticleUpsertWithoutCommentsInput
    connect?: KbArticleWhereUniqueInput
    update?: XOR<XOR<KbArticleUpdateToOneWithWhereWithoutCommentsInput, KbArticleUpdateWithoutCommentsInput>, KbArticleUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutKbArticleCommentsNestedInput = {
    create?: XOR<UserCreateWithoutKbArticleCommentsInput, UserUncheckedCreateWithoutKbArticleCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutKbArticleCommentsInput
    upsert?: UserUpsertWithoutKbArticleCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutKbArticleCommentsInput, UserUpdateWithoutKbArticleCommentsInput>, UserUncheckedUpdateWithoutKbArticleCommentsInput>
  }

  export type UserCreateNestedOneWithoutSupport_tickets_support_tickets_assigneeIdTousersInput = {
    create?: XOR<UserCreateWithoutSupport_tickets_support_tickets_assigneeIdTousersInput, UserUncheckedCreateWithoutSupport_tickets_support_tickets_assigneeIdTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupport_tickets_support_tickets_assigneeIdTousersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSupport_tickets_support_tickets_userIdTousersInput = {
    create?: XOR<UserCreateWithoutSupport_tickets_support_tickets_userIdTousersInput, UserUncheckedCreateWithoutSupport_tickets_support_tickets_userIdTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupport_tickets_support_tickets_userIdTousersInput
    connect?: UserWhereUniqueInput
  }

  export type MailroomPackageCreateNestedManyWithoutTicketInput = {
    create?: XOR<MailroomPackageCreateWithoutTicketInput, MailroomPackageUncheckedCreateWithoutTicketInput> | MailroomPackageCreateWithoutTicketInput[] | MailroomPackageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: MailroomPackageCreateOrConnectWithoutTicketInput | MailroomPackageCreateOrConnectWithoutTicketInput[]
    createMany?: MailroomPackageCreateManyTicketInputEnvelope
    connect?: MailroomPackageWhereUniqueInput | MailroomPackageWhereUniqueInput[]
  }

  export type AssetTicketHistoryCreateNestedManyWithoutTicketInput = {
    create?: XOR<AssetTicketHistoryCreateWithoutTicketInput, AssetTicketHistoryUncheckedCreateWithoutTicketInput> | AssetTicketHistoryCreateWithoutTicketInput[] | AssetTicketHistoryUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: AssetTicketHistoryCreateOrConnectWithoutTicketInput | AssetTicketHistoryCreateOrConnectWithoutTicketInput[]
    createMany?: AssetTicketHistoryCreateManyTicketInputEnvelope
    connect?: AssetTicketHistoryWhereUniqueInput | AssetTicketHistoryWhereUniqueInput[]
  }

  export type RITMCreateNestedManyWithoutTicketInput = {
    create?: XOR<RITMCreateWithoutTicketInput, RITMUncheckedCreateWithoutTicketInput> | RITMCreateWithoutTicketInput[] | RITMUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: RITMCreateOrConnectWithoutTicketInput | RITMCreateOrConnectWithoutTicketInput[]
    createMany?: RITMCreateManyTicketInputEnvelope
    connect?: RITMWhereUniqueInput | RITMWhereUniqueInput[]
  }

  export type MailroomPackageUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<MailroomPackageCreateWithoutTicketInput, MailroomPackageUncheckedCreateWithoutTicketInput> | MailroomPackageCreateWithoutTicketInput[] | MailroomPackageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: MailroomPackageCreateOrConnectWithoutTicketInput | MailroomPackageCreateOrConnectWithoutTicketInput[]
    createMany?: MailroomPackageCreateManyTicketInputEnvelope
    connect?: MailroomPackageWhereUniqueInput | MailroomPackageWhereUniqueInput[]
  }

  export type AssetTicketHistoryUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<AssetTicketHistoryCreateWithoutTicketInput, AssetTicketHistoryUncheckedCreateWithoutTicketInput> | AssetTicketHistoryCreateWithoutTicketInput[] | AssetTicketHistoryUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: AssetTicketHistoryCreateOrConnectWithoutTicketInput | AssetTicketHistoryCreateOrConnectWithoutTicketInput[]
    createMany?: AssetTicketHistoryCreateManyTicketInputEnvelope
    connect?: AssetTicketHistoryWhereUniqueInput | AssetTicketHistoryWhereUniqueInput[]
  }

  export type RITMUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<RITMCreateWithoutTicketInput, RITMUncheckedCreateWithoutTicketInput> | RITMCreateWithoutTicketInput[] | RITMUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: RITMCreateOrConnectWithoutTicketInput | RITMCreateOrConnectWithoutTicketInput[]
    createMany?: RITMCreateManyTicketInputEnvelope
    connect?: RITMWhereUniqueInput | RITMWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutSupport_tickets_support_tickets_assigneeIdTousersNestedInput = {
    create?: XOR<UserCreateWithoutSupport_tickets_support_tickets_assigneeIdTousersInput, UserUncheckedCreateWithoutSupport_tickets_support_tickets_assigneeIdTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupport_tickets_support_tickets_assigneeIdTousersInput
    upsert?: UserUpsertWithoutSupport_tickets_support_tickets_assigneeIdTousersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSupport_tickets_support_tickets_assigneeIdTousersInput, UserUpdateWithoutSupport_tickets_support_tickets_assigneeIdTousersInput>, UserUncheckedUpdateWithoutSupport_tickets_support_tickets_assigneeIdTousersInput>
  }

  export type UserUpdateOneWithoutSupport_tickets_support_tickets_userIdTousersNestedInput = {
    create?: XOR<UserCreateWithoutSupport_tickets_support_tickets_userIdTousersInput, UserUncheckedCreateWithoutSupport_tickets_support_tickets_userIdTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupport_tickets_support_tickets_userIdTousersInput
    upsert?: UserUpsertWithoutSupport_tickets_support_tickets_userIdTousersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSupport_tickets_support_tickets_userIdTousersInput, UserUpdateWithoutSupport_tickets_support_tickets_userIdTousersInput>, UserUncheckedUpdateWithoutSupport_tickets_support_tickets_userIdTousersInput>
  }

  export type MailroomPackageUpdateManyWithoutTicketNestedInput = {
    create?: XOR<MailroomPackageCreateWithoutTicketInput, MailroomPackageUncheckedCreateWithoutTicketInput> | MailroomPackageCreateWithoutTicketInput[] | MailroomPackageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: MailroomPackageCreateOrConnectWithoutTicketInput | MailroomPackageCreateOrConnectWithoutTicketInput[]
    upsert?: MailroomPackageUpsertWithWhereUniqueWithoutTicketInput | MailroomPackageUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: MailroomPackageCreateManyTicketInputEnvelope
    set?: MailroomPackageWhereUniqueInput | MailroomPackageWhereUniqueInput[]
    disconnect?: MailroomPackageWhereUniqueInput | MailroomPackageWhereUniqueInput[]
    delete?: MailroomPackageWhereUniqueInput | MailroomPackageWhereUniqueInput[]
    connect?: MailroomPackageWhereUniqueInput | MailroomPackageWhereUniqueInput[]
    update?: MailroomPackageUpdateWithWhereUniqueWithoutTicketInput | MailroomPackageUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: MailroomPackageUpdateManyWithWhereWithoutTicketInput | MailroomPackageUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: MailroomPackageScalarWhereInput | MailroomPackageScalarWhereInput[]
  }

  export type AssetTicketHistoryUpdateManyWithoutTicketNestedInput = {
    create?: XOR<AssetTicketHistoryCreateWithoutTicketInput, AssetTicketHistoryUncheckedCreateWithoutTicketInput> | AssetTicketHistoryCreateWithoutTicketInput[] | AssetTicketHistoryUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: AssetTicketHistoryCreateOrConnectWithoutTicketInput | AssetTicketHistoryCreateOrConnectWithoutTicketInput[]
    upsert?: AssetTicketHistoryUpsertWithWhereUniqueWithoutTicketInput | AssetTicketHistoryUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: AssetTicketHistoryCreateManyTicketInputEnvelope
    set?: AssetTicketHistoryWhereUniqueInput | AssetTicketHistoryWhereUniqueInput[]
    disconnect?: AssetTicketHistoryWhereUniqueInput | AssetTicketHistoryWhereUniqueInput[]
    delete?: AssetTicketHistoryWhereUniqueInput | AssetTicketHistoryWhereUniqueInput[]
    connect?: AssetTicketHistoryWhereUniqueInput | AssetTicketHistoryWhereUniqueInput[]
    update?: AssetTicketHistoryUpdateWithWhereUniqueWithoutTicketInput | AssetTicketHistoryUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: AssetTicketHistoryUpdateManyWithWhereWithoutTicketInput | AssetTicketHistoryUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: AssetTicketHistoryScalarWhereInput | AssetTicketHistoryScalarWhereInput[]
  }

  export type RITMUpdateManyWithoutTicketNestedInput = {
    create?: XOR<RITMCreateWithoutTicketInput, RITMUncheckedCreateWithoutTicketInput> | RITMCreateWithoutTicketInput[] | RITMUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: RITMCreateOrConnectWithoutTicketInput | RITMCreateOrConnectWithoutTicketInput[]
    upsert?: RITMUpsertWithWhereUniqueWithoutTicketInput | RITMUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: RITMCreateManyTicketInputEnvelope
    set?: RITMWhereUniqueInput | RITMWhereUniqueInput[]
    disconnect?: RITMWhereUniqueInput | RITMWhereUniqueInput[]
    delete?: RITMWhereUniqueInput | RITMWhereUniqueInput[]
    connect?: RITMWhereUniqueInput | RITMWhereUniqueInput[]
    update?: RITMUpdateWithWhereUniqueWithoutTicketInput | RITMUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: RITMUpdateManyWithWhereWithoutTicketInput | RITMUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: RITMScalarWhereInput | RITMScalarWhereInput[]
  }

  export type MailroomPackageUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<MailroomPackageCreateWithoutTicketInput, MailroomPackageUncheckedCreateWithoutTicketInput> | MailroomPackageCreateWithoutTicketInput[] | MailroomPackageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: MailroomPackageCreateOrConnectWithoutTicketInput | MailroomPackageCreateOrConnectWithoutTicketInput[]
    upsert?: MailroomPackageUpsertWithWhereUniqueWithoutTicketInput | MailroomPackageUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: MailroomPackageCreateManyTicketInputEnvelope
    set?: MailroomPackageWhereUniqueInput | MailroomPackageWhereUniqueInput[]
    disconnect?: MailroomPackageWhereUniqueInput | MailroomPackageWhereUniqueInput[]
    delete?: MailroomPackageWhereUniqueInput | MailroomPackageWhereUniqueInput[]
    connect?: MailroomPackageWhereUniqueInput | MailroomPackageWhereUniqueInput[]
    update?: MailroomPackageUpdateWithWhereUniqueWithoutTicketInput | MailroomPackageUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: MailroomPackageUpdateManyWithWhereWithoutTicketInput | MailroomPackageUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: MailroomPackageScalarWhereInput | MailroomPackageScalarWhereInput[]
  }

  export type AssetTicketHistoryUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<AssetTicketHistoryCreateWithoutTicketInput, AssetTicketHistoryUncheckedCreateWithoutTicketInput> | AssetTicketHistoryCreateWithoutTicketInput[] | AssetTicketHistoryUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: AssetTicketHistoryCreateOrConnectWithoutTicketInput | AssetTicketHistoryCreateOrConnectWithoutTicketInput[]
    upsert?: AssetTicketHistoryUpsertWithWhereUniqueWithoutTicketInput | AssetTicketHistoryUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: AssetTicketHistoryCreateManyTicketInputEnvelope
    set?: AssetTicketHistoryWhereUniqueInput | AssetTicketHistoryWhereUniqueInput[]
    disconnect?: AssetTicketHistoryWhereUniqueInput | AssetTicketHistoryWhereUniqueInput[]
    delete?: AssetTicketHistoryWhereUniqueInput | AssetTicketHistoryWhereUniqueInput[]
    connect?: AssetTicketHistoryWhereUniqueInput | AssetTicketHistoryWhereUniqueInput[]
    update?: AssetTicketHistoryUpdateWithWhereUniqueWithoutTicketInput | AssetTicketHistoryUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: AssetTicketHistoryUpdateManyWithWhereWithoutTicketInput | AssetTicketHistoryUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: AssetTicketHistoryScalarWhereInput | AssetTicketHistoryScalarWhereInput[]
  }

  export type RITMUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<RITMCreateWithoutTicketInput, RITMUncheckedCreateWithoutTicketInput> | RITMCreateWithoutTicketInput[] | RITMUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: RITMCreateOrConnectWithoutTicketInput | RITMCreateOrConnectWithoutTicketInput[]
    upsert?: RITMUpsertWithWhereUniqueWithoutTicketInput | RITMUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: RITMCreateManyTicketInputEnvelope
    set?: RITMWhereUniqueInput | RITMWhereUniqueInput[]
    disconnect?: RITMWhereUniqueInput | RITMWhereUniqueInput[]
    delete?: RITMWhereUniqueInput | RITMWhereUniqueInput[]
    connect?: RITMWhereUniqueInput | RITMWhereUniqueInput[]
    update?: RITMUpdateWithWhereUniqueWithoutTicketInput | RITMUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: RITMUpdateManyWithWhereWithoutTicketInput | RITMUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: RITMScalarWhereInput | RITMScalarWhereInput[]
  }

  export type AssetStatusLogCreateNestedManyWithoutAssetInput = {
    create?: XOR<AssetStatusLogCreateWithoutAssetInput, AssetStatusLogUncheckedCreateWithoutAssetInput> | AssetStatusLogCreateWithoutAssetInput[] | AssetStatusLogUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetStatusLogCreateOrConnectWithoutAssetInput | AssetStatusLogCreateOrConnectWithoutAssetInput[]
    createMany?: AssetStatusLogCreateManyAssetInputEnvelope
    connect?: AssetStatusLogWhereUniqueInput | AssetStatusLogWhereUniqueInput[]
  }

  export type AssetAssignmentCreateNestedManyWithoutAssetInput = {
    create?: XOR<AssetAssignmentCreateWithoutAssetInput, AssetAssignmentUncheckedCreateWithoutAssetInput> | AssetAssignmentCreateWithoutAssetInput[] | AssetAssignmentUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetAssignmentCreateOrConnectWithoutAssetInput | AssetAssignmentCreateOrConnectWithoutAssetInput[]
    createMany?: AssetAssignmentCreateManyAssetInputEnvelope
    connect?: AssetAssignmentWhereUniqueInput | AssetAssignmentWhereUniqueInput[]
  }

  export type MailroomPackageCreateNestedManyWithoutAssetInput = {
    create?: XOR<MailroomPackageCreateWithoutAssetInput, MailroomPackageUncheckedCreateWithoutAssetInput> | MailroomPackageCreateWithoutAssetInput[] | MailroomPackageUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: MailroomPackageCreateOrConnectWithoutAssetInput | MailroomPackageCreateOrConnectWithoutAssetInput[]
    createMany?: MailroomPackageCreateManyAssetInputEnvelope
    connect?: MailroomPackageWhereUniqueInput | MailroomPackageWhereUniqueInput[]
  }

  export type AssetTicketHistoryCreateNestedManyWithoutAssetInput = {
    create?: XOR<AssetTicketHistoryCreateWithoutAssetInput, AssetTicketHistoryUncheckedCreateWithoutAssetInput> | AssetTicketHistoryCreateWithoutAssetInput[] | AssetTicketHistoryUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetTicketHistoryCreateOrConnectWithoutAssetInput | AssetTicketHistoryCreateOrConnectWithoutAssetInput[]
    createMany?: AssetTicketHistoryCreateManyAssetInputEnvelope
    connect?: AssetTicketHistoryWhereUniqueInput | AssetTicketHistoryWhereUniqueInput[]
  }

  export type AssetWarrantyAlertCreateNestedManyWithoutAssetInput = {
    create?: XOR<AssetWarrantyAlertCreateWithoutAssetInput, AssetWarrantyAlertUncheckedCreateWithoutAssetInput> | AssetWarrantyAlertCreateWithoutAssetInput[] | AssetWarrantyAlertUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetWarrantyAlertCreateOrConnectWithoutAssetInput | AssetWarrantyAlertCreateOrConnectWithoutAssetInput[]
    createMany?: AssetWarrantyAlertCreateManyAssetInputEnvelope
    connect?: AssetWarrantyAlertWhereUniqueInput | AssetWarrantyAlertWhereUniqueInput[]
  }

  export type KioskAssetRegistryCreateNestedManyWithoutAssetInput = {
    create?: XOR<KioskAssetRegistryCreateWithoutAssetInput, KioskAssetRegistryUncheckedCreateWithoutAssetInput> | KioskAssetRegistryCreateWithoutAssetInput[] | KioskAssetRegistryUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: KioskAssetRegistryCreateOrConnectWithoutAssetInput | KioskAssetRegistryCreateOrConnectWithoutAssetInput[]
    createMany?: KioskAssetRegistryCreateManyAssetInputEnvelope
    connect?: KioskAssetRegistryWhereUniqueInput | KioskAssetRegistryWhereUniqueInput[]
  }

  export type AssetValidationLogCreateNestedManyWithoutAssetInput = {
    create?: XOR<AssetValidationLogCreateWithoutAssetInput, AssetValidationLogUncheckedCreateWithoutAssetInput> | AssetValidationLogCreateWithoutAssetInput[] | AssetValidationLogUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetValidationLogCreateOrConnectWithoutAssetInput | AssetValidationLogCreateOrConnectWithoutAssetInput[]
    createMany?: AssetValidationLogCreateManyAssetInputEnvelope
    connect?: AssetValidationLogWhereUniqueInput | AssetValidationLogWhereUniqueInput[]
  }

  export type HelixSyncFailureCreateNestedManyWithoutAssetInput = {
    create?: XOR<HelixSyncFailureCreateWithoutAssetInput, HelixSyncFailureUncheckedCreateWithoutAssetInput> | HelixSyncFailureCreateWithoutAssetInput[] | HelixSyncFailureUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: HelixSyncFailureCreateOrConnectWithoutAssetInput | HelixSyncFailureCreateOrConnectWithoutAssetInput[]
    createMany?: HelixSyncFailureCreateManyAssetInputEnvelope
    connect?: HelixSyncFailureWhereUniqueInput | HelixSyncFailureWhereUniqueInput[]
  }

  export type AssetImportBatchCreateNestedOneWithoutAssetsInput = {
    create?: XOR<AssetImportBatchCreateWithoutAssetsInput, AssetImportBatchUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: AssetImportBatchCreateOrConnectWithoutAssetsInput
    connect?: AssetImportBatchWhereUniqueInput
  }

  export type AssetStatusLogUncheckedCreateNestedManyWithoutAssetInput = {
    create?: XOR<AssetStatusLogCreateWithoutAssetInput, AssetStatusLogUncheckedCreateWithoutAssetInput> | AssetStatusLogCreateWithoutAssetInput[] | AssetStatusLogUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetStatusLogCreateOrConnectWithoutAssetInput | AssetStatusLogCreateOrConnectWithoutAssetInput[]
    createMany?: AssetStatusLogCreateManyAssetInputEnvelope
    connect?: AssetStatusLogWhereUniqueInput | AssetStatusLogWhereUniqueInput[]
  }

  export type AssetAssignmentUncheckedCreateNestedManyWithoutAssetInput = {
    create?: XOR<AssetAssignmentCreateWithoutAssetInput, AssetAssignmentUncheckedCreateWithoutAssetInput> | AssetAssignmentCreateWithoutAssetInput[] | AssetAssignmentUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetAssignmentCreateOrConnectWithoutAssetInput | AssetAssignmentCreateOrConnectWithoutAssetInput[]
    createMany?: AssetAssignmentCreateManyAssetInputEnvelope
    connect?: AssetAssignmentWhereUniqueInput | AssetAssignmentWhereUniqueInput[]
  }

  export type MailroomPackageUncheckedCreateNestedManyWithoutAssetInput = {
    create?: XOR<MailroomPackageCreateWithoutAssetInput, MailroomPackageUncheckedCreateWithoutAssetInput> | MailroomPackageCreateWithoutAssetInput[] | MailroomPackageUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: MailroomPackageCreateOrConnectWithoutAssetInput | MailroomPackageCreateOrConnectWithoutAssetInput[]
    createMany?: MailroomPackageCreateManyAssetInputEnvelope
    connect?: MailroomPackageWhereUniqueInput | MailroomPackageWhereUniqueInput[]
  }

  export type AssetTicketHistoryUncheckedCreateNestedManyWithoutAssetInput = {
    create?: XOR<AssetTicketHistoryCreateWithoutAssetInput, AssetTicketHistoryUncheckedCreateWithoutAssetInput> | AssetTicketHistoryCreateWithoutAssetInput[] | AssetTicketHistoryUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetTicketHistoryCreateOrConnectWithoutAssetInput | AssetTicketHistoryCreateOrConnectWithoutAssetInput[]
    createMany?: AssetTicketHistoryCreateManyAssetInputEnvelope
    connect?: AssetTicketHistoryWhereUniqueInput | AssetTicketHistoryWhereUniqueInput[]
  }

  export type AssetWarrantyAlertUncheckedCreateNestedManyWithoutAssetInput = {
    create?: XOR<AssetWarrantyAlertCreateWithoutAssetInput, AssetWarrantyAlertUncheckedCreateWithoutAssetInput> | AssetWarrantyAlertCreateWithoutAssetInput[] | AssetWarrantyAlertUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetWarrantyAlertCreateOrConnectWithoutAssetInput | AssetWarrantyAlertCreateOrConnectWithoutAssetInput[]
    createMany?: AssetWarrantyAlertCreateManyAssetInputEnvelope
    connect?: AssetWarrantyAlertWhereUniqueInput | AssetWarrantyAlertWhereUniqueInput[]
  }

  export type KioskAssetRegistryUncheckedCreateNestedManyWithoutAssetInput = {
    create?: XOR<KioskAssetRegistryCreateWithoutAssetInput, KioskAssetRegistryUncheckedCreateWithoutAssetInput> | KioskAssetRegistryCreateWithoutAssetInput[] | KioskAssetRegistryUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: KioskAssetRegistryCreateOrConnectWithoutAssetInput | KioskAssetRegistryCreateOrConnectWithoutAssetInput[]
    createMany?: KioskAssetRegistryCreateManyAssetInputEnvelope
    connect?: KioskAssetRegistryWhereUniqueInput | KioskAssetRegistryWhereUniqueInput[]
  }

  export type AssetValidationLogUncheckedCreateNestedManyWithoutAssetInput = {
    create?: XOR<AssetValidationLogCreateWithoutAssetInput, AssetValidationLogUncheckedCreateWithoutAssetInput> | AssetValidationLogCreateWithoutAssetInput[] | AssetValidationLogUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetValidationLogCreateOrConnectWithoutAssetInput | AssetValidationLogCreateOrConnectWithoutAssetInput[]
    createMany?: AssetValidationLogCreateManyAssetInputEnvelope
    connect?: AssetValidationLogWhereUniqueInput | AssetValidationLogWhereUniqueInput[]
  }

  export type HelixSyncFailureUncheckedCreateNestedManyWithoutAssetInput = {
    create?: XOR<HelixSyncFailureCreateWithoutAssetInput, HelixSyncFailureUncheckedCreateWithoutAssetInput> | HelixSyncFailureCreateWithoutAssetInput[] | HelixSyncFailureUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: HelixSyncFailureCreateOrConnectWithoutAssetInput | HelixSyncFailureCreateOrConnectWithoutAssetInput[]
    createMany?: HelixSyncFailureCreateManyAssetInputEnvelope
    connect?: HelixSyncFailureWhereUniqueInput | HelixSyncFailureWhereUniqueInput[]
  }

  export type AssetStatusLogUpdateManyWithoutAssetNestedInput = {
    create?: XOR<AssetStatusLogCreateWithoutAssetInput, AssetStatusLogUncheckedCreateWithoutAssetInput> | AssetStatusLogCreateWithoutAssetInput[] | AssetStatusLogUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetStatusLogCreateOrConnectWithoutAssetInput | AssetStatusLogCreateOrConnectWithoutAssetInput[]
    upsert?: AssetStatusLogUpsertWithWhereUniqueWithoutAssetInput | AssetStatusLogUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: AssetStatusLogCreateManyAssetInputEnvelope
    set?: AssetStatusLogWhereUniqueInput | AssetStatusLogWhereUniqueInput[]
    disconnect?: AssetStatusLogWhereUniqueInput | AssetStatusLogWhereUniqueInput[]
    delete?: AssetStatusLogWhereUniqueInput | AssetStatusLogWhereUniqueInput[]
    connect?: AssetStatusLogWhereUniqueInput | AssetStatusLogWhereUniqueInput[]
    update?: AssetStatusLogUpdateWithWhereUniqueWithoutAssetInput | AssetStatusLogUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: AssetStatusLogUpdateManyWithWhereWithoutAssetInput | AssetStatusLogUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: AssetStatusLogScalarWhereInput | AssetStatusLogScalarWhereInput[]
  }

  export type AssetAssignmentUpdateManyWithoutAssetNestedInput = {
    create?: XOR<AssetAssignmentCreateWithoutAssetInput, AssetAssignmentUncheckedCreateWithoutAssetInput> | AssetAssignmentCreateWithoutAssetInput[] | AssetAssignmentUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetAssignmentCreateOrConnectWithoutAssetInput | AssetAssignmentCreateOrConnectWithoutAssetInput[]
    upsert?: AssetAssignmentUpsertWithWhereUniqueWithoutAssetInput | AssetAssignmentUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: AssetAssignmentCreateManyAssetInputEnvelope
    set?: AssetAssignmentWhereUniqueInput | AssetAssignmentWhereUniqueInput[]
    disconnect?: AssetAssignmentWhereUniqueInput | AssetAssignmentWhereUniqueInput[]
    delete?: AssetAssignmentWhereUniqueInput | AssetAssignmentWhereUniqueInput[]
    connect?: AssetAssignmentWhereUniqueInput | AssetAssignmentWhereUniqueInput[]
    update?: AssetAssignmentUpdateWithWhereUniqueWithoutAssetInput | AssetAssignmentUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: AssetAssignmentUpdateManyWithWhereWithoutAssetInput | AssetAssignmentUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: AssetAssignmentScalarWhereInput | AssetAssignmentScalarWhereInput[]
  }

  export type MailroomPackageUpdateManyWithoutAssetNestedInput = {
    create?: XOR<MailroomPackageCreateWithoutAssetInput, MailroomPackageUncheckedCreateWithoutAssetInput> | MailroomPackageCreateWithoutAssetInput[] | MailroomPackageUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: MailroomPackageCreateOrConnectWithoutAssetInput | MailroomPackageCreateOrConnectWithoutAssetInput[]
    upsert?: MailroomPackageUpsertWithWhereUniqueWithoutAssetInput | MailroomPackageUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: MailroomPackageCreateManyAssetInputEnvelope
    set?: MailroomPackageWhereUniqueInput | MailroomPackageWhereUniqueInput[]
    disconnect?: MailroomPackageWhereUniqueInput | MailroomPackageWhereUniqueInput[]
    delete?: MailroomPackageWhereUniqueInput | MailroomPackageWhereUniqueInput[]
    connect?: MailroomPackageWhereUniqueInput | MailroomPackageWhereUniqueInput[]
    update?: MailroomPackageUpdateWithWhereUniqueWithoutAssetInput | MailroomPackageUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: MailroomPackageUpdateManyWithWhereWithoutAssetInput | MailroomPackageUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: MailroomPackageScalarWhereInput | MailroomPackageScalarWhereInput[]
  }

  export type AssetTicketHistoryUpdateManyWithoutAssetNestedInput = {
    create?: XOR<AssetTicketHistoryCreateWithoutAssetInput, AssetTicketHistoryUncheckedCreateWithoutAssetInput> | AssetTicketHistoryCreateWithoutAssetInput[] | AssetTicketHistoryUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetTicketHistoryCreateOrConnectWithoutAssetInput | AssetTicketHistoryCreateOrConnectWithoutAssetInput[]
    upsert?: AssetTicketHistoryUpsertWithWhereUniqueWithoutAssetInput | AssetTicketHistoryUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: AssetTicketHistoryCreateManyAssetInputEnvelope
    set?: AssetTicketHistoryWhereUniqueInput | AssetTicketHistoryWhereUniqueInput[]
    disconnect?: AssetTicketHistoryWhereUniqueInput | AssetTicketHistoryWhereUniqueInput[]
    delete?: AssetTicketHistoryWhereUniqueInput | AssetTicketHistoryWhereUniqueInput[]
    connect?: AssetTicketHistoryWhereUniqueInput | AssetTicketHistoryWhereUniqueInput[]
    update?: AssetTicketHistoryUpdateWithWhereUniqueWithoutAssetInput | AssetTicketHistoryUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: AssetTicketHistoryUpdateManyWithWhereWithoutAssetInput | AssetTicketHistoryUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: AssetTicketHistoryScalarWhereInput | AssetTicketHistoryScalarWhereInput[]
  }

  export type AssetWarrantyAlertUpdateManyWithoutAssetNestedInput = {
    create?: XOR<AssetWarrantyAlertCreateWithoutAssetInput, AssetWarrantyAlertUncheckedCreateWithoutAssetInput> | AssetWarrantyAlertCreateWithoutAssetInput[] | AssetWarrantyAlertUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetWarrantyAlertCreateOrConnectWithoutAssetInput | AssetWarrantyAlertCreateOrConnectWithoutAssetInput[]
    upsert?: AssetWarrantyAlertUpsertWithWhereUniqueWithoutAssetInput | AssetWarrantyAlertUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: AssetWarrantyAlertCreateManyAssetInputEnvelope
    set?: AssetWarrantyAlertWhereUniqueInput | AssetWarrantyAlertWhereUniqueInput[]
    disconnect?: AssetWarrantyAlertWhereUniqueInput | AssetWarrantyAlertWhereUniqueInput[]
    delete?: AssetWarrantyAlertWhereUniqueInput | AssetWarrantyAlertWhereUniqueInput[]
    connect?: AssetWarrantyAlertWhereUniqueInput | AssetWarrantyAlertWhereUniqueInput[]
    update?: AssetWarrantyAlertUpdateWithWhereUniqueWithoutAssetInput | AssetWarrantyAlertUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: AssetWarrantyAlertUpdateManyWithWhereWithoutAssetInput | AssetWarrantyAlertUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: AssetWarrantyAlertScalarWhereInput | AssetWarrantyAlertScalarWhereInput[]
  }

  export type KioskAssetRegistryUpdateManyWithoutAssetNestedInput = {
    create?: XOR<KioskAssetRegistryCreateWithoutAssetInput, KioskAssetRegistryUncheckedCreateWithoutAssetInput> | KioskAssetRegistryCreateWithoutAssetInput[] | KioskAssetRegistryUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: KioskAssetRegistryCreateOrConnectWithoutAssetInput | KioskAssetRegistryCreateOrConnectWithoutAssetInput[]
    upsert?: KioskAssetRegistryUpsertWithWhereUniqueWithoutAssetInput | KioskAssetRegistryUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: KioskAssetRegistryCreateManyAssetInputEnvelope
    set?: KioskAssetRegistryWhereUniqueInput | KioskAssetRegistryWhereUniqueInput[]
    disconnect?: KioskAssetRegistryWhereUniqueInput | KioskAssetRegistryWhereUniqueInput[]
    delete?: KioskAssetRegistryWhereUniqueInput | KioskAssetRegistryWhereUniqueInput[]
    connect?: KioskAssetRegistryWhereUniqueInput | KioskAssetRegistryWhereUniqueInput[]
    update?: KioskAssetRegistryUpdateWithWhereUniqueWithoutAssetInput | KioskAssetRegistryUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: KioskAssetRegistryUpdateManyWithWhereWithoutAssetInput | KioskAssetRegistryUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: KioskAssetRegistryScalarWhereInput | KioskAssetRegistryScalarWhereInput[]
  }

  export type AssetValidationLogUpdateManyWithoutAssetNestedInput = {
    create?: XOR<AssetValidationLogCreateWithoutAssetInput, AssetValidationLogUncheckedCreateWithoutAssetInput> | AssetValidationLogCreateWithoutAssetInput[] | AssetValidationLogUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetValidationLogCreateOrConnectWithoutAssetInput | AssetValidationLogCreateOrConnectWithoutAssetInput[]
    upsert?: AssetValidationLogUpsertWithWhereUniqueWithoutAssetInput | AssetValidationLogUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: AssetValidationLogCreateManyAssetInputEnvelope
    set?: AssetValidationLogWhereUniqueInput | AssetValidationLogWhereUniqueInput[]
    disconnect?: AssetValidationLogWhereUniqueInput | AssetValidationLogWhereUniqueInput[]
    delete?: AssetValidationLogWhereUniqueInput | AssetValidationLogWhereUniqueInput[]
    connect?: AssetValidationLogWhereUniqueInput | AssetValidationLogWhereUniqueInput[]
    update?: AssetValidationLogUpdateWithWhereUniqueWithoutAssetInput | AssetValidationLogUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: AssetValidationLogUpdateManyWithWhereWithoutAssetInput | AssetValidationLogUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: AssetValidationLogScalarWhereInput | AssetValidationLogScalarWhereInput[]
  }

  export type HelixSyncFailureUpdateManyWithoutAssetNestedInput = {
    create?: XOR<HelixSyncFailureCreateWithoutAssetInput, HelixSyncFailureUncheckedCreateWithoutAssetInput> | HelixSyncFailureCreateWithoutAssetInput[] | HelixSyncFailureUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: HelixSyncFailureCreateOrConnectWithoutAssetInput | HelixSyncFailureCreateOrConnectWithoutAssetInput[]
    upsert?: HelixSyncFailureUpsertWithWhereUniqueWithoutAssetInput | HelixSyncFailureUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: HelixSyncFailureCreateManyAssetInputEnvelope
    set?: HelixSyncFailureWhereUniqueInput | HelixSyncFailureWhereUniqueInput[]
    disconnect?: HelixSyncFailureWhereUniqueInput | HelixSyncFailureWhereUniqueInput[]
    delete?: HelixSyncFailureWhereUniqueInput | HelixSyncFailureWhereUniqueInput[]
    connect?: HelixSyncFailureWhereUniqueInput | HelixSyncFailureWhereUniqueInput[]
    update?: HelixSyncFailureUpdateWithWhereUniqueWithoutAssetInput | HelixSyncFailureUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: HelixSyncFailureUpdateManyWithWhereWithoutAssetInput | HelixSyncFailureUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: HelixSyncFailureScalarWhereInput | HelixSyncFailureScalarWhereInput[]
  }

  export type AssetImportBatchUpdateOneWithoutAssetsNestedInput = {
    create?: XOR<AssetImportBatchCreateWithoutAssetsInput, AssetImportBatchUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: AssetImportBatchCreateOrConnectWithoutAssetsInput
    upsert?: AssetImportBatchUpsertWithoutAssetsInput
    disconnect?: AssetImportBatchWhereInput | boolean
    delete?: AssetImportBatchWhereInput | boolean
    connect?: AssetImportBatchWhereUniqueInput
    update?: XOR<XOR<AssetImportBatchUpdateToOneWithWhereWithoutAssetsInput, AssetImportBatchUpdateWithoutAssetsInput>, AssetImportBatchUncheckedUpdateWithoutAssetsInput>
  }

  export type AssetStatusLogUncheckedUpdateManyWithoutAssetNestedInput = {
    create?: XOR<AssetStatusLogCreateWithoutAssetInput, AssetStatusLogUncheckedCreateWithoutAssetInput> | AssetStatusLogCreateWithoutAssetInput[] | AssetStatusLogUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetStatusLogCreateOrConnectWithoutAssetInput | AssetStatusLogCreateOrConnectWithoutAssetInput[]
    upsert?: AssetStatusLogUpsertWithWhereUniqueWithoutAssetInput | AssetStatusLogUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: AssetStatusLogCreateManyAssetInputEnvelope
    set?: AssetStatusLogWhereUniqueInput | AssetStatusLogWhereUniqueInput[]
    disconnect?: AssetStatusLogWhereUniqueInput | AssetStatusLogWhereUniqueInput[]
    delete?: AssetStatusLogWhereUniqueInput | AssetStatusLogWhereUniqueInput[]
    connect?: AssetStatusLogWhereUniqueInput | AssetStatusLogWhereUniqueInput[]
    update?: AssetStatusLogUpdateWithWhereUniqueWithoutAssetInput | AssetStatusLogUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: AssetStatusLogUpdateManyWithWhereWithoutAssetInput | AssetStatusLogUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: AssetStatusLogScalarWhereInput | AssetStatusLogScalarWhereInput[]
  }

  export type AssetAssignmentUncheckedUpdateManyWithoutAssetNestedInput = {
    create?: XOR<AssetAssignmentCreateWithoutAssetInput, AssetAssignmentUncheckedCreateWithoutAssetInput> | AssetAssignmentCreateWithoutAssetInput[] | AssetAssignmentUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetAssignmentCreateOrConnectWithoutAssetInput | AssetAssignmentCreateOrConnectWithoutAssetInput[]
    upsert?: AssetAssignmentUpsertWithWhereUniqueWithoutAssetInput | AssetAssignmentUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: AssetAssignmentCreateManyAssetInputEnvelope
    set?: AssetAssignmentWhereUniqueInput | AssetAssignmentWhereUniqueInput[]
    disconnect?: AssetAssignmentWhereUniqueInput | AssetAssignmentWhereUniqueInput[]
    delete?: AssetAssignmentWhereUniqueInput | AssetAssignmentWhereUniqueInput[]
    connect?: AssetAssignmentWhereUniqueInput | AssetAssignmentWhereUniqueInput[]
    update?: AssetAssignmentUpdateWithWhereUniqueWithoutAssetInput | AssetAssignmentUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: AssetAssignmentUpdateManyWithWhereWithoutAssetInput | AssetAssignmentUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: AssetAssignmentScalarWhereInput | AssetAssignmentScalarWhereInput[]
  }

  export type MailroomPackageUncheckedUpdateManyWithoutAssetNestedInput = {
    create?: XOR<MailroomPackageCreateWithoutAssetInput, MailroomPackageUncheckedCreateWithoutAssetInput> | MailroomPackageCreateWithoutAssetInput[] | MailroomPackageUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: MailroomPackageCreateOrConnectWithoutAssetInput | MailroomPackageCreateOrConnectWithoutAssetInput[]
    upsert?: MailroomPackageUpsertWithWhereUniqueWithoutAssetInput | MailroomPackageUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: MailroomPackageCreateManyAssetInputEnvelope
    set?: MailroomPackageWhereUniqueInput | MailroomPackageWhereUniqueInput[]
    disconnect?: MailroomPackageWhereUniqueInput | MailroomPackageWhereUniqueInput[]
    delete?: MailroomPackageWhereUniqueInput | MailroomPackageWhereUniqueInput[]
    connect?: MailroomPackageWhereUniqueInput | MailroomPackageWhereUniqueInput[]
    update?: MailroomPackageUpdateWithWhereUniqueWithoutAssetInput | MailroomPackageUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: MailroomPackageUpdateManyWithWhereWithoutAssetInput | MailroomPackageUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: MailroomPackageScalarWhereInput | MailroomPackageScalarWhereInput[]
  }

  export type AssetTicketHistoryUncheckedUpdateManyWithoutAssetNestedInput = {
    create?: XOR<AssetTicketHistoryCreateWithoutAssetInput, AssetTicketHistoryUncheckedCreateWithoutAssetInput> | AssetTicketHistoryCreateWithoutAssetInput[] | AssetTicketHistoryUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetTicketHistoryCreateOrConnectWithoutAssetInput | AssetTicketHistoryCreateOrConnectWithoutAssetInput[]
    upsert?: AssetTicketHistoryUpsertWithWhereUniqueWithoutAssetInput | AssetTicketHistoryUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: AssetTicketHistoryCreateManyAssetInputEnvelope
    set?: AssetTicketHistoryWhereUniqueInput | AssetTicketHistoryWhereUniqueInput[]
    disconnect?: AssetTicketHistoryWhereUniqueInput | AssetTicketHistoryWhereUniqueInput[]
    delete?: AssetTicketHistoryWhereUniqueInput | AssetTicketHistoryWhereUniqueInput[]
    connect?: AssetTicketHistoryWhereUniqueInput | AssetTicketHistoryWhereUniqueInput[]
    update?: AssetTicketHistoryUpdateWithWhereUniqueWithoutAssetInput | AssetTicketHistoryUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: AssetTicketHistoryUpdateManyWithWhereWithoutAssetInput | AssetTicketHistoryUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: AssetTicketHistoryScalarWhereInput | AssetTicketHistoryScalarWhereInput[]
  }

  export type AssetWarrantyAlertUncheckedUpdateManyWithoutAssetNestedInput = {
    create?: XOR<AssetWarrantyAlertCreateWithoutAssetInput, AssetWarrantyAlertUncheckedCreateWithoutAssetInput> | AssetWarrantyAlertCreateWithoutAssetInput[] | AssetWarrantyAlertUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetWarrantyAlertCreateOrConnectWithoutAssetInput | AssetWarrantyAlertCreateOrConnectWithoutAssetInput[]
    upsert?: AssetWarrantyAlertUpsertWithWhereUniqueWithoutAssetInput | AssetWarrantyAlertUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: AssetWarrantyAlertCreateManyAssetInputEnvelope
    set?: AssetWarrantyAlertWhereUniqueInput | AssetWarrantyAlertWhereUniqueInput[]
    disconnect?: AssetWarrantyAlertWhereUniqueInput | AssetWarrantyAlertWhereUniqueInput[]
    delete?: AssetWarrantyAlertWhereUniqueInput | AssetWarrantyAlertWhereUniqueInput[]
    connect?: AssetWarrantyAlertWhereUniqueInput | AssetWarrantyAlertWhereUniqueInput[]
    update?: AssetWarrantyAlertUpdateWithWhereUniqueWithoutAssetInput | AssetWarrantyAlertUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: AssetWarrantyAlertUpdateManyWithWhereWithoutAssetInput | AssetWarrantyAlertUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: AssetWarrantyAlertScalarWhereInput | AssetWarrantyAlertScalarWhereInput[]
  }

  export type KioskAssetRegistryUncheckedUpdateManyWithoutAssetNestedInput = {
    create?: XOR<KioskAssetRegistryCreateWithoutAssetInput, KioskAssetRegistryUncheckedCreateWithoutAssetInput> | KioskAssetRegistryCreateWithoutAssetInput[] | KioskAssetRegistryUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: KioskAssetRegistryCreateOrConnectWithoutAssetInput | KioskAssetRegistryCreateOrConnectWithoutAssetInput[]
    upsert?: KioskAssetRegistryUpsertWithWhereUniqueWithoutAssetInput | KioskAssetRegistryUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: KioskAssetRegistryCreateManyAssetInputEnvelope
    set?: KioskAssetRegistryWhereUniqueInput | KioskAssetRegistryWhereUniqueInput[]
    disconnect?: KioskAssetRegistryWhereUniqueInput | KioskAssetRegistryWhereUniqueInput[]
    delete?: KioskAssetRegistryWhereUniqueInput | KioskAssetRegistryWhereUniqueInput[]
    connect?: KioskAssetRegistryWhereUniqueInput | KioskAssetRegistryWhereUniqueInput[]
    update?: KioskAssetRegistryUpdateWithWhereUniqueWithoutAssetInput | KioskAssetRegistryUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: KioskAssetRegistryUpdateManyWithWhereWithoutAssetInput | KioskAssetRegistryUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: KioskAssetRegistryScalarWhereInput | KioskAssetRegistryScalarWhereInput[]
  }

  export type AssetValidationLogUncheckedUpdateManyWithoutAssetNestedInput = {
    create?: XOR<AssetValidationLogCreateWithoutAssetInput, AssetValidationLogUncheckedCreateWithoutAssetInput> | AssetValidationLogCreateWithoutAssetInput[] | AssetValidationLogUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetValidationLogCreateOrConnectWithoutAssetInput | AssetValidationLogCreateOrConnectWithoutAssetInput[]
    upsert?: AssetValidationLogUpsertWithWhereUniqueWithoutAssetInput | AssetValidationLogUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: AssetValidationLogCreateManyAssetInputEnvelope
    set?: AssetValidationLogWhereUniqueInput | AssetValidationLogWhereUniqueInput[]
    disconnect?: AssetValidationLogWhereUniqueInput | AssetValidationLogWhereUniqueInput[]
    delete?: AssetValidationLogWhereUniqueInput | AssetValidationLogWhereUniqueInput[]
    connect?: AssetValidationLogWhereUniqueInput | AssetValidationLogWhereUniqueInput[]
    update?: AssetValidationLogUpdateWithWhereUniqueWithoutAssetInput | AssetValidationLogUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: AssetValidationLogUpdateManyWithWhereWithoutAssetInput | AssetValidationLogUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: AssetValidationLogScalarWhereInput | AssetValidationLogScalarWhereInput[]
  }

  export type HelixSyncFailureUncheckedUpdateManyWithoutAssetNestedInput = {
    create?: XOR<HelixSyncFailureCreateWithoutAssetInput, HelixSyncFailureUncheckedCreateWithoutAssetInput> | HelixSyncFailureCreateWithoutAssetInput[] | HelixSyncFailureUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: HelixSyncFailureCreateOrConnectWithoutAssetInput | HelixSyncFailureCreateOrConnectWithoutAssetInput[]
    upsert?: HelixSyncFailureUpsertWithWhereUniqueWithoutAssetInput | HelixSyncFailureUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: HelixSyncFailureCreateManyAssetInputEnvelope
    set?: HelixSyncFailureWhereUniqueInput | HelixSyncFailureWhereUniqueInput[]
    disconnect?: HelixSyncFailureWhereUniqueInput | HelixSyncFailureWhereUniqueInput[]
    delete?: HelixSyncFailureWhereUniqueInput | HelixSyncFailureWhereUniqueInput[]
    connect?: HelixSyncFailureWhereUniqueInput | HelixSyncFailureWhereUniqueInput[]
    update?: HelixSyncFailureUpdateWithWhereUniqueWithoutAssetInput | HelixSyncFailureUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: HelixSyncFailureUpdateManyWithWhereWithoutAssetInput | HelixSyncFailureUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: HelixSyncFailureScalarWhereInput | HelixSyncFailureScalarWhereInput[]
  }

  export type InventoryAssetCreateNestedOneWithoutStatusLogsInput = {
    create?: XOR<InventoryAssetCreateWithoutStatusLogsInput, InventoryAssetUncheckedCreateWithoutStatusLogsInput>
    connectOrCreate?: InventoryAssetCreateOrConnectWithoutStatusLogsInput
    connect?: InventoryAssetWhereUniqueInput
  }

  export type InventoryAssetUpdateOneRequiredWithoutStatusLogsNestedInput = {
    create?: XOR<InventoryAssetCreateWithoutStatusLogsInput, InventoryAssetUncheckedCreateWithoutStatusLogsInput>
    connectOrCreate?: InventoryAssetCreateOrConnectWithoutStatusLogsInput
    upsert?: InventoryAssetUpsertWithoutStatusLogsInput
    connect?: InventoryAssetWhereUniqueInput
    update?: XOR<XOR<InventoryAssetUpdateToOneWithWhereWithoutStatusLogsInput, InventoryAssetUpdateWithoutStatusLogsInput>, InventoryAssetUncheckedUpdateWithoutStatusLogsInput>
  }

  export type InventoryAssetCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<InventoryAssetCreateWithoutAssignmentsInput, InventoryAssetUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: InventoryAssetCreateOrConnectWithoutAssignmentsInput
    connect?: InventoryAssetWhereUniqueInput
  }

  export type InventoryAssetUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<InventoryAssetCreateWithoutAssignmentsInput, InventoryAssetUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: InventoryAssetCreateOrConnectWithoutAssignmentsInput
    upsert?: InventoryAssetUpsertWithoutAssignmentsInput
    connect?: InventoryAssetWhereUniqueInput
    update?: XOR<XOR<InventoryAssetUpdateToOneWithWhereWithoutAssignmentsInput, InventoryAssetUpdateWithoutAssignmentsInput>, InventoryAssetUncheckedUpdateWithoutAssignmentsInput>
  }

  export type InventoryAssetCreateNestedOneWithoutTicketHistoryInput = {
    create?: XOR<InventoryAssetCreateWithoutTicketHistoryInput, InventoryAssetUncheckedCreateWithoutTicketHistoryInput>
    connectOrCreate?: InventoryAssetCreateOrConnectWithoutTicketHistoryInput
    connect?: InventoryAssetWhereUniqueInput
  }

  export type SupportTicketCreateNestedOneWithoutAssetHistoryInput = {
    create?: XOR<SupportTicketCreateWithoutAssetHistoryInput, SupportTicketUncheckedCreateWithoutAssetHistoryInput>
    connectOrCreate?: SupportTicketCreateOrConnectWithoutAssetHistoryInput
    connect?: SupportTicketWhereUniqueInput
  }

  export type InventoryAssetUpdateOneRequiredWithoutTicketHistoryNestedInput = {
    create?: XOR<InventoryAssetCreateWithoutTicketHistoryInput, InventoryAssetUncheckedCreateWithoutTicketHistoryInput>
    connectOrCreate?: InventoryAssetCreateOrConnectWithoutTicketHistoryInput
    upsert?: InventoryAssetUpsertWithoutTicketHistoryInput
    connect?: InventoryAssetWhereUniqueInput
    update?: XOR<XOR<InventoryAssetUpdateToOneWithWhereWithoutTicketHistoryInput, InventoryAssetUpdateWithoutTicketHistoryInput>, InventoryAssetUncheckedUpdateWithoutTicketHistoryInput>
  }

  export type SupportTicketUpdateOneRequiredWithoutAssetHistoryNestedInput = {
    create?: XOR<SupportTicketCreateWithoutAssetHistoryInput, SupportTicketUncheckedCreateWithoutAssetHistoryInput>
    connectOrCreate?: SupportTicketCreateOrConnectWithoutAssetHistoryInput
    upsert?: SupportTicketUpsertWithoutAssetHistoryInput
    connect?: SupportTicketWhereUniqueInput
    update?: XOR<XOR<SupportTicketUpdateToOneWithWhereWithoutAssetHistoryInput, SupportTicketUpdateWithoutAssetHistoryInput>, SupportTicketUncheckedUpdateWithoutAssetHistoryInput>
  }

  export type InventoryAssetCreateNestedOneWithoutWarrantyAlertsInput = {
    create?: XOR<InventoryAssetCreateWithoutWarrantyAlertsInput, InventoryAssetUncheckedCreateWithoutWarrantyAlertsInput>
    connectOrCreate?: InventoryAssetCreateOrConnectWithoutWarrantyAlertsInput
    connect?: InventoryAssetWhereUniqueInput
  }

  export type InventoryAssetUpdateOneRequiredWithoutWarrantyAlertsNestedInput = {
    create?: XOR<InventoryAssetCreateWithoutWarrantyAlertsInput, InventoryAssetUncheckedCreateWithoutWarrantyAlertsInput>
    connectOrCreate?: InventoryAssetCreateOrConnectWithoutWarrantyAlertsInput
    upsert?: InventoryAssetUpsertWithoutWarrantyAlertsInput
    connect?: InventoryAssetWhereUniqueInput
    update?: XOR<XOR<InventoryAssetUpdateToOneWithWhereWithoutWarrantyAlertsInput, InventoryAssetUpdateWithoutWarrantyAlertsInput>, InventoryAssetUncheckedUpdateWithoutWarrantyAlertsInput>
  }

  export type InventoryAssetCreateNestedManyWithoutImportBatchInput = {
    create?: XOR<InventoryAssetCreateWithoutImportBatchInput, InventoryAssetUncheckedCreateWithoutImportBatchInput> | InventoryAssetCreateWithoutImportBatchInput[] | InventoryAssetUncheckedCreateWithoutImportBatchInput[]
    connectOrCreate?: InventoryAssetCreateOrConnectWithoutImportBatchInput | InventoryAssetCreateOrConnectWithoutImportBatchInput[]
    createMany?: InventoryAssetCreateManyImportBatchInputEnvelope
    connect?: InventoryAssetWhereUniqueInput | InventoryAssetWhereUniqueInput[]
  }

  export type AssetValidationLogCreateNestedManyWithoutBatchInput = {
    create?: XOR<AssetValidationLogCreateWithoutBatchInput, AssetValidationLogUncheckedCreateWithoutBatchInput> | AssetValidationLogCreateWithoutBatchInput[] | AssetValidationLogUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: AssetValidationLogCreateOrConnectWithoutBatchInput | AssetValidationLogCreateOrConnectWithoutBatchInput[]
    createMany?: AssetValidationLogCreateManyBatchInputEnvelope
    connect?: AssetValidationLogWhereUniqueInput | AssetValidationLogWhereUniqueInput[]
  }

  export type InventoryAssetUncheckedCreateNestedManyWithoutImportBatchInput = {
    create?: XOR<InventoryAssetCreateWithoutImportBatchInput, InventoryAssetUncheckedCreateWithoutImportBatchInput> | InventoryAssetCreateWithoutImportBatchInput[] | InventoryAssetUncheckedCreateWithoutImportBatchInput[]
    connectOrCreate?: InventoryAssetCreateOrConnectWithoutImportBatchInput | InventoryAssetCreateOrConnectWithoutImportBatchInput[]
    createMany?: InventoryAssetCreateManyImportBatchInputEnvelope
    connect?: InventoryAssetWhereUniqueInput | InventoryAssetWhereUniqueInput[]
  }

  export type AssetValidationLogUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<AssetValidationLogCreateWithoutBatchInput, AssetValidationLogUncheckedCreateWithoutBatchInput> | AssetValidationLogCreateWithoutBatchInput[] | AssetValidationLogUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: AssetValidationLogCreateOrConnectWithoutBatchInput | AssetValidationLogCreateOrConnectWithoutBatchInput[]
    createMany?: AssetValidationLogCreateManyBatchInputEnvelope
    connect?: AssetValidationLogWhereUniqueInput | AssetValidationLogWhereUniqueInput[]
  }

  export type InventoryAssetUpdateManyWithoutImportBatchNestedInput = {
    create?: XOR<InventoryAssetCreateWithoutImportBatchInput, InventoryAssetUncheckedCreateWithoutImportBatchInput> | InventoryAssetCreateWithoutImportBatchInput[] | InventoryAssetUncheckedCreateWithoutImportBatchInput[]
    connectOrCreate?: InventoryAssetCreateOrConnectWithoutImportBatchInput | InventoryAssetCreateOrConnectWithoutImportBatchInput[]
    upsert?: InventoryAssetUpsertWithWhereUniqueWithoutImportBatchInput | InventoryAssetUpsertWithWhereUniqueWithoutImportBatchInput[]
    createMany?: InventoryAssetCreateManyImportBatchInputEnvelope
    set?: InventoryAssetWhereUniqueInput | InventoryAssetWhereUniqueInput[]
    disconnect?: InventoryAssetWhereUniqueInput | InventoryAssetWhereUniqueInput[]
    delete?: InventoryAssetWhereUniqueInput | InventoryAssetWhereUniqueInput[]
    connect?: InventoryAssetWhereUniqueInput | InventoryAssetWhereUniqueInput[]
    update?: InventoryAssetUpdateWithWhereUniqueWithoutImportBatchInput | InventoryAssetUpdateWithWhereUniqueWithoutImportBatchInput[]
    updateMany?: InventoryAssetUpdateManyWithWhereWithoutImportBatchInput | InventoryAssetUpdateManyWithWhereWithoutImportBatchInput[]
    deleteMany?: InventoryAssetScalarWhereInput | InventoryAssetScalarWhereInput[]
  }

  export type AssetValidationLogUpdateManyWithoutBatchNestedInput = {
    create?: XOR<AssetValidationLogCreateWithoutBatchInput, AssetValidationLogUncheckedCreateWithoutBatchInput> | AssetValidationLogCreateWithoutBatchInput[] | AssetValidationLogUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: AssetValidationLogCreateOrConnectWithoutBatchInput | AssetValidationLogCreateOrConnectWithoutBatchInput[]
    upsert?: AssetValidationLogUpsertWithWhereUniqueWithoutBatchInput | AssetValidationLogUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: AssetValidationLogCreateManyBatchInputEnvelope
    set?: AssetValidationLogWhereUniqueInput | AssetValidationLogWhereUniqueInput[]
    disconnect?: AssetValidationLogWhereUniqueInput | AssetValidationLogWhereUniqueInput[]
    delete?: AssetValidationLogWhereUniqueInput | AssetValidationLogWhereUniqueInput[]
    connect?: AssetValidationLogWhereUniqueInput | AssetValidationLogWhereUniqueInput[]
    update?: AssetValidationLogUpdateWithWhereUniqueWithoutBatchInput | AssetValidationLogUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: AssetValidationLogUpdateManyWithWhereWithoutBatchInput | AssetValidationLogUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: AssetValidationLogScalarWhereInput | AssetValidationLogScalarWhereInput[]
  }

  export type InventoryAssetUncheckedUpdateManyWithoutImportBatchNestedInput = {
    create?: XOR<InventoryAssetCreateWithoutImportBatchInput, InventoryAssetUncheckedCreateWithoutImportBatchInput> | InventoryAssetCreateWithoutImportBatchInput[] | InventoryAssetUncheckedCreateWithoutImportBatchInput[]
    connectOrCreate?: InventoryAssetCreateOrConnectWithoutImportBatchInput | InventoryAssetCreateOrConnectWithoutImportBatchInput[]
    upsert?: InventoryAssetUpsertWithWhereUniqueWithoutImportBatchInput | InventoryAssetUpsertWithWhereUniqueWithoutImportBatchInput[]
    createMany?: InventoryAssetCreateManyImportBatchInputEnvelope
    set?: InventoryAssetWhereUniqueInput | InventoryAssetWhereUniqueInput[]
    disconnect?: InventoryAssetWhereUniqueInput | InventoryAssetWhereUniqueInput[]
    delete?: InventoryAssetWhereUniqueInput | InventoryAssetWhereUniqueInput[]
    connect?: InventoryAssetWhereUniqueInput | InventoryAssetWhereUniqueInput[]
    update?: InventoryAssetUpdateWithWhereUniqueWithoutImportBatchInput | InventoryAssetUpdateWithWhereUniqueWithoutImportBatchInput[]
    updateMany?: InventoryAssetUpdateManyWithWhereWithoutImportBatchInput | InventoryAssetUpdateManyWithWhereWithoutImportBatchInput[]
    deleteMany?: InventoryAssetScalarWhereInput | InventoryAssetScalarWhereInput[]
  }

  export type AssetValidationLogUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<AssetValidationLogCreateWithoutBatchInput, AssetValidationLogUncheckedCreateWithoutBatchInput> | AssetValidationLogCreateWithoutBatchInput[] | AssetValidationLogUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: AssetValidationLogCreateOrConnectWithoutBatchInput | AssetValidationLogCreateOrConnectWithoutBatchInput[]
    upsert?: AssetValidationLogUpsertWithWhereUniqueWithoutBatchInput | AssetValidationLogUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: AssetValidationLogCreateManyBatchInputEnvelope
    set?: AssetValidationLogWhereUniqueInput | AssetValidationLogWhereUniqueInput[]
    disconnect?: AssetValidationLogWhereUniqueInput | AssetValidationLogWhereUniqueInput[]
    delete?: AssetValidationLogWhereUniqueInput | AssetValidationLogWhereUniqueInput[]
    connect?: AssetValidationLogWhereUniqueInput | AssetValidationLogWhereUniqueInput[]
    update?: AssetValidationLogUpdateWithWhereUniqueWithoutBatchInput | AssetValidationLogUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: AssetValidationLogUpdateManyWithWhereWithoutBatchInput | AssetValidationLogUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: AssetValidationLogScalarWhereInput | AssetValidationLogScalarWhereInput[]
  }

  export type AssetImportBatchCreateNestedOneWithoutValidationLogsInput = {
    create?: XOR<AssetImportBatchCreateWithoutValidationLogsInput, AssetImportBatchUncheckedCreateWithoutValidationLogsInput>
    connectOrCreate?: AssetImportBatchCreateOrConnectWithoutValidationLogsInput
    connect?: AssetImportBatchWhereUniqueInput
  }

  export type InventoryAssetCreateNestedOneWithoutValidationLogsInput = {
    create?: XOR<InventoryAssetCreateWithoutValidationLogsInput, InventoryAssetUncheckedCreateWithoutValidationLogsInput>
    connectOrCreate?: InventoryAssetCreateOrConnectWithoutValidationLogsInput
    connect?: InventoryAssetWhereUniqueInput
  }

  export type AssetImportBatchUpdateOneRequiredWithoutValidationLogsNestedInput = {
    create?: XOR<AssetImportBatchCreateWithoutValidationLogsInput, AssetImportBatchUncheckedCreateWithoutValidationLogsInput>
    connectOrCreate?: AssetImportBatchCreateOrConnectWithoutValidationLogsInput
    upsert?: AssetImportBatchUpsertWithoutValidationLogsInput
    connect?: AssetImportBatchWhereUniqueInput
    update?: XOR<XOR<AssetImportBatchUpdateToOneWithWhereWithoutValidationLogsInput, AssetImportBatchUpdateWithoutValidationLogsInput>, AssetImportBatchUncheckedUpdateWithoutValidationLogsInput>
  }

  export type InventoryAssetUpdateOneWithoutValidationLogsNestedInput = {
    create?: XOR<InventoryAssetCreateWithoutValidationLogsInput, InventoryAssetUncheckedCreateWithoutValidationLogsInput>
    connectOrCreate?: InventoryAssetCreateOrConnectWithoutValidationLogsInput
    upsert?: InventoryAssetUpsertWithoutValidationLogsInput
    disconnect?: InventoryAssetWhereInput | boolean
    delete?: InventoryAssetWhereInput | boolean
    connect?: InventoryAssetWhereUniqueInput
    update?: XOR<XOR<InventoryAssetUpdateToOneWithWhereWithoutValidationLogsInput, InventoryAssetUpdateWithoutValidationLogsInput>, InventoryAssetUncheckedUpdateWithoutValidationLogsInput>
  }

  export type KioskCreateNestedOneWithoutAssetRegistryInput = {
    create?: XOR<KioskCreateWithoutAssetRegistryInput, KioskUncheckedCreateWithoutAssetRegistryInput>
    connectOrCreate?: KioskCreateOrConnectWithoutAssetRegistryInput
    connect?: KioskWhereUniqueInput
  }

  export type InventoryAssetCreateNestedOneWithoutKioskRegistrationsInput = {
    create?: XOR<InventoryAssetCreateWithoutKioskRegistrationsInput, InventoryAssetUncheckedCreateWithoutKioskRegistrationsInput>
    connectOrCreate?: InventoryAssetCreateOrConnectWithoutKioskRegistrationsInput
    connect?: InventoryAssetWhereUniqueInput
  }

  export type KioskUpdateOneRequiredWithoutAssetRegistryNestedInput = {
    create?: XOR<KioskCreateWithoutAssetRegistryInput, KioskUncheckedCreateWithoutAssetRegistryInput>
    connectOrCreate?: KioskCreateOrConnectWithoutAssetRegistryInput
    upsert?: KioskUpsertWithoutAssetRegistryInput
    connect?: KioskWhereUniqueInput
    update?: XOR<XOR<KioskUpdateToOneWithWhereWithoutAssetRegistryInput, KioskUpdateWithoutAssetRegistryInput>, KioskUncheckedUpdateWithoutAssetRegistryInput>
  }

  export type InventoryAssetUpdateOneRequiredWithoutKioskRegistrationsNestedInput = {
    create?: XOR<InventoryAssetCreateWithoutKioskRegistrationsInput, InventoryAssetUncheckedCreateWithoutKioskRegistrationsInput>
    connectOrCreate?: InventoryAssetCreateOrConnectWithoutKioskRegistrationsInput
    upsert?: InventoryAssetUpsertWithoutKioskRegistrationsInput
    connect?: InventoryAssetWhereUniqueInput
    update?: XOR<XOR<InventoryAssetUpdateToOneWithWhereWithoutKioskRegistrationsInput, InventoryAssetUpdateWithoutKioskRegistrationsInput>, InventoryAssetUncheckedUpdateWithoutKioskRegistrationsInput>
  }

  export type KioskCreateNestedOneWithoutSyncFailuresInput = {
    create?: XOR<KioskCreateWithoutSyncFailuresInput, KioskUncheckedCreateWithoutSyncFailuresInput>
    connectOrCreate?: KioskCreateOrConnectWithoutSyncFailuresInput
    connect?: KioskWhereUniqueInput
  }

  export type InventoryAssetCreateNestedOneWithoutSyncFailuresInput = {
    create?: XOR<InventoryAssetCreateWithoutSyncFailuresInput, InventoryAssetUncheckedCreateWithoutSyncFailuresInput>
    connectOrCreate?: InventoryAssetCreateOrConnectWithoutSyncFailuresInput
    connect?: InventoryAssetWhereUniqueInput
  }

  export type KioskUpdateOneRequiredWithoutSyncFailuresNestedInput = {
    create?: XOR<KioskCreateWithoutSyncFailuresInput, KioskUncheckedCreateWithoutSyncFailuresInput>
    connectOrCreate?: KioskCreateOrConnectWithoutSyncFailuresInput
    upsert?: KioskUpsertWithoutSyncFailuresInput
    connect?: KioskWhereUniqueInput
    update?: XOR<XOR<KioskUpdateToOneWithWhereWithoutSyncFailuresInput, KioskUpdateWithoutSyncFailuresInput>, KioskUncheckedUpdateWithoutSyncFailuresInput>
  }

  export type InventoryAssetUpdateOneRequiredWithoutSyncFailuresNestedInput = {
    create?: XOR<InventoryAssetCreateWithoutSyncFailuresInput, InventoryAssetUncheckedCreateWithoutSyncFailuresInput>
    connectOrCreate?: InventoryAssetCreateOrConnectWithoutSyncFailuresInput
    upsert?: InventoryAssetUpsertWithoutSyncFailuresInput
    connect?: InventoryAssetWhereUniqueInput
    update?: XOR<XOR<InventoryAssetUpdateToOneWithWhereWithoutSyncFailuresInput, InventoryAssetUpdateWithoutSyncFailuresInput>, InventoryAssetUncheckedUpdateWithoutSyncFailuresInput>
  }

  export type KioskCreateNestedOneWithoutOrgAssignmentInput = {
    create?: XOR<KioskCreateWithoutOrgAssignmentInput, KioskUncheckedCreateWithoutOrgAssignmentInput>
    connectOrCreate?: KioskCreateOrConnectWithoutOrgAssignmentInput
    connect?: KioskWhereUniqueInput
  }

  export type KioskUpdateOneRequiredWithoutOrgAssignmentNestedInput = {
    create?: XOR<KioskCreateWithoutOrgAssignmentInput, KioskUncheckedCreateWithoutOrgAssignmentInput>
    connectOrCreate?: KioskCreateOrConnectWithoutOrgAssignmentInput
    upsert?: KioskUpsertWithoutOrgAssignmentInput
    connect?: KioskWhereUniqueInput
    update?: XOR<XOR<KioskUpdateToOneWithWhereWithoutOrgAssignmentInput, KioskUpdateWithoutOrgAssignmentInput>, KioskUncheckedUpdateWithoutOrgAssignmentInput>
  }

  export type KioskCreateNestedOneWithoutMetadataLogsInput = {
    create?: XOR<KioskCreateWithoutMetadataLogsInput, KioskUncheckedCreateWithoutMetadataLogsInput>
    connectOrCreate?: KioskCreateOrConnectWithoutMetadataLogsInput
    connect?: KioskWhereUniqueInput
  }

  export type KioskUpdateOneRequiredWithoutMetadataLogsNestedInput = {
    create?: XOR<KioskCreateWithoutMetadataLogsInput, KioskUncheckedCreateWithoutMetadataLogsInput>
    connectOrCreate?: KioskCreateOrConnectWithoutMetadataLogsInput
    upsert?: KioskUpsertWithoutMetadataLogsInput
    connect?: KioskWhereUniqueInput
    update?: XOR<XOR<KioskUpdateToOneWithWhereWithoutMetadataLogsInput, KioskUpdateWithoutMetadataLogsInput>, KioskUncheckedUpdateWithoutMetadataLogsInput>
  }

  export type UserCreateNestedOneWithoutXpEventsInput = {
    create?: XOR<UserCreateWithoutXpEventsInput, UserUncheckedCreateWithoutXpEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutXpEventsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutXpEventsNestedInput = {
    create?: XOR<UserCreateWithoutXpEventsInput, UserUncheckedCreateWithoutXpEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutXpEventsInput
    upsert?: UserUpsertWithoutXpEventsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutXpEventsInput, UserUpdateWithoutXpEventsInput>, UserUncheckedUpdateWithoutXpEventsInput>
  }

  export type UserCreateNestedOneWithoutLeaderboardInput = {
    create?: XOR<UserCreateWithoutLeaderboardInput, UserUncheckedCreateWithoutLeaderboardInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaderboardInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLeaderboardNestedInput = {
    create?: XOR<UserCreateWithoutLeaderboardInput, UserUncheckedCreateWithoutLeaderboardInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaderboardInput
    upsert?: UserUpsertWithoutLeaderboardInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeaderboardInput, UserUpdateWithoutLeaderboardInput>, UserUncheckedUpdateWithoutLeaderboardInput>
  }

  export type UserCreateNestedOneWithoutScimMappingsInput = {
    create?: XOR<UserCreateWithoutScimMappingsInput, UserUncheckedCreateWithoutScimMappingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutScimMappingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutScimMappingsNestedInput = {
    create?: XOR<UserCreateWithoutScimMappingsInput, UserUncheckedCreateWithoutScimMappingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutScimMappingsInput
    upsert?: UserUpsertWithoutScimMappingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutScimMappingsInput, UserUpdateWithoutScimMappingsInput>, UserUncheckedUpdateWithoutScimMappingsInput>
  }

  export type MailroomPackageCreateflagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutMailroomPackagesInput = {
    create?: XOR<UserCreateWithoutMailroomPackagesInput, UserUncheckedCreateWithoutMailroomPackagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMailroomPackagesInput
    connect?: UserWhereUniqueInput
  }

  export type SupportTicketCreateNestedOneWithoutMailroomPackagesInput = {
    create?: XOR<SupportTicketCreateWithoutMailroomPackagesInput, SupportTicketUncheckedCreateWithoutMailroomPackagesInput>
    connectOrCreate?: SupportTicketCreateOrConnectWithoutMailroomPackagesInput
    connect?: SupportTicketWhereUniqueInput
  }

  export type InventoryAssetCreateNestedOneWithoutMailroomPackagesInput = {
    create?: XOR<InventoryAssetCreateWithoutMailroomPackagesInput, InventoryAssetUncheckedCreateWithoutMailroomPackagesInput>
    connectOrCreate?: InventoryAssetCreateOrConnectWithoutMailroomPackagesInput
    connect?: InventoryAssetWhereUniqueInput
  }

  export type DeliveryEventCreateNestedManyWithoutPackageInput = {
    create?: XOR<DeliveryEventCreateWithoutPackageInput, DeliveryEventUncheckedCreateWithoutPackageInput> | DeliveryEventCreateWithoutPackageInput[] | DeliveryEventUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: DeliveryEventCreateOrConnectWithoutPackageInput | DeliveryEventCreateOrConnectWithoutPackageInput[]
    createMany?: DeliveryEventCreateManyPackageInputEnvelope
    connect?: DeliveryEventWhereUniqueInput | DeliveryEventWhereUniqueInput[]
  }

  export type ProxyAuthorizationCreateNestedManyWithoutPackageInput = {
    create?: XOR<ProxyAuthorizationCreateWithoutPackageInput, ProxyAuthorizationUncheckedCreateWithoutPackageInput> | ProxyAuthorizationCreateWithoutPackageInput[] | ProxyAuthorizationUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: ProxyAuthorizationCreateOrConnectWithoutPackageInput | ProxyAuthorizationCreateOrConnectWithoutPackageInput[]
    createMany?: ProxyAuthorizationCreateManyPackageInputEnvelope
    connect?: ProxyAuthorizationWhereUniqueInput | ProxyAuthorizationWhereUniqueInput[]
  }

  export type DeliveryEventUncheckedCreateNestedManyWithoutPackageInput = {
    create?: XOR<DeliveryEventCreateWithoutPackageInput, DeliveryEventUncheckedCreateWithoutPackageInput> | DeliveryEventCreateWithoutPackageInput[] | DeliveryEventUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: DeliveryEventCreateOrConnectWithoutPackageInput | DeliveryEventCreateOrConnectWithoutPackageInput[]
    createMany?: DeliveryEventCreateManyPackageInputEnvelope
    connect?: DeliveryEventWhereUniqueInput | DeliveryEventWhereUniqueInput[]
  }

  export type ProxyAuthorizationUncheckedCreateNestedManyWithoutPackageInput = {
    create?: XOR<ProxyAuthorizationCreateWithoutPackageInput, ProxyAuthorizationUncheckedCreateWithoutPackageInput> | ProxyAuthorizationCreateWithoutPackageInput[] | ProxyAuthorizationUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: ProxyAuthorizationCreateOrConnectWithoutPackageInput | ProxyAuthorizationCreateOrConnectWithoutPackageInput[]
    createMany?: ProxyAuthorizationCreateManyPackageInputEnvelope
    connect?: ProxyAuthorizationWhereUniqueInput | ProxyAuthorizationWhereUniqueInput[]
  }

  export type MailroomPackageUpdateflagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutMailroomPackagesNestedInput = {
    create?: XOR<UserCreateWithoutMailroomPackagesInput, UserUncheckedCreateWithoutMailroomPackagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMailroomPackagesInput
    upsert?: UserUpsertWithoutMailroomPackagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMailroomPackagesInput, UserUpdateWithoutMailroomPackagesInput>, UserUncheckedUpdateWithoutMailroomPackagesInput>
  }

  export type SupportTicketUpdateOneWithoutMailroomPackagesNestedInput = {
    create?: XOR<SupportTicketCreateWithoutMailroomPackagesInput, SupportTicketUncheckedCreateWithoutMailroomPackagesInput>
    connectOrCreate?: SupportTicketCreateOrConnectWithoutMailroomPackagesInput
    upsert?: SupportTicketUpsertWithoutMailroomPackagesInput
    disconnect?: SupportTicketWhereInput | boolean
    delete?: SupportTicketWhereInput | boolean
    connect?: SupportTicketWhereUniqueInput
    update?: XOR<XOR<SupportTicketUpdateToOneWithWhereWithoutMailroomPackagesInput, SupportTicketUpdateWithoutMailroomPackagesInput>, SupportTicketUncheckedUpdateWithoutMailroomPackagesInput>
  }

  export type InventoryAssetUpdateOneWithoutMailroomPackagesNestedInput = {
    create?: XOR<InventoryAssetCreateWithoutMailroomPackagesInput, InventoryAssetUncheckedCreateWithoutMailroomPackagesInput>
    connectOrCreate?: InventoryAssetCreateOrConnectWithoutMailroomPackagesInput
    upsert?: InventoryAssetUpsertWithoutMailroomPackagesInput
    disconnect?: InventoryAssetWhereInput | boolean
    delete?: InventoryAssetWhereInput | boolean
    connect?: InventoryAssetWhereUniqueInput
    update?: XOR<XOR<InventoryAssetUpdateToOneWithWhereWithoutMailroomPackagesInput, InventoryAssetUpdateWithoutMailroomPackagesInput>, InventoryAssetUncheckedUpdateWithoutMailroomPackagesInput>
  }

  export type DeliveryEventUpdateManyWithoutPackageNestedInput = {
    create?: XOR<DeliveryEventCreateWithoutPackageInput, DeliveryEventUncheckedCreateWithoutPackageInput> | DeliveryEventCreateWithoutPackageInput[] | DeliveryEventUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: DeliveryEventCreateOrConnectWithoutPackageInput | DeliveryEventCreateOrConnectWithoutPackageInput[]
    upsert?: DeliveryEventUpsertWithWhereUniqueWithoutPackageInput | DeliveryEventUpsertWithWhereUniqueWithoutPackageInput[]
    createMany?: DeliveryEventCreateManyPackageInputEnvelope
    set?: DeliveryEventWhereUniqueInput | DeliveryEventWhereUniqueInput[]
    disconnect?: DeliveryEventWhereUniqueInput | DeliveryEventWhereUniqueInput[]
    delete?: DeliveryEventWhereUniqueInput | DeliveryEventWhereUniqueInput[]
    connect?: DeliveryEventWhereUniqueInput | DeliveryEventWhereUniqueInput[]
    update?: DeliveryEventUpdateWithWhereUniqueWithoutPackageInput | DeliveryEventUpdateWithWhereUniqueWithoutPackageInput[]
    updateMany?: DeliveryEventUpdateManyWithWhereWithoutPackageInput | DeliveryEventUpdateManyWithWhereWithoutPackageInput[]
    deleteMany?: DeliveryEventScalarWhereInput | DeliveryEventScalarWhereInput[]
  }

  export type ProxyAuthorizationUpdateManyWithoutPackageNestedInput = {
    create?: XOR<ProxyAuthorizationCreateWithoutPackageInput, ProxyAuthorizationUncheckedCreateWithoutPackageInput> | ProxyAuthorizationCreateWithoutPackageInput[] | ProxyAuthorizationUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: ProxyAuthorizationCreateOrConnectWithoutPackageInput | ProxyAuthorizationCreateOrConnectWithoutPackageInput[]
    upsert?: ProxyAuthorizationUpsertWithWhereUniqueWithoutPackageInput | ProxyAuthorizationUpsertWithWhereUniqueWithoutPackageInput[]
    createMany?: ProxyAuthorizationCreateManyPackageInputEnvelope
    set?: ProxyAuthorizationWhereUniqueInput | ProxyAuthorizationWhereUniqueInput[]
    disconnect?: ProxyAuthorizationWhereUniqueInput | ProxyAuthorizationWhereUniqueInput[]
    delete?: ProxyAuthorizationWhereUniqueInput | ProxyAuthorizationWhereUniqueInput[]
    connect?: ProxyAuthorizationWhereUniqueInput | ProxyAuthorizationWhereUniqueInput[]
    update?: ProxyAuthorizationUpdateWithWhereUniqueWithoutPackageInput | ProxyAuthorizationUpdateWithWhereUniqueWithoutPackageInput[]
    updateMany?: ProxyAuthorizationUpdateManyWithWhereWithoutPackageInput | ProxyAuthorizationUpdateManyWithWhereWithoutPackageInput[]
    deleteMany?: ProxyAuthorizationScalarWhereInput | ProxyAuthorizationScalarWhereInput[]
  }

  export type DeliveryEventUncheckedUpdateManyWithoutPackageNestedInput = {
    create?: XOR<DeliveryEventCreateWithoutPackageInput, DeliveryEventUncheckedCreateWithoutPackageInput> | DeliveryEventCreateWithoutPackageInput[] | DeliveryEventUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: DeliveryEventCreateOrConnectWithoutPackageInput | DeliveryEventCreateOrConnectWithoutPackageInput[]
    upsert?: DeliveryEventUpsertWithWhereUniqueWithoutPackageInput | DeliveryEventUpsertWithWhereUniqueWithoutPackageInput[]
    createMany?: DeliveryEventCreateManyPackageInputEnvelope
    set?: DeliveryEventWhereUniqueInput | DeliveryEventWhereUniqueInput[]
    disconnect?: DeliveryEventWhereUniqueInput | DeliveryEventWhereUniqueInput[]
    delete?: DeliveryEventWhereUniqueInput | DeliveryEventWhereUniqueInput[]
    connect?: DeliveryEventWhereUniqueInput | DeliveryEventWhereUniqueInput[]
    update?: DeliveryEventUpdateWithWhereUniqueWithoutPackageInput | DeliveryEventUpdateWithWhereUniqueWithoutPackageInput[]
    updateMany?: DeliveryEventUpdateManyWithWhereWithoutPackageInput | DeliveryEventUpdateManyWithWhereWithoutPackageInput[]
    deleteMany?: DeliveryEventScalarWhereInput | DeliveryEventScalarWhereInput[]
  }

  export type ProxyAuthorizationUncheckedUpdateManyWithoutPackageNestedInput = {
    create?: XOR<ProxyAuthorizationCreateWithoutPackageInput, ProxyAuthorizationUncheckedCreateWithoutPackageInput> | ProxyAuthorizationCreateWithoutPackageInput[] | ProxyAuthorizationUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: ProxyAuthorizationCreateOrConnectWithoutPackageInput | ProxyAuthorizationCreateOrConnectWithoutPackageInput[]
    upsert?: ProxyAuthorizationUpsertWithWhereUniqueWithoutPackageInput | ProxyAuthorizationUpsertWithWhereUniqueWithoutPackageInput[]
    createMany?: ProxyAuthorizationCreateManyPackageInputEnvelope
    set?: ProxyAuthorizationWhereUniqueInput | ProxyAuthorizationWhereUniqueInput[]
    disconnect?: ProxyAuthorizationWhereUniqueInput | ProxyAuthorizationWhereUniqueInput[]
    delete?: ProxyAuthorizationWhereUniqueInput | ProxyAuthorizationWhereUniqueInput[]
    connect?: ProxyAuthorizationWhereUniqueInput | ProxyAuthorizationWhereUniqueInput[]
    update?: ProxyAuthorizationUpdateWithWhereUniqueWithoutPackageInput | ProxyAuthorizationUpdateWithWhereUniqueWithoutPackageInput[]
    updateMany?: ProxyAuthorizationUpdateManyWithWhereWithoutPackageInput | ProxyAuthorizationUpdateManyWithWhereWithoutPackageInput[]
    deleteMany?: ProxyAuthorizationScalarWhereInput | ProxyAuthorizationScalarWhereInput[]
  }

  export type MailroomPackageCreateNestedOneWithoutDeliveryEventsInput = {
    create?: XOR<MailroomPackageCreateWithoutDeliveryEventsInput, MailroomPackageUncheckedCreateWithoutDeliveryEventsInput>
    connectOrCreate?: MailroomPackageCreateOrConnectWithoutDeliveryEventsInput
    connect?: MailroomPackageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDeliveryEventsInput = {
    create?: XOR<UserCreateWithoutDeliveryEventsInput, UserUncheckedCreateWithoutDeliveryEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeliveryEventsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Uint8Array | null
  }

  export type MailroomPackageUpdateOneRequiredWithoutDeliveryEventsNestedInput = {
    create?: XOR<MailroomPackageCreateWithoutDeliveryEventsInput, MailroomPackageUncheckedCreateWithoutDeliveryEventsInput>
    connectOrCreate?: MailroomPackageCreateOrConnectWithoutDeliveryEventsInput
    upsert?: MailroomPackageUpsertWithoutDeliveryEventsInput
    connect?: MailroomPackageWhereUniqueInput
    update?: XOR<XOR<MailroomPackageUpdateToOneWithWhereWithoutDeliveryEventsInput, MailroomPackageUpdateWithoutDeliveryEventsInput>, MailroomPackageUncheckedUpdateWithoutDeliveryEventsInput>
  }

  export type UserUpdateOneRequiredWithoutDeliveryEventsNestedInput = {
    create?: XOR<UserCreateWithoutDeliveryEventsInput, UserUncheckedCreateWithoutDeliveryEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeliveryEventsInput
    upsert?: UserUpsertWithoutDeliveryEventsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeliveryEventsInput, UserUpdateWithoutDeliveryEventsInput>, UserUncheckedUpdateWithoutDeliveryEventsInput>
  }

  export type UserCreateNestedOneWithoutProxyAuthorizationsAsRecipientInput = {
    create?: XOR<UserCreateWithoutProxyAuthorizationsAsRecipientInput, UserUncheckedCreateWithoutProxyAuthorizationsAsRecipientInput>
    connectOrCreate?: UserCreateOrConnectWithoutProxyAuthorizationsAsRecipientInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProxyAuthorizationsAsProxyInput = {
    create?: XOR<UserCreateWithoutProxyAuthorizationsAsProxyInput, UserUncheckedCreateWithoutProxyAuthorizationsAsProxyInput>
    connectOrCreate?: UserCreateOrConnectWithoutProxyAuthorizationsAsProxyInput
    connect?: UserWhereUniqueInput
  }

  export type MailroomPackageCreateNestedOneWithoutProxyAuthorizationsInput = {
    create?: XOR<MailroomPackageCreateWithoutProxyAuthorizationsInput, MailroomPackageUncheckedCreateWithoutProxyAuthorizationsInput>
    connectOrCreate?: MailroomPackageCreateOrConnectWithoutProxyAuthorizationsInput
    connect?: MailroomPackageWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProxyAuthorizationsAsRecipientNestedInput = {
    create?: XOR<UserCreateWithoutProxyAuthorizationsAsRecipientInput, UserUncheckedCreateWithoutProxyAuthorizationsAsRecipientInput>
    connectOrCreate?: UserCreateOrConnectWithoutProxyAuthorizationsAsRecipientInput
    upsert?: UserUpsertWithoutProxyAuthorizationsAsRecipientInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProxyAuthorizationsAsRecipientInput, UserUpdateWithoutProxyAuthorizationsAsRecipientInput>, UserUncheckedUpdateWithoutProxyAuthorizationsAsRecipientInput>
  }

  export type UserUpdateOneRequiredWithoutProxyAuthorizationsAsProxyNestedInput = {
    create?: XOR<UserCreateWithoutProxyAuthorizationsAsProxyInput, UserUncheckedCreateWithoutProxyAuthorizationsAsProxyInput>
    connectOrCreate?: UserCreateOrConnectWithoutProxyAuthorizationsAsProxyInput
    upsert?: UserUpsertWithoutProxyAuthorizationsAsProxyInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProxyAuthorizationsAsProxyInput, UserUpdateWithoutProxyAuthorizationsAsProxyInput>, UserUncheckedUpdateWithoutProxyAuthorizationsAsProxyInput>
  }

  export type MailroomPackageUpdateOneRequiredWithoutProxyAuthorizationsNestedInput = {
    create?: XOR<MailroomPackageCreateWithoutProxyAuthorizationsInput, MailroomPackageUncheckedCreateWithoutProxyAuthorizationsInput>
    connectOrCreate?: MailroomPackageCreateOrConnectWithoutProxyAuthorizationsInput
    upsert?: MailroomPackageUpsertWithoutProxyAuthorizationsInput
    connect?: MailroomPackageWhereUniqueInput
    update?: XOR<XOR<MailroomPackageUpdateToOneWithWhereWithoutProxyAuthorizationsInput, MailroomPackageUpdateWithoutProxyAuthorizationsInput>, MailroomPackageUncheckedUpdateWithoutProxyAuthorizationsInput>
  }

  export type RITMCreateNestedManyWithoutCatalogItemInput = {
    create?: XOR<RITMCreateWithoutCatalogItemInput, RITMUncheckedCreateWithoutCatalogItemInput> | RITMCreateWithoutCatalogItemInput[] | RITMUncheckedCreateWithoutCatalogItemInput[]
    connectOrCreate?: RITMCreateOrConnectWithoutCatalogItemInput | RITMCreateOrConnectWithoutCatalogItemInput[]
    createMany?: RITMCreateManyCatalogItemInputEnvelope
    connect?: RITMWhereUniqueInput | RITMWhereUniqueInput[]
  }

  export type RITMUncheckedCreateNestedManyWithoutCatalogItemInput = {
    create?: XOR<RITMCreateWithoutCatalogItemInput, RITMUncheckedCreateWithoutCatalogItemInput> | RITMCreateWithoutCatalogItemInput[] | RITMUncheckedCreateWithoutCatalogItemInput[]
    connectOrCreate?: RITMCreateOrConnectWithoutCatalogItemInput | RITMCreateOrConnectWithoutCatalogItemInput[]
    createMany?: RITMCreateManyCatalogItemInputEnvelope
    connect?: RITMWhereUniqueInput | RITMWhereUniqueInput[]
  }

  export type RITMUpdateManyWithoutCatalogItemNestedInput = {
    create?: XOR<RITMCreateWithoutCatalogItemInput, RITMUncheckedCreateWithoutCatalogItemInput> | RITMCreateWithoutCatalogItemInput[] | RITMUncheckedCreateWithoutCatalogItemInput[]
    connectOrCreate?: RITMCreateOrConnectWithoutCatalogItemInput | RITMCreateOrConnectWithoutCatalogItemInput[]
    upsert?: RITMUpsertWithWhereUniqueWithoutCatalogItemInput | RITMUpsertWithWhereUniqueWithoutCatalogItemInput[]
    createMany?: RITMCreateManyCatalogItemInputEnvelope
    set?: RITMWhereUniqueInput | RITMWhereUniqueInput[]
    disconnect?: RITMWhereUniqueInput | RITMWhereUniqueInput[]
    delete?: RITMWhereUniqueInput | RITMWhereUniqueInput[]
    connect?: RITMWhereUniqueInput | RITMWhereUniqueInput[]
    update?: RITMUpdateWithWhereUniqueWithoutCatalogItemInput | RITMUpdateWithWhereUniqueWithoutCatalogItemInput[]
    updateMany?: RITMUpdateManyWithWhereWithoutCatalogItemInput | RITMUpdateManyWithWhereWithoutCatalogItemInput[]
    deleteMany?: RITMScalarWhereInput | RITMScalarWhereInput[]
  }

  export type RITMUncheckedUpdateManyWithoutCatalogItemNestedInput = {
    create?: XOR<RITMCreateWithoutCatalogItemInput, RITMUncheckedCreateWithoutCatalogItemInput> | RITMCreateWithoutCatalogItemInput[] | RITMUncheckedCreateWithoutCatalogItemInput[]
    connectOrCreate?: RITMCreateOrConnectWithoutCatalogItemInput | RITMCreateOrConnectWithoutCatalogItemInput[]
    upsert?: RITMUpsertWithWhereUniqueWithoutCatalogItemInput | RITMUpsertWithWhereUniqueWithoutCatalogItemInput[]
    createMany?: RITMCreateManyCatalogItemInputEnvelope
    set?: RITMWhereUniqueInput | RITMWhereUniqueInput[]
    disconnect?: RITMWhereUniqueInput | RITMWhereUniqueInput[]
    delete?: RITMWhereUniqueInput | RITMWhereUniqueInput[]
    connect?: RITMWhereUniqueInput | RITMWhereUniqueInput[]
    update?: RITMUpdateWithWhereUniqueWithoutCatalogItemInput | RITMUpdateWithWhereUniqueWithoutCatalogItemInput[]
    updateMany?: RITMUpdateManyWithWhereWithoutCatalogItemInput | RITMUpdateManyWithWhereWithoutCatalogItemInput[]
    deleteMany?: RITMScalarWhereInput | RITMScalarWhereInput[]
  }

  export type SupportTicketCreateNestedOneWithoutRitmsInput = {
    create?: XOR<SupportTicketCreateWithoutRitmsInput, SupportTicketUncheckedCreateWithoutRitmsInput>
    connectOrCreate?: SupportTicketCreateOrConnectWithoutRitmsInput
    connect?: SupportTicketWhereUniqueInput
  }

  export type RequestCatalogItemCreateNestedOneWithoutRitmsInput = {
    create?: XOR<RequestCatalogItemCreateWithoutRitmsInput, RequestCatalogItemUncheckedCreateWithoutRitmsInput>
    connectOrCreate?: RequestCatalogItemCreateOrConnectWithoutRitmsInput
    connect?: RequestCatalogItemWhereUniqueInput
  }

  export type SupportTicketUpdateOneRequiredWithoutRitmsNestedInput = {
    create?: XOR<SupportTicketCreateWithoutRitmsInput, SupportTicketUncheckedCreateWithoutRitmsInput>
    connectOrCreate?: SupportTicketCreateOrConnectWithoutRitmsInput
    upsert?: SupportTicketUpsertWithoutRitmsInput
    connect?: SupportTicketWhereUniqueInput
    update?: XOR<XOR<SupportTicketUpdateToOneWithWhereWithoutRitmsInput, SupportTicketUpdateWithoutRitmsInput>, SupportTicketUncheckedUpdateWithoutRitmsInput>
  }

  export type RequestCatalogItemUpdateOneRequiredWithoutRitmsNestedInput = {
    create?: XOR<RequestCatalogItemCreateWithoutRitmsInput, RequestCatalogItemUncheckedCreateWithoutRitmsInput>
    connectOrCreate?: RequestCatalogItemCreateOrConnectWithoutRitmsInput
    upsert?: RequestCatalogItemUpsertWithoutRitmsInput
    connect?: RequestCatalogItemWhereUniqueInput
    update?: XOR<XOR<RequestCatalogItemUpdateToOneWithWhereWithoutRitmsInput, RequestCatalogItemUpdateWithoutRitmsInput>, RequestCatalogItemUncheckedUpdateWithoutRitmsInput>
  }

  export type UserCreateNestedOneWithoutVipProxiesAsVipInput = {
    create?: XOR<UserCreateWithoutVipProxiesAsVipInput, UserUncheckedCreateWithoutVipProxiesAsVipInput>
    connectOrCreate?: UserCreateOrConnectWithoutVipProxiesAsVipInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVipProxiesAsProxyInput = {
    create?: XOR<UserCreateWithoutVipProxiesAsProxyInput, UserUncheckedCreateWithoutVipProxiesAsProxyInput>
    connectOrCreate?: UserCreateOrConnectWithoutVipProxiesAsProxyInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutVipProxiesAsVipNestedInput = {
    create?: XOR<UserCreateWithoutVipProxiesAsVipInput, UserUncheckedCreateWithoutVipProxiesAsVipInput>
    connectOrCreate?: UserCreateOrConnectWithoutVipProxiesAsVipInput
    upsert?: UserUpsertWithoutVipProxiesAsVipInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVipProxiesAsVipInput, UserUpdateWithoutVipProxiesAsVipInput>, UserUncheckedUpdateWithoutVipProxiesAsVipInput>
  }

  export type UserUpdateOneRequiredWithoutVipProxiesAsProxyNestedInput = {
    create?: XOR<UserCreateWithoutVipProxiesAsProxyInput, UserUncheckedCreateWithoutVipProxiesAsProxyInput>
    connectOrCreate?: UserCreateOrConnectWithoutVipProxiesAsProxyInput
    upsert?: UserUpsertWithoutVipProxiesAsProxyInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVipProxiesAsProxyInput, UserUpdateWithoutVipProxiesAsProxyInput>, UserUncheckedUpdateWithoutVipProxiesAsProxyInput>
  }

  export type UserCreateNestedOneWithoutVipSlaHistoryInput = {
    create?: XOR<UserCreateWithoutVipSlaHistoryInput, UserUncheckedCreateWithoutVipSlaHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutVipSlaHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutVipSlaHistoryNestedInput = {
    create?: XOR<UserCreateWithoutVipSlaHistoryInput, UserUncheckedCreateWithoutVipSlaHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutVipSlaHistoryInput
    upsert?: UserUpsertWithoutVipSlaHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVipSlaHistoryInput, UserUpdateWithoutVipSlaHistoryInput>, UserUncheckedUpdateWithoutVipSlaHistoryInput>
  }

  export type UserCreateNestedOneWithoutAgentAvailabilityInput = {
    create?: XOR<UserCreateWithoutAgentAvailabilityInput, UserUncheckedCreateWithoutAgentAvailabilityInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgentAvailabilityInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAgentAvailabilityNestedInput = {
    create?: XOR<UserCreateWithoutAgentAvailabilityInput, UserUncheckedCreateWithoutAgentAvailabilityInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgentAvailabilityInput
    upsert?: UserUpsertWithoutAgentAvailabilityInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAgentAvailabilityInput, UserUpdateWithoutAgentAvailabilityInput>, UserUncheckedUpdateWithoutAgentAvailabilityInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type QueueAlertCreatenotifiedUsersInput = {
    set: string[]
  }

  export type QueueAlertUpdatenotifiedUsersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FeedbackCreateWithoutUserInput = {
    name?: string | null
    message?: string | null
    timestamp?: Date | string
  }

  export type FeedbackUncheckedCreateWithoutUserInput = {
    id?: number
    name?: string | null
    message?: string | null
    timestamp?: Date | string
  }

  export type FeedbackCreateOrConnectWithoutUserInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput>
  }

  export type FeedbackCreateManyUserInputEnvelope = {
    data: FeedbackCreateManyUserInput | FeedbackCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LogCreateWithoutUserInput = {
    ticketId?: string | null
    name?: string | null
    email?: string | null
    title?: string | null
    system?: string | null
    urgency?: string | null
    timestamp?: Date | string
    emailStatus?: string | null
  }

  export type LogUncheckedCreateWithoutUserInput = {
    id?: number
    ticketId?: string | null
    name?: string | null
    email?: string | null
    title?: string | null
    system?: string | null
    urgency?: string | null
    timestamp?: Date | string
    emailStatus?: string | null
  }

  export type LogCreateOrConnectWithoutUserInput = {
    where: LogWhereUniqueInput
    create: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput>
  }

  export type LogCreateManyUserInputEnvelope = {
    data: LogCreateManyUserInput | LogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PasskeyCreateWithoutUserInput = {
    credentialId: string
    publicKey: string
    counter?: number
    transports?: string | null
    deviceType?: string | null
    backedUp?: boolean
    createdAt?: Date | string
    lastUsed?: Date | string | null
  }

  export type PasskeyUncheckedCreateWithoutUserInput = {
    id?: number
    credentialId: string
    publicKey: string
    counter?: number
    transports?: string | null
    deviceType?: string | null
    backedUp?: boolean
    createdAt?: Date | string
    lastUsed?: Date | string | null
  }

  export type PasskeyCreateOrConnectWithoutUserInput = {
    where: PasskeyWhereUniqueInput
    create: XOR<PasskeyCreateWithoutUserInput, PasskeyUncheckedCreateWithoutUserInput>
  }

  export type PasskeyCreateManyUserInputEnvelope = {
    data: PasskeyCreateManyUserInput | PasskeyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SupportTicketCreateWithoutUsers_support_tickets_assigneeIdTousersInput = {
    title: string
    description: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vipPriorityScore?: number | null
    vipTriggerSource?: string | null
    users_support_tickets_userIdTousers?: UserCreateNestedOneWithoutSupport_tickets_support_tickets_userIdTousersInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutTicketInput
    assetHistory?: AssetTicketHistoryCreateNestedManyWithoutTicketInput
    ritms?: RITMCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUncheckedCreateWithoutUsers_support_tickets_assigneeIdTousersInput = {
    id?: number
    title: string
    description: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    vipPriorityScore?: number | null
    vipTriggerSource?: string | null
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutTicketInput
    assetHistory?: AssetTicketHistoryUncheckedCreateNestedManyWithoutTicketInput
    ritms?: RITMUncheckedCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketCreateOrConnectWithoutUsers_support_tickets_assigneeIdTousersInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutUsers_support_tickets_assigneeIdTousersInput, SupportTicketUncheckedCreateWithoutUsers_support_tickets_assigneeIdTousersInput>
  }

  export type SupportTicketCreateManyUsers_support_tickets_assigneeIdTousersInputEnvelope = {
    data: SupportTicketCreateManyUsers_support_tickets_assigneeIdTousersInput | SupportTicketCreateManyUsers_support_tickets_assigneeIdTousersInput[]
    skipDuplicates?: boolean
  }

  export type SupportTicketCreateWithoutUsers_support_tickets_userIdTousersInput = {
    title: string
    description: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vipPriorityScore?: number | null
    vipTriggerSource?: string | null
    users_support_tickets_assigneeIdTousers?: UserCreateNestedOneWithoutSupport_tickets_support_tickets_assigneeIdTousersInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutTicketInput
    assetHistory?: AssetTicketHistoryCreateNestedManyWithoutTicketInput
    ritms?: RITMCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUncheckedCreateWithoutUsers_support_tickets_userIdTousersInput = {
    id?: number
    title: string
    description: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assigneeId?: string | null
    vipPriorityScore?: number | null
    vipTriggerSource?: string | null
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutTicketInput
    assetHistory?: AssetTicketHistoryUncheckedCreateNestedManyWithoutTicketInput
    ritms?: RITMUncheckedCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketCreateOrConnectWithoutUsers_support_tickets_userIdTousersInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutUsers_support_tickets_userIdTousersInput, SupportTicketUncheckedCreateWithoutUsers_support_tickets_userIdTousersInput>
  }

  export type SupportTicketCreateManyUsers_support_tickets_userIdTousersInputEnvelope = {
    data: SupportTicketCreateManyUsers_support_tickets_userIdTousersInput | SupportTicketCreateManyUsers_support_tickets_userIdTousersInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleCreateWithoutUserInput = {
    assignedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserRoleUncheckedCreateWithoutUserInput = {
    roleId: number
    assignedAt?: Date | string
  }

  export type UserRoleCreateOrConnectWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleCreateManyUserInputEnvelope = {
    data: UserRoleCreateManyUserInput | UserRoleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ScimMappingCreateWithoutUserInput = {
    id?: string
    externalId?: string | null
    provider?: string | null
    syncTime?: Date | string | null
  }

  export type ScimMappingUncheckedCreateWithoutUserInput = {
    id?: string
    externalId?: string | null
    provider?: string | null
    syncTime?: Date | string | null
  }

  export type ScimMappingCreateOrConnectWithoutUserInput = {
    where: ScimMappingWhereUniqueInput
    create: XOR<ScimMappingCreateWithoutUserInput, ScimMappingUncheckedCreateWithoutUserInput>
  }

  export type ScimMappingCreateManyUserInputEnvelope = {
    data: ScimMappingCreateManyUserInput | ScimMappingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type KbArticleCreateWithoutAuthorInput = {
    slug: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isPublished?: boolean
    tags?: KbArticleCreatetagsInput | string[]
    versions?: KbArticleVersionCreateNestedManyWithoutArticleInput
    comments?: KbArticleCommentCreateNestedManyWithoutArticleInput
    currentVersion?: KbArticleVersionCreateNestedOneWithoutCurrentForArticleInput
  }

  export type KbArticleUncheckedCreateWithoutAuthorInput = {
    id?: number
    slug: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    currentVersionId?: number | null
    isPublished?: boolean
    tags?: KbArticleCreatetagsInput | string[]
    versions?: KbArticleVersionUncheckedCreateNestedManyWithoutArticleInput
    comments?: KbArticleCommentUncheckedCreateNestedManyWithoutArticleInput
  }

  export type KbArticleCreateOrConnectWithoutAuthorInput = {
    where: KbArticleWhereUniqueInput
    create: XOR<KbArticleCreateWithoutAuthorInput, KbArticleUncheckedCreateWithoutAuthorInput>
  }

  export type KbArticleCreateManyAuthorInputEnvelope = {
    data: KbArticleCreateManyAuthorInput | KbArticleCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type KbArticleVersionCreateWithoutAuthorInput = {
    content: string
    summary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: number
    isApproved?: boolean
    article: KbArticleCreateNestedOneWithoutVersionsInput
    currentForArticle?: KbArticleCreateNestedManyWithoutCurrentVersionInput
  }

  export type KbArticleVersionUncheckedCreateWithoutAuthorInput = {
    id?: number
    articleId: number
    content: string
    summary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: number
    isApproved?: boolean
    currentForArticle?: KbArticleUncheckedCreateNestedManyWithoutCurrentVersionInput
  }

  export type KbArticleVersionCreateOrConnectWithoutAuthorInput = {
    where: KbArticleVersionWhereUniqueInput
    create: XOR<KbArticleVersionCreateWithoutAuthorInput, KbArticleVersionUncheckedCreateWithoutAuthorInput>
  }

  export type KbArticleVersionCreateManyAuthorInputEnvelope = {
    data: KbArticleVersionCreateManyAuthorInput | KbArticleVersionCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type KbArticleCommentCreateWithoutUserInput = {
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    article: KbArticleCreateNestedOneWithoutCommentsInput
  }

  export type KbArticleCommentUncheckedCreateWithoutUserInput = {
    id?: number
    articleId: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type KbArticleCommentCreateOrConnectWithoutUserInput = {
    where: KbArticleCommentWhereUniqueInput
    create: XOR<KbArticleCommentCreateWithoutUserInput, KbArticleCommentUncheckedCreateWithoutUserInput>
  }

  export type KbArticleCommentCreateManyUserInputEnvelope = {
    data: KbArticleCommentCreateManyUserInput | KbArticleCommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type XpEventCreateWithoutUserInput = {
    amount: number
    reason?: string | null
    createdAt?: Date | string
  }

  export type XpEventUncheckedCreateWithoutUserInput = {
    id?: number
    amount: number
    reason?: string | null
    createdAt?: Date | string
  }

  export type XpEventCreateOrConnectWithoutUserInput = {
    where: XpEventWhereUniqueInput
    create: XOR<XpEventCreateWithoutUserInput, XpEventUncheckedCreateWithoutUserInput>
  }

  export type XpEventCreateManyUserInputEnvelope = {
    data: XpEventCreateManyUserInput | XpEventCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LeaderboardCreateWithoutUserInput = {
    xpTotal?: number
  }

  export type LeaderboardUncheckedCreateWithoutUserInput = {
    xpTotal?: number
  }

  export type LeaderboardCreateOrConnectWithoutUserInput = {
    where: LeaderboardWhereUniqueInput
    create: XOR<LeaderboardCreateWithoutUserInput, LeaderboardUncheckedCreateWithoutUserInput>
  }

  export type MailroomPackageCreateWithoutRecipientInput = {
    trackingNumber: string
    carrier: string
    sender?: string | null
    department?: string | null
    packageType?: string | null
    status: string
    assignedLocation?: string | null
    flags?: MailroomPackageCreateflagsInput | string[]
    intakePhotoUrl?: string | null
    deliveryPhotoUrl?: string | null
    signatureUrl?: string | null
    intakeLocation?: string | null
    deliveryLocation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ticket?: SupportTicketCreateNestedOneWithoutMailroomPackagesInput
    asset?: InventoryAssetCreateNestedOneWithoutMailroomPackagesInput
    deliveryEvents?: DeliveryEventCreateNestedManyWithoutPackageInput
    proxyAuthorizations?: ProxyAuthorizationCreateNestedManyWithoutPackageInput
  }

  export type MailroomPackageUncheckedCreateWithoutRecipientInput = {
    id?: number
    trackingNumber: string
    carrier: string
    sender?: string | null
    department?: string | null
    packageType?: string | null
    status: string
    assignedLocation?: string | null
    linkedTicketId?: number | null
    linkedAssetId?: number | null
    flags?: MailroomPackageCreateflagsInput | string[]
    intakePhotoUrl?: string | null
    deliveryPhotoUrl?: string | null
    signatureUrl?: string | null
    intakeLocation?: string | null
    deliveryLocation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveryEvents?: DeliveryEventUncheckedCreateNestedManyWithoutPackageInput
    proxyAuthorizations?: ProxyAuthorizationUncheckedCreateNestedManyWithoutPackageInput
  }

  export type MailroomPackageCreateOrConnectWithoutRecipientInput = {
    where: MailroomPackageWhereUniqueInput
    create: XOR<MailroomPackageCreateWithoutRecipientInput, MailroomPackageUncheckedCreateWithoutRecipientInput>
  }

  export type MailroomPackageCreateManyRecipientInputEnvelope = {
    data: MailroomPackageCreateManyRecipientInput | MailroomPackageCreateManyRecipientInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryEventCreateWithoutUserInput = {
    eventType: string
    location?: string | null
    timestamp?: Date | string
    photoUrl?: string | null
    signatureBlob?: Uint8Array | null
    package: MailroomPackageCreateNestedOneWithoutDeliveryEventsInput
  }

  export type DeliveryEventUncheckedCreateWithoutUserInput = {
    id?: number
    packageId: number
    eventType: string
    location?: string | null
    timestamp?: Date | string
    photoUrl?: string | null
    signatureBlob?: Uint8Array | null
  }

  export type DeliveryEventCreateOrConnectWithoutUserInput = {
    where: DeliveryEventWhereUniqueInput
    create: XOR<DeliveryEventCreateWithoutUserInput, DeliveryEventUncheckedCreateWithoutUserInput>
  }

  export type DeliveryEventCreateManyUserInputEnvelope = {
    data: DeliveryEventCreateManyUserInput | DeliveryEventCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProxyAuthorizationCreateWithoutRecipientInput = {
    expiration?: Date | string | null
    status: string
    proxy: UserCreateNestedOneWithoutProxyAuthorizationsAsProxyInput
    package: MailroomPackageCreateNestedOneWithoutProxyAuthorizationsInput
  }

  export type ProxyAuthorizationUncheckedCreateWithoutRecipientInput = {
    id?: number
    proxyId: string
    packageId: number
    expiration?: Date | string | null
    status: string
  }

  export type ProxyAuthorizationCreateOrConnectWithoutRecipientInput = {
    where: ProxyAuthorizationWhereUniqueInput
    create: XOR<ProxyAuthorizationCreateWithoutRecipientInput, ProxyAuthorizationUncheckedCreateWithoutRecipientInput>
  }

  export type ProxyAuthorizationCreateManyRecipientInputEnvelope = {
    data: ProxyAuthorizationCreateManyRecipientInput | ProxyAuthorizationCreateManyRecipientInput[]
    skipDuplicates?: boolean
  }

  export type ProxyAuthorizationCreateWithoutProxyInput = {
    expiration?: Date | string | null
    status: string
    recipient: UserCreateNestedOneWithoutProxyAuthorizationsAsRecipientInput
    package: MailroomPackageCreateNestedOneWithoutProxyAuthorizationsInput
  }

  export type ProxyAuthorizationUncheckedCreateWithoutProxyInput = {
    id?: number
    recipientId: string
    packageId: number
    expiration?: Date | string | null
    status: string
  }

  export type ProxyAuthorizationCreateOrConnectWithoutProxyInput = {
    where: ProxyAuthorizationWhereUniqueInput
    create: XOR<ProxyAuthorizationCreateWithoutProxyInput, ProxyAuthorizationUncheckedCreateWithoutProxyInput>
  }

  export type ProxyAuthorizationCreateManyProxyInputEnvelope = {
    data: ProxyAuthorizationCreateManyProxyInput | ProxyAuthorizationCreateManyProxyInput[]
    skipDuplicates?: boolean
  }

  export type VipProxyCreateWithoutVipInput = {
    createdAt?: Date | string
    expiresAt?: Date | string | null
    proxy: UserCreateNestedOneWithoutVipProxiesAsProxyInput
  }

  export type VipProxyUncheckedCreateWithoutVipInput = {
    id?: number
    proxyId: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type VipProxyCreateOrConnectWithoutVipInput = {
    where: VipProxyWhereUniqueInput
    create: XOR<VipProxyCreateWithoutVipInput, VipProxyUncheckedCreateWithoutVipInput>
  }

  export type VipProxyCreateManyVipInputEnvelope = {
    data: VipProxyCreateManyVipInput | VipProxyCreateManyVipInput[]
    skipDuplicates?: boolean
  }

  export type VipProxyCreateWithoutProxyInput = {
    createdAt?: Date | string
    expiresAt?: Date | string | null
    vip: UserCreateNestedOneWithoutVipProxiesAsVipInput
  }

  export type VipProxyUncheckedCreateWithoutProxyInput = {
    id?: number
    vipId: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type VipProxyCreateOrConnectWithoutProxyInput = {
    where: VipProxyWhereUniqueInput
    create: XOR<VipProxyCreateWithoutProxyInput, VipProxyUncheckedCreateWithoutProxyInput>
  }

  export type VipProxyCreateManyProxyInputEnvelope = {
    data: VipProxyCreateManyProxyInput | VipProxyCreateManyProxyInput[]
    skipDuplicates?: boolean
  }

  export type VipSlaHistoryCreateWithoutUserInput = {
    sla: JsonNullValueInput | InputJsonValue
    effectiveAt?: Date | string
    endedAt?: Date | string | null
  }

  export type VipSlaHistoryUncheckedCreateWithoutUserInput = {
    id?: number
    sla: JsonNullValueInput | InputJsonValue
    effectiveAt?: Date | string
    endedAt?: Date | string | null
  }

  export type VipSlaHistoryCreateOrConnectWithoutUserInput = {
    where: VipSlaHistoryWhereUniqueInput
    create: XOR<VipSlaHistoryCreateWithoutUserInput, VipSlaHistoryUncheckedCreateWithoutUserInput>
  }

  export type VipSlaHistoryCreateManyUserInputEnvelope = {
    data: VipSlaHistoryCreateManyUserInput | VipSlaHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AgentAvailabilityCreateWithoutUserInput = {
    id?: string
    queueName: string
    isAvailable?: boolean
    maxCapacity?: number
    currentLoad?: number
    status?: string
    lastUpdated?: Date | string
    createdAt?: Date | string
  }

  export type AgentAvailabilityUncheckedCreateWithoutUserInput = {
    id?: string
    queueName: string
    isAvailable?: boolean
    maxCapacity?: number
    currentLoad?: number
    status?: string
    lastUpdated?: Date | string
    createdAt?: Date | string
  }

  export type AgentAvailabilityCreateOrConnectWithoutUserInput = {
    where: AgentAvailabilityWhereUniqueInput
    create: XOR<AgentAvailabilityCreateWithoutUserInput, AgentAvailabilityUncheckedCreateWithoutUserInput>
  }

  export type AgentAvailabilityCreateManyUserInputEnvelope = {
    data: AgentAvailabilityCreateManyUserInput | AgentAvailabilityCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FeedbackUpsertWithWhereUniqueWithoutUserInput = {
    where: FeedbackWhereUniqueInput
    update: XOR<FeedbackUpdateWithoutUserInput, FeedbackUncheckedUpdateWithoutUserInput>
    create: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput>
  }

  export type FeedbackUpdateWithWhereUniqueWithoutUserInput = {
    where: FeedbackWhereUniqueInput
    data: XOR<FeedbackUpdateWithoutUserInput, FeedbackUncheckedUpdateWithoutUserInput>
  }

  export type FeedbackUpdateManyWithWhereWithoutUserInput = {
    where: FeedbackScalarWhereInput
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyWithoutUserInput>
  }

  export type FeedbackScalarWhereInput = {
    AND?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
    OR?: FeedbackScalarWhereInput[]
    NOT?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
    id?: IntFilter<"Feedback"> | number
    name?: StringNullableFilter<"Feedback"> | string | null
    message?: StringNullableFilter<"Feedback"> | string | null
    timestamp?: DateTimeFilter<"Feedback"> | Date | string
    userId?: StringNullableFilter<"Feedback"> | string | null
  }

  export type LogUpsertWithWhereUniqueWithoutUserInput = {
    where: LogWhereUniqueInput
    update: XOR<LogUpdateWithoutUserInput, LogUncheckedUpdateWithoutUserInput>
    create: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput>
  }

  export type LogUpdateWithWhereUniqueWithoutUserInput = {
    where: LogWhereUniqueInput
    data: XOR<LogUpdateWithoutUserInput, LogUncheckedUpdateWithoutUserInput>
  }

  export type LogUpdateManyWithWhereWithoutUserInput = {
    where: LogScalarWhereInput
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyWithoutUserInput>
  }

  export type LogScalarWhereInput = {
    AND?: LogScalarWhereInput | LogScalarWhereInput[]
    OR?: LogScalarWhereInput[]
    NOT?: LogScalarWhereInput | LogScalarWhereInput[]
    id?: IntFilter<"Log"> | number
    ticketId?: StringNullableFilter<"Log"> | string | null
    name?: StringNullableFilter<"Log"> | string | null
    email?: StringNullableFilter<"Log"> | string | null
    title?: StringNullableFilter<"Log"> | string | null
    system?: StringNullableFilter<"Log"> | string | null
    urgency?: StringNullableFilter<"Log"> | string | null
    timestamp?: DateTimeFilter<"Log"> | Date | string
    emailStatus?: StringNullableFilter<"Log"> | string | null
    userId?: StringNullableFilter<"Log"> | string | null
  }

  export type PasskeyUpsertWithWhereUniqueWithoutUserInput = {
    where: PasskeyWhereUniqueInput
    update: XOR<PasskeyUpdateWithoutUserInput, PasskeyUncheckedUpdateWithoutUserInput>
    create: XOR<PasskeyCreateWithoutUserInput, PasskeyUncheckedCreateWithoutUserInput>
  }

  export type PasskeyUpdateWithWhereUniqueWithoutUserInput = {
    where: PasskeyWhereUniqueInput
    data: XOR<PasskeyUpdateWithoutUserInput, PasskeyUncheckedUpdateWithoutUserInput>
  }

  export type PasskeyUpdateManyWithWhereWithoutUserInput = {
    where: PasskeyScalarWhereInput
    data: XOR<PasskeyUpdateManyMutationInput, PasskeyUncheckedUpdateManyWithoutUserInput>
  }

  export type PasskeyScalarWhereInput = {
    AND?: PasskeyScalarWhereInput | PasskeyScalarWhereInput[]
    OR?: PasskeyScalarWhereInput[]
    NOT?: PasskeyScalarWhereInput | PasskeyScalarWhereInput[]
    id?: IntFilter<"Passkey"> | number
    userId?: StringFilter<"Passkey"> | string
    credentialId?: StringFilter<"Passkey"> | string
    publicKey?: StringFilter<"Passkey"> | string
    counter?: IntFilter<"Passkey"> | number
    transports?: StringNullableFilter<"Passkey"> | string | null
    deviceType?: StringNullableFilter<"Passkey"> | string | null
    backedUp?: BoolFilter<"Passkey"> | boolean
    createdAt?: DateTimeFilter<"Passkey"> | Date | string
    lastUsed?: DateTimeNullableFilter<"Passkey"> | Date | string | null
  }

  export type SupportTicketUpsertWithWhereUniqueWithoutUsers_support_tickets_assigneeIdTousersInput = {
    where: SupportTicketWhereUniqueInput
    update: XOR<SupportTicketUpdateWithoutUsers_support_tickets_assigneeIdTousersInput, SupportTicketUncheckedUpdateWithoutUsers_support_tickets_assigneeIdTousersInput>
    create: XOR<SupportTicketCreateWithoutUsers_support_tickets_assigneeIdTousersInput, SupportTicketUncheckedCreateWithoutUsers_support_tickets_assigneeIdTousersInput>
  }

  export type SupportTicketUpdateWithWhereUniqueWithoutUsers_support_tickets_assigneeIdTousersInput = {
    where: SupportTicketWhereUniqueInput
    data: XOR<SupportTicketUpdateWithoutUsers_support_tickets_assigneeIdTousersInput, SupportTicketUncheckedUpdateWithoutUsers_support_tickets_assigneeIdTousersInput>
  }

  export type SupportTicketUpdateManyWithWhereWithoutUsers_support_tickets_assigneeIdTousersInput = {
    where: SupportTicketScalarWhereInput
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_assigneeIdTousersInput>
  }

  export type SupportTicketScalarWhereInput = {
    AND?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
    OR?: SupportTicketScalarWhereInput[]
    NOT?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
    id?: IntFilter<"SupportTicket"> | number
    title?: StringFilter<"SupportTicket"> | string
    description?: StringFilter<"SupportTicket"> | string
    status?: StringFilter<"SupportTicket"> | string
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
    userId?: StringNullableFilter<"SupportTicket"> | string | null
    assigneeId?: StringNullableFilter<"SupportTicket"> | string | null
    vipPriorityScore?: IntNullableFilter<"SupportTicket"> | number | null
    vipTriggerSource?: StringNullableFilter<"SupportTicket"> | string | null
  }

  export type SupportTicketUpsertWithWhereUniqueWithoutUsers_support_tickets_userIdTousersInput = {
    where: SupportTicketWhereUniqueInput
    update: XOR<SupportTicketUpdateWithoutUsers_support_tickets_userIdTousersInput, SupportTicketUncheckedUpdateWithoutUsers_support_tickets_userIdTousersInput>
    create: XOR<SupportTicketCreateWithoutUsers_support_tickets_userIdTousersInput, SupportTicketUncheckedCreateWithoutUsers_support_tickets_userIdTousersInput>
  }

  export type SupportTicketUpdateWithWhereUniqueWithoutUsers_support_tickets_userIdTousersInput = {
    where: SupportTicketWhereUniqueInput
    data: XOR<SupportTicketUpdateWithoutUsers_support_tickets_userIdTousersInput, SupportTicketUncheckedUpdateWithoutUsers_support_tickets_userIdTousersInput>
  }

  export type SupportTicketUpdateManyWithWhereWithoutUsers_support_tickets_userIdTousersInput = {
    where: SupportTicketScalarWhereInput
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_userIdTousersInput>
  }

  export type UserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    OR?: UserRoleScalarWhereInput[]
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    userId?: StringFilter<"UserRole"> | string
    roleId?: IntFilter<"UserRole"> | number
    assignedAt?: DateTimeFilter<"UserRole"> | Date | string
  }

  export type ScimMappingUpsertWithWhereUniqueWithoutUserInput = {
    where: ScimMappingWhereUniqueInput
    update: XOR<ScimMappingUpdateWithoutUserInput, ScimMappingUncheckedUpdateWithoutUserInput>
    create: XOR<ScimMappingCreateWithoutUserInput, ScimMappingUncheckedCreateWithoutUserInput>
  }

  export type ScimMappingUpdateWithWhereUniqueWithoutUserInput = {
    where: ScimMappingWhereUniqueInput
    data: XOR<ScimMappingUpdateWithoutUserInput, ScimMappingUncheckedUpdateWithoutUserInput>
  }

  export type ScimMappingUpdateManyWithWhereWithoutUserInput = {
    where: ScimMappingScalarWhereInput
    data: XOR<ScimMappingUpdateManyMutationInput, ScimMappingUncheckedUpdateManyWithoutUserInput>
  }

  export type ScimMappingScalarWhereInput = {
    AND?: ScimMappingScalarWhereInput | ScimMappingScalarWhereInput[]
    OR?: ScimMappingScalarWhereInput[]
    NOT?: ScimMappingScalarWhereInput | ScimMappingScalarWhereInput[]
    id?: StringFilter<"ScimMapping"> | string
    externalId?: StringNullableFilter<"ScimMapping"> | string | null
    userId?: StringFilter<"ScimMapping"> | string
    provider?: StringNullableFilter<"ScimMapping"> | string | null
    syncTime?: DateTimeNullableFilter<"ScimMapping"> | Date | string | null
  }

  export type KbArticleUpsertWithWhereUniqueWithoutAuthorInput = {
    where: KbArticleWhereUniqueInput
    update: XOR<KbArticleUpdateWithoutAuthorInput, KbArticleUncheckedUpdateWithoutAuthorInput>
    create: XOR<KbArticleCreateWithoutAuthorInput, KbArticleUncheckedCreateWithoutAuthorInput>
  }

  export type KbArticleUpdateWithWhereUniqueWithoutAuthorInput = {
    where: KbArticleWhereUniqueInput
    data: XOR<KbArticleUpdateWithoutAuthorInput, KbArticleUncheckedUpdateWithoutAuthorInput>
  }

  export type KbArticleUpdateManyWithWhereWithoutAuthorInput = {
    where: KbArticleScalarWhereInput
    data: XOR<KbArticleUpdateManyMutationInput, KbArticleUncheckedUpdateManyWithoutAuthorInput>
  }

  export type KbArticleScalarWhereInput = {
    AND?: KbArticleScalarWhereInput | KbArticleScalarWhereInput[]
    OR?: KbArticleScalarWhereInput[]
    NOT?: KbArticleScalarWhereInput | KbArticleScalarWhereInput[]
    id?: IntFilter<"KbArticle"> | number
    slug?: StringFilter<"KbArticle"> | string
    title?: StringFilter<"KbArticle"> | string
    createdAt?: DateTimeFilter<"KbArticle"> | Date | string
    updatedAt?: DateTimeFilter<"KbArticle"> | Date | string
    authorId?: StringNullableFilter<"KbArticle"> | string | null
    currentVersionId?: IntNullableFilter<"KbArticle"> | number | null
    isPublished?: BoolFilter<"KbArticle"> | boolean
    tags?: StringNullableListFilter<"KbArticle">
  }

  export type KbArticleVersionUpsertWithWhereUniqueWithoutAuthorInput = {
    where: KbArticleVersionWhereUniqueInput
    update: XOR<KbArticleVersionUpdateWithoutAuthorInput, KbArticleVersionUncheckedUpdateWithoutAuthorInput>
    create: XOR<KbArticleVersionCreateWithoutAuthorInput, KbArticleVersionUncheckedCreateWithoutAuthorInput>
  }

  export type KbArticleVersionUpdateWithWhereUniqueWithoutAuthorInput = {
    where: KbArticleVersionWhereUniqueInput
    data: XOR<KbArticleVersionUpdateWithoutAuthorInput, KbArticleVersionUncheckedUpdateWithoutAuthorInput>
  }

  export type KbArticleVersionUpdateManyWithWhereWithoutAuthorInput = {
    where: KbArticleVersionScalarWhereInput
    data: XOR<KbArticleVersionUpdateManyMutationInput, KbArticleVersionUncheckedUpdateManyWithoutAuthorInput>
  }

  export type KbArticleVersionScalarWhereInput = {
    AND?: KbArticleVersionScalarWhereInput | KbArticleVersionScalarWhereInput[]
    OR?: KbArticleVersionScalarWhereInput[]
    NOT?: KbArticleVersionScalarWhereInput | KbArticleVersionScalarWhereInput[]
    id?: IntFilter<"KbArticleVersion"> | number
    articleId?: IntFilter<"KbArticleVersion"> | number
    content?: StringFilter<"KbArticleVersion"> | string
    summary?: StringNullableFilter<"KbArticleVersion"> | string | null
    createdAt?: DateTimeFilter<"KbArticleVersion"> | Date | string
    updatedAt?: DateTimeFilter<"KbArticleVersion"> | Date | string
    authorId?: StringNullableFilter<"KbArticleVersion"> | string | null
    version?: IntFilter<"KbArticleVersion"> | number
    isApproved?: BoolFilter<"KbArticleVersion"> | boolean
  }

  export type KbArticleCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: KbArticleCommentWhereUniqueInput
    update: XOR<KbArticleCommentUpdateWithoutUserInput, KbArticleCommentUncheckedUpdateWithoutUserInput>
    create: XOR<KbArticleCommentCreateWithoutUserInput, KbArticleCommentUncheckedCreateWithoutUserInput>
  }

  export type KbArticleCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: KbArticleCommentWhereUniqueInput
    data: XOR<KbArticleCommentUpdateWithoutUserInput, KbArticleCommentUncheckedUpdateWithoutUserInput>
  }

  export type KbArticleCommentUpdateManyWithWhereWithoutUserInput = {
    where: KbArticleCommentScalarWhereInput
    data: XOR<KbArticleCommentUpdateManyMutationInput, KbArticleCommentUncheckedUpdateManyWithoutUserInput>
  }

  export type KbArticleCommentScalarWhereInput = {
    AND?: KbArticleCommentScalarWhereInput | KbArticleCommentScalarWhereInput[]
    OR?: KbArticleCommentScalarWhereInput[]
    NOT?: KbArticleCommentScalarWhereInput | KbArticleCommentScalarWhereInput[]
    id?: IntFilter<"KbArticleComment"> | number
    articleId?: IntFilter<"KbArticleComment"> | number
    userId?: StringFilter<"KbArticleComment"> | string
    content?: StringFilter<"KbArticleComment"> | string
    createdAt?: DateTimeFilter<"KbArticleComment"> | Date | string
    updatedAt?: DateTimeFilter<"KbArticleComment"> | Date | string
    isDeleted?: BoolFilter<"KbArticleComment"> | boolean
  }

  export type XpEventUpsertWithWhereUniqueWithoutUserInput = {
    where: XpEventWhereUniqueInput
    update: XOR<XpEventUpdateWithoutUserInput, XpEventUncheckedUpdateWithoutUserInput>
    create: XOR<XpEventCreateWithoutUserInput, XpEventUncheckedCreateWithoutUserInput>
  }

  export type XpEventUpdateWithWhereUniqueWithoutUserInput = {
    where: XpEventWhereUniqueInput
    data: XOR<XpEventUpdateWithoutUserInput, XpEventUncheckedUpdateWithoutUserInput>
  }

  export type XpEventUpdateManyWithWhereWithoutUserInput = {
    where: XpEventScalarWhereInput
    data: XOR<XpEventUpdateManyMutationInput, XpEventUncheckedUpdateManyWithoutUserInput>
  }

  export type XpEventScalarWhereInput = {
    AND?: XpEventScalarWhereInput | XpEventScalarWhereInput[]
    OR?: XpEventScalarWhereInput[]
    NOT?: XpEventScalarWhereInput | XpEventScalarWhereInput[]
    id?: IntFilter<"XpEvent"> | number
    userId?: StringFilter<"XpEvent"> | string
    amount?: IntFilter<"XpEvent"> | number
    reason?: StringNullableFilter<"XpEvent"> | string | null
    createdAt?: DateTimeFilter<"XpEvent"> | Date | string
  }

  export type LeaderboardUpsertWithoutUserInput = {
    update: XOR<LeaderboardUpdateWithoutUserInput, LeaderboardUncheckedUpdateWithoutUserInput>
    create: XOR<LeaderboardCreateWithoutUserInput, LeaderboardUncheckedCreateWithoutUserInput>
    where?: LeaderboardWhereInput
  }

  export type LeaderboardUpdateToOneWithWhereWithoutUserInput = {
    where?: LeaderboardWhereInput
    data: XOR<LeaderboardUpdateWithoutUserInput, LeaderboardUncheckedUpdateWithoutUserInput>
  }

  export type LeaderboardUpdateWithoutUserInput = {
    xpTotal?: IntFieldUpdateOperationsInput | number
  }

  export type LeaderboardUncheckedUpdateWithoutUserInput = {
    xpTotal?: IntFieldUpdateOperationsInput | number
  }

  export type MailroomPackageUpsertWithWhereUniqueWithoutRecipientInput = {
    where: MailroomPackageWhereUniqueInput
    update: XOR<MailroomPackageUpdateWithoutRecipientInput, MailroomPackageUncheckedUpdateWithoutRecipientInput>
    create: XOR<MailroomPackageCreateWithoutRecipientInput, MailroomPackageUncheckedCreateWithoutRecipientInput>
  }

  export type MailroomPackageUpdateWithWhereUniqueWithoutRecipientInput = {
    where: MailroomPackageWhereUniqueInput
    data: XOR<MailroomPackageUpdateWithoutRecipientInput, MailroomPackageUncheckedUpdateWithoutRecipientInput>
  }

  export type MailroomPackageUpdateManyWithWhereWithoutRecipientInput = {
    where: MailroomPackageScalarWhereInput
    data: XOR<MailroomPackageUpdateManyMutationInput, MailroomPackageUncheckedUpdateManyWithoutRecipientInput>
  }

  export type MailroomPackageScalarWhereInput = {
    AND?: MailroomPackageScalarWhereInput | MailroomPackageScalarWhereInput[]
    OR?: MailroomPackageScalarWhereInput[]
    NOT?: MailroomPackageScalarWhereInput | MailroomPackageScalarWhereInput[]
    id?: IntFilter<"MailroomPackage"> | number
    trackingNumber?: StringFilter<"MailroomPackage"> | string
    carrier?: StringFilter<"MailroomPackage"> | string
    sender?: StringNullableFilter<"MailroomPackage"> | string | null
    recipientId?: StringFilter<"MailroomPackage"> | string
    department?: StringNullableFilter<"MailroomPackage"> | string | null
    packageType?: StringNullableFilter<"MailroomPackage"> | string | null
    status?: StringFilter<"MailroomPackage"> | string
    assignedLocation?: StringNullableFilter<"MailroomPackage"> | string | null
    linkedTicketId?: IntNullableFilter<"MailroomPackage"> | number | null
    linkedAssetId?: IntNullableFilter<"MailroomPackage"> | number | null
    flags?: StringNullableListFilter<"MailroomPackage">
    intakePhotoUrl?: StringNullableFilter<"MailroomPackage"> | string | null
    deliveryPhotoUrl?: StringNullableFilter<"MailroomPackage"> | string | null
    signatureUrl?: StringNullableFilter<"MailroomPackage"> | string | null
    intakeLocation?: StringNullableFilter<"MailroomPackage"> | string | null
    deliveryLocation?: StringNullableFilter<"MailroomPackage"> | string | null
    createdAt?: DateTimeFilter<"MailroomPackage"> | Date | string
    updatedAt?: DateTimeFilter<"MailroomPackage"> | Date | string
  }

  export type DeliveryEventUpsertWithWhereUniqueWithoutUserInput = {
    where: DeliveryEventWhereUniqueInput
    update: XOR<DeliveryEventUpdateWithoutUserInput, DeliveryEventUncheckedUpdateWithoutUserInput>
    create: XOR<DeliveryEventCreateWithoutUserInput, DeliveryEventUncheckedCreateWithoutUserInput>
  }

  export type DeliveryEventUpdateWithWhereUniqueWithoutUserInput = {
    where: DeliveryEventWhereUniqueInput
    data: XOR<DeliveryEventUpdateWithoutUserInput, DeliveryEventUncheckedUpdateWithoutUserInput>
  }

  export type DeliveryEventUpdateManyWithWhereWithoutUserInput = {
    where: DeliveryEventScalarWhereInput
    data: XOR<DeliveryEventUpdateManyMutationInput, DeliveryEventUncheckedUpdateManyWithoutUserInput>
  }

  export type DeliveryEventScalarWhereInput = {
    AND?: DeliveryEventScalarWhereInput | DeliveryEventScalarWhereInput[]
    OR?: DeliveryEventScalarWhereInput[]
    NOT?: DeliveryEventScalarWhereInput | DeliveryEventScalarWhereInput[]
    id?: IntFilter<"DeliveryEvent"> | number
    packageId?: IntFilter<"DeliveryEvent"> | number
    eventType?: StringFilter<"DeliveryEvent"> | string
    performedBy?: StringFilter<"DeliveryEvent"> | string
    location?: StringNullableFilter<"DeliveryEvent"> | string | null
    timestamp?: DateTimeFilter<"DeliveryEvent"> | Date | string
    photoUrl?: StringNullableFilter<"DeliveryEvent"> | string | null
    signatureBlob?: BytesNullableFilter<"DeliveryEvent"> | Uint8Array | null
  }

  export type ProxyAuthorizationUpsertWithWhereUniqueWithoutRecipientInput = {
    where: ProxyAuthorizationWhereUniqueInput
    update: XOR<ProxyAuthorizationUpdateWithoutRecipientInput, ProxyAuthorizationUncheckedUpdateWithoutRecipientInput>
    create: XOR<ProxyAuthorizationCreateWithoutRecipientInput, ProxyAuthorizationUncheckedCreateWithoutRecipientInput>
  }

  export type ProxyAuthorizationUpdateWithWhereUniqueWithoutRecipientInput = {
    where: ProxyAuthorizationWhereUniqueInput
    data: XOR<ProxyAuthorizationUpdateWithoutRecipientInput, ProxyAuthorizationUncheckedUpdateWithoutRecipientInput>
  }

  export type ProxyAuthorizationUpdateManyWithWhereWithoutRecipientInput = {
    where: ProxyAuthorizationScalarWhereInput
    data: XOR<ProxyAuthorizationUpdateManyMutationInput, ProxyAuthorizationUncheckedUpdateManyWithoutRecipientInput>
  }

  export type ProxyAuthorizationScalarWhereInput = {
    AND?: ProxyAuthorizationScalarWhereInput | ProxyAuthorizationScalarWhereInput[]
    OR?: ProxyAuthorizationScalarWhereInput[]
    NOT?: ProxyAuthorizationScalarWhereInput | ProxyAuthorizationScalarWhereInput[]
    id?: IntFilter<"ProxyAuthorization"> | number
    recipientId?: StringFilter<"ProxyAuthorization"> | string
    proxyId?: StringFilter<"ProxyAuthorization"> | string
    packageId?: IntFilter<"ProxyAuthorization"> | number
    expiration?: DateTimeNullableFilter<"ProxyAuthorization"> | Date | string | null
    status?: StringFilter<"ProxyAuthorization"> | string
  }

  export type ProxyAuthorizationUpsertWithWhereUniqueWithoutProxyInput = {
    where: ProxyAuthorizationWhereUniqueInput
    update: XOR<ProxyAuthorizationUpdateWithoutProxyInput, ProxyAuthorizationUncheckedUpdateWithoutProxyInput>
    create: XOR<ProxyAuthorizationCreateWithoutProxyInput, ProxyAuthorizationUncheckedCreateWithoutProxyInput>
  }

  export type ProxyAuthorizationUpdateWithWhereUniqueWithoutProxyInput = {
    where: ProxyAuthorizationWhereUniqueInput
    data: XOR<ProxyAuthorizationUpdateWithoutProxyInput, ProxyAuthorizationUncheckedUpdateWithoutProxyInput>
  }

  export type ProxyAuthorizationUpdateManyWithWhereWithoutProxyInput = {
    where: ProxyAuthorizationScalarWhereInput
    data: XOR<ProxyAuthorizationUpdateManyMutationInput, ProxyAuthorizationUncheckedUpdateManyWithoutProxyInput>
  }

  export type VipProxyUpsertWithWhereUniqueWithoutVipInput = {
    where: VipProxyWhereUniqueInput
    update: XOR<VipProxyUpdateWithoutVipInput, VipProxyUncheckedUpdateWithoutVipInput>
    create: XOR<VipProxyCreateWithoutVipInput, VipProxyUncheckedCreateWithoutVipInput>
  }

  export type VipProxyUpdateWithWhereUniqueWithoutVipInput = {
    where: VipProxyWhereUniqueInput
    data: XOR<VipProxyUpdateWithoutVipInput, VipProxyUncheckedUpdateWithoutVipInput>
  }

  export type VipProxyUpdateManyWithWhereWithoutVipInput = {
    where: VipProxyScalarWhereInput
    data: XOR<VipProxyUpdateManyMutationInput, VipProxyUncheckedUpdateManyWithoutVipInput>
  }

  export type VipProxyScalarWhereInput = {
    AND?: VipProxyScalarWhereInput | VipProxyScalarWhereInput[]
    OR?: VipProxyScalarWhereInput[]
    NOT?: VipProxyScalarWhereInput | VipProxyScalarWhereInput[]
    id?: IntFilter<"VipProxy"> | number
    vipId?: StringFilter<"VipProxy"> | string
    proxyId?: StringFilter<"VipProxy"> | string
    createdAt?: DateTimeFilter<"VipProxy"> | Date | string
    expiresAt?: DateTimeNullableFilter<"VipProxy"> | Date | string | null
  }

  export type VipProxyUpsertWithWhereUniqueWithoutProxyInput = {
    where: VipProxyWhereUniqueInput
    update: XOR<VipProxyUpdateWithoutProxyInput, VipProxyUncheckedUpdateWithoutProxyInput>
    create: XOR<VipProxyCreateWithoutProxyInput, VipProxyUncheckedCreateWithoutProxyInput>
  }

  export type VipProxyUpdateWithWhereUniqueWithoutProxyInput = {
    where: VipProxyWhereUniqueInput
    data: XOR<VipProxyUpdateWithoutProxyInput, VipProxyUncheckedUpdateWithoutProxyInput>
  }

  export type VipProxyUpdateManyWithWhereWithoutProxyInput = {
    where: VipProxyScalarWhereInput
    data: XOR<VipProxyUpdateManyMutationInput, VipProxyUncheckedUpdateManyWithoutProxyInput>
  }

  export type VipSlaHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: VipSlaHistoryWhereUniqueInput
    update: XOR<VipSlaHistoryUpdateWithoutUserInput, VipSlaHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<VipSlaHistoryCreateWithoutUserInput, VipSlaHistoryUncheckedCreateWithoutUserInput>
  }

  export type VipSlaHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: VipSlaHistoryWhereUniqueInput
    data: XOR<VipSlaHistoryUpdateWithoutUserInput, VipSlaHistoryUncheckedUpdateWithoutUserInput>
  }

  export type VipSlaHistoryUpdateManyWithWhereWithoutUserInput = {
    where: VipSlaHistoryScalarWhereInput
    data: XOR<VipSlaHistoryUpdateManyMutationInput, VipSlaHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type VipSlaHistoryScalarWhereInput = {
    AND?: VipSlaHistoryScalarWhereInput | VipSlaHistoryScalarWhereInput[]
    OR?: VipSlaHistoryScalarWhereInput[]
    NOT?: VipSlaHistoryScalarWhereInput | VipSlaHistoryScalarWhereInput[]
    id?: IntFilter<"VipSlaHistory"> | number
    userId?: StringFilter<"VipSlaHistory"> | string
    sla?: JsonFilter<"VipSlaHistory">
    effectiveAt?: DateTimeFilter<"VipSlaHistory"> | Date | string
    endedAt?: DateTimeNullableFilter<"VipSlaHistory"> | Date | string | null
  }

  export type AgentAvailabilityUpsertWithWhereUniqueWithoutUserInput = {
    where: AgentAvailabilityWhereUniqueInput
    update: XOR<AgentAvailabilityUpdateWithoutUserInput, AgentAvailabilityUncheckedUpdateWithoutUserInput>
    create: XOR<AgentAvailabilityCreateWithoutUserInput, AgentAvailabilityUncheckedCreateWithoutUserInput>
  }

  export type AgentAvailabilityUpdateWithWhereUniqueWithoutUserInput = {
    where: AgentAvailabilityWhereUniqueInput
    data: XOR<AgentAvailabilityUpdateWithoutUserInput, AgentAvailabilityUncheckedUpdateWithoutUserInput>
  }

  export type AgentAvailabilityUpdateManyWithWhereWithoutUserInput = {
    where: AgentAvailabilityScalarWhereInput
    data: XOR<AgentAvailabilityUpdateManyMutationInput, AgentAvailabilityUncheckedUpdateManyWithoutUserInput>
  }

  export type AgentAvailabilityScalarWhereInput = {
    AND?: AgentAvailabilityScalarWhereInput | AgentAvailabilityScalarWhereInput[]
    OR?: AgentAvailabilityScalarWhereInput[]
    NOT?: AgentAvailabilityScalarWhereInput | AgentAvailabilityScalarWhereInput[]
    id?: StringFilter<"AgentAvailability"> | string
    userId?: StringFilter<"AgentAvailability"> | string
    queueName?: StringFilter<"AgentAvailability"> | string
    isAvailable?: BoolFilter<"AgentAvailability"> | boolean
    maxCapacity?: IntFilter<"AgentAvailability"> | number
    currentLoad?: IntFilter<"AgentAvailability"> | number
    status?: StringFilter<"AgentAvailability"> | string
    lastUpdated?: DateTimeFilter<"AgentAvailability"> | Date | string
    createdAt?: DateTimeFilter<"AgentAvailability"> | Date | string
  }

  export type RolePermissionCreateWithoutRoleInput = {
    assignedAt?: Date | string
    permission: PermissionCreateNestedOneWithoutRolesInput
  }

  export type RolePermissionUncheckedCreateWithoutRoleInput = {
    permissionId: number
    assignedAt?: Date | string
  }

  export type RolePermissionCreateOrConnectWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionCreateManyRoleInputEnvelope = {
    data: RolePermissionCreateManyRoleInput | RolePermissionCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleCreateWithoutRoleInput = {
    assignedAt?: Date | string
    user: UserCreateNestedOneWithoutRolesInput
  }

  export type UserRoleUncheckedCreateWithoutRoleInput = {
    userId: string
    assignedAt?: Date | string
  }

  export type UserRoleCreateOrConnectWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleCreateManyRoleInputEnvelope = {
    data: UserRoleCreateManyRoleInput | UserRoleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutRoleInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutRoleInput>
  }

  export type RolePermissionScalarWhereInput = {
    AND?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    OR?: RolePermissionScalarWhereInput[]
    NOT?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    roleId?: IntFilter<"RolePermission"> | number
    permissionId?: IntFilter<"RolePermission"> | number
    assignedAt?: DateTimeFilter<"RolePermission"> | Date | string
  }

  export type UserRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutRoleInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type RolePermissionCreateWithoutPermissionInput = {
    assignedAt?: Date | string
    role: RoleCreateNestedOneWithoutPermissionsInput
  }

  export type RolePermissionUncheckedCreateWithoutPermissionInput = {
    roleId: number
    assignedAt?: Date | string
  }

  export type RolePermissionCreateOrConnectWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionCreateManyPermissionInputEnvelope = {
    data: RolePermissionCreateManyPermissionInput | RolePermissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type RoleCreateWithoutUsersInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutRolesInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    scimMappings?: ScimMappingCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentCreateNestedManyWithoutUserInput
    xpEvents?: XpEventCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRolesInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    scimMappings?: ScimMappingUncheckedCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentUncheckedCreateNestedManyWithoutUserInput
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventUncheckedCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyUncheckedCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyUncheckedCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryUncheckedCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type UserUpsertWithoutRolesInput = {
    update: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
  }

  export type UserUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    scimMappings?: ScimMappingUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    scimMappings?: ScimMappingUncheckedUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUncheckedUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUncheckedUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUncheckedUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUncheckedUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUncheckedUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PermissionCreateWithoutRolesInput = {
    name: string
    description?: string | null
    resource?: string | null
    action?: string | null
    createdAt?: Date | string
  }

  export type PermissionUncheckedCreateWithoutRolesInput = {
    id?: number
    name: string
    description?: string | null
    resource?: string | null
    action?: string | null
    createdAt?: Date | string
  }

  export type PermissionCreateOrConnectWithoutRolesInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
  }

  export type RoleCreateWithoutPermissionsInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutPermissionsInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutPermissionsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
  }

  export type PermissionUpsertWithoutRolesInput = {
    update: XOR<PermissionUpdateWithoutRolesInput, PermissionUncheckedUpdateWithoutRolesInput>
    create: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    where?: PermissionWhereInput
  }

  export type PermissionUpdateToOneWithWhereWithoutRolesInput = {
    where?: PermissionWhereInput
    data: XOR<PermissionUpdateWithoutRolesInput, PermissionUncheckedUpdateWithoutRolesInput>
  }

  export type PermissionUpdateWithoutRolesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUpsertWithoutPermissionsInput = {
    update: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type RoleUpdateWithoutPermissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutPermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type UserCreateWithoutPasskeysInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentCreateNestedManyWithoutUserInput
    xpEvents?: XpEventCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPasskeysInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingUncheckedCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentUncheckedCreateNestedManyWithoutUserInput
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventUncheckedCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyUncheckedCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyUncheckedCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryUncheckedCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPasskeysInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasskeysInput, UserUncheckedCreateWithoutPasskeysInput>
  }

  export type UserUpsertWithoutPasskeysInput = {
    update: XOR<UserUpdateWithoutPasskeysInput, UserUncheckedUpdateWithoutPasskeysInput>
    create: XOR<UserCreateWithoutPasskeysInput, UserUncheckedCreateWithoutPasskeysInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasskeysInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasskeysInput, UserUncheckedUpdateWithoutPasskeysInput>
  }

  export type UserUpdateWithoutPasskeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPasskeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUncheckedUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUncheckedUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUncheckedUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUncheckedUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUncheckedUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUncheckedUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutLogsInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentCreateNestedManyWithoutUserInput
    xpEvents?: XpEventCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLogsInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingUncheckedCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentUncheckedCreateNestedManyWithoutUserInput
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventUncheckedCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyUncheckedCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyUncheckedCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryUncheckedCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
  }

  export type UserUpsertWithoutLogsInput = {
    update: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
  }

  export type UserUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUncheckedUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUncheckedUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUncheckedUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUncheckedUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUncheckedUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUncheckedUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ConfigHistoryCreateWithoutConfigInput = {
    oldValue?: string | null
    newValue?: string | null
    changedBy?: string | null
    changeReason?: string | null
    createdAt?: Date | string
  }

  export type ConfigHistoryUncheckedCreateWithoutConfigInput = {
    id?: number
    oldValue?: string | null
    newValue?: string | null
    changedBy?: string | null
    changeReason?: string | null
    createdAt?: Date | string
  }

  export type ConfigHistoryCreateOrConnectWithoutConfigInput = {
    where: ConfigHistoryWhereUniqueInput
    create: XOR<ConfigHistoryCreateWithoutConfigInput, ConfigHistoryUncheckedCreateWithoutConfigInput>
  }

  export type ConfigHistoryCreateManyConfigInputEnvelope = {
    data: ConfigHistoryCreateManyConfigInput | ConfigHistoryCreateManyConfigInput[]
    skipDuplicates?: boolean
  }

  export type ConfigHistoryUpsertWithWhereUniqueWithoutConfigInput = {
    where: ConfigHistoryWhereUniqueInput
    update: XOR<ConfigHistoryUpdateWithoutConfigInput, ConfigHistoryUncheckedUpdateWithoutConfigInput>
    create: XOR<ConfigHistoryCreateWithoutConfigInput, ConfigHistoryUncheckedCreateWithoutConfigInput>
  }

  export type ConfigHistoryUpdateWithWhereUniqueWithoutConfigInput = {
    where: ConfigHistoryWhereUniqueInput
    data: XOR<ConfigHistoryUpdateWithoutConfigInput, ConfigHistoryUncheckedUpdateWithoutConfigInput>
  }

  export type ConfigHistoryUpdateManyWithWhereWithoutConfigInput = {
    where: ConfigHistoryScalarWhereInput
    data: XOR<ConfigHistoryUpdateManyMutationInput, ConfigHistoryUncheckedUpdateManyWithoutConfigInput>
  }

  export type ConfigHistoryScalarWhereInput = {
    AND?: ConfigHistoryScalarWhereInput | ConfigHistoryScalarWhereInput[]
    OR?: ConfigHistoryScalarWhereInput[]
    NOT?: ConfigHistoryScalarWhereInput | ConfigHistoryScalarWhereInput[]
    id?: IntFilter<"ConfigHistory"> | number
    configKey?: StringFilter<"ConfigHistory"> | string
    oldValue?: StringNullableFilter<"ConfigHistory"> | string | null
    newValue?: StringNullableFilter<"ConfigHistory"> | string | null
    changedBy?: StringNullableFilter<"ConfigHistory"> | string | null
    changeReason?: StringNullableFilter<"ConfigHistory"> | string | null
    createdAt?: DateTimeFilter<"ConfigHistory"> | Date | string
  }

  export type ConfigCreateWithoutHistoryInput = {
    key: string
    value?: string | null
    valueType?: string | null
    description?: string | null
    isPublic?: boolean
    category?: string | null
    subcategory?: string | null
    isUIEditable?: boolean
    isRequired?: boolean
    defaultValue?: string | null
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    displayOrder?: number | null
    helpText?: string | null
    isAdvanced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type ConfigUncheckedCreateWithoutHistoryInput = {
    key: string
    value?: string | null
    valueType?: string | null
    description?: string | null
    isPublic?: boolean
    category?: string | null
    subcategory?: string | null
    isUIEditable?: boolean
    isRequired?: boolean
    defaultValue?: string | null
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    displayOrder?: number | null
    helpText?: string | null
    isAdvanced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type ConfigCreateOrConnectWithoutHistoryInput = {
    where: ConfigWhereUniqueInput
    create: XOR<ConfigCreateWithoutHistoryInput, ConfigUncheckedCreateWithoutHistoryInput>
  }

  export type ConfigUpsertWithoutHistoryInput = {
    update: XOR<ConfigUpdateWithoutHistoryInput, ConfigUncheckedUpdateWithoutHistoryInput>
    create: XOR<ConfigCreateWithoutHistoryInput, ConfigUncheckedCreateWithoutHistoryInput>
    where?: ConfigWhereInput
  }

  export type ConfigUpdateToOneWithWhereWithoutHistoryInput = {
    where?: ConfigWhereInput
    data: XOR<ConfigUpdateWithoutHistoryInput, ConfigUncheckedUpdateWithoutHistoryInput>
  }

  export type ConfigUpdateWithoutHistoryInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    valueType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    isUIEditable?: BoolFieldUpdateOperationsInput | boolean
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    isAdvanced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConfigUncheckedUpdateWithoutHistoryInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    valueType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    isUIEditable?: BoolFieldUpdateOperationsInput | boolean
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    validationRules?: NullableJsonNullValueInput | InputJsonValue
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    isAdvanced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KioskActivationCreateWithoutKioskInput = {
    id: string
    code: string
    qrCode: string
    expiresAt: Date | string
    used?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type KioskActivationUncheckedCreateWithoutKioskInput = {
    id: string
    code: string
    qrCode: string
    expiresAt: Date | string
    used?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type KioskActivationCreateOrConnectWithoutKioskInput = {
    where: KioskActivationWhereUniqueInput
    create: XOR<KioskActivationCreateWithoutKioskInput, KioskActivationUncheckedCreateWithoutKioskInput>
  }

  export type KioskActivationCreateManyKioskInputEnvelope = {
    data: KioskActivationCreateManyKioskInput | KioskActivationCreateManyKioskInput[]
    skipDuplicates?: boolean
  }

  export type KioskAssetRegistryCreateWithoutKioskInput = {
    registrationDate?: Date | string
    lastCheckIn?: Date | string | null
    status?: string
    helixSyncStatus?: string
    helixLastSync?: Date | string | null
    helixErrorMessage?: string | null
    encryptedMetadata?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    asset: InventoryAssetCreateNestedOneWithoutKioskRegistrationsInput
  }

  export type KioskAssetRegistryUncheckedCreateWithoutKioskInput = {
    id?: number
    assetId: number
    registrationDate?: Date | string
    lastCheckIn?: Date | string | null
    status?: string
    helixSyncStatus?: string
    helixLastSync?: Date | string | null
    helixErrorMessage?: string | null
    encryptedMetadata?: string | null
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type KioskAssetRegistryCreateOrConnectWithoutKioskInput = {
    where: KioskAssetRegistryWhereUniqueInput
    create: XOR<KioskAssetRegistryCreateWithoutKioskInput, KioskAssetRegistryUncheckedCreateWithoutKioskInput>
  }

  export type KioskAssetRegistryCreateManyKioskInputEnvelope = {
    data: KioskAssetRegistryCreateManyKioskInput | KioskAssetRegistryCreateManyKioskInput[]
    skipDuplicates?: boolean
  }

  export type HelixSyncFailureCreateWithoutKioskInput = {
    errorMessage: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: number
    nextRetryAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    asset: InventoryAssetCreateNestedOneWithoutSyncFailuresInput
  }

  export type HelixSyncFailureUncheckedCreateWithoutKioskInput = {
    id?: number
    assetId: number
    errorMessage: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: number
    nextRetryAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HelixSyncFailureCreateOrConnectWithoutKioskInput = {
    where: HelixSyncFailureWhereUniqueInput
    create: XOR<HelixSyncFailureCreateWithoutKioskInput, HelixSyncFailureUncheckedCreateWithoutKioskInput>
  }

  export type HelixSyncFailureCreateManyKioskInputEnvelope = {
    data: HelixSyncFailureCreateManyKioskInput | HelixSyncFailureCreateManyKioskInput[]
    skipDuplicates?: boolean
  }

  export type KioskOrganizationAssignmentCreateWithoutKioskInput = {
    organizationId: number
    department?: string | null
    floor?: string | null
    room?: string | null
    building?: string | null
    assignedBy?: string | null
    assignmentMetadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KioskOrganizationAssignmentUncheckedCreateWithoutKioskInput = {
    id?: number
    organizationId: number
    department?: string | null
    floor?: string | null
    room?: string | null
    building?: string | null
    assignedBy?: string | null
    assignmentMetadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KioskOrganizationAssignmentCreateOrConnectWithoutKioskInput = {
    where: KioskOrganizationAssignmentWhereUniqueInput
    create: XOR<KioskOrganizationAssignmentCreateWithoutKioskInput, KioskOrganizationAssignmentUncheckedCreateWithoutKioskInput>
  }

  export type KioskMetadataLogCreateWithoutKioskInput = {
    metadataType: string
    encryptedMetadata?: string | null
    collectionTimestamp?: Date | string
  }

  export type KioskMetadataLogUncheckedCreateWithoutKioskInput = {
    id?: number
    metadataType: string
    encryptedMetadata?: string | null
    collectionTimestamp?: Date | string
  }

  export type KioskMetadataLogCreateOrConnectWithoutKioskInput = {
    where: KioskMetadataLogWhereUniqueInput
    create: XOR<KioskMetadataLogCreateWithoutKioskInput, KioskMetadataLogUncheckedCreateWithoutKioskInput>
  }

  export type KioskMetadataLogCreateManyKioskInputEnvelope = {
    data: KioskMetadataLogCreateManyKioskInput | KioskMetadataLogCreateManyKioskInput[]
    skipDuplicates?: boolean
  }

  export type KioskActivationUpsertWithWhereUniqueWithoutKioskInput = {
    where: KioskActivationWhereUniqueInput
    update: XOR<KioskActivationUpdateWithoutKioskInput, KioskActivationUncheckedUpdateWithoutKioskInput>
    create: XOR<KioskActivationCreateWithoutKioskInput, KioskActivationUncheckedCreateWithoutKioskInput>
  }

  export type KioskActivationUpdateWithWhereUniqueWithoutKioskInput = {
    where: KioskActivationWhereUniqueInput
    data: XOR<KioskActivationUpdateWithoutKioskInput, KioskActivationUncheckedUpdateWithoutKioskInput>
  }

  export type KioskActivationUpdateManyWithWhereWithoutKioskInput = {
    where: KioskActivationScalarWhereInput
    data: XOR<KioskActivationUpdateManyMutationInput, KioskActivationUncheckedUpdateManyWithoutKioskInput>
  }

  export type KioskActivationScalarWhereInput = {
    AND?: KioskActivationScalarWhereInput | KioskActivationScalarWhereInput[]
    OR?: KioskActivationScalarWhereInput[]
    NOT?: KioskActivationScalarWhereInput | KioskActivationScalarWhereInput[]
    id?: StringFilter<"KioskActivation"> | string
    code?: StringFilter<"KioskActivation"> | string
    qrCode?: StringFilter<"KioskActivation"> | string
    expiresAt?: DateTimeFilter<"KioskActivation"> | Date | string
    used?: BoolFilter<"KioskActivation"> | boolean
    usedAt?: DateTimeNullableFilter<"KioskActivation"> | Date | string | null
    createdAt?: DateTimeFilter<"KioskActivation"> | Date | string
    kioskId?: StringNullableFilter<"KioskActivation"> | string | null
  }

  export type KioskAssetRegistryUpsertWithWhereUniqueWithoutKioskInput = {
    where: KioskAssetRegistryWhereUniqueInput
    update: XOR<KioskAssetRegistryUpdateWithoutKioskInput, KioskAssetRegistryUncheckedUpdateWithoutKioskInput>
    create: XOR<KioskAssetRegistryCreateWithoutKioskInput, KioskAssetRegistryUncheckedCreateWithoutKioskInput>
  }

  export type KioskAssetRegistryUpdateWithWhereUniqueWithoutKioskInput = {
    where: KioskAssetRegistryWhereUniqueInput
    data: XOR<KioskAssetRegistryUpdateWithoutKioskInput, KioskAssetRegistryUncheckedUpdateWithoutKioskInput>
  }

  export type KioskAssetRegistryUpdateManyWithWhereWithoutKioskInput = {
    where: KioskAssetRegistryScalarWhereInput
    data: XOR<KioskAssetRegistryUpdateManyMutationInput, KioskAssetRegistryUncheckedUpdateManyWithoutKioskInput>
  }

  export type KioskAssetRegistryScalarWhereInput = {
    AND?: KioskAssetRegistryScalarWhereInput | KioskAssetRegistryScalarWhereInput[]
    OR?: KioskAssetRegistryScalarWhereInput[]
    NOT?: KioskAssetRegistryScalarWhereInput | KioskAssetRegistryScalarWhereInput[]
    id?: IntFilter<"KioskAssetRegistry"> | number
    kioskId?: StringFilter<"KioskAssetRegistry"> | string
    assetId?: IntFilter<"KioskAssetRegistry"> | number
    registrationDate?: DateTimeFilter<"KioskAssetRegistry"> | Date | string
    lastCheckIn?: DateTimeNullableFilter<"KioskAssetRegistry"> | Date | string | null
    status?: StringFilter<"KioskAssetRegistry"> | string
    helixSyncStatus?: StringFilter<"KioskAssetRegistry"> | string
    helixLastSync?: DateTimeNullableFilter<"KioskAssetRegistry"> | Date | string | null
    helixErrorMessage?: StringNullableFilter<"KioskAssetRegistry"> | string | null
    encryptedMetadata?: StringNullableFilter<"KioskAssetRegistry"> | string | null
    createdBy?: StringNullableFilter<"KioskAssetRegistry"> | string | null
    updatedBy?: StringNullableFilter<"KioskAssetRegistry"> | string | null
  }

  export type HelixSyncFailureUpsertWithWhereUniqueWithoutKioskInput = {
    where: HelixSyncFailureWhereUniqueInput
    update: XOR<HelixSyncFailureUpdateWithoutKioskInput, HelixSyncFailureUncheckedUpdateWithoutKioskInput>
    create: XOR<HelixSyncFailureCreateWithoutKioskInput, HelixSyncFailureUncheckedCreateWithoutKioskInput>
  }

  export type HelixSyncFailureUpdateWithWhereUniqueWithoutKioskInput = {
    where: HelixSyncFailureWhereUniqueInput
    data: XOR<HelixSyncFailureUpdateWithoutKioskInput, HelixSyncFailureUncheckedUpdateWithoutKioskInput>
  }

  export type HelixSyncFailureUpdateManyWithWhereWithoutKioskInput = {
    where: HelixSyncFailureScalarWhereInput
    data: XOR<HelixSyncFailureUpdateManyMutationInput, HelixSyncFailureUncheckedUpdateManyWithoutKioskInput>
  }

  export type HelixSyncFailureScalarWhereInput = {
    AND?: HelixSyncFailureScalarWhereInput | HelixSyncFailureScalarWhereInput[]
    OR?: HelixSyncFailureScalarWhereInput[]
    NOT?: HelixSyncFailureScalarWhereInput | HelixSyncFailureScalarWhereInput[]
    id?: IntFilter<"HelixSyncFailure"> | number
    kioskId?: StringFilter<"HelixSyncFailure"> | string
    assetId?: IntFilter<"HelixSyncFailure"> | number
    errorMessage?: StringFilter<"HelixSyncFailure"> | string
    metadata?: JsonNullableFilter<"HelixSyncFailure">
    retryCount?: IntFilter<"HelixSyncFailure"> | number
    nextRetryAt?: DateTimeFilter<"HelixSyncFailure"> | Date | string
    createdAt?: DateTimeFilter<"HelixSyncFailure"> | Date | string
    updatedAt?: DateTimeFilter<"HelixSyncFailure"> | Date | string
  }

  export type KioskOrganizationAssignmentUpsertWithoutKioskInput = {
    update: XOR<KioskOrganizationAssignmentUpdateWithoutKioskInput, KioskOrganizationAssignmentUncheckedUpdateWithoutKioskInput>
    create: XOR<KioskOrganizationAssignmentCreateWithoutKioskInput, KioskOrganizationAssignmentUncheckedCreateWithoutKioskInput>
    where?: KioskOrganizationAssignmentWhereInput
  }

  export type KioskOrganizationAssignmentUpdateToOneWithWhereWithoutKioskInput = {
    where?: KioskOrganizationAssignmentWhereInput
    data: XOR<KioskOrganizationAssignmentUpdateWithoutKioskInput, KioskOrganizationAssignmentUncheckedUpdateWithoutKioskInput>
  }

  export type KioskOrganizationAssignmentUpdateWithoutKioskInput = {
    organizationId?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assignmentMetadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KioskOrganizationAssignmentUncheckedUpdateWithoutKioskInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assignmentMetadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KioskMetadataLogUpsertWithWhereUniqueWithoutKioskInput = {
    where: KioskMetadataLogWhereUniqueInput
    update: XOR<KioskMetadataLogUpdateWithoutKioskInput, KioskMetadataLogUncheckedUpdateWithoutKioskInput>
    create: XOR<KioskMetadataLogCreateWithoutKioskInput, KioskMetadataLogUncheckedCreateWithoutKioskInput>
  }

  export type KioskMetadataLogUpdateWithWhereUniqueWithoutKioskInput = {
    where: KioskMetadataLogWhereUniqueInput
    data: XOR<KioskMetadataLogUpdateWithoutKioskInput, KioskMetadataLogUncheckedUpdateWithoutKioskInput>
  }

  export type KioskMetadataLogUpdateManyWithWhereWithoutKioskInput = {
    where: KioskMetadataLogScalarWhereInput
    data: XOR<KioskMetadataLogUpdateManyMutationInput, KioskMetadataLogUncheckedUpdateManyWithoutKioskInput>
  }

  export type KioskMetadataLogScalarWhereInput = {
    AND?: KioskMetadataLogScalarWhereInput | KioskMetadataLogScalarWhereInput[]
    OR?: KioskMetadataLogScalarWhereInput[]
    NOT?: KioskMetadataLogScalarWhereInput | KioskMetadataLogScalarWhereInput[]
    id?: IntFilter<"KioskMetadataLog"> | number
    kioskId?: StringFilter<"KioskMetadataLog"> | string
    metadataType?: StringFilter<"KioskMetadataLog"> | string
    encryptedMetadata?: StringNullableFilter<"KioskMetadataLog"> | string | null
    collectionTimestamp?: DateTimeFilter<"KioskMetadataLog"> | Date | string
  }

  export type UserCreateWithoutFeedbackInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    logs?: LogCreateNestedManyWithoutUserInput
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentCreateNestedManyWithoutUserInput
    xpEvents?: XpEventCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFeedbackInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingUncheckedCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentUncheckedCreateNestedManyWithoutUserInput
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventUncheckedCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyUncheckedCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyUncheckedCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryUncheckedCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFeedbackInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeedbackInput, UserUncheckedCreateWithoutFeedbackInput>
  }

  export type UserUpsertWithoutFeedbackInput = {
    update: XOR<UserUpdateWithoutFeedbackInput, UserUncheckedUpdateWithoutFeedbackInput>
    create: XOR<UserCreateWithoutFeedbackInput, UserUncheckedCreateWithoutFeedbackInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFeedbackInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFeedbackInput, UserUncheckedUpdateWithoutFeedbackInput>
  }

  export type UserUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    logs?: LogUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUncheckedUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUncheckedUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUncheckedUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUncheckedUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUncheckedUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUncheckedUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type KioskCreateWithoutActivationsInput = {
    id: string
    lastSeen?: Date | string | null
    version?: string | null
    active?: boolean
    logoUrl?: string | null
    bgUrl?: string | null
    statusEnabled?: boolean
    currentStatus?: string | null
    openMsg?: string | null
    closedMsg?: string | null
    errorMsg?: string | null
    meetingMsg?: string | null
    brbMsg?: string | null
    lunchMsg?: string | null
    unavailableMsg?: string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assetRegistry?: KioskAssetRegistryCreateNestedManyWithoutKioskInput
    syncFailures?: HelixSyncFailureCreateNestedManyWithoutKioskInput
    orgAssignment?: KioskOrganizationAssignmentCreateNestedOneWithoutKioskInput
    metadataLogs?: KioskMetadataLogCreateNestedManyWithoutKioskInput
  }

  export type KioskUncheckedCreateWithoutActivationsInput = {
    id: string
    lastSeen?: Date | string | null
    version?: string | null
    active?: boolean
    logoUrl?: string | null
    bgUrl?: string | null
    statusEnabled?: boolean
    currentStatus?: string | null
    openMsg?: string | null
    closedMsg?: string | null
    errorMsg?: string | null
    meetingMsg?: string | null
    brbMsg?: string | null
    lunchMsg?: string | null
    unavailableMsg?: string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assetRegistry?: KioskAssetRegistryUncheckedCreateNestedManyWithoutKioskInput
    syncFailures?: HelixSyncFailureUncheckedCreateNestedManyWithoutKioskInput
    orgAssignment?: KioskOrganizationAssignmentUncheckedCreateNestedOneWithoutKioskInput
    metadataLogs?: KioskMetadataLogUncheckedCreateNestedManyWithoutKioskInput
  }

  export type KioskCreateOrConnectWithoutActivationsInput = {
    where: KioskWhereUniqueInput
    create: XOR<KioskCreateWithoutActivationsInput, KioskUncheckedCreateWithoutActivationsInput>
  }

  export type KioskUpsertWithoutActivationsInput = {
    update: XOR<KioskUpdateWithoutActivationsInput, KioskUncheckedUpdateWithoutActivationsInput>
    create: XOR<KioskCreateWithoutActivationsInput, KioskUncheckedCreateWithoutActivationsInput>
    where?: KioskWhereInput
  }

  export type KioskUpdateToOneWithWhereWithoutActivationsInput = {
    where?: KioskWhereInput
    data: XOR<KioskUpdateWithoutActivationsInput, KioskUncheckedUpdateWithoutActivationsInput>
  }

  export type KioskUpdateWithoutActivationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statusEnabled?: BoolFieldUpdateOperationsInput | boolean
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    openMsg?: NullableStringFieldUpdateOperationsInput | string | null
    closedMsg?: NullableStringFieldUpdateOperationsInput | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    meetingMsg?: NullableStringFieldUpdateOperationsInput | string | null
    brbMsg?: NullableStringFieldUpdateOperationsInput | string | null
    lunchMsg?: NullableStringFieldUpdateOperationsInput | string | null
    unavailableMsg?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetRegistry?: KioskAssetRegistryUpdateManyWithoutKioskNestedInput
    syncFailures?: HelixSyncFailureUpdateManyWithoutKioskNestedInput
    orgAssignment?: KioskOrganizationAssignmentUpdateOneWithoutKioskNestedInput
    metadataLogs?: KioskMetadataLogUpdateManyWithoutKioskNestedInput
  }

  export type KioskUncheckedUpdateWithoutActivationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statusEnabled?: BoolFieldUpdateOperationsInput | boolean
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    openMsg?: NullableStringFieldUpdateOperationsInput | string | null
    closedMsg?: NullableStringFieldUpdateOperationsInput | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    meetingMsg?: NullableStringFieldUpdateOperationsInput | string | null
    brbMsg?: NullableStringFieldUpdateOperationsInput | string | null
    lunchMsg?: NullableStringFieldUpdateOperationsInput | string | null
    unavailableMsg?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetRegistry?: KioskAssetRegistryUncheckedUpdateManyWithoutKioskNestedInput
    syncFailures?: HelixSyncFailureUncheckedUpdateManyWithoutKioskNestedInput
    orgAssignment?: KioskOrganizationAssignmentUncheckedUpdateOneWithoutKioskNestedInput
    metadataLogs?: KioskMetadataLogUncheckedUpdateManyWithoutKioskNestedInput
  }

  export type UserCreateWithoutKbArticlesAuthoredInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingCreateNestedManyWithoutUserInput
    kbArticleVersionsAuthored?: KbArticleVersionCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentCreateNestedManyWithoutUserInput
    xpEvents?: XpEventCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutKbArticlesAuthoredInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingUncheckedCreateNestedManyWithoutUserInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentUncheckedCreateNestedManyWithoutUserInput
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventUncheckedCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyUncheckedCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyUncheckedCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryUncheckedCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutKbArticlesAuthoredInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutKbArticlesAuthoredInput, UserUncheckedCreateWithoutKbArticlesAuthoredInput>
  }

  export type KbArticleVersionCreateWithoutArticleInput = {
    content: string
    summary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: number
    isApproved?: boolean
    author?: UserCreateNestedOneWithoutKbArticleVersionsAuthoredInput
    currentForArticle?: KbArticleCreateNestedManyWithoutCurrentVersionInput
  }

  export type KbArticleVersionUncheckedCreateWithoutArticleInput = {
    id?: number
    content: string
    summary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId?: string | null
    version?: number
    isApproved?: boolean
    currentForArticle?: KbArticleUncheckedCreateNestedManyWithoutCurrentVersionInput
  }

  export type KbArticleVersionCreateOrConnectWithoutArticleInput = {
    where: KbArticleVersionWhereUniqueInput
    create: XOR<KbArticleVersionCreateWithoutArticleInput, KbArticleVersionUncheckedCreateWithoutArticleInput>
  }

  export type KbArticleVersionCreateManyArticleInputEnvelope = {
    data: KbArticleVersionCreateManyArticleInput | KbArticleVersionCreateManyArticleInput[]
    skipDuplicates?: boolean
  }

  export type KbArticleCommentCreateWithoutArticleInput = {
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    user: UserCreateNestedOneWithoutKbArticleCommentsInput
  }

  export type KbArticleCommentUncheckedCreateWithoutArticleInput = {
    id?: number
    userId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type KbArticleCommentCreateOrConnectWithoutArticleInput = {
    where: KbArticleCommentWhereUniqueInput
    create: XOR<KbArticleCommentCreateWithoutArticleInput, KbArticleCommentUncheckedCreateWithoutArticleInput>
  }

  export type KbArticleCommentCreateManyArticleInputEnvelope = {
    data: KbArticleCommentCreateManyArticleInput | KbArticleCommentCreateManyArticleInput[]
    skipDuplicates?: boolean
  }

  export type KbArticleVersionCreateWithoutCurrentForArticleInput = {
    content: string
    summary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: number
    isApproved?: boolean
    article: KbArticleCreateNestedOneWithoutVersionsInput
    author?: UserCreateNestedOneWithoutKbArticleVersionsAuthoredInput
  }

  export type KbArticleVersionUncheckedCreateWithoutCurrentForArticleInput = {
    id?: number
    articleId: number
    content: string
    summary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId?: string | null
    version?: number
    isApproved?: boolean
  }

  export type KbArticleVersionCreateOrConnectWithoutCurrentForArticleInput = {
    where: KbArticleVersionWhereUniqueInput
    create: XOR<KbArticleVersionCreateWithoutCurrentForArticleInput, KbArticleVersionUncheckedCreateWithoutCurrentForArticleInput>
  }

  export type UserUpsertWithoutKbArticlesAuthoredInput = {
    update: XOR<UserUpdateWithoutKbArticlesAuthoredInput, UserUncheckedUpdateWithoutKbArticlesAuthoredInput>
    create: XOR<UserCreateWithoutKbArticlesAuthoredInput, UserUncheckedCreateWithoutKbArticlesAuthoredInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutKbArticlesAuthoredInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutKbArticlesAuthoredInput, UserUncheckedUpdateWithoutKbArticlesAuthoredInput>
  }

  export type UserUpdateWithoutKbArticlesAuthoredInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUpdateManyWithoutUserNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutKbArticlesAuthoredInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUncheckedUpdateManyWithoutUserNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUncheckedUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUncheckedUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUncheckedUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUncheckedUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUncheckedUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type KbArticleVersionUpsertWithWhereUniqueWithoutArticleInput = {
    where: KbArticleVersionWhereUniqueInput
    update: XOR<KbArticleVersionUpdateWithoutArticleInput, KbArticleVersionUncheckedUpdateWithoutArticleInput>
    create: XOR<KbArticleVersionCreateWithoutArticleInput, KbArticleVersionUncheckedCreateWithoutArticleInput>
  }

  export type KbArticleVersionUpdateWithWhereUniqueWithoutArticleInput = {
    where: KbArticleVersionWhereUniqueInput
    data: XOR<KbArticleVersionUpdateWithoutArticleInput, KbArticleVersionUncheckedUpdateWithoutArticleInput>
  }

  export type KbArticleVersionUpdateManyWithWhereWithoutArticleInput = {
    where: KbArticleVersionScalarWhereInput
    data: XOR<KbArticleVersionUpdateManyMutationInput, KbArticleVersionUncheckedUpdateManyWithoutArticleInput>
  }

  export type KbArticleCommentUpsertWithWhereUniqueWithoutArticleInput = {
    where: KbArticleCommentWhereUniqueInput
    update: XOR<KbArticleCommentUpdateWithoutArticleInput, KbArticleCommentUncheckedUpdateWithoutArticleInput>
    create: XOR<KbArticleCommentCreateWithoutArticleInput, KbArticleCommentUncheckedCreateWithoutArticleInput>
  }

  export type KbArticleCommentUpdateWithWhereUniqueWithoutArticleInput = {
    where: KbArticleCommentWhereUniqueInput
    data: XOR<KbArticleCommentUpdateWithoutArticleInput, KbArticleCommentUncheckedUpdateWithoutArticleInput>
  }

  export type KbArticleCommentUpdateManyWithWhereWithoutArticleInput = {
    where: KbArticleCommentScalarWhereInput
    data: XOR<KbArticleCommentUpdateManyMutationInput, KbArticleCommentUncheckedUpdateManyWithoutArticleInput>
  }

  export type KbArticleVersionUpsertWithoutCurrentForArticleInput = {
    update: XOR<KbArticleVersionUpdateWithoutCurrentForArticleInput, KbArticleVersionUncheckedUpdateWithoutCurrentForArticleInput>
    create: XOR<KbArticleVersionCreateWithoutCurrentForArticleInput, KbArticleVersionUncheckedCreateWithoutCurrentForArticleInput>
    where?: KbArticleVersionWhereInput
  }

  export type KbArticleVersionUpdateToOneWithWhereWithoutCurrentForArticleInput = {
    where?: KbArticleVersionWhereInput
    data: XOR<KbArticleVersionUpdateWithoutCurrentForArticleInput, KbArticleVersionUncheckedUpdateWithoutCurrentForArticleInput>
  }

  export type KbArticleVersionUpdateWithoutCurrentForArticleInput = {
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    article?: KbArticleUpdateOneRequiredWithoutVersionsNestedInput
    author?: UserUpdateOneWithoutKbArticleVersionsAuthoredNestedInput
  }

  export type KbArticleVersionUncheckedUpdateWithoutCurrentForArticleInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type KbArticleCreateWithoutVersionsInput = {
    slug: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isPublished?: boolean
    tags?: KbArticleCreatetagsInput | string[]
    author?: UserCreateNestedOneWithoutKbArticlesAuthoredInput
    comments?: KbArticleCommentCreateNestedManyWithoutArticleInput
    currentVersion?: KbArticleVersionCreateNestedOneWithoutCurrentForArticleInput
  }

  export type KbArticleUncheckedCreateWithoutVersionsInput = {
    id?: number
    slug: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId?: string | null
    currentVersionId?: number | null
    isPublished?: boolean
    tags?: KbArticleCreatetagsInput | string[]
    comments?: KbArticleCommentUncheckedCreateNestedManyWithoutArticleInput
  }

  export type KbArticleCreateOrConnectWithoutVersionsInput = {
    where: KbArticleWhereUniqueInput
    create: XOR<KbArticleCreateWithoutVersionsInput, KbArticleUncheckedCreateWithoutVersionsInput>
  }

  export type UserCreateWithoutKbArticleVersionsAuthoredInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentCreateNestedManyWithoutUserInput
    xpEvents?: XpEventCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutKbArticleVersionsAuthoredInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingUncheckedCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentUncheckedCreateNestedManyWithoutUserInput
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventUncheckedCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyUncheckedCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyUncheckedCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryUncheckedCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutKbArticleVersionsAuthoredInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutKbArticleVersionsAuthoredInput, UserUncheckedCreateWithoutKbArticleVersionsAuthoredInput>
  }

  export type KbArticleCreateWithoutCurrentVersionInput = {
    slug: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isPublished?: boolean
    tags?: KbArticleCreatetagsInput | string[]
    author?: UserCreateNestedOneWithoutKbArticlesAuthoredInput
    versions?: KbArticleVersionCreateNestedManyWithoutArticleInput
    comments?: KbArticleCommentCreateNestedManyWithoutArticleInput
  }

  export type KbArticleUncheckedCreateWithoutCurrentVersionInput = {
    id?: number
    slug: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId?: string | null
    isPublished?: boolean
    tags?: KbArticleCreatetagsInput | string[]
    versions?: KbArticleVersionUncheckedCreateNestedManyWithoutArticleInput
    comments?: KbArticleCommentUncheckedCreateNestedManyWithoutArticleInput
  }

  export type KbArticleCreateOrConnectWithoutCurrentVersionInput = {
    where: KbArticleWhereUniqueInput
    create: XOR<KbArticleCreateWithoutCurrentVersionInput, KbArticleUncheckedCreateWithoutCurrentVersionInput>
  }

  export type KbArticleCreateManyCurrentVersionInputEnvelope = {
    data: KbArticleCreateManyCurrentVersionInput | KbArticleCreateManyCurrentVersionInput[]
    skipDuplicates?: boolean
  }

  export type KbArticleUpsertWithoutVersionsInput = {
    update: XOR<KbArticleUpdateWithoutVersionsInput, KbArticleUncheckedUpdateWithoutVersionsInput>
    create: XOR<KbArticleCreateWithoutVersionsInput, KbArticleUncheckedCreateWithoutVersionsInput>
    where?: KbArticleWhereInput
  }

  export type KbArticleUpdateToOneWithWhereWithoutVersionsInput = {
    where?: KbArticleWhereInput
    data: XOR<KbArticleUpdateWithoutVersionsInput, KbArticleUncheckedUpdateWithoutVersionsInput>
  }

  export type KbArticleUpdateWithoutVersionsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    tags?: KbArticleUpdatetagsInput | string[]
    author?: UserUpdateOneWithoutKbArticlesAuthoredNestedInput
    comments?: KbArticleCommentUpdateManyWithoutArticleNestedInput
    currentVersion?: KbArticleVersionUpdateOneWithoutCurrentForArticleNestedInput
  }

  export type KbArticleUncheckedUpdateWithoutVersionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    currentVersionId?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    tags?: KbArticleUpdatetagsInput | string[]
    comments?: KbArticleCommentUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type UserUpsertWithoutKbArticleVersionsAuthoredInput = {
    update: XOR<UserUpdateWithoutKbArticleVersionsAuthoredInput, UserUncheckedUpdateWithoutKbArticleVersionsAuthoredInput>
    create: XOR<UserCreateWithoutKbArticleVersionsAuthoredInput, UserUncheckedCreateWithoutKbArticleVersionsAuthoredInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutKbArticleVersionsAuthoredInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutKbArticleVersionsAuthoredInput, UserUncheckedUpdateWithoutKbArticleVersionsAuthoredInput>
  }

  export type UserUpdateWithoutKbArticleVersionsAuthoredInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutKbArticleVersionsAuthoredInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUncheckedUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUncheckedUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUncheckedUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUncheckedUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUncheckedUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUncheckedUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type KbArticleUpsertWithWhereUniqueWithoutCurrentVersionInput = {
    where: KbArticleWhereUniqueInput
    update: XOR<KbArticleUpdateWithoutCurrentVersionInput, KbArticleUncheckedUpdateWithoutCurrentVersionInput>
    create: XOR<KbArticleCreateWithoutCurrentVersionInput, KbArticleUncheckedCreateWithoutCurrentVersionInput>
  }

  export type KbArticleUpdateWithWhereUniqueWithoutCurrentVersionInput = {
    where: KbArticleWhereUniqueInput
    data: XOR<KbArticleUpdateWithoutCurrentVersionInput, KbArticleUncheckedUpdateWithoutCurrentVersionInput>
  }

  export type KbArticleUpdateManyWithWhereWithoutCurrentVersionInput = {
    where: KbArticleScalarWhereInput
    data: XOR<KbArticleUpdateManyMutationInput, KbArticleUncheckedUpdateManyWithoutCurrentVersionInput>
  }

  export type KbArticleCreateWithoutCommentsInput = {
    slug: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isPublished?: boolean
    tags?: KbArticleCreatetagsInput | string[]
    author?: UserCreateNestedOneWithoutKbArticlesAuthoredInput
    versions?: KbArticleVersionCreateNestedManyWithoutArticleInput
    currentVersion?: KbArticleVersionCreateNestedOneWithoutCurrentForArticleInput
  }

  export type KbArticleUncheckedCreateWithoutCommentsInput = {
    id?: number
    slug: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId?: string | null
    currentVersionId?: number | null
    isPublished?: boolean
    tags?: KbArticleCreatetagsInput | string[]
    versions?: KbArticleVersionUncheckedCreateNestedManyWithoutArticleInput
  }

  export type KbArticleCreateOrConnectWithoutCommentsInput = {
    where: KbArticleWhereUniqueInput
    create: XOR<KbArticleCreateWithoutCommentsInput, KbArticleUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutKbArticleCommentsInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionCreateNestedManyWithoutAuthorInput
    xpEvents?: XpEventCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutKbArticleCommentsInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingUncheckedCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedCreateNestedManyWithoutAuthorInput
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventUncheckedCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyUncheckedCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyUncheckedCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryUncheckedCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutKbArticleCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutKbArticleCommentsInput, UserUncheckedCreateWithoutKbArticleCommentsInput>
  }

  export type KbArticleUpsertWithoutCommentsInput = {
    update: XOR<KbArticleUpdateWithoutCommentsInput, KbArticleUncheckedUpdateWithoutCommentsInput>
    create: XOR<KbArticleCreateWithoutCommentsInput, KbArticleUncheckedCreateWithoutCommentsInput>
    where?: KbArticleWhereInput
  }

  export type KbArticleUpdateToOneWithWhereWithoutCommentsInput = {
    where?: KbArticleWhereInput
    data: XOR<KbArticleUpdateWithoutCommentsInput, KbArticleUncheckedUpdateWithoutCommentsInput>
  }

  export type KbArticleUpdateWithoutCommentsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    tags?: KbArticleUpdatetagsInput | string[]
    author?: UserUpdateOneWithoutKbArticlesAuthoredNestedInput
    versions?: KbArticleVersionUpdateManyWithoutArticleNestedInput
    currentVersion?: KbArticleVersionUpdateOneWithoutCurrentForArticleNestedInput
  }

  export type KbArticleUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    currentVersionId?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    tags?: KbArticleUpdatetagsInput | string[]
    versions?: KbArticleVersionUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type UserUpsertWithoutKbArticleCommentsInput = {
    update: XOR<UserUpdateWithoutKbArticleCommentsInput, UserUncheckedUpdateWithoutKbArticleCommentsInput>
    create: XOR<UserCreateWithoutKbArticleCommentsInput, UserUncheckedCreateWithoutKbArticleCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutKbArticleCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutKbArticleCommentsInput, UserUncheckedUpdateWithoutKbArticleCommentsInput>
  }

  export type UserUpdateWithoutKbArticleCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUpdateManyWithoutAuthorNestedInput
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutKbArticleCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUncheckedUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedUpdateManyWithoutAuthorNestedInput
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUncheckedUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUncheckedUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUncheckedUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUncheckedUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSupport_tickets_support_tickets_assigneeIdTousersInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentCreateNestedManyWithoutUserInput
    xpEvents?: XpEventCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSupport_tickets_support_tickets_assigneeIdTousersInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingUncheckedCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentUncheckedCreateNestedManyWithoutUserInput
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventUncheckedCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyUncheckedCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyUncheckedCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryUncheckedCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSupport_tickets_support_tickets_assigneeIdTousersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSupport_tickets_support_tickets_assigneeIdTousersInput, UserUncheckedCreateWithoutSupport_tickets_support_tickets_assigneeIdTousersInput>
  }

  export type UserCreateWithoutSupport_tickets_support_tickets_userIdTousersInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentCreateNestedManyWithoutUserInput
    xpEvents?: XpEventCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSupport_tickets_support_tickets_userIdTousersInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingUncheckedCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentUncheckedCreateNestedManyWithoutUserInput
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventUncheckedCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyUncheckedCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyUncheckedCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryUncheckedCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSupport_tickets_support_tickets_userIdTousersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSupport_tickets_support_tickets_userIdTousersInput, UserUncheckedCreateWithoutSupport_tickets_support_tickets_userIdTousersInput>
  }

  export type MailroomPackageCreateWithoutTicketInput = {
    trackingNumber: string
    carrier: string
    sender?: string | null
    department?: string | null
    packageType?: string | null
    status: string
    assignedLocation?: string | null
    flags?: MailroomPackageCreateflagsInput | string[]
    intakePhotoUrl?: string | null
    deliveryPhotoUrl?: string | null
    signatureUrl?: string | null
    intakeLocation?: string | null
    deliveryLocation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recipient: UserCreateNestedOneWithoutMailroomPackagesInput
    asset?: InventoryAssetCreateNestedOneWithoutMailroomPackagesInput
    deliveryEvents?: DeliveryEventCreateNestedManyWithoutPackageInput
    proxyAuthorizations?: ProxyAuthorizationCreateNestedManyWithoutPackageInput
  }

  export type MailroomPackageUncheckedCreateWithoutTicketInput = {
    id?: number
    trackingNumber: string
    carrier: string
    sender?: string | null
    recipientId: string
    department?: string | null
    packageType?: string | null
    status: string
    assignedLocation?: string | null
    linkedAssetId?: number | null
    flags?: MailroomPackageCreateflagsInput | string[]
    intakePhotoUrl?: string | null
    deliveryPhotoUrl?: string | null
    signatureUrl?: string | null
    intakeLocation?: string | null
    deliveryLocation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveryEvents?: DeliveryEventUncheckedCreateNestedManyWithoutPackageInput
    proxyAuthorizations?: ProxyAuthorizationUncheckedCreateNestedManyWithoutPackageInput
  }

  export type MailroomPackageCreateOrConnectWithoutTicketInput = {
    where: MailroomPackageWhereUniqueInput
    create: XOR<MailroomPackageCreateWithoutTicketInput, MailroomPackageUncheckedCreateWithoutTicketInput>
  }

  export type MailroomPackageCreateManyTicketInputEnvelope = {
    data: MailroomPackageCreateManyTicketInput | MailroomPackageCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type AssetTicketHistoryCreateWithoutTicketInput = {
    relationshipType: string
    createdAt?: Date | string
    endedAt?: Date | string | null
    createdBy?: string | null
    notes?: string | null
    asset: InventoryAssetCreateNestedOneWithoutTicketHistoryInput
  }

  export type AssetTicketHistoryUncheckedCreateWithoutTicketInput = {
    id?: number
    assetId: number
    relationshipType: string
    createdAt?: Date | string
    endedAt?: Date | string | null
    createdBy?: string | null
    notes?: string | null
  }

  export type AssetTicketHistoryCreateOrConnectWithoutTicketInput = {
    where: AssetTicketHistoryWhereUniqueInput
    create: XOR<AssetTicketHistoryCreateWithoutTicketInput, AssetTicketHistoryUncheckedCreateWithoutTicketInput>
  }

  export type AssetTicketHistoryCreateManyTicketInputEnvelope = {
    data: AssetTicketHistoryCreateManyTicketInput | AssetTicketHistoryCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type RITMCreateWithoutTicketInput = {
    status?: string
    catalogItem: RequestCatalogItemCreateNestedOneWithoutRitmsInput
  }

  export type RITMUncheckedCreateWithoutTicketInput = {
    id?: number
    catalogItemId: number
    status?: string
  }

  export type RITMCreateOrConnectWithoutTicketInput = {
    where: RITMWhereUniqueInput
    create: XOR<RITMCreateWithoutTicketInput, RITMUncheckedCreateWithoutTicketInput>
  }

  export type RITMCreateManyTicketInputEnvelope = {
    data: RITMCreateManyTicketInput | RITMCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSupport_tickets_support_tickets_assigneeIdTousersInput = {
    update: XOR<UserUpdateWithoutSupport_tickets_support_tickets_assigneeIdTousersInput, UserUncheckedUpdateWithoutSupport_tickets_support_tickets_assigneeIdTousersInput>
    create: XOR<UserCreateWithoutSupport_tickets_support_tickets_assigneeIdTousersInput, UserUncheckedCreateWithoutSupport_tickets_support_tickets_assigneeIdTousersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSupport_tickets_support_tickets_assigneeIdTousersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSupport_tickets_support_tickets_assigneeIdTousersInput, UserUncheckedUpdateWithoutSupport_tickets_support_tickets_assigneeIdTousersInput>
  }

  export type UserUpdateWithoutSupport_tickets_support_tickets_assigneeIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSupport_tickets_support_tickets_assigneeIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUncheckedUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUncheckedUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUncheckedUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUncheckedUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUncheckedUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUncheckedUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutSupport_tickets_support_tickets_userIdTousersInput = {
    update: XOR<UserUpdateWithoutSupport_tickets_support_tickets_userIdTousersInput, UserUncheckedUpdateWithoutSupport_tickets_support_tickets_userIdTousersInput>
    create: XOR<UserCreateWithoutSupport_tickets_support_tickets_userIdTousersInput, UserUncheckedCreateWithoutSupport_tickets_support_tickets_userIdTousersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSupport_tickets_support_tickets_userIdTousersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSupport_tickets_support_tickets_userIdTousersInput, UserUncheckedUpdateWithoutSupport_tickets_support_tickets_userIdTousersInput>
  }

  export type UserUpdateWithoutSupport_tickets_support_tickets_userIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSupport_tickets_support_tickets_userIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUncheckedUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUncheckedUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUncheckedUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUncheckedUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUncheckedUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUncheckedUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MailroomPackageUpsertWithWhereUniqueWithoutTicketInput = {
    where: MailroomPackageWhereUniqueInput
    update: XOR<MailroomPackageUpdateWithoutTicketInput, MailroomPackageUncheckedUpdateWithoutTicketInput>
    create: XOR<MailroomPackageCreateWithoutTicketInput, MailroomPackageUncheckedCreateWithoutTicketInput>
  }

  export type MailroomPackageUpdateWithWhereUniqueWithoutTicketInput = {
    where: MailroomPackageWhereUniqueInput
    data: XOR<MailroomPackageUpdateWithoutTicketInput, MailroomPackageUncheckedUpdateWithoutTicketInput>
  }

  export type MailroomPackageUpdateManyWithWhereWithoutTicketInput = {
    where: MailroomPackageScalarWhereInput
    data: XOR<MailroomPackageUpdateManyMutationInput, MailroomPackageUncheckedUpdateManyWithoutTicketInput>
  }

  export type AssetTicketHistoryUpsertWithWhereUniqueWithoutTicketInput = {
    where: AssetTicketHistoryWhereUniqueInput
    update: XOR<AssetTicketHistoryUpdateWithoutTicketInput, AssetTicketHistoryUncheckedUpdateWithoutTicketInput>
    create: XOR<AssetTicketHistoryCreateWithoutTicketInput, AssetTicketHistoryUncheckedCreateWithoutTicketInput>
  }

  export type AssetTicketHistoryUpdateWithWhereUniqueWithoutTicketInput = {
    where: AssetTicketHistoryWhereUniqueInput
    data: XOR<AssetTicketHistoryUpdateWithoutTicketInput, AssetTicketHistoryUncheckedUpdateWithoutTicketInput>
  }

  export type AssetTicketHistoryUpdateManyWithWhereWithoutTicketInput = {
    where: AssetTicketHistoryScalarWhereInput
    data: XOR<AssetTicketHistoryUpdateManyMutationInput, AssetTicketHistoryUncheckedUpdateManyWithoutTicketInput>
  }

  export type AssetTicketHistoryScalarWhereInput = {
    AND?: AssetTicketHistoryScalarWhereInput | AssetTicketHistoryScalarWhereInput[]
    OR?: AssetTicketHistoryScalarWhereInput[]
    NOT?: AssetTicketHistoryScalarWhereInput | AssetTicketHistoryScalarWhereInput[]
    id?: IntFilter<"AssetTicketHistory"> | number
    assetId?: IntFilter<"AssetTicketHistory"> | number
    ticketId?: IntFilter<"AssetTicketHistory"> | number
    relationshipType?: StringFilter<"AssetTicketHistory"> | string
    createdAt?: DateTimeFilter<"AssetTicketHistory"> | Date | string
    endedAt?: DateTimeNullableFilter<"AssetTicketHistory"> | Date | string | null
    createdBy?: StringNullableFilter<"AssetTicketHistory"> | string | null
    notes?: StringNullableFilter<"AssetTicketHistory"> | string | null
  }

  export type RITMUpsertWithWhereUniqueWithoutTicketInput = {
    where: RITMWhereUniqueInput
    update: XOR<RITMUpdateWithoutTicketInput, RITMUncheckedUpdateWithoutTicketInput>
    create: XOR<RITMCreateWithoutTicketInput, RITMUncheckedCreateWithoutTicketInput>
  }

  export type RITMUpdateWithWhereUniqueWithoutTicketInput = {
    where: RITMWhereUniqueInput
    data: XOR<RITMUpdateWithoutTicketInput, RITMUncheckedUpdateWithoutTicketInput>
  }

  export type RITMUpdateManyWithWhereWithoutTicketInput = {
    where: RITMScalarWhereInput
    data: XOR<RITMUpdateManyMutationInput, RITMUncheckedUpdateManyWithoutTicketInput>
  }

  export type RITMScalarWhereInput = {
    AND?: RITMScalarWhereInput | RITMScalarWhereInput[]
    OR?: RITMScalarWhereInput[]
    NOT?: RITMScalarWhereInput | RITMScalarWhereInput[]
    id?: IntFilter<"RITM"> | number
    reqId?: IntFilter<"RITM"> | number
    catalogItemId?: IntFilter<"RITM"> | number
    status?: StringFilter<"RITM"> | string
  }

  export type AssetStatusLogCreateWithoutAssetInput = {
    previousStatus?: string | null
    newStatus: string
    changedByUserId?: string | null
    notes?: string | null
    timestamp?: Date | string
  }

  export type AssetStatusLogUncheckedCreateWithoutAssetInput = {
    id?: number
    previousStatus?: string | null
    newStatus: string
    changedByUserId?: string | null
    notes?: string | null
    timestamp?: Date | string
  }

  export type AssetStatusLogCreateOrConnectWithoutAssetInput = {
    where: AssetStatusLogWhereUniqueInput
    create: XOR<AssetStatusLogCreateWithoutAssetInput, AssetStatusLogUncheckedCreateWithoutAssetInput>
  }

  export type AssetStatusLogCreateManyAssetInputEnvelope = {
    data: AssetStatusLogCreateManyAssetInput | AssetStatusLogCreateManyAssetInput[]
    skipDuplicates?: boolean
  }

  export type AssetAssignmentCreateWithoutAssetInput = {
    userId?: string | null
    orgId?: number | null
    customerId?: number | null
    assignedBy?: string | null
    assignedDate?: Date | string
    expectedReturn?: Date | string | null
    returnDate?: Date | string | null
    managerId?: string | null
  }

  export type AssetAssignmentUncheckedCreateWithoutAssetInput = {
    id?: number
    userId?: string | null
    orgId?: number | null
    customerId?: number | null
    assignedBy?: string | null
    assignedDate?: Date | string
    expectedReturn?: Date | string | null
    returnDate?: Date | string | null
    managerId?: string | null
  }

  export type AssetAssignmentCreateOrConnectWithoutAssetInput = {
    where: AssetAssignmentWhereUniqueInput
    create: XOR<AssetAssignmentCreateWithoutAssetInput, AssetAssignmentUncheckedCreateWithoutAssetInput>
  }

  export type AssetAssignmentCreateManyAssetInputEnvelope = {
    data: AssetAssignmentCreateManyAssetInput | AssetAssignmentCreateManyAssetInput[]
    skipDuplicates?: boolean
  }

  export type MailroomPackageCreateWithoutAssetInput = {
    trackingNumber: string
    carrier: string
    sender?: string | null
    department?: string | null
    packageType?: string | null
    status: string
    assignedLocation?: string | null
    flags?: MailroomPackageCreateflagsInput | string[]
    intakePhotoUrl?: string | null
    deliveryPhotoUrl?: string | null
    signatureUrl?: string | null
    intakeLocation?: string | null
    deliveryLocation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recipient: UserCreateNestedOneWithoutMailroomPackagesInput
    ticket?: SupportTicketCreateNestedOneWithoutMailroomPackagesInput
    deliveryEvents?: DeliveryEventCreateNestedManyWithoutPackageInput
    proxyAuthorizations?: ProxyAuthorizationCreateNestedManyWithoutPackageInput
  }

  export type MailroomPackageUncheckedCreateWithoutAssetInput = {
    id?: number
    trackingNumber: string
    carrier: string
    sender?: string | null
    recipientId: string
    department?: string | null
    packageType?: string | null
    status: string
    assignedLocation?: string | null
    linkedTicketId?: number | null
    flags?: MailroomPackageCreateflagsInput | string[]
    intakePhotoUrl?: string | null
    deliveryPhotoUrl?: string | null
    signatureUrl?: string | null
    intakeLocation?: string | null
    deliveryLocation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveryEvents?: DeliveryEventUncheckedCreateNestedManyWithoutPackageInput
    proxyAuthorizations?: ProxyAuthorizationUncheckedCreateNestedManyWithoutPackageInput
  }

  export type MailroomPackageCreateOrConnectWithoutAssetInput = {
    where: MailroomPackageWhereUniqueInput
    create: XOR<MailroomPackageCreateWithoutAssetInput, MailroomPackageUncheckedCreateWithoutAssetInput>
  }

  export type MailroomPackageCreateManyAssetInputEnvelope = {
    data: MailroomPackageCreateManyAssetInput | MailroomPackageCreateManyAssetInput[]
    skipDuplicates?: boolean
  }

  export type AssetTicketHistoryCreateWithoutAssetInput = {
    relationshipType: string
    createdAt?: Date | string
    endedAt?: Date | string | null
    createdBy?: string | null
    notes?: string | null
    ticket: SupportTicketCreateNestedOneWithoutAssetHistoryInput
  }

  export type AssetTicketHistoryUncheckedCreateWithoutAssetInput = {
    id?: number
    ticketId: number
    relationshipType: string
    createdAt?: Date | string
    endedAt?: Date | string | null
    createdBy?: string | null
    notes?: string | null
  }

  export type AssetTicketHistoryCreateOrConnectWithoutAssetInput = {
    where: AssetTicketHistoryWhereUniqueInput
    create: XOR<AssetTicketHistoryCreateWithoutAssetInput, AssetTicketHistoryUncheckedCreateWithoutAssetInput>
  }

  export type AssetTicketHistoryCreateManyAssetInputEnvelope = {
    data: AssetTicketHistoryCreateManyAssetInput | AssetTicketHistoryCreateManyAssetInput[]
    skipDuplicates?: boolean
  }

  export type AssetWarrantyAlertCreateWithoutAssetInput = {
    alertType: string
    alertDate?: Date | string
    expiryDate: Date | string
    daysRemaining: number
    notificationSent?: boolean
    notificationSentAt?: Date | string | null
    dismissed?: boolean
    dismissedBy?: string | null
    dismissedAt?: Date | string | null
  }

  export type AssetWarrantyAlertUncheckedCreateWithoutAssetInput = {
    id?: number
    alertType: string
    alertDate?: Date | string
    expiryDate: Date | string
    daysRemaining: number
    notificationSent?: boolean
    notificationSentAt?: Date | string | null
    dismissed?: boolean
    dismissedBy?: string | null
    dismissedAt?: Date | string | null
  }

  export type AssetWarrantyAlertCreateOrConnectWithoutAssetInput = {
    where: AssetWarrantyAlertWhereUniqueInput
    create: XOR<AssetWarrantyAlertCreateWithoutAssetInput, AssetWarrantyAlertUncheckedCreateWithoutAssetInput>
  }

  export type AssetWarrantyAlertCreateManyAssetInputEnvelope = {
    data: AssetWarrantyAlertCreateManyAssetInput | AssetWarrantyAlertCreateManyAssetInput[]
    skipDuplicates?: boolean
  }

  export type KioskAssetRegistryCreateWithoutAssetInput = {
    registrationDate?: Date | string
    lastCheckIn?: Date | string | null
    status?: string
    helixSyncStatus?: string
    helixLastSync?: Date | string | null
    helixErrorMessage?: string | null
    encryptedMetadata?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    kiosk: KioskCreateNestedOneWithoutAssetRegistryInput
  }

  export type KioskAssetRegistryUncheckedCreateWithoutAssetInput = {
    id?: number
    kioskId: string
    registrationDate?: Date | string
    lastCheckIn?: Date | string | null
    status?: string
    helixSyncStatus?: string
    helixLastSync?: Date | string | null
    helixErrorMessage?: string | null
    encryptedMetadata?: string | null
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type KioskAssetRegistryCreateOrConnectWithoutAssetInput = {
    where: KioskAssetRegistryWhereUniqueInput
    create: XOR<KioskAssetRegistryCreateWithoutAssetInput, KioskAssetRegistryUncheckedCreateWithoutAssetInput>
  }

  export type KioskAssetRegistryCreateManyAssetInputEnvelope = {
    data: KioskAssetRegistryCreateManyAssetInput | KioskAssetRegistryCreateManyAssetInput[]
    skipDuplicates?: boolean
  }

  export type AssetValidationLogCreateWithoutAssetInput = {
    rowNumber: number
    validationLevel: string
    fieldName?: string | null
    message: string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    batch: AssetImportBatchCreateNestedOneWithoutValidationLogsInput
  }

  export type AssetValidationLogUncheckedCreateWithoutAssetInput = {
    id?: number
    batchId: string
    rowNumber: number
    validationLevel: string
    fieldName?: string | null
    message: string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AssetValidationLogCreateOrConnectWithoutAssetInput = {
    where: AssetValidationLogWhereUniqueInput
    create: XOR<AssetValidationLogCreateWithoutAssetInput, AssetValidationLogUncheckedCreateWithoutAssetInput>
  }

  export type AssetValidationLogCreateManyAssetInputEnvelope = {
    data: AssetValidationLogCreateManyAssetInput | AssetValidationLogCreateManyAssetInput[]
    skipDuplicates?: boolean
  }

  export type HelixSyncFailureCreateWithoutAssetInput = {
    errorMessage: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: number
    nextRetryAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    kiosk: KioskCreateNestedOneWithoutSyncFailuresInput
  }

  export type HelixSyncFailureUncheckedCreateWithoutAssetInput = {
    id?: number
    kioskId: string
    errorMessage: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: number
    nextRetryAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HelixSyncFailureCreateOrConnectWithoutAssetInput = {
    where: HelixSyncFailureWhereUniqueInput
    create: XOR<HelixSyncFailureCreateWithoutAssetInput, HelixSyncFailureUncheckedCreateWithoutAssetInput>
  }

  export type HelixSyncFailureCreateManyAssetInputEnvelope = {
    data: HelixSyncFailureCreateManyAssetInput | HelixSyncFailureCreateManyAssetInput[]
    skipDuplicates?: boolean
  }

  export type AssetImportBatchCreateWithoutAssetsInput = {
    id?: string
    filename: string
    importedBy: string
    importDate?: Date | string
    totalRecords?: number
    successfulRecords?: number
    failedRecords?: number
    validationStatus?: string
    validationErrors?: string | null
    rollbackDate?: Date | string | null
    rollbackBy?: string | null
    validationLogs?: AssetValidationLogCreateNestedManyWithoutBatchInput
  }

  export type AssetImportBatchUncheckedCreateWithoutAssetsInput = {
    id?: string
    filename: string
    importedBy: string
    importDate?: Date | string
    totalRecords?: number
    successfulRecords?: number
    failedRecords?: number
    validationStatus?: string
    validationErrors?: string | null
    rollbackDate?: Date | string | null
    rollbackBy?: string | null
    validationLogs?: AssetValidationLogUncheckedCreateNestedManyWithoutBatchInput
  }

  export type AssetImportBatchCreateOrConnectWithoutAssetsInput = {
    where: AssetImportBatchWhereUniqueInput
    create: XOR<AssetImportBatchCreateWithoutAssetsInput, AssetImportBatchUncheckedCreateWithoutAssetsInput>
  }

  export type AssetStatusLogUpsertWithWhereUniqueWithoutAssetInput = {
    where: AssetStatusLogWhereUniqueInput
    update: XOR<AssetStatusLogUpdateWithoutAssetInput, AssetStatusLogUncheckedUpdateWithoutAssetInput>
    create: XOR<AssetStatusLogCreateWithoutAssetInput, AssetStatusLogUncheckedCreateWithoutAssetInput>
  }

  export type AssetStatusLogUpdateWithWhereUniqueWithoutAssetInput = {
    where: AssetStatusLogWhereUniqueInput
    data: XOR<AssetStatusLogUpdateWithoutAssetInput, AssetStatusLogUncheckedUpdateWithoutAssetInput>
  }

  export type AssetStatusLogUpdateManyWithWhereWithoutAssetInput = {
    where: AssetStatusLogScalarWhereInput
    data: XOR<AssetStatusLogUpdateManyMutationInput, AssetStatusLogUncheckedUpdateManyWithoutAssetInput>
  }

  export type AssetStatusLogScalarWhereInput = {
    AND?: AssetStatusLogScalarWhereInput | AssetStatusLogScalarWhereInput[]
    OR?: AssetStatusLogScalarWhereInput[]
    NOT?: AssetStatusLogScalarWhereInput | AssetStatusLogScalarWhereInput[]
    id?: IntFilter<"AssetStatusLog"> | number
    assetId?: IntFilter<"AssetStatusLog"> | number
    previousStatus?: StringNullableFilter<"AssetStatusLog"> | string | null
    newStatus?: StringFilter<"AssetStatusLog"> | string
    changedByUserId?: StringNullableFilter<"AssetStatusLog"> | string | null
    notes?: StringNullableFilter<"AssetStatusLog"> | string | null
    timestamp?: DateTimeFilter<"AssetStatusLog"> | Date | string
  }

  export type AssetAssignmentUpsertWithWhereUniqueWithoutAssetInput = {
    where: AssetAssignmentWhereUniqueInput
    update: XOR<AssetAssignmentUpdateWithoutAssetInput, AssetAssignmentUncheckedUpdateWithoutAssetInput>
    create: XOR<AssetAssignmentCreateWithoutAssetInput, AssetAssignmentUncheckedCreateWithoutAssetInput>
  }

  export type AssetAssignmentUpdateWithWhereUniqueWithoutAssetInput = {
    where: AssetAssignmentWhereUniqueInput
    data: XOR<AssetAssignmentUpdateWithoutAssetInput, AssetAssignmentUncheckedUpdateWithoutAssetInput>
  }

  export type AssetAssignmentUpdateManyWithWhereWithoutAssetInput = {
    where: AssetAssignmentScalarWhereInput
    data: XOR<AssetAssignmentUpdateManyMutationInput, AssetAssignmentUncheckedUpdateManyWithoutAssetInput>
  }

  export type AssetAssignmentScalarWhereInput = {
    AND?: AssetAssignmentScalarWhereInput | AssetAssignmentScalarWhereInput[]
    OR?: AssetAssignmentScalarWhereInput[]
    NOT?: AssetAssignmentScalarWhereInput | AssetAssignmentScalarWhereInput[]
    id?: IntFilter<"AssetAssignment"> | number
    assetId?: IntFilter<"AssetAssignment"> | number
    userId?: StringNullableFilter<"AssetAssignment"> | string | null
    orgId?: IntNullableFilter<"AssetAssignment"> | number | null
    customerId?: IntNullableFilter<"AssetAssignment"> | number | null
    assignedBy?: StringNullableFilter<"AssetAssignment"> | string | null
    assignedDate?: DateTimeFilter<"AssetAssignment"> | Date | string
    expectedReturn?: DateTimeNullableFilter<"AssetAssignment"> | Date | string | null
    returnDate?: DateTimeNullableFilter<"AssetAssignment"> | Date | string | null
    managerId?: StringNullableFilter<"AssetAssignment"> | string | null
  }

  export type MailroomPackageUpsertWithWhereUniqueWithoutAssetInput = {
    where: MailroomPackageWhereUniqueInput
    update: XOR<MailroomPackageUpdateWithoutAssetInput, MailroomPackageUncheckedUpdateWithoutAssetInput>
    create: XOR<MailroomPackageCreateWithoutAssetInput, MailroomPackageUncheckedCreateWithoutAssetInput>
  }

  export type MailroomPackageUpdateWithWhereUniqueWithoutAssetInput = {
    where: MailroomPackageWhereUniqueInput
    data: XOR<MailroomPackageUpdateWithoutAssetInput, MailroomPackageUncheckedUpdateWithoutAssetInput>
  }

  export type MailroomPackageUpdateManyWithWhereWithoutAssetInput = {
    where: MailroomPackageScalarWhereInput
    data: XOR<MailroomPackageUpdateManyMutationInput, MailroomPackageUncheckedUpdateManyWithoutAssetInput>
  }

  export type AssetTicketHistoryUpsertWithWhereUniqueWithoutAssetInput = {
    where: AssetTicketHistoryWhereUniqueInput
    update: XOR<AssetTicketHistoryUpdateWithoutAssetInput, AssetTicketHistoryUncheckedUpdateWithoutAssetInput>
    create: XOR<AssetTicketHistoryCreateWithoutAssetInput, AssetTicketHistoryUncheckedCreateWithoutAssetInput>
  }

  export type AssetTicketHistoryUpdateWithWhereUniqueWithoutAssetInput = {
    where: AssetTicketHistoryWhereUniqueInput
    data: XOR<AssetTicketHistoryUpdateWithoutAssetInput, AssetTicketHistoryUncheckedUpdateWithoutAssetInput>
  }

  export type AssetTicketHistoryUpdateManyWithWhereWithoutAssetInput = {
    where: AssetTicketHistoryScalarWhereInput
    data: XOR<AssetTicketHistoryUpdateManyMutationInput, AssetTicketHistoryUncheckedUpdateManyWithoutAssetInput>
  }

  export type AssetWarrantyAlertUpsertWithWhereUniqueWithoutAssetInput = {
    where: AssetWarrantyAlertWhereUniqueInput
    update: XOR<AssetWarrantyAlertUpdateWithoutAssetInput, AssetWarrantyAlertUncheckedUpdateWithoutAssetInput>
    create: XOR<AssetWarrantyAlertCreateWithoutAssetInput, AssetWarrantyAlertUncheckedCreateWithoutAssetInput>
  }

  export type AssetWarrantyAlertUpdateWithWhereUniqueWithoutAssetInput = {
    where: AssetWarrantyAlertWhereUniqueInput
    data: XOR<AssetWarrantyAlertUpdateWithoutAssetInput, AssetWarrantyAlertUncheckedUpdateWithoutAssetInput>
  }

  export type AssetWarrantyAlertUpdateManyWithWhereWithoutAssetInput = {
    where: AssetWarrantyAlertScalarWhereInput
    data: XOR<AssetWarrantyAlertUpdateManyMutationInput, AssetWarrantyAlertUncheckedUpdateManyWithoutAssetInput>
  }

  export type AssetWarrantyAlertScalarWhereInput = {
    AND?: AssetWarrantyAlertScalarWhereInput | AssetWarrantyAlertScalarWhereInput[]
    OR?: AssetWarrantyAlertScalarWhereInput[]
    NOT?: AssetWarrantyAlertScalarWhereInput | AssetWarrantyAlertScalarWhereInput[]
    id?: IntFilter<"AssetWarrantyAlert"> | number
    assetId?: IntFilter<"AssetWarrantyAlert"> | number
    alertType?: StringFilter<"AssetWarrantyAlert"> | string
    alertDate?: DateTimeFilter<"AssetWarrantyAlert"> | Date | string
    expiryDate?: DateTimeFilter<"AssetWarrantyAlert"> | Date | string
    daysRemaining?: IntFilter<"AssetWarrantyAlert"> | number
    notificationSent?: BoolFilter<"AssetWarrantyAlert"> | boolean
    notificationSentAt?: DateTimeNullableFilter<"AssetWarrantyAlert"> | Date | string | null
    dismissed?: BoolFilter<"AssetWarrantyAlert"> | boolean
    dismissedBy?: StringNullableFilter<"AssetWarrantyAlert"> | string | null
    dismissedAt?: DateTimeNullableFilter<"AssetWarrantyAlert"> | Date | string | null
  }

  export type KioskAssetRegistryUpsertWithWhereUniqueWithoutAssetInput = {
    where: KioskAssetRegistryWhereUniqueInput
    update: XOR<KioskAssetRegistryUpdateWithoutAssetInput, KioskAssetRegistryUncheckedUpdateWithoutAssetInput>
    create: XOR<KioskAssetRegistryCreateWithoutAssetInput, KioskAssetRegistryUncheckedCreateWithoutAssetInput>
  }

  export type KioskAssetRegistryUpdateWithWhereUniqueWithoutAssetInput = {
    where: KioskAssetRegistryWhereUniqueInput
    data: XOR<KioskAssetRegistryUpdateWithoutAssetInput, KioskAssetRegistryUncheckedUpdateWithoutAssetInput>
  }

  export type KioskAssetRegistryUpdateManyWithWhereWithoutAssetInput = {
    where: KioskAssetRegistryScalarWhereInput
    data: XOR<KioskAssetRegistryUpdateManyMutationInput, KioskAssetRegistryUncheckedUpdateManyWithoutAssetInput>
  }

  export type AssetValidationLogUpsertWithWhereUniqueWithoutAssetInput = {
    where: AssetValidationLogWhereUniqueInput
    update: XOR<AssetValidationLogUpdateWithoutAssetInput, AssetValidationLogUncheckedUpdateWithoutAssetInput>
    create: XOR<AssetValidationLogCreateWithoutAssetInput, AssetValidationLogUncheckedCreateWithoutAssetInput>
  }

  export type AssetValidationLogUpdateWithWhereUniqueWithoutAssetInput = {
    where: AssetValidationLogWhereUniqueInput
    data: XOR<AssetValidationLogUpdateWithoutAssetInput, AssetValidationLogUncheckedUpdateWithoutAssetInput>
  }

  export type AssetValidationLogUpdateManyWithWhereWithoutAssetInput = {
    where: AssetValidationLogScalarWhereInput
    data: XOR<AssetValidationLogUpdateManyMutationInput, AssetValidationLogUncheckedUpdateManyWithoutAssetInput>
  }

  export type AssetValidationLogScalarWhereInput = {
    AND?: AssetValidationLogScalarWhereInput | AssetValidationLogScalarWhereInput[]
    OR?: AssetValidationLogScalarWhereInput[]
    NOT?: AssetValidationLogScalarWhereInput | AssetValidationLogScalarWhereInput[]
    id?: IntFilter<"AssetValidationLog"> | number
    batchId?: StringFilter<"AssetValidationLog"> | string
    assetId?: IntNullableFilter<"AssetValidationLog"> | number | null
    rowNumber?: IntFilter<"AssetValidationLog"> | number
    validationLevel?: StringFilter<"AssetValidationLog"> | string
    fieldName?: StringNullableFilter<"AssetValidationLog"> | string | null
    message?: StringFilter<"AssetValidationLog"> | string
    rawData?: JsonNullableFilter<"AssetValidationLog">
    createdAt?: DateTimeFilter<"AssetValidationLog"> | Date | string
  }

  export type HelixSyncFailureUpsertWithWhereUniqueWithoutAssetInput = {
    where: HelixSyncFailureWhereUniqueInput
    update: XOR<HelixSyncFailureUpdateWithoutAssetInput, HelixSyncFailureUncheckedUpdateWithoutAssetInput>
    create: XOR<HelixSyncFailureCreateWithoutAssetInput, HelixSyncFailureUncheckedCreateWithoutAssetInput>
  }

  export type HelixSyncFailureUpdateWithWhereUniqueWithoutAssetInput = {
    where: HelixSyncFailureWhereUniqueInput
    data: XOR<HelixSyncFailureUpdateWithoutAssetInput, HelixSyncFailureUncheckedUpdateWithoutAssetInput>
  }

  export type HelixSyncFailureUpdateManyWithWhereWithoutAssetInput = {
    where: HelixSyncFailureScalarWhereInput
    data: XOR<HelixSyncFailureUpdateManyMutationInput, HelixSyncFailureUncheckedUpdateManyWithoutAssetInput>
  }

  export type AssetImportBatchUpsertWithoutAssetsInput = {
    update: XOR<AssetImportBatchUpdateWithoutAssetsInput, AssetImportBatchUncheckedUpdateWithoutAssetsInput>
    create: XOR<AssetImportBatchCreateWithoutAssetsInput, AssetImportBatchUncheckedCreateWithoutAssetsInput>
    where?: AssetImportBatchWhereInput
  }

  export type AssetImportBatchUpdateToOneWithWhereWithoutAssetsInput = {
    where?: AssetImportBatchWhereInput
    data: XOR<AssetImportBatchUpdateWithoutAssetsInput, AssetImportBatchUncheckedUpdateWithoutAssetsInput>
  }

  export type AssetImportBatchUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    importedBy?: StringFieldUpdateOperationsInput | string
    importDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalRecords?: IntFieldUpdateOperationsInput | number
    successfulRecords?: IntFieldUpdateOperationsInput | number
    failedRecords?: IntFieldUpdateOperationsInput | number
    validationStatus?: StringFieldUpdateOperationsInput | string
    validationErrors?: NullableStringFieldUpdateOperationsInput | string | null
    rollbackDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackBy?: NullableStringFieldUpdateOperationsInput | string | null
    validationLogs?: AssetValidationLogUpdateManyWithoutBatchNestedInput
  }

  export type AssetImportBatchUncheckedUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    importedBy?: StringFieldUpdateOperationsInput | string
    importDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalRecords?: IntFieldUpdateOperationsInput | number
    successfulRecords?: IntFieldUpdateOperationsInput | number
    failedRecords?: IntFieldUpdateOperationsInput | number
    validationStatus?: StringFieldUpdateOperationsInput | string
    validationErrors?: NullableStringFieldUpdateOperationsInput | string | null
    rollbackDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackBy?: NullableStringFieldUpdateOperationsInput | string | null
    validationLogs?: AssetValidationLogUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type InventoryAssetCreateWithoutStatusLogsInput = {
    assetTag: string
    typeId?: number | null
    serialNumber?: string | null
    model?: string | null
    vendorId?: number | null
    purchaseDate?: Date | string | null
    warrantyExpiry?: Date | string | null
    assignedToUserId?: string | null
    assignedToOrgId?: number | null
    assignedToCustomerId?: number | null
    department?: string | null
    status?: string | null
    locationId?: number | null
    kioskId?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serialNumberEnc?: string | null
    warrantyInfoEnc?: string | null
    purchaseInfoEnc?: string | null
    maintenanceNotesEnc?: string | null
    warrantyAlertDays?: number | null
    warrantyAlertEnabled?: boolean
    lastWarrantyAlertSent?: Date | string | null
    importSource?: string | null
    importValidated?: boolean
    validationErrors?: string | null
    assignments?: AssetAssignmentCreateNestedManyWithoutAssetInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutAssetInput
    ticketHistory?: AssetTicketHistoryCreateNestedManyWithoutAssetInput
    warrantyAlerts?: AssetWarrantyAlertCreateNestedManyWithoutAssetInput
    kioskRegistrations?: KioskAssetRegistryCreateNestedManyWithoutAssetInput
    validationLogs?: AssetValidationLogCreateNestedManyWithoutAssetInput
    syncFailures?: HelixSyncFailureCreateNestedManyWithoutAssetInput
    importBatch?: AssetImportBatchCreateNestedOneWithoutAssetsInput
  }

  export type InventoryAssetUncheckedCreateWithoutStatusLogsInput = {
    id?: number
    assetTag: string
    typeId?: number | null
    serialNumber?: string | null
    model?: string | null
    vendorId?: number | null
    purchaseDate?: Date | string | null
    warrantyExpiry?: Date | string | null
    assignedToUserId?: string | null
    assignedToOrgId?: number | null
    assignedToCustomerId?: number | null
    department?: string | null
    status?: string | null
    locationId?: number | null
    kioskId?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serialNumberEnc?: string | null
    warrantyInfoEnc?: string | null
    purchaseInfoEnc?: string | null
    maintenanceNotesEnc?: string | null
    warrantyAlertDays?: number | null
    warrantyAlertEnabled?: boolean
    lastWarrantyAlertSent?: Date | string | null
    importBatchId?: string | null
    importSource?: string | null
    importValidated?: boolean
    validationErrors?: string | null
    assignments?: AssetAssignmentUncheckedCreateNestedManyWithoutAssetInput
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutAssetInput
    ticketHistory?: AssetTicketHistoryUncheckedCreateNestedManyWithoutAssetInput
    warrantyAlerts?: AssetWarrantyAlertUncheckedCreateNestedManyWithoutAssetInput
    kioskRegistrations?: KioskAssetRegistryUncheckedCreateNestedManyWithoutAssetInput
    validationLogs?: AssetValidationLogUncheckedCreateNestedManyWithoutAssetInput
    syncFailures?: HelixSyncFailureUncheckedCreateNestedManyWithoutAssetInput
  }

  export type InventoryAssetCreateOrConnectWithoutStatusLogsInput = {
    where: InventoryAssetWhereUniqueInput
    create: XOR<InventoryAssetCreateWithoutStatusLogsInput, InventoryAssetUncheckedCreateWithoutStatusLogsInput>
  }

  export type InventoryAssetUpsertWithoutStatusLogsInput = {
    update: XOR<InventoryAssetUpdateWithoutStatusLogsInput, InventoryAssetUncheckedUpdateWithoutStatusLogsInput>
    create: XOR<InventoryAssetCreateWithoutStatusLogsInput, InventoryAssetUncheckedCreateWithoutStatusLogsInput>
    where?: InventoryAssetWhereInput
  }

  export type InventoryAssetUpdateToOneWithWhereWithoutStatusLogsInput = {
    where?: InventoryAssetWhereInput
    data: XOR<InventoryAssetUpdateWithoutStatusLogsInput, InventoryAssetUncheckedUpdateWithoutStatusLogsInput>
  }

  export type InventoryAssetUpdateWithoutStatusLogsInput = {
    assetTag?: StringFieldUpdateOperationsInput | string
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToOrgId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedToCustomerId?: NullableIntFieldUpdateOperationsInput | number | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    kioskId?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serialNumberEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyAlertDays?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyAlertEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastWarrantyAlertSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importSource?: NullableStringFieldUpdateOperationsInput | string | null
    importValidated?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableStringFieldUpdateOperationsInput | string | null
    assignments?: AssetAssignmentUpdateManyWithoutAssetNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutAssetNestedInput
    ticketHistory?: AssetTicketHistoryUpdateManyWithoutAssetNestedInput
    warrantyAlerts?: AssetWarrantyAlertUpdateManyWithoutAssetNestedInput
    kioskRegistrations?: KioskAssetRegistryUpdateManyWithoutAssetNestedInput
    validationLogs?: AssetValidationLogUpdateManyWithoutAssetNestedInput
    syncFailures?: HelixSyncFailureUpdateManyWithoutAssetNestedInput
    importBatch?: AssetImportBatchUpdateOneWithoutAssetsNestedInput
  }

  export type InventoryAssetUncheckedUpdateWithoutStatusLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetTag?: StringFieldUpdateOperationsInput | string
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToOrgId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedToCustomerId?: NullableIntFieldUpdateOperationsInput | number | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    kioskId?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serialNumberEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyAlertDays?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyAlertEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastWarrantyAlertSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    importSource?: NullableStringFieldUpdateOperationsInput | string | null
    importValidated?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableStringFieldUpdateOperationsInput | string | null
    assignments?: AssetAssignmentUncheckedUpdateManyWithoutAssetNestedInput
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutAssetNestedInput
    ticketHistory?: AssetTicketHistoryUncheckedUpdateManyWithoutAssetNestedInput
    warrantyAlerts?: AssetWarrantyAlertUncheckedUpdateManyWithoutAssetNestedInput
    kioskRegistrations?: KioskAssetRegistryUncheckedUpdateManyWithoutAssetNestedInput
    validationLogs?: AssetValidationLogUncheckedUpdateManyWithoutAssetNestedInput
    syncFailures?: HelixSyncFailureUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type InventoryAssetCreateWithoutAssignmentsInput = {
    assetTag: string
    typeId?: number | null
    serialNumber?: string | null
    model?: string | null
    vendorId?: number | null
    purchaseDate?: Date | string | null
    warrantyExpiry?: Date | string | null
    assignedToUserId?: string | null
    assignedToOrgId?: number | null
    assignedToCustomerId?: number | null
    department?: string | null
    status?: string | null
    locationId?: number | null
    kioskId?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serialNumberEnc?: string | null
    warrantyInfoEnc?: string | null
    purchaseInfoEnc?: string | null
    maintenanceNotesEnc?: string | null
    warrantyAlertDays?: number | null
    warrantyAlertEnabled?: boolean
    lastWarrantyAlertSent?: Date | string | null
    importSource?: string | null
    importValidated?: boolean
    validationErrors?: string | null
    statusLogs?: AssetStatusLogCreateNestedManyWithoutAssetInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutAssetInput
    ticketHistory?: AssetTicketHistoryCreateNestedManyWithoutAssetInput
    warrantyAlerts?: AssetWarrantyAlertCreateNestedManyWithoutAssetInput
    kioskRegistrations?: KioskAssetRegistryCreateNestedManyWithoutAssetInput
    validationLogs?: AssetValidationLogCreateNestedManyWithoutAssetInput
    syncFailures?: HelixSyncFailureCreateNestedManyWithoutAssetInput
    importBatch?: AssetImportBatchCreateNestedOneWithoutAssetsInput
  }

  export type InventoryAssetUncheckedCreateWithoutAssignmentsInput = {
    id?: number
    assetTag: string
    typeId?: number | null
    serialNumber?: string | null
    model?: string | null
    vendorId?: number | null
    purchaseDate?: Date | string | null
    warrantyExpiry?: Date | string | null
    assignedToUserId?: string | null
    assignedToOrgId?: number | null
    assignedToCustomerId?: number | null
    department?: string | null
    status?: string | null
    locationId?: number | null
    kioskId?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serialNumberEnc?: string | null
    warrantyInfoEnc?: string | null
    purchaseInfoEnc?: string | null
    maintenanceNotesEnc?: string | null
    warrantyAlertDays?: number | null
    warrantyAlertEnabled?: boolean
    lastWarrantyAlertSent?: Date | string | null
    importBatchId?: string | null
    importSource?: string | null
    importValidated?: boolean
    validationErrors?: string | null
    statusLogs?: AssetStatusLogUncheckedCreateNestedManyWithoutAssetInput
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutAssetInput
    ticketHistory?: AssetTicketHistoryUncheckedCreateNestedManyWithoutAssetInput
    warrantyAlerts?: AssetWarrantyAlertUncheckedCreateNestedManyWithoutAssetInput
    kioskRegistrations?: KioskAssetRegistryUncheckedCreateNestedManyWithoutAssetInput
    validationLogs?: AssetValidationLogUncheckedCreateNestedManyWithoutAssetInput
    syncFailures?: HelixSyncFailureUncheckedCreateNestedManyWithoutAssetInput
  }

  export type InventoryAssetCreateOrConnectWithoutAssignmentsInput = {
    where: InventoryAssetWhereUniqueInput
    create: XOR<InventoryAssetCreateWithoutAssignmentsInput, InventoryAssetUncheckedCreateWithoutAssignmentsInput>
  }

  export type InventoryAssetUpsertWithoutAssignmentsInput = {
    update: XOR<InventoryAssetUpdateWithoutAssignmentsInput, InventoryAssetUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<InventoryAssetCreateWithoutAssignmentsInput, InventoryAssetUncheckedCreateWithoutAssignmentsInput>
    where?: InventoryAssetWhereInput
  }

  export type InventoryAssetUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: InventoryAssetWhereInput
    data: XOR<InventoryAssetUpdateWithoutAssignmentsInput, InventoryAssetUncheckedUpdateWithoutAssignmentsInput>
  }

  export type InventoryAssetUpdateWithoutAssignmentsInput = {
    assetTag?: StringFieldUpdateOperationsInput | string
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToOrgId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedToCustomerId?: NullableIntFieldUpdateOperationsInput | number | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    kioskId?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serialNumberEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyAlertDays?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyAlertEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastWarrantyAlertSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importSource?: NullableStringFieldUpdateOperationsInput | string | null
    importValidated?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableStringFieldUpdateOperationsInput | string | null
    statusLogs?: AssetStatusLogUpdateManyWithoutAssetNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutAssetNestedInput
    ticketHistory?: AssetTicketHistoryUpdateManyWithoutAssetNestedInput
    warrantyAlerts?: AssetWarrantyAlertUpdateManyWithoutAssetNestedInput
    kioskRegistrations?: KioskAssetRegistryUpdateManyWithoutAssetNestedInput
    validationLogs?: AssetValidationLogUpdateManyWithoutAssetNestedInput
    syncFailures?: HelixSyncFailureUpdateManyWithoutAssetNestedInput
    importBatch?: AssetImportBatchUpdateOneWithoutAssetsNestedInput
  }

  export type InventoryAssetUncheckedUpdateWithoutAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetTag?: StringFieldUpdateOperationsInput | string
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToOrgId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedToCustomerId?: NullableIntFieldUpdateOperationsInput | number | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    kioskId?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serialNumberEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyAlertDays?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyAlertEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastWarrantyAlertSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    importSource?: NullableStringFieldUpdateOperationsInput | string | null
    importValidated?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableStringFieldUpdateOperationsInput | string | null
    statusLogs?: AssetStatusLogUncheckedUpdateManyWithoutAssetNestedInput
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutAssetNestedInput
    ticketHistory?: AssetTicketHistoryUncheckedUpdateManyWithoutAssetNestedInput
    warrantyAlerts?: AssetWarrantyAlertUncheckedUpdateManyWithoutAssetNestedInput
    kioskRegistrations?: KioskAssetRegistryUncheckedUpdateManyWithoutAssetNestedInput
    validationLogs?: AssetValidationLogUncheckedUpdateManyWithoutAssetNestedInput
    syncFailures?: HelixSyncFailureUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type InventoryAssetCreateWithoutTicketHistoryInput = {
    assetTag: string
    typeId?: number | null
    serialNumber?: string | null
    model?: string | null
    vendorId?: number | null
    purchaseDate?: Date | string | null
    warrantyExpiry?: Date | string | null
    assignedToUserId?: string | null
    assignedToOrgId?: number | null
    assignedToCustomerId?: number | null
    department?: string | null
    status?: string | null
    locationId?: number | null
    kioskId?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serialNumberEnc?: string | null
    warrantyInfoEnc?: string | null
    purchaseInfoEnc?: string | null
    maintenanceNotesEnc?: string | null
    warrantyAlertDays?: number | null
    warrantyAlertEnabled?: boolean
    lastWarrantyAlertSent?: Date | string | null
    importSource?: string | null
    importValidated?: boolean
    validationErrors?: string | null
    statusLogs?: AssetStatusLogCreateNestedManyWithoutAssetInput
    assignments?: AssetAssignmentCreateNestedManyWithoutAssetInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutAssetInput
    warrantyAlerts?: AssetWarrantyAlertCreateNestedManyWithoutAssetInput
    kioskRegistrations?: KioskAssetRegistryCreateNestedManyWithoutAssetInput
    validationLogs?: AssetValidationLogCreateNestedManyWithoutAssetInput
    syncFailures?: HelixSyncFailureCreateNestedManyWithoutAssetInput
    importBatch?: AssetImportBatchCreateNestedOneWithoutAssetsInput
  }

  export type InventoryAssetUncheckedCreateWithoutTicketHistoryInput = {
    id?: number
    assetTag: string
    typeId?: number | null
    serialNumber?: string | null
    model?: string | null
    vendorId?: number | null
    purchaseDate?: Date | string | null
    warrantyExpiry?: Date | string | null
    assignedToUserId?: string | null
    assignedToOrgId?: number | null
    assignedToCustomerId?: number | null
    department?: string | null
    status?: string | null
    locationId?: number | null
    kioskId?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serialNumberEnc?: string | null
    warrantyInfoEnc?: string | null
    purchaseInfoEnc?: string | null
    maintenanceNotesEnc?: string | null
    warrantyAlertDays?: number | null
    warrantyAlertEnabled?: boolean
    lastWarrantyAlertSent?: Date | string | null
    importBatchId?: string | null
    importSource?: string | null
    importValidated?: boolean
    validationErrors?: string | null
    statusLogs?: AssetStatusLogUncheckedCreateNestedManyWithoutAssetInput
    assignments?: AssetAssignmentUncheckedCreateNestedManyWithoutAssetInput
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutAssetInput
    warrantyAlerts?: AssetWarrantyAlertUncheckedCreateNestedManyWithoutAssetInput
    kioskRegistrations?: KioskAssetRegistryUncheckedCreateNestedManyWithoutAssetInput
    validationLogs?: AssetValidationLogUncheckedCreateNestedManyWithoutAssetInput
    syncFailures?: HelixSyncFailureUncheckedCreateNestedManyWithoutAssetInput
  }

  export type InventoryAssetCreateOrConnectWithoutTicketHistoryInput = {
    where: InventoryAssetWhereUniqueInput
    create: XOR<InventoryAssetCreateWithoutTicketHistoryInput, InventoryAssetUncheckedCreateWithoutTicketHistoryInput>
  }

  export type SupportTicketCreateWithoutAssetHistoryInput = {
    title: string
    description: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vipPriorityScore?: number | null
    vipTriggerSource?: string | null
    users_support_tickets_assigneeIdTousers?: UserCreateNestedOneWithoutSupport_tickets_support_tickets_assigneeIdTousersInput
    users_support_tickets_userIdTousers?: UserCreateNestedOneWithoutSupport_tickets_support_tickets_userIdTousersInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutTicketInput
    ritms?: RITMCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUncheckedCreateWithoutAssetHistoryInput = {
    id?: number
    title: string
    description: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    assigneeId?: string | null
    vipPriorityScore?: number | null
    vipTriggerSource?: string | null
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutTicketInput
    ritms?: RITMUncheckedCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketCreateOrConnectWithoutAssetHistoryInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutAssetHistoryInput, SupportTicketUncheckedCreateWithoutAssetHistoryInput>
  }

  export type InventoryAssetUpsertWithoutTicketHistoryInput = {
    update: XOR<InventoryAssetUpdateWithoutTicketHistoryInput, InventoryAssetUncheckedUpdateWithoutTicketHistoryInput>
    create: XOR<InventoryAssetCreateWithoutTicketHistoryInput, InventoryAssetUncheckedCreateWithoutTicketHistoryInput>
    where?: InventoryAssetWhereInput
  }

  export type InventoryAssetUpdateToOneWithWhereWithoutTicketHistoryInput = {
    where?: InventoryAssetWhereInput
    data: XOR<InventoryAssetUpdateWithoutTicketHistoryInput, InventoryAssetUncheckedUpdateWithoutTicketHistoryInput>
  }

  export type InventoryAssetUpdateWithoutTicketHistoryInput = {
    assetTag?: StringFieldUpdateOperationsInput | string
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToOrgId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedToCustomerId?: NullableIntFieldUpdateOperationsInput | number | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    kioskId?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serialNumberEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyAlertDays?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyAlertEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastWarrantyAlertSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importSource?: NullableStringFieldUpdateOperationsInput | string | null
    importValidated?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableStringFieldUpdateOperationsInput | string | null
    statusLogs?: AssetStatusLogUpdateManyWithoutAssetNestedInput
    assignments?: AssetAssignmentUpdateManyWithoutAssetNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutAssetNestedInput
    warrantyAlerts?: AssetWarrantyAlertUpdateManyWithoutAssetNestedInput
    kioskRegistrations?: KioskAssetRegistryUpdateManyWithoutAssetNestedInput
    validationLogs?: AssetValidationLogUpdateManyWithoutAssetNestedInput
    syncFailures?: HelixSyncFailureUpdateManyWithoutAssetNestedInput
    importBatch?: AssetImportBatchUpdateOneWithoutAssetsNestedInput
  }

  export type InventoryAssetUncheckedUpdateWithoutTicketHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetTag?: StringFieldUpdateOperationsInput | string
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToOrgId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedToCustomerId?: NullableIntFieldUpdateOperationsInput | number | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    kioskId?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serialNumberEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyAlertDays?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyAlertEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastWarrantyAlertSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    importSource?: NullableStringFieldUpdateOperationsInput | string | null
    importValidated?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableStringFieldUpdateOperationsInput | string | null
    statusLogs?: AssetStatusLogUncheckedUpdateManyWithoutAssetNestedInput
    assignments?: AssetAssignmentUncheckedUpdateManyWithoutAssetNestedInput
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutAssetNestedInput
    warrantyAlerts?: AssetWarrantyAlertUncheckedUpdateManyWithoutAssetNestedInput
    kioskRegistrations?: KioskAssetRegistryUncheckedUpdateManyWithoutAssetNestedInput
    validationLogs?: AssetValidationLogUncheckedUpdateManyWithoutAssetNestedInput
    syncFailures?: HelixSyncFailureUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type SupportTicketUpsertWithoutAssetHistoryInput = {
    update: XOR<SupportTicketUpdateWithoutAssetHistoryInput, SupportTicketUncheckedUpdateWithoutAssetHistoryInput>
    create: XOR<SupportTicketCreateWithoutAssetHistoryInput, SupportTicketUncheckedCreateWithoutAssetHistoryInput>
    where?: SupportTicketWhereInput
  }

  export type SupportTicketUpdateToOneWithWhereWithoutAssetHistoryInput = {
    where?: SupportTicketWhereInput
    data: XOR<SupportTicketUpdateWithoutAssetHistoryInput, SupportTicketUncheckedUpdateWithoutAssetHistoryInput>
  }

  export type SupportTicketUpdateWithoutAssetHistoryInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vipPriorityScore?: NullableIntFieldUpdateOperationsInput | number | null
    vipTriggerSource?: NullableStringFieldUpdateOperationsInput | string | null
    users_support_tickets_assigneeIdTousers?: UserUpdateOneWithoutSupport_tickets_support_tickets_assigneeIdTousersNestedInput
    users_support_tickets_userIdTousers?: UserUpdateOneWithoutSupport_tickets_support_tickets_userIdTousersNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutTicketNestedInput
    ritms?: RITMUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutAssetHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    vipPriorityScore?: NullableIntFieldUpdateOperationsInput | number | null
    vipTriggerSource?: NullableStringFieldUpdateOperationsInput | string | null
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutTicketNestedInput
    ritms?: RITMUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type InventoryAssetCreateWithoutWarrantyAlertsInput = {
    assetTag: string
    typeId?: number | null
    serialNumber?: string | null
    model?: string | null
    vendorId?: number | null
    purchaseDate?: Date | string | null
    warrantyExpiry?: Date | string | null
    assignedToUserId?: string | null
    assignedToOrgId?: number | null
    assignedToCustomerId?: number | null
    department?: string | null
    status?: string | null
    locationId?: number | null
    kioskId?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serialNumberEnc?: string | null
    warrantyInfoEnc?: string | null
    purchaseInfoEnc?: string | null
    maintenanceNotesEnc?: string | null
    warrantyAlertDays?: number | null
    warrantyAlertEnabled?: boolean
    lastWarrantyAlertSent?: Date | string | null
    importSource?: string | null
    importValidated?: boolean
    validationErrors?: string | null
    statusLogs?: AssetStatusLogCreateNestedManyWithoutAssetInput
    assignments?: AssetAssignmentCreateNestedManyWithoutAssetInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutAssetInput
    ticketHistory?: AssetTicketHistoryCreateNestedManyWithoutAssetInput
    kioskRegistrations?: KioskAssetRegistryCreateNestedManyWithoutAssetInput
    validationLogs?: AssetValidationLogCreateNestedManyWithoutAssetInput
    syncFailures?: HelixSyncFailureCreateNestedManyWithoutAssetInput
    importBatch?: AssetImportBatchCreateNestedOneWithoutAssetsInput
  }

  export type InventoryAssetUncheckedCreateWithoutWarrantyAlertsInput = {
    id?: number
    assetTag: string
    typeId?: number | null
    serialNumber?: string | null
    model?: string | null
    vendorId?: number | null
    purchaseDate?: Date | string | null
    warrantyExpiry?: Date | string | null
    assignedToUserId?: string | null
    assignedToOrgId?: number | null
    assignedToCustomerId?: number | null
    department?: string | null
    status?: string | null
    locationId?: number | null
    kioskId?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serialNumberEnc?: string | null
    warrantyInfoEnc?: string | null
    purchaseInfoEnc?: string | null
    maintenanceNotesEnc?: string | null
    warrantyAlertDays?: number | null
    warrantyAlertEnabled?: boolean
    lastWarrantyAlertSent?: Date | string | null
    importBatchId?: string | null
    importSource?: string | null
    importValidated?: boolean
    validationErrors?: string | null
    statusLogs?: AssetStatusLogUncheckedCreateNestedManyWithoutAssetInput
    assignments?: AssetAssignmentUncheckedCreateNestedManyWithoutAssetInput
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutAssetInput
    ticketHistory?: AssetTicketHistoryUncheckedCreateNestedManyWithoutAssetInput
    kioskRegistrations?: KioskAssetRegistryUncheckedCreateNestedManyWithoutAssetInput
    validationLogs?: AssetValidationLogUncheckedCreateNestedManyWithoutAssetInput
    syncFailures?: HelixSyncFailureUncheckedCreateNestedManyWithoutAssetInput
  }

  export type InventoryAssetCreateOrConnectWithoutWarrantyAlertsInput = {
    where: InventoryAssetWhereUniqueInput
    create: XOR<InventoryAssetCreateWithoutWarrantyAlertsInput, InventoryAssetUncheckedCreateWithoutWarrantyAlertsInput>
  }

  export type InventoryAssetUpsertWithoutWarrantyAlertsInput = {
    update: XOR<InventoryAssetUpdateWithoutWarrantyAlertsInput, InventoryAssetUncheckedUpdateWithoutWarrantyAlertsInput>
    create: XOR<InventoryAssetCreateWithoutWarrantyAlertsInput, InventoryAssetUncheckedCreateWithoutWarrantyAlertsInput>
    where?: InventoryAssetWhereInput
  }

  export type InventoryAssetUpdateToOneWithWhereWithoutWarrantyAlertsInput = {
    where?: InventoryAssetWhereInput
    data: XOR<InventoryAssetUpdateWithoutWarrantyAlertsInput, InventoryAssetUncheckedUpdateWithoutWarrantyAlertsInput>
  }

  export type InventoryAssetUpdateWithoutWarrantyAlertsInput = {
    assetTag?: StringFieldUpdateOperationsInput | string
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToOrgId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedToCustomerId?: NullableIntFieldUpdateOperationsInput | number | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    kioskId?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serialNumberEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyAlertDays?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyAlertEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastWarrantyAlertSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importSource?: NullableStringFieldUpdateOperationsInput | string | null
    importValidated?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableStringFieldUpdateOperationsInput | string | null
    statusLogs?: AssetStatusLogUpdateManyWithoutAssetNestedInput
    assignments?: AssetAssignmentUpdateManyWithoutAssetNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutAssetNestedInput
    ticketHistory?: AssetTicketHistoryUpdateManyWithoutAssetNestedInput
    kioskRegistrations?: KioskAssetRegistryUpdateManyWithoutAssetNestedInput
    validationLogs?: AssetValidationLogUpdateManyWithoutAssetNestedInput
    syncFailures?: HelixSyncFailureUpdateManyWithoutAssetNestedInput
    importBatch?: AssetImportBatchUpdateOneWithoutAssetsNestedInput
  }

  export type InventoryAssetUncheckedUpdateWithoutWarrantyAlertsInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetTag?: StringFieldUpdateOperationsInput | string
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToOrgId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedToCustomerId?: NullableIntFieldUpdateOperationsInput | number | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    kioskId?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serialNumberEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyAlertDays?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyAlertEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastWarrantyAlertSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    importSource?: NullableStringFieldUpdateOperationsInput | string | null
    importValidated?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableStringFieldUpdateOperationsInput | string | null
    statusLogs?: AssetStatusLogUncheckedUpdateManyWithoutAssetNestedInput
    assignments?: AssetAssignmentUncheckedUpdateManyWithoutAssetNestedInput
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutAssetNestedInput
    ticketHistory?: AssetTicketHistoryUncheckedUpdateManyWithoutAssetNestedInput
    kioskRegistrations?: KioskAssetRegistryUncheckedUpdateManyWithoutAssetNestedInput
    validationLogs?: AssetValidationLogUncheckedUpdateManyWithoutAssetNestedInput
    syncFailures?: HelixSyncFailureUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type InventoryAssetCreateWithoutImportBatchInput = {
    assetTag: string
    typeId?: number | null
    serialNumber?: string | null
    model?: string | null
    vendorId?: number | null
    purchaseDate?: Date | string | null
    warrantyExpiry?: Date | string | null
    assignedToUserId?: string | null
    assignedToOrgId?: number | null
    assignedToCustomerId?: number | null
    department?: string | null
    status?: string | null
    locationId?: number | null
    kioskId?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serialNumberEnc?: string | null
    warrantyInfoEnc?: string | null
    purchaseInfoEnc?: string | null
    maintenanceNotesEnc?: string | null
    warrantyAlertDays?: number | null
    warrantyAlertEnabled?: boolean
    lastWarrantyAlertSent?: Date | string | null
    importSource?: string | null
    importValidated?: boolean
    validationErrors?: string | null
    statusLogs?: AssetStatusLogCreateNestedManyWithoutAssetInput
    assignments?: AssetAssignmentCreateNestedManyWithoutAssetInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutAssetInput
    ticketHistory?: AssetTicketHistoryCreateNestedManyWithoutAssetInput
    warrantyAlerts?: AssetWarrantyAlertCreateNestedManyWithoutAssetInput
    kioskRegistrations?: KioskAssetRegistryCreateNestedManyWithoutAssetInput
    validationLogs?: AssetValidationLogCreateNestedManyWithoutAssetInput
    syncFailures?: HelixSyncFailureCreateNestedManyWithoutAssetInput
  }

  export type InventoryAssetUncheckedCreateWithoutImportBatchInput = {
    id?: number
    assetTag: string
    typeId?: number | null
    serialNumber?: string | null
    model?: string | null
    vendorId?: number | null
    purchaseDate?: Date | string | null
    warrantyExpiry?: Date | string | null
    assignedToUserId?: string | null
    assignedToOrgId?: number | null
    assignedToCustomerId?: number | null
    department?: string | null
    status?: string | null
    locationId?: number | null
    kioskId?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serialNumberEnc?: string | null
    warrantyInfoEnc?: string | null
    purchaseInfoEnc?: string | null
    maintenanceNotesEnc?: string | null
    warrantyAlertDays?: number | null
    warrantyAlertEnabled?: boolean
    lastWarrantyAlertSent?: Date | string | null
    importSource?: string | null
    importValidated?: boolean
    validationErrors?: string | null
    statusLogs?: AssetStatusLogUncheckedCreateNestedManyWithoutAssetInput
    assignments?: AssetAssignmentUncheckedCreateNestedManyWithoutAssetInput
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutAssetInput
    ticketHistory?: AssetTicketHistoryUncheckedCreateNestedManyWithoutAssetInput
    warrantyAlerts?: AssetWarrantyAlertUncheckedCreateNestedManyWithoutAssetInput
    kioskRegistrations?: KioskAssetRegistryUncheckedCreateNestedManyWithoutAssetInput
    validationLogs?: AssetValidationLogUncheckedCreateNestedManyWithoutAssetInput
    syncFailures?: HelixSyncFailureUncheckedCreateNestedManyWithoutAssetInput
  }

  export type InventoryAssetCreateOrConnectWithoutImportBatchInput = {
    where: InventoryAssetWhereUniqueInput
    create: XOR<InventoryAssetCreateWithoutImportBatchInput, InventoryAssetUncheckedCreateWithoutImportBatchInput>
  }

  export type InventoryAssetCreateManyImportBatchInputEnvelope = {
    data: InventoryAssetCreateManyImportBatchInput | InventoryAssetCreateManyImportBatchInput[]
    skipDuplicates?: boolean
  }

  export type AssetValidationLogCreateWithoutBatchInput = {
    rowNumber: number
    validationLevel: string
    fieldName?: string | null
    message: string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    asset?: InventoryAssetCreateNestedOneWithoutValidationLogsInput
  }

  export type AssetValidationLogUncheckedCreateWithoutBatchInput = {
    id?: number
    assetId?: number | null
    rowNumber: number
    validationLevel: string
    fieldName?: string | null
    message: string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AssetValidationLogCreateOrConnectWithoutBatchInput = {
    where: AssetValidationLogWhereUniqueInput
    create: XOR<AssetValidationLogCreateWithoutBatchInput, AssetValidationLogUncheckedCreateWithoutBatchInput>
  }

  export type AssetValidationLogCreateManyBatchInputEnvelope = {
    data: AssetValidationLogCreateManyBatchInput | AssetValidationLogCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type InventoryAssetUpsertWithWhereUniqueWithoutImportBatchInput = {
    where: InventoryAssetWhereUniqueInput
    update: XOR<InventoryAssetUpdateWithoutImportBatchInput, InventoryAssetUncheckedUpdateWithoutImportBatchInput>
    create: XOR<InventoryAssetCreateWithoutImportBatchInput, InventoryAssetUncheckedCreateWithoutImportBatchInput>
  }

  export type InventoryAssetUpdateWithWhereUniqueWithoutImportBatchInput = {
    where: InventoryAssetWhereUniqueInput
    data: XOR<InventoryAssetUpdateWithoutImportBatchInput, InventoryAssetUncheckedUpdateWithoutImportBatchInput>
  }

  export type InventoryAssetUpdateManyWithWhereWithoutImportBatchInput = {
    where: InventoryAssetScalarWhereInput
    data: XOR<InventoryAssetUpdateManyMutationInput, InventoryAssetUncheckedUpdateManyWithoutImportBatchInput>
  }

  export type InventoryAssetScalarWhereInput = {
    AND?: InventoryAssetScalarWhereInput | InventoryAssetScalarWhereInput[]
    OR?: InventoryAssetScalarWhereInput[]
    NOT?: InventoryAssetScalarWhereInput | InventoryAssetScalarWhereInput[]
    id?: IntFilter<"InventoryAsset"> | number
    assetTag?: StringFilter<"InventoryAsset"> | string
    typeId?: IntNullableFilter<"InventoryAsset"> | number | null
    serialNumber?: StringNullableFilter<"InventoryAsset"> | string | null
    model?: StringNullableFilter<"InventoryAsset"> | string | null
    vendorId?: IntNullableFilter<"InventoryAsset"> | number | null
    purchaseDate?: DateTimeNullableFilter<"InventoryAsset"> | Date | string | null
    warrantyExpiry?: DateTimeNullableFilter<"InventoryAsset"> | Date | string | null
    assignedToUserId?: StringNullableFilter<"InventoryAsset"> | string | null
    assignedToOrgId?: IntNullableFilter<"InventoryAsset"> | number | null
    assignedToCustomerId?: IntNullableFilter<"InventoryAsset"> | number | null
    department?: StringNullableFilter<"InventoryAsset"> | string | null
    status?: StringNullableFilter<"InventoryAsset"> | string | null
    locationId?: IntNullableFilter<"InventoryAsset"> | number | null
    kioskId?: StringNullableFilter<"InventoryAsset"> | string | null
    customFields?: JsonNullableFilter<"InventoryAsset">
    notes?: StringNullableFilter<"InventoryAsset"> | string | null
    createdBy?: StringNullableFilter<"InventoryAsset"> | string | null
    updatedBy?: StringNullableFilter<"InventoryAsset"> | string | null
    createdAt?: DateTimeFilter<"InventoryAsset"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryAsset"> | Date | string
    serialNumberEnc?: StringNullableFilter<"InventoryAsset"> | string | null
    warrantyInfoEnc?: StringNullableFilter<"InventoryAsset"> | string | null
    purchaseInfoEnc?: StringNullableFilter<"InventoryAsset"> | string | null
    maintenanceNotesEnc?: StringNullableFilter<"InventoryAsset"> | string | null
    warrantyAlertDays?: IntNullableFilter<"InventoryAsset"> | number | null
    warrantyAlertEnabled?: BoolFilter<"InventoryAsset"> | boolean
    lastWarrantyAlertSent?: DateTimeNullableFilter<"InventoryAsset"> | Date | string | null
    importBatchId?: StringNullableFilter<"InventoryAsset"> | string | null
    importSource?: StringNullableFilter<"InventoryAsset"> | string | null
    importValidated?: BoolFilter<"InventoryAsset"> | boolean
    validationErrors?: StringNullableFilter<"InventoryAsset"> | string | null
  }

  export type AssetValidationLogUpsertWithWhereUniqueWithoutBatchInput = {
    where: AssetValidationLogWhereUniqueInput
    update: XOR<AssetValidationLogUpdateWithoutBatchInput, AssetValidationLogUncheckedUpdateWithoutBatchInput>
    create: XOR<AssetValidationLogCreateWithoutBatchInput, AssetValidationLogUncheckedCreateWithoutBatchInput>
  }

  export type AssetValidationLogUpdateWithWhereUniqueWithoutBatchInput = {
    where: AssetValidationLogWhereUniqueInput
    data: XOR<AssetValidationLogUpdateWithoutBatchInput, AssetValidationLogUncheckedUpdateWithoutBatchInput>
  }

  export type AssetValidationLogUpdateManyWithWhereWithoutBatchInput = {
    where: AssetValidationLogScalarWhereInput
    data: XOR<AssetValidationLogUpdateManyMutationInput, AssetValidationLogUncheckedUpdateManyWithoutBatchInput>
  }

  export type AssetImportBatchCreateWithoutValidationLogsInput = {
    id?: string
    filename: string
    importedBy: string
    importDate?: Date | string
    totalRecords?: number
    successfulRecords?: number
    failedRecords?: number
    validationStatus?: string
    validationErrors?: string | null
    rollbackDate?: Date | string | null
    rollbackBy?: string | null
    assets?: InventoryAssetCreateNestedManyWithoutImportBatchInput
  }

  export type AssetImportBatchUncheckedCreateWithoutValidationLogsInput = {
    id?: string
    filename: string
    importedBy: string
    importDate?: Date | string
    totalRecords?: number
    successfulRecords?: number
    failedRecords?: number
    validationStatus?: string
    validationErrors?: string | null
    rollbackDate?: Date | string | null
    rollbackBy?: string | null
    assets?: InventoryAssetUncheckedCreateNestedManyWithoutImportBatchInput
  }

  export type AssetImportBatchCreateOrConnectWithoutValidationLogsInput = {
    where: AssetImportBatchWhereUniqueInput
    create: XOR<AssetImportBatchCreateWithoutValidationLogsInput, AssetImportBatchUncheckedCreateWithoutValidationLogsInput>
  }

  export type InventoryAssetCreateWithoutValidationLogsInput = {
    assetTag: string
    typeId?: number | null
    serialNumber?: string | null
    model?: string | null
    vendorId?: number | null
    purchaseDate?: Date | string | null
    warrantyExpiry?: Date | string | null
    assignedToUserId?: string | null
    assignedToOrgId?: number | null
    assignedToCustomerId?: number | null
    department?: string | null
    status?: string | null
    locationId?: number | null
    kioskId?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serialNumberEnc?: string | null
    warrantyInfoEnc?: string | null
    purchaseInfoEnc?: string | null
    maintenanceNotesEnc?: string | null
    warrantyAlertDays?: number | null
    warrantyAlertEnabled?: boolean
    lastWarrantyAlertSent?: Date | string | null
    importSource?: string | null
    importValidated?: boolean
    validationErrors?: string | null
    statusLogs?: AssetStatusLogCreateNestedManyWithoutAssetInput
    assignments?: AssetAssignmentCreateNestedManyWithoutAssetInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutAssetInput
    ticketHistory?: AssetTicketHistoryCreateNestedManyWithoutAssetInput
    warrantyAlerts?: AssetWarrantyAlertCreateNestedManyWithoutAssetInput
    kioskRegistrations?: KioskAssetRegistryCreateNestedManyWithoutAssetInput
    syncFailures?: HelixSyncFailureCreateNestedManyWithoutAssetInput
    importBatch?: AssetImportBatchCreateNestedOneWithoutAssetsInput
  }

  export type InventoryAssetUncheckedCreateWithoutValidationLogsInput = {
    id?: number
    assetTag: string
    typeId?: number | null
    serialNumber?: string | null
    model?: string | null
    vendorId?: number | null
    purchaseDate?: Date | string | null
    warrantyExpiry?: Date | string | null
    assignedToUserId?: string | null
    assignedToOrgId?: number | null
    assignedToCustomerId?: number | null
    department?: string | null
    status?: string | null
    locationId?: number | null
    kioskId?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serialNumberEnc?: string | null
    warrantyInfoEnc?: string | null
    purchaseInfoEnc?: string | null
    maintenanceNotesEnc?: string | null
    warrantyAlertDays?: number | null
    warrantyAlertEnabled?: boolean
    lastWarrantyAlertSent?: Date | string | null
    importBatchId?: string | null
    importSource?: string | null
    importValidated?: boolean
    validationErrors?: string | null
    statusLogs?: AssetStatusLogUncheckedCreateNestedManyWithoutAssetInput
    assignments?: AssetAssignmentUncheckedCreateNestedManyWithoutAssetInput
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutAssetInput
    ticketHistory?: AssetTicketHistoryUncheckedCreateNestedManyWithoutAssetInput
    warrantyAlerts?: AssetWarrantyAlertUncheckedCreateNestedManyWithoutAssetInput
    kioskRegistrations?: KioskAssetRegistryUncheckedCreateNestedManyWithoutAssetInput
    syncFailures?: HelixSyncFailureUncheckedCreateNestedManyWithoutAssetInput
  }

  export type InventoryAssetCreateOrConnectWithoutValidationLogsInput = {
    where: InventoryAssetWhereUniqueInput
    create: XOR<InventoryAssetCreateWithoutValidationLogsInput, InventoryAssetUncheckedCreateWithoutValidationLogsInput>
  }

  export type AssetImportBatchUpsertWithoutValidationLogsInput = {
    update: XOR<AssetImportBatchUpdateWithoutValidationLogsInput, AssetImportBatchUncheckedUpdateWithoutValidationLogsInput>
    create: XOR<AssetImportBatchCreateWithoutValidationLogsInput, AssetImportBatchUncheckedCreateWithoutValidationLogsInput>
    where?: AssetImportBatchWhereInput
  }

  export type AssetImportBatchUpdateToOneWithWhereWithoutValidationLogsInput = {
    where?: AssetImportBatchWhereInput
    data: XOR<AssetImportBatchUpdateWithoutValidationLogsInput, AssetImportBatchUncheckedUpdateWithoutValidationLogsInput>
  }

  export type AssetImportBatchUpdateWithoutValidationLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    importedBy?: StringFieldUpdateOperationsInput | string
    importDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalRecords?: IntFieldUpdateOperationsInput | number
    successfulRecords?: IntFieldUpdateOperationsInput | number
    failedRecords?: IntFieldUpdateOperationsInput | number
    validationStatus?: StringFieldUpdateOperationsInput | string
    validationErrors?: NullableStringFieldUpdateOperationsInput | string | null
    rollbackDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackBy?: NullableStringFieldUpdateOperationsInput | string | null
    assets?: InventoryAssetUpdateManyWithoutImportBatchNestedInput
  }

  export type AssetImportBatchUncheckedUpdateWithoutValidationLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    importedBy?: StringFieldUpdateOperationsInput | string
    importDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalRecords?: IntFieldUpdateOperationsInput | number
    successfulRecords?: IntFieldUpdateOperationsInput | number
    failedRecords?: IntFieldUpdateOperationsInput | number
    validationStatus?: StringFieldUpdateOperationsInput | string
    validationErrors?: NullableStringFieldUpdateOperationsInput | string | null
    rollbackDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackBy?: NullableStringFieldUpdateOperationsInput | string | null
    assets?: InventoryAssetUncheckedUpdateManyWithoutImportBatchNestedInput
  }

  export type InventoryAssetUpsertWithoutValidationLogsInput = {
    update: XOR<InventoryAssetUpdateWithoutValidationLogsInput, InventoryAssetUncheckedUpdateWithoutValidationLogsInput>
    create: XOR<InventoryAssetCreateWithoutValidationLogsInput, InventoryAssetUncheckedCreateWithoutValidationLogsInput>
    where?: InventoryAssetWhereInput
  }

  export type InventoryAssetUpdateToOneWithWhereWithoutValidationLogsInput = {
    where?: InventoryAssetWhereInput
    data: XOR<InventoryAssetUpdateWithoutValidationLogsInput, InventoryAssetUncheckedUpdateWithoutValidationLogsInput>
  }

  export type InventoryAssetUpdateWithoutValidationLogsInput = {
    assetTag?: StringFieldUpdateOperationsInput | string
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToOrgId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedToCustomerId?: NullableIntFieldUpdateOperationsInput | number | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    kioskId?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serialNumberEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyAlertDays?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyAlertEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastWarrantyAlertSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importSource?: NullableStringFieldUpdateOperationsInput | string | null
    importValidated?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableStringFieldUpdateOperationsInput | string | null
    statusLogs?: AssetStatusLogUpdateManyWithoutAssetNestedInput
    assignments?: AssetAssignmentUpdateManyWithoutAssetNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutAssetNestedInput
    ticketHistory?: AssetTicketHistoryUpdateManyWithoutAssetNestedInput
    warrantyAlerts?: AssetWarrantyAlertUpdateManyWithoutAssetNestedInput
    kioskRegistrations?: KioskAssetRegistryUpdateManyWithoutAssetNestedInput
    syncFailures?: HelixSyncFailureUpdateManyWithoutAssetNestedInput
    importBatch?: AssetImportBatchUpdateOneWithoutAssetsNestedInput
  }

  export type InventoryAssetUncheckedUpdateWithoutValidationLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetTag?: StringFieldUpdateOperationsInput | string
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToOrgId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedToCustomerId?: NullableIntFieldUpdateOperationsInput | number | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    kioskId?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serialNumberEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyAlertDays?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyAlertEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastWarrantyAlertSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    importSource?: NullableStringFieldUpdateOperationsInput | string | null
    importValidated?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableStringFieldUpdateOperationsInput | string | null
    statusLogs?: AssetStatusLogUncheckedUpdateManyWithoutAssetNestedInput
    assignments?: AssetAssignmentUncheckedUpdateManyWithoutAssetNestedInput
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutAssetNestedInput
    ticketHistory?: AssetTicketHistoryUncheckedUpdateManyWithoutAssetNestedInput
    warrantyAlerts?: AssetWarrantyAlertUncheckedUpdateManyWithoutAssetNestedInput
    kioskRegistrations?: KioskAssetRegistryUncheckedUpdateManyWithoutAssetNestedInput
    syncFailures?: HelixSyncFailureUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type KioskCreateWithoutAssetRegistryInput = {
    id: string
    lastSeen?: Date | string | null
    version?: string | null
    active?: boolean
    logoUrl?: string | null
    bgUrl?: string | null
    statusEnabled?: boolean
    currentStatus?: string | null
    openMsg?: string | null
    closedMsg?: string | null
    errorMsg?: string | null
    meetingMsg?: string | null
    brbMsg?: string | null
    lunchMsg?: string | null
    unavailableMsg?: string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    activations?: KioskActivationCreateNestedManyWithoutKioskInput
    syncFailures?: HelixSyncFailureCreateNestedManyWithoutKioskInput
    orgAssignment?: KioskOrganizationAssignmentCreateNestedOneWithoutKioskInput
    metadataLogs?: KioskMetadataLogCreateNestedManyWithoutKioskInput
  }

  export type KioskUncheckedCreateWithoutAssetRegistryInput = {
    id: string
    lastSeen?: Date | string | null
    version?: string | null
    active?: boolean
    logoUrl?: string | null
    bgUrl?: string | null
    statusEnabled?: boolean
    currentStatus?: string | null
    openMsg?: string | null
    closedMsg?: string | null
    errorMsg?: string | null
    meetingMsg?: string | null
    brbMsg?: string | null
    lunchMsg?: string | null
    unavailableMsg?: string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    activations?: KioskActivationUncheckedCreateNestedManyWithoutKioskInput
    syncFailures?: HelixSyncFailureUncheckedCreateNestedManyWithoutKioskInput
    orgAssignment?: KioskOrganizationAssignmentUncheckedCreateNestedOneWithoutKioskInput
    metadataLogs?: KioskMetadataLogUncheckedCreateNestedManyWithoutKioskInput
  }

  export type KioskCreateOrConnectWithoutAssetRegistryInput = {
    where: KioskWhereUniqueInput
    create: XOR<KioskCreateWithoutAssetRegistryInput, KioskUncheckedCreateWithoutAssetRegistryInput>
  }

  export type InventoryAssetCreateWithoutKioskRegistrationsInput = {
    assetTag: string
    typeId?: number | null
    serialNumber?: string | null
    model?: string | null
    vendorId?: number | null
    purchaseDate?: Date | string | null
    warrantyExpiry?: Date | string | null
    assignedToUserId?: string | null
    assignedToOrgId?: number | null
    assignedToCustomerId?: number | null
    department?: string | null
    status?: string | null
    locationId?: number | null
    kioskId?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serialNumberEnc?: string | null
    warrantyInfoEnc?: string | null
    purchaseInfoEnc?: string | null
    maintenanceNotesEnc?: string | null
    warrantyAlertDays?: number | null
    warrantyAlertEnabled?: boolean
    lastWarrantyAlertSent?: Date | string | null
    importSource?: string | null
    importValidated?: boolean
    validationErrors?: string | null
    statusLogs?: AssetStatusLogCreateNestedManyWithoutAssetInput
    assignments?: AssetAssignmentCreateNestedManyWithoutAssetInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutAssetInput
    ticketHistory?: AssetTicketHistoryCreateNestedManyWithoutAssetInput
    warrantyAlerts?: AssetWarrantyAlertCreateNestedManyWithoutAssetInput
    validationLogs?: AssetValidationLogCreateNestedManyWithoutAssetInput
    syncFailures?: HelixSyncFailureCreateNestedManyWithoutAssetInput
    importBatch?: AssetImportBatchCreateNestedOneWithoutAssetsInput
  }

  export type InventoryAssetUncheckedCreateWithoutKioskRegistrationsInput = {
    id?: number
    assetTag: string
    typeId?: number | null
    serialNumber?: string | null
    model?: string | null
    vendorId?: number | null
    purchaseDate?: Date | string | null
    warrantyExpiry?: Date | string | null
    assignedToUserId?: string | null
    assignedToOrgId?: number | null
    assignedToCustomerId?: number | null
    department?: string | null
    status?: string | null
    locationId?: number | null
    kioskId?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serialNumberEnc?: string | null
    warrantyInfoEnc?: string | null
    purchaseInfoEnc?: string | null
    maintenanceNotesEnc?: string | null
    warrantyAlertDays?: number | null
    warrantyAlertEnabled?: boolean
    lastWarrantyAlertSent?: Date | string | null
    importBatchId?: string | null
    importSource?: string | null
    importValidated?: boolean
    validationErrors?: string | null
    statusLogs?: AssetStatusLogUncheckedCreateNestedManyWithoutAssetInput
    assignments?: AssetAssignmentUncheckedCreateNestedManyWithoutAssetInput
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutAssetInput
    ticketHistory?: AssetTicketHistoryUncheckedCreateNestedManyWithoutAssetInput
    warrantyAlerts?: AssetWarrantyAlertUncheckedCreateNestedManyWithoutAssetInput
    validationLogs?: AssetValidationLogUncheckedCreateNestedManyWithoutAssetInput
    syncFailures?: HelixSyncFailureUncheckedCreateNestedManyWithoutAssetInput
  }

  export type InventoryAssetCreateOrConnectWithoutKioskRegistrationsInput = {
    where: InventoryAssetWhereUniqueInput
    create: XOR<InventoryAssetCreateWithoutKioskRegistrationsInput, InventoryAssetUncheckedCreateWithoutKioskRegistrationsInput>
  }

  export type KioskUpsertWithoutAssetRegistryInput = {
    update: XOR<KioskUpdateWithoutAssetRegistryInput, KioskUncheckedUpdateWithoutAssetRegistryInput>
    create: XOR<KioskCreateWithoutAssetRegistryInput, KioskUncheckedCreateWithoutAssetRegistryInput>
    where?: KioskWhereInput
  }

  export type KioskUpdateToOneWithWhereWithoutAssetRegistryInput = {
    where?: KioskWhereInput
    data: XOR<KioskUpdateWithoutAssetRegistryInput, KioskUncheckedUpdateWithoutAssetRegistryInput>
  }

  export type KioskUpdateWithoutAssetRegistryInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statusEnabled?: BoolFieldUpdateOperationsInput | boolean
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    openMsg?: NullableStringFieldUpdateOperationsInput | string | null
    closedMsg?: NullableStringFieldUpdateOperationsInput | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    meetingMsg?: NullableStringFieldUpdateOperationsInput | string | null
    brbMsg?: NullableStringFieldUpdateOperationsInput | string | null
    lunchMsg?: NullableStringFieldUpdateOperationsInput | string | null
    unavailableMsg?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activations?: KioskActivationUpdateManyWithoutKioskNestedInput
    syncFailures?: HelixSyncFailureUpdateManyWithoutKioskNestedInput
    orgAssignment?: KioskOrganizationAssignmentUpdateOneWithoutKioskNestedInput
    metadataLogs?: KioskMetadataLogUpdateManyWithoutKioskNestedInput
  }

  export type KioskUncheckedUpdateWithoutAssetRegistryInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statusEnabled?: BoolFieldUpdateOperationsInput | boolean
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    openMsg?: NullableStringFieldUpdateOperationsInput | string | null
    closedMsg?: NullableStringFieldUpdateOperationsInput | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    meetingMsg?: NullableStringFieldUpdateOperationsInput | string | null
    brbMsg?: NullableStringFieldUpdateOperationsInput | string | null
    lunchMsg?: NullableStringFieldUpdateOperationsInput | string | null
    unavailableMsg?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activations?: KioskActivationUncheckedUpdateManyWithoutKioskNestedInput
    syncFailures?: HelixSyncFailureUncheckedUpdateManyWithoutKioskNestedInput
    orgAssignment?: KioskOrganizationAssignmentUncheckedUpdateOneWithoutKioskNestedInput
    metadataLogs?: KioskMetadataLogUncheckedUpdateManyWithoutKioskNestedInput
  }

  export type InventoryAssetUpsertWithoutKioskRegistrationsInput = {
    update: XOR<InventoryAssetUpdateWithoutKioskRegistrationsInput, InventoryAssetUncheckedUpdateWithoutKioskRegistrationsInput>
    create: XOR<InventoryAssetCreateWithoutKioskRegistrationsInput, InventoryAssetUncheckedCreateWithoutKioskRegistrationsInput>
    where?: InventoryAssetWhereInput
  }

  export type InventoryAssetUpdateToOneWithWhereWithoutKioskRegistrationsInput = {
    where?: InventoryAssetWhereInput
    data: XOR<InventoryAssetUpdateWithoutKioskRegistrationsInput, InventoryAssetUncheckedUpdateWithoutKioskRegistrationsInput>
  }

  export type InventoryAssetUpdateWithoutKioskRegistrationsInput = {
    assetTag?: StringFieldUpdateOperationsInput | string
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToOrgId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedToCustomerId?: NullableIntFieldUpdateOperationsInput | number | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    kioskId?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serialNumberEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyAlertDays?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyAlertEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastWarrantyAlertSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importSource?: NullableStringFieldUpdateOperationsInput | string | null
    importValidated?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableStringFieldUpdateOperationsInput | string | null
    statusLogs?: AssetStatusLogUpdateManyWithoutAssetNestedInput
    assignments?: AssetAssignmentUpdateManyWithoutAssetNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutAssetNestedInput
    ticketHistory?: AssetTicketHistoryUpdateManyWithoutAssetNestedInput
    warrantyAlerts?: AssetWarrantyAlertUpdateManyWithoutAssetNestedInput
    validationLogs?: AssetValidationLogUpdateManyWithoutAssetNestedInput
    syncFailures?: HelixSyncFailureUpdateManyWithoutAssetNestedInput
    importBatch?: AssetImportBatchUpdateOneWithoutAssetsNestedInput
  }

  export type InventoryAssetUncheckedUpdateWithoutKioskRegistrationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetTag?: StringFieldUpdateOperationsInput | string
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToOrgId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedToCustomerId?: NullableIntFieldUpdateOperationsInput | number | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    kioskId?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serialNumberEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyAlertDays?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyAlertEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastWarrantyAlertSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    importSource?: NullableStringFieldUpdateOperationsInput | string | null
    importValidated?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableStringFieldUpdateOperationsInput | string | null
    statusLogs?: AssetStatusLogUncheckedUpdateManyWithoutAssetNestedInput
    assignments?: AssetAssignmentUncheckedUpdateManyWithoutAssetNestedInput
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutAssetNestedInput
    ticketHistory?: AssetTicketHistoryUncheckedUpdateManyWithoutAssetNestedInput
    warrantyAlerts?: AssetWarrantyAlertUncheckedUpdateManyWithoutAssetNestedInput
    validationLogs?: AssetValidationLogUncheckedUpdateManyWithoutAssetNestedInput
    syncFailures?: HelixSyncFailureUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type KioskCreateWithoutSyncFailuresInput = {
    id: string
    lastSeen?: Date | string | null
    version?: string | null
    active?: boolean
    logoUrl?: string | null
    bgUrl?: string | null
    statusEnabled?: boolean
    currentStatus?: string | null
    openMsg?: string | null
    closedMsg?: string | null
    errorMsg?: string | null
    meetingMsg?: string | null
    brbMsg?: string | null
    lunchMsg?: string | null
    unavailableMsg?: string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    activations?: KioskActivationCreateNestedManyWithoutKioskInput
    assetRegistry?: KioskAssetRegistryCreateNestedManyWithoutKioskInput
    orgAssignment?: KioskOrganizationAssignmentCreateNestedOneWithoutKioskInput
    metadataLogs?: KioskMetadataLogCreateNestedManyWithoutKioskInput
  }

  export type KioskUncheckedCreateWithoutSyncFailuresInput = {
    id: string
    lastSeen?: Date | string | null
    version?: string | null
    active?: boolean
    logoUrl?: string | null
    bgUrl?: string | null
    statusEnabled?: boolean
    currentStatus?: string | null
    openMsg?: string | null
    closedMsg?: string | null
    errorMsg?: string | null
    meetingMsg?: string | null
    brbMsg?: string | null
    lunchMsg?: string | null
    unavailableMsg?: string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    activations?: KioskActivationUncheckedCreateNestedManyWithoutKioskInput
    assetRegistry?: KioskAssetRegistryUncheckedCreateNestedManyWithoutKioskInput
    orgAssignment?: KioskOrganizationAssignmentUncheckedCreateNestedOneWithoutKioskInput
    metadataLogs?: KioskMetadataLogUncheckedCreateNestedManyWithoutKioskInput
  }

  export type KioskCreateOrConnectWithoutSyncFailuresInput = {
    where: KioskWhereUniqueInput
    create: XOR<KioskCreateWithoutSyncFailuresInput, KioskUncheckedCreateWithoutSyncFailuresInput>
  }

  export type InventoryAssetCreateWithoutSyncFailuresInput = {
    assetTag: string
    typeId?: number | null
    serialNumber?: string | null
    model?: string | null
    vendorId?: number | null
    purchaseDate?: Date | string | null
    warrantyExpiry?: Date | string | null
    assignedToUserId?: string | null
    assignedToOrgId?: number | null
    assignedToCustomerId?: number | null
    department?: string | null
    status?: string | null
    locationId?: number | null
    kioskId?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serialNumberEnc?: string | null
    warrantyInfoEnc?: string | null
    purchaseInfoEnc?: string | null
    maintenanceNotesEnc?: string | null
    warrantyAlertDays?: number | null
    warrantyAlertEnabled?: boolean
    lastWarrantyAlertSent?: Date | string | null
    importSource?: string | null
    importValidated?: boolean
    validationErrors?: string | null
    statusLogs?: AssetStatusLogCreateNestedManyWithoutAssetInput
    assignments?: AssetAssignmentCreateNestedManyWithoutAssetInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutAssetInput
    ticketHistory?: AssetTicketHistoryCreateNestedManyWithoutAssetInput
    warrantyAlerts?: AssetWarrantyAlertCreateNestedManyWithoutAssetInput
    kioskRegistrations?: KioskAssetRegistryCreateNestedManyWithoutAssetInput
    validationLogs?: AssetValidationLogCreateNestedManyWithoutAssetInput
    importBatch?: AssetImportBatchCreateNestedOneWithoutAssetsInput
  }

  export type InventoryAssetUncheckedCreateWithoutSyncFailuresInput = {
    id?: number
    assetTag: string
    typeId?: number | null
    serialNumber?: string | null
    model?: string | null
    vendorId?: number | null
    purchaseDate?: Date | string | null
    warrantyExpiry?: Date | string | null
    assignedToUserId?: string | null
    assignedToOrgId?: number | null
    assignedToCustomerId?: number | null
    department?: string | null
    status?: string | null
    locationId?: number | null
    kioskId?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serialNumberEnc?: string | null
    warrantyInfoEnc?: string | null
    purchaseInfoEnc?: string | null
    maintenanceNotesEnc?: string | null
    warrantyAlertDays?: number | null
    warrantyAlertEnabled?: boolean
    lastWarrantyAlertSent?: Date | string | null
    importBatchId?: string | null
    importSource?: string | null
    importValidated?: boolean
    validationErrors?: string | null
    statusLogs?: AssetStatusLogUncheckedCreateNestedManyWithoutAssetInput
    assignments?: AssetAssignmentUncheckedCreateNestedManyWithoutAssetInput
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutAssetInput
    ticketHistory?: AssetTicketHistoryUncheckedCreateNestedManyWithoutAssetInput
    warrantyAlerts?: AssetWarrantyAlertUncheckedCreateNestedManyWithoutAssetInput
    kioskRegistrations?: KioskAssetRegistryUncheckedCreateNestedManyWithoutAssetInput
    validationLogs?: AssetValidationLogUncheckedCreateNestedManyWithoutAssetInput
  }

  export type InventoryAssetCreateOrConnectWithoutSyncFailuresInput = {
    where: InventoryAssetWhereUniqueInput
    create: XOR<InventoryAssetCreateWithoutSyncFailuresInput, InventoryAssetUncheckedCreateWithoutSyncFailuresInput>
  }

  export type KioskUpsertWithoutSyncFailuresInput = {
    update: XOR<KioskUpdateWithoutSyncFailuresInput, KioskUncheckedUpdateWithoutSyncFailuresInput>
    create: XOR<KioskCreateWithoutSyncFailuresInput, KioskUncheckedCreateWithoutSyncFailuresInput>
    where?: KioskWhereInput
  }

  export type KioskUpdateToOneWithWhereWithoutSyncFailuresInput = {
    where?: KioskWhereInput
    data: XOR<KioskUpdateWithoutSyncFailuresInput, KioskUncheckedUpdateWithoutSyncFailuresInput>
  }

  export type KioskUpdateWithoutSyncFailuresInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statusEnabled?: BoolFieldUpdateOperationsInput | boolean
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    openMsg?: NullableStringFieldUpdateOperationsInput | string | null
    closedMsg?: NullableStringFieldUpdateOperationsInput | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    meetingMsg?: NullableStringFieldUpdateOperationsInput | string | null
    brbMsg?: NullableStringFieldUpdateOperationsInput | string | null
    lunchMsg?: NullableStringFieldUpdateOperationsInput | string | null
    unavailableMsg?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activations?: KioskActivationUpdateManyWithoutKioskNestedInput
    assetRegistry?: KioskAssetRegistryUpdateManyWithoutKioskNestedInput
    orgAssignment?: KioskOrganizationAssignmentUpdateOneWithoutKioskNestedInput
    metadataLogs?: KioskMetadataLogUpdateManyWithoutKioskNestedInput
  }

  export type KioskUncheckedUpdateWithoutSyncFailuresInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statusEnabled?: BoolFieldUpdateOperationsInput | boolean
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    openMsg?: NullableStringFieldUpdateOperationsInput | string | null
    closedMsg?: NullableStringFieldUpdateOperationsInput | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    meetingMsg?: NullableStringFieldUpdateOperationsInput | string | null
    brbMsg?: NullableStringFieldUpdateOperationsInput | string | null
    lunchMsg?: NullableStringFieldUpdateOperationsInput | string | null
    unavailableMsg?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activations?: KioskActivationUncheckedUpdateManyWithoutKioskNestedInput
    assetRegistry?: KioskAssetRegistryUncheckedUpdateManyWithoutKioskNestedInput
    orgAssignment?: KioskOrganizationAssignmentUncheckedUpdateOneWithoutKioskNestedInput
    metadataLogs?: KioskMetadataLogUncheckedUpdateManyWithoutKioskNestedInput
  }

  export type InventoryAssetUpsertWithoutSyncFailuresInput = {
    update: XOR<InventoryAssetUpdateWithoutSyncFailuresInput, InventoryAssetUncheckedUpdateWithoutSyncFailuresInput>
    create: XOR<InventoryAssetCreateWithoutSyncFailuresInput, InventoryAssetUncheckedCreateWithoutSyncFailuresInput>
    where?: InventoryAssetWhereInput
  }

  export type InventoryAssetUpdateToOneWithWhereWithoutSyncFailuresInput = {
    where?: InventoryAssetWhereInput
    data: XOR<InventoryAssetUpdateWithoutSyncFailuresInput, InventoryAssetUncheckedUpdateWithoutSyncFailuresInput>
  }

  export type InventoryAssetUpdateWithoutSyncFailuresInput = {
    assetTag?: StringFieldUpdateOperationsInput | string
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToOrgId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedToCustomerId?: NullableIntFieldUpdateOperationsInput | number | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    kioskId?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serialNumberEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyAlertDays?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyAlertEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastWarrantyAlertSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importSource?: NullableStringFieldUpdateOperationsInput | string | null
    importValidated?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableStringFieldUpdateOperationsInput | string | null
    statusLogs?: AssetStatusLogUpdateManyWithoutAssetNestedInput
    assignments?: AssetAssignmentUpdateManyWithoutAssetNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutAssetNestedInput
    ticketHistory?: AssetTicketHistoryUpdateManyWithoutAssetNestedInput
    warrantyAlerts?: AssetWarrantyAlertUpdateManyWithoutAssetNestedInput
    kioskRegistrations?: KioskAssetRegistryUpdateManyWithoutAssetNestedInput
    validationLogs?: AssetValidationLogUpdateManyWithoutAssetNestedInput
    importBatch?: AssetImportBatchUpdateOneWithoutAssetsNestedInput
  }

  export type InventoryAssetUncheckedUpdateWithoutSyncFailuresInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetTag?: StringFieldUpdateOperationsInput | string
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToOrgId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedToCustomerId?: NullableIntFieldUpdateOperationsInput | number | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    kioskId?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serialNumberEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyAlertDays?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyAlertEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastWarrantyAlertSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    importSource?: NullableStringFieldUpdateOperationsInput | string | null
    importValidated?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableStringFieldUpdateOperationsInput | string | null
    statusLogs?: AssetStatusLogUncheckedUpdateManyWithoutAssetNestedInput
    assignments?: AssetAssignmentUncheckedUpdateManyWithoutAssetNestedInput
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutAssetNestedInput
    ticketHistory?: AssetTicketHistoryUncheckedUpdateManyWithoutAssetNestedInput
    warrantyAlerts?: AssetWarrantyAlertUncheckedUpdateManyWithoutAssetNestedInput
    kioskRegistrations?: KioskAssetRegistryUncheckedUpdateManyWithoutAssetNestedInput
    validationLogs?: AssetValidationLogUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type KioskCreateWithoutOrgAssignmentInput = {
    id: string
    lastSeen?: Date | string | null
    version?: string | null
    active?: boolean
    logoUrl?: string | null
    bgUrl?: string | null
    statusEnabled?: boolean
    currentStatus?: string | null
    openMsg?: string | null
    closedMsg?: string | null
    errorMsg?: string | null
    meetingMsg?: string | null
    brbMsg?: string | null
    lunchMsg?: string | null
    unavailableMsg?: string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    activations?: KioskActivationCreateNestedManyWithoutKioskInput
    assetRegistry?: KioskAssetRegistryCreateNestedManyWithoutKioskInput
    syncFailures?: HelixSyncFailureCreateNestedManyWithoutKioskInput
    metadataLogs?: KioskMetadataLogCreateNestedManyWithoutKioskInput
  }

  export type KioskUncheckedCreateWithoutOrgAssignmentInput = {
    id: string
    lastSeen?: Date | string | null
    version?: string | null
    active?: boolean
    logoUrl?: string | null
    bgUrl?: string | null
    statusEnabled?: boolean
    currentStatus?: string | null
    openMsg?: string | null
    closedMsg?: string | null
    errorMsg?: string | null
    meetingMsg?: string | null
    brbMsg?: string | null
    lunchMsg?: string | null
    unavailableMsg?: string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    activations?: KioskActivationUncheckedCreateNestedManyWithoutKioskInput
    assetRegistry?: KioskAssetRegistryUncheckedCreateNestedManyWithoutKioskInput
    syncFailures?: HelixSyncFailureUncheckedCreateNestedManyWithoutKioskInput
    metadataLogs?: KioskMetadataLogUncheckedCreateNestedManyWithoutKioskInput
  }

  export type KioskCreateOrConnectWithoutOrgAssignmentInput = {
    where: KioskWhereUniqueInput
    create: XOR<KioskCreateWithoutOrgAssignmentInput, KioskUncheckedCreateWithoutOrgAssignmentInput>
  }

  export type KioskUpsertWithoutOrgAssignmentInput = {
    update: XOR<KioskUpdateWithoutOrgAssignmentInput, KioskUncheckedUpdateWithoutOrgAssignmentInput>
    create: XOR<KioskCreateWithoutOrgAssignmentInput, KioskUncheckedCreateWithoutOrgAssignmentInput>
    where?: KioskWhereInput
  }

  export type KioskUpdateToOneWithWhereWithoutOrgAssignmentInput = {
    where?: KioskWhereInput
    data: XOR<KioskUpdateWithoutOrgAssignmentInput, KioskUncheckedUpdateWithoutOrgAssignmentInput>
  }

  export type KioskUpdateWithoutOrgAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statusEnabled?: BoolFieldUpdateOperationsInput | boolean
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    openMsg?: NullableStringFieldUpdateOperationsInput | string | null
    closedMsg?: NullableStringFieldUpdateOperationsInput | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    meetingMsg?: NullableStringFieldUpdateOperationsInput | string | null
    brbMsg?: NullableStringFieldUpdateOperationsInput | string | null
    lunchMsg?: NullableStringFieldUpdateOperationsInput | string | null
    unavailableMsg?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activations?: KioskActivationUpdateManyWithoutKioskNestedInput
    assetRegistry?: KioskAssetRegistryUpdateManyWithoutKioskNestedInput
    syncFailures?: HelixSyncFailureUpdateManyWithoutKioskNestedInput
    metadataLogs?: KioskMetadataLogUpdateManyWithoutKioskNestedInput
  }

  export type KioskUncheckedUpdateWithoutOrgAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statusEnabled?: BoolFieldUpdateOperationsInput | boolean
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    openMsg?: NullableStringFieldUpdateOperationsInput | string | null
    closedMsg?: NullableStringFieldUpdateOperationsInput | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    meetingMsg?: NullableStringFieldUpdateOperationsInput | string | null
    brbMsg?: NullableStringFieldUpdateOperationsInput | string | null
    lunchMsg?: NullableStringFieldUpdateOperationsInput | string | null
    unavailableMsg?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activations?: KioskActivationUncheckedUpdateManyWithoutKioskNestedInput
    assetRegistry?: KioskAssetRegistryUncheckedUpdateManyWithoutKioskNestedInput
    syncFailures?: HelixSyncFailureUncheckedUpdateManyWithoutKioskNestedInput
    metadataLogs?: KioskMetadataLogUncheckedUpdateManyWithoutKioskNestedInput
  }

  export type KioskCreateWithoutMetadataLogsInput = {
    id: string
    lastSeen?: Date | string | null
    version?: string | null
    active?: boolean
    logoUrl?: string | null
    bgUrl?: string | null
    statusEnabled?: boolean
    currentStatus?: string | null
    openMsg?: string | null
    closedMsg?: string | null
    errorMsg?: string | null
    meetingMsg?: string | null
    brbMsg?: string | null
    lunchMsg?: string | null
    unavailableMsg?: string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    activations?: KioskActivationCreateNestedManyWithoutKioskInput
    assetRegistry?: KioskAssetRegistryCreateNestedManyWithoutKioskInput
    syncFailures?: HelixSyncFailureCreateNestedManyWithoutKioskInput
    orgAssignment?: KioskOrganizationAssignmentCreateNestedOneWithoutKioskInput
  }

  export type KioskUncheckedCreateWithoutMetadataLogsInput = {
    id: string
    lastSeen?: Date | string | null
    version?: string | null
    active?: boolean
    logoUrl?: string | null
    bgUrl?: string | null
    statusEnabled?: boolean
    currentStatus?: string | null
    openMsg?: string | null
    closedMsg?: string | null
    errorMsg?: string | null
    meetingMsg?: string | null
    brbMsg?: string | null
    lunchMsg?: string | null
    unavailableMsg?: string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    activations?: KioskActivationUncheckedCreateNestedManyWithoutKioskInput
    assetRegistry?: KioskAssetRegistryUncheckedCreateNestedManyWithoutKioskInput
    syncFailures?: HelixSyncFailureUncheckedCreateNestedManyWithoutKioskInput
    orgAssignment?: KioskOrganizationAssignmentUncheckedCreateNestedOneWithoutKioskInput
  }

  export type KioskCreateOrConnectWithoutMetadataLogsInput = {
    where: KioskWhereUniqueInput
    create: XOR<KioskCreateWithoutMetadataLogsInput, KioskUncheckedCreateWithoutMetadataLogsInput>
  }

  export type KioskUpsertWithoutMetadataLogsInput = {
    update: XOR<KioskUpdateWithoutMetadataLogsInput, KioskUncheckedUpdateWithoutMetadataLogsInput>
    create: XOR<KioskCreateWithoutMetadataLogsInput, KioskUncheckedCreateWithoutMetadataLogsInput>
    where?: KioskWhereInput
  }

  export type KioskUpdateToOneWithWhereWithoutMetadataLogsInput = {
    where?: KioskWhereInput
    data: XOR<KioskUpdateWithoutMetadataLogsInput, KioskUncheckedUpdateWithoutMetadataLogsInput>
  }

  export type KioskUpdateWithoutMetadataLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statusEnabled?: BoolFieldUpdateOperationsInput | boolean
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    openMsg?: NullableStringFieldUpdateOperationsInput | string | null
    closedMsg?: NullableStringFieldUpdateOperationsInput | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    meetingMsg?: NullableStringFieldUpdateOperationsInput | string | null
    brbMsg?: NullableStringFieldUpdateOperationsInput | string | null
    lunchMsg?: NullableStringFieldUpdateOperationsInput | string | null
    unavailableMsg?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activations?: KioskActivationUpdateManyWithoutKioskNestedInput
    assetRegistry?: KioskAssetRegistryUpdateManyWithoutKioskNestedInput
    syncFailures?: HelixSyncFailureUpdateManyWithoutKioskNestedInput
    orgAssignment?: KioskOrganizationAssignmentUpdateOneWithoutKioskNestedInput
  }

  export type KioskUncheckedUpdateWithoutMetadataLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    statusEnabled?: BoolFieldUpdateOperationsInput | boolean
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    openMsg?: NullableStringFieldUpdateOperationsInput | string | null
    closedMsg?: NullableStringFieldUpdateOperationsInput | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    meetingMsg?: NullableStringFieldUpdateOperationsInput | string | null
    brbMsg?: NullableStringFieldUpdateOperationsInput | string | null
    lunchMsg?: NullableStringFieldUpdateOperationsInput | string | null
    unavailableMsg?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activations?: KioskActivationUncheckedUpdateManyWithoutKioskNestedInput
    assetRegistry?: KioskAssetRegistryUncheckedUpdateManyWithoutKioskNestedInput
    syncFailures?: HelixSyncFailureUncheckedUpdateManyWithoutKioskNestedInput
    orgAssignment?: KioskOrganizationAssignmentUncheckedUpdateOneWithoutKioskNestedInput
  }

  export type UserCreateWithoutXpEventsInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutXpEventsInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingUncheckedCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventUncheckedCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyUncheckedCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyUncheckedCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryUncheckedCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutXpEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutXpEventsInput, UserUncheckedCreateWithoutXpEventsInput>
  }

  export type UserUpsertWithoutXpEventsInput = {
    update: XOR<UserUpdateWithoutXpEventsInput, UserUncheckedUpdateWithoutXpEventsInput>
    create: XOR<UserCreateWithoutXpEventsInput, UserUncheckedCreateWithoutXpEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutXpEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutXpEventsInput, UserUncheckedUpdateWithoutXpEventsInput>
  }

  export type UserUpdateWithoutXpEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutXpEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUncheckedUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUncheckedUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUncheckedUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUncheckedUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUncheckedUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutLeaderboardInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentCreateNestedManyWithoutUserInput
    xpEvents?: XpEventCreateNestedManyWithoutUserInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLeaderboardInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingUncheckedCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentUncheckedCreateNestedManyWithoutUserInput
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventUncheckedCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyUncheckedCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyUncheckedCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryUncheckedCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLeaderboardInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeaderboardInput, UserUncheckedCreateWithoutLeaderboardInput>
  }

  export type UserUpsertWithoutLeaderboardInput = {
    update: XOR<UserUpdateWithoutLeaderboardInput, UserUncheckedUpdateWithoutLeaderboardInput>
    create: XOR<UserCreateWithoutLeaderboardInput, UserUncheckedCreateWithoutLeaderboardInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeaderboardInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeaderboardInput, UserUncheckedUpdateWithoutLeaderboardInput>
  }

  export type UserUpdateWithoutLeaderboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLeaderboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUncheckedUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUncheckedUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUncheckedUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUncheckedUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUncheckedUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUncheckedUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutScimMappingsInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentCreateNestedManyWithoutUserInput
    xpEvents?: XpEventCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutScimMappingsInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentUncheckedCreateNestedManyWithoutUserInput
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventUncheckedCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyUncheckedCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyUncheckedCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryUncheckedCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutScimMappingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutScimMappingsInput, UserUncheckedCreateWithoutScimMappingsInput>
  }

  export type UserUpsertWithoutScimMappingsInput = {
    update: XOR<UserUpdateWithoutScimMappingsInput, UserUncheckedUpdateWithoutScimMappingsInput>
    create: XOR<UserCreateWithoutScimMappingsInput, UserUncheckedCreateWithoutScimMappingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutScimMappingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutScimMappingsInput, UserUncheckedUpdateWithoutScimMappingsInput>
  }

  export type UserUpdateWithoutScimMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutScimMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUncheckedUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUncheckedUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUncheckedUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUncheckedUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUncheckedUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMailroomPackagesInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentCreateNestedManyWithoutUserInput
    xpEvents?: XpEventCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedOneWithoutUserInput
    deliveryEvents?: DeliveryEventCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMailroomPackagesInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingUncheckedCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentUncheckedCreateNestedManyWithoutUserInput
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedOneWithoutUserInput
    deliveryEvents?: DeliveryEventUncheckedCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyUncheckedCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyUncheckedCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryUncheckedCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMailroomPackagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMailroomPackagesInput, UserUncheckedCreateWithoutMailroomPackagesInput>
  }

  export type SupportTicketCreateWithoutMailroomPackagesInput = {
    title: string
    description: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vipPriorityScore?: number | null
    vipTriggerSource?: string | null
    users_support_tickets_assigneeIdTousers?: UserCreateNestedOneWithoutSupport_tickets_support_tickets_assigneeIdTousersInput
    users_support_tickets_userIdTousers?: UserCreateNestedOneWithoutSupport_tickets_support_tickets_userIdTousersInput
    assetHistory?: AssetTicketHistoryCreateNestedManyWithoutTicketInput
    ritms?: RITMCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUncheckedCreateWithoutMailroomPackagesInput = {
    id?: number
    title: string
    description: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    assigneeId?: string | null
    vipPriorityScore?: number | null
    vipTriggerSource?: string | null
    assetHistory?: AssetTicketHistoryUncheckedCreateNestedManyWithoutTicketInput
    ritms?: RITMUncheckedCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketCreateOrConnectWithoutMailroomPackagesInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutMailroomPackagesInput, SupportTicketUncheckedCreateWithoutMailroomPackagesInput>
  }

  export type InventoryAssetCreateWithoutMailroomPackagesInput = {
    assetTag: string
    typeId?: number | null
    serialNumber?: string | null
    model?: string | null
    vendorId?: number | null
    purchaseDate?: Date | string | null
    warrantyExpiry?: Date | string | null
    assignedToUserId?: string | null
    assignedToOrgId?: number | null
    assignedToCustomerId?: number | null
    department?: string | null
    status?: string | null
    locationId?: number | null
    kioskId?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serialNumberEnc?: string | null
    warrantyInfoEnc?: string | null
    purchaseInfoEnc?: string | null
    maintenanceNotesEnc?: string | null
    warrantyAlertDays?: number | null
    warrantyAlertEnabled?: boolean
    lastWarrantyAlertSent?: Date | string | null
    importSource?: string | null
    importValidated?: boolean
    validationErrors?: string | null
    statusLogs?: AssetStatusLogCreateNestedManyWithoutAssetInput
    assignments?: AssetAssignmentCreateNestedManyWithoutAssetInput
    ticketHistory?: AssetTicketHistoryCreateNestedManyWithoutAssetInput
    warrantyAlerts?: AssetWarrantyAlertCreateNestedManyWithoutAssetInput
    kioskRegistrations?: KioskAssetRegistryCreateNestedManyWithoutAssetInput
    validationLogs?: AssetValidationLogCreateNestedManyWithoutAssetInput
    syncFailures?: HelixSyncFailureCreateNestedManyWithoutAssetInput
    importBatch?: AssetImportBatchCreateNestedOneWithoutAssetsInput
  }

  export type InventoryAssetUncheckedCreateWithoutMailroomPackagesInput = {
    id?: number
    assetTag: string
    typeId?: number | null
    serialNumber?: string | null
    model?: string | null
    vendorId?: number | null
    purchaseDate?: Date | string | null
    warrantyExpiry?: Date | string | null
    assignedToUserId?: string | null
    assignedToOrgId?: number | null
    assignedToCustomerId?: number | null
    department?: string | null
    status?: string | null
    locationId?: number | null
    kioskId?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serialNumberEnc?: string | null
    warrantyInfoEnc?: string | null
    purchaseInfoEnc?: string | null
    maintenanceNotesEnc?: string | null
    warrantyAlertDays?: number | null
    warrantyAlertEnabled?: boolean
    lastWarrantyAlertSent?: Date | string | null
    importBatchId?: string | null
    importSource?: string | null
    importValidated?: boolean
    validationErrors?: string | null
    statusLogs?: AssetStatusLogUncheckedCreateNestedManyWithoutAssetInput
    assignments?: AssetAssignmentUncheckedCreateNestedManyWithoutAssetInput
    ticketHistory?: AssetTicketHistoryUncheckedCreateNestedManyWithoutAssetInput
    warrantyAlerts?: AssetWarrantyAlertUncheckedCreateNestedManyWithoutAssetInput
    kioskRegistrations?: KioskAssetRegistryUncheckedCreateNestedManyWithoutAssetInput
    validationLogs?: AssetValidationLogUncheckedCreateNestedManyWithoutAssetInput
    syncFailures?: HelixSyncFailureUncheckedCreateNestedManyWithoutAssetInput
  }

  export type InventoryAssetCreateOrConnectWithoutMailroomPackagesInput = {
    where: InventoryAssetWhereUniqueInput
    create: XOR<InventoryAssetCreateWithoutMailroomPackagesInput, InventoryAssetUncheckedCreateWithoutMailroomPackagesInput>
  }

  export type DeliveryEventCreateWithoutPackageInput = {
    eventType: string
    location?: string | null
    timestamp?: Date | string
    photoUrl?: string | null
    signatureBlob?: Uint8Array | null
    user: UserCreateNestedOneWithoutDeliveryEventsInput
  }

  export type DeliveryEventUncheckedCreateWithoutPackageInput = {
    id?: number
    eventType: string
    performedBy: string
    location?: string | null
    timestamp?: Date | string
    photoUrl?: string | null
    signatureBlob?: Uint8Array | null
  }

  export type DeliveryEventCreateOrConnectWithoutPackageInput = {
    where: DeliveryEventWhereUniqueInput
    create: XOR<DeliveryEventCreateWithoutPackageInput, DeliveryEventUncheckedCreateWithoutPackageInput>
  }

  export type DeliveryEventCreateManyPackageInputEnvelope = {
    data: DeliveryEventCreateManyPackageInput | DeliveryEventCreateManyPackageInput[]
    skipDuplicates?: boolean
  }

  export type ProxyAuthorizationCreateWithoutPackageInput = {
    expiration?: Date | string | null
    status: string
    recipient: UserCreateNestedOneWithoutProxyAuthorizationsAsRecipientInput
    proxy: UserCreateNestedOneWithoutProxyAuthorizationsAsProxyInput
  }

  export type ProxyAuthorizationUncheckedCreateWithoutPackageInput = {
    id?: number
    recipientId: string
    proxyId: string
    expiration?: Date | string | null
    status: string
  }

  export type ProxyAuthorizationCreateOrConnectWithoutPackageInput = {
    where: ProxyAuthorizationWhereUniqueInput
    create: XOR<ProxyAuthorizationCreateWithoutPackageInput, ProxyAuthorizationUncheckedCreateWithoutPackageInput>
  }

  export type ProxyAuthorizationCreateManyPackageInputEnvelope = {
    data: ProxyAuthorizationCreateManyPackageInput | ProxyAuthorizationCreateManyPackageInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutMailroomPackagesInput = {
    update: XOR<UserUpdateWithoutMailroomPackagesInput, UserUncheckedUpdateWithoutMailroomPackagesInput>
    create: XOR<UserCreateWithoutMailroomPackagesInput, UserUncheckedCreateWithoutMailroomPackagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMailroomPackagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMailroomPackagesInput, UserUncheckedUpdateWithoutMailroomPackagesInput>
  }

  export type UserUpdateWithoutMailroomPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateOneWithoutUserNestedInput
    deliveryEvents?: DeliveryEventUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMailroomPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUncheckedUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUncheckedUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateOneWithoutUserNestedInput
    deliveryEvents?: DeliveryEventUncheckedUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUncheckedUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUncheckedUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUncheckedUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SupportTicketUpsertWithoutMailroomPackagesInput = {
    update: XOR<SupportTicketUpdateWithoutMailroomPackagesInput, SupportTicketUncheckedUpdateWithoutMailroomPackagesInput>
    create: XOR<SupportTicketCreateWithoutMailroomPackagesInput, SupportTicketUncheckedCreateWithoutMailroomPackagesInput>
    where?: SupportTicketWhereInput
  }

  export type SupportTicketUpdateToOneWithWhereWithoutMailroomPackagesInput = {
    where?: SupportTicketWhereInput
    data: XOR<SupportTicketUpdateWithoutMailroomPackagesInput, SupportTicketUncheckedUpdateWithoutMailroomPackagesInput>
  }

  export type SupportTicketUpdateWithoutMailroomPackagesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vipPriorityScore?: NullableIntFieldUpdateOperationsInput | number | null
    vipTriggerSource?: NullableStringFieldUpdateOperationsInput | string | null
    users_support_tickets_assigneeIdTousers?: UserUpdateOneWithoutSupport_tickets_support_tickets_assigneeIdTousersNestedInput
    users_support_tickets_userIdTousers?: UserUpdateOneWithoutSupport_tickets_support_tickets_userIdTousersNestedInput
    assetHistory?: AssetTicketHistoryUpdateManyWithoutTicketNestedInput
    ritms?: RITMUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutMailroomPackagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    vipPriorityScore?: NullableIntFieldUpdateOperationsInput | number | null
    vipTriggerSource?: NullableStringFieldUpdateOperationsInput | string | null
    assetHistory?: AssetTicketHistoryUncheckedUpdateManyWithoutTicketNestedInput
    ritms?: RITMUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type InventoryAssetUpsertWithoutMailroomPackagesInput = {
    update: XOR<InventoryAssetUpdateWithoutMailroomPackagesInput, InventoryAssetUncheckedUpdateWithoutMailroomPackagesInput>
    create: XOR<InventoryAssetCreateWithoutMailroomPackagesInput, InventoryAssetUncheckedCreateWithoutMailroomPackagesInput>
    where?: InventoryAssetWhereInput
  }

  export type InventoryAssetUpdateToOneWithWhereWithoutMailroomPackagesInput = {
    where?: InventoryAssetWhereInput
    data: XOR<InventoryAssetUpdateWithoutMailroomPackagesInput, InventoryAssetUncheckedUpdateWithoutMailroomPackagesInput>
  }

  export type InventoryAssetUpdateWithoutMailroomPackagesInput = {
    assetTag?: StringFieldUpdateOperationsInput | string
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToOrgId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedToCustomerId?: NullableIntFieldUpdateOperationsInput | number | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    kioskId?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serialNumberEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyAlertDays?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyAlertEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastWarrantyAlertSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importSource?: NullableStringFieldUpdateOperationsInput | string | null
    importValidated?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableStringFieldUpdateOperationsInput | string | null
    statusLogs?: AssetStatusLogUpdateManyWithoutAssetNestedInput
    assignments?: AssetAssignmentUpdateManyWithoutAssetNestedInput
    ticketHistory?: AssetTicketHistoryUpdateManyWithoutAssetNestedInput
    warrantyAlerts?: AssetWarrantyAlertUpdateManyWithoutAssetNestedInput
    kioskRegistrations?: KioskAssetRegistryUpdateManyWithoutAssetNestedInput
    validationLogs?: AssetValidationLogUpdateManyWithoutAssetNestedInput
    syncFailures?: HelixSyncFailureUpdateManyWithoutAssetNestedInput
    importBatch?: AssetImportBatchUpdateOneWithoutAssetsNestedInput
  }

  export type InventoryAssetUncheckedUpdateWithoutMailroomPackagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetTag?: StringFieldUpdateOperationsInput | string
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToOrgId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedToCustomerId?: NullableIntFieldUpdateOperationsInput | number | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    kioskId?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serialNumberEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyAlertDays?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyAlertEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastWarrantyAlertSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    importSource?: NullableStringFieldUpdateOperationsInput | string | null
    importValidated?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableStringFieldUpdateOperationsInput | string | null
    statusLogs?: AssetStatusLogUncheckedUpdateManyWithoutAssetNestedInput
    assignments?: AssetAssignmentUncheckedUpdateManyWithoutAssetNestedInput
    ticketHistory?: AssetTicketHistoryUncheckedUpdateManyWithoutAssetNestedInput
    warrantyAlerts?: AssetWarrantyAlertUncheckedUpdateManyWithoutAssetNestedInput
    kioskRegistrations?: KioskAssetRegistryUncheckedUpdateManyWithoutAssetNestedInput
    validationLogs?: AssetValidationLogUncheckedUpdateManyWithoutAssetNestedInput
    syncFailures?: HelixSyncFailureUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type DeliveryEventUpsertWithWhereUniqueWithoutPackageInput = {
    where: DeliveryEventWhereUniqueInput
    update: XOR<DeliveryEventUpdateWithoutPackageInput, DeliveryEventUncheckedUpdateWithoutPackageInput>
    create: XOR<DeliveryEventCreateWithoutPackageInput, DeliveryEventUncheckedCreateWithoutPackageInput>
  }

  export type DeliveryEventUpdateWithWhereUniqueWithoutPackageInput = {
    where: DeliveryEventWhereUniqueInput
    data: XOR<DeliveryEventUpdateWithoutPackageInput, DeliveryEventUncheckedUpdateWithoutPackageInput>
  }

  export type DeliveryEventUpdateManyWithWhereWithoutPackageInput = {
    where: DeliveryEventScalarWhereInput
    data: XOR<DeliveryEventUpdateManyMutationInput, DeliveryEventUncheckedUpdateManyWithoutPackageInput>
  }

  export type ProxyAuthorizationUpsertWithWhereUniqueWithoutPackageInput = {
    where: ProxyAuthorizationWhereUniqueInput
    update: XOR<ProxyAuthorizationUpdateWithoutPackageInput, ProxyAuthorizationUncheckedUpdateWithoutPackageInput>
    create: XOR<ProxyAuthorizationCreateWithoutPackageInput, ProxyAuthorizationUncheckedCreateWithoutPackageInput>
  }

  export type ProxyAuthorizationUpdateWithWhereUniqueWithoutPackageInput = {
    where: ProxyAuthorizationWhereUniqueInput
    data: XOR<ProxyAuthorizationUpdateWithoutPackageInput, ProxyAuthorizationUncheckedUpdateWithoutPackageInput>
  }

  export type ProxyAuthorizationUpdateManyWithWhereWithoutPackageInput = {
    where: ProxyAuthorizationScalarWhereInput
    data: XOR<ProxyAuthorizationUpdateManyMutationInput, ProxyAuthorizationUncheckedUpdateManyWithoutPackageInput>
  }

  export type MailroomPackageCreateWithoutDeliveryEventsInput = {
    trackingNumber: string
    carrier: string
    sender?: string | null
    department?: string | null
    packageType?: string | null
    status: string
    assignedLocation?: string | null
    flags?: MailroomPackageCreateflagsInput | string[]
    intakePhotoUrl?: string | null
    deliveryPhotoUrl?: string | null
    signatureUrl?: string | null
    intakeLocation?: string | null
    deliveryLocation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recipient: UserCreateNestedOneWithoutMailroomPackagesInput
    ticket?: SupportTicketCreateNestedOneWithoutMailroomPackagesInput
    asset?: InventoryAssetCreateNestedOneWithoutMailroomPackagesInput
    proxyAuthorizations?: ProxyAuthorizationCreateNestedManyWithoutPackageInput
  }

  export type MailroomPackageUncheckedCreateWithoutDeliveryEventsInput = {
    id?: number
    trackingNumber: string
    carrier: string
    sender?: string | null
    recipientId: string
    department?: string | null
    packageType?: string | null
    status: string
    assignedLocation?: string | null
    linkedTicketId?: number | null
    linkedAssetId?: number | null
    flags?: MailroomPackageCreateflagsInput | string[]
    intakePhotoUrl?: string | null
    deliveryPhotoUrl?: string | null
    signatureUrl?: string | null
    intakeLocation?: string | null
    deliveryLocation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    proxyAuthorizations?: ProxyAuthorizationUncheckedCreateNestedManyWithoutPackageInput
  }

  export type MailroomPackageCreateOrConnectWithoutDeliveryEventsInput = {
    where: MailroomPackageWhereUniqueInput
    create: XOR<MailroomPackageCreateWithoutDeliveryEventsInput, MailroomPackageUncheckedCreateWithoutDeliveryEventsInput>
  }

  export type UserCreateWithoutDeliveryEventsInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentCreateNestedManyWithoutUserInput
    xpEvents?: XpEventCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDeliveryEventsInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingUncheckedCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentUncheckedCreateNestedManyWithoutUserInput
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyUncheckedCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyUncheckedCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryUncheckedCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDeliveryEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeliveryEventsInput, UserUncheckedCreateWithoutDeliveryEventsInput>
  }

  export type MailroomPackageUpsertWithoutDeliveryEventsInput = {
    update: XOR<MailroomPackageUpdateWithoutDeliveryEventsInput, MailroomPackageUncheckedUpdateWithoutDeliveryEventsInput>
    create: XOR<MailroomPackageCreateWithoutDeliveryEventsInput, MailroomPackageUncheckedCreateWithoutDeliveryEventsInput>
    where?: MailroomPackageWhereInput
  }

  export type MailroomPackageUpdateToOneWithWhereWithoutDeliveryEventsInput = {
    where?: MailroomPackageWhereInput
    data: XOR<MailroomPackageUpdateWithoutDeliveryEventsInput, MailroomPackageUncheckedUpdateWithoutDeliveryEventsInput>
  }

  export type MailroomPackageUpdateWithoutDeliveryEventsInput = {
    trackingNumber?: StringFieldUpdateOperationsInput | string
    carrier?: StringFieldUpdateOperationsInput | string
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    packageType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    assignedLocation?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: MailroomPackageUpdateflagsInput | string[]
    intakePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    intakeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryLocation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: UserUpdateOneRequiredWithoutMailroomPackagesNestedInput
    ticket?: SupportTicketUpdateOneWithoutMailroomPackagesNestedInput
    asset?: InventoryAssetUpdateOneWithoutMailroomPackagesNestedInput
    proxyAuthorizations?: ProxyAuthorizationUpdateManyWithoutPackageNestedInput
  }

  export type MailroomPackageUncheckedUpdateWithoutDeliveryEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackingNumber?: StringFieldUpdateOperationsInput | string
    carrier?: StringFieldUpdateOperationsInput | string
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    recipientId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    packageType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    assignedLocation?: NullableStringFieldUpdateOperationsInput | string | null
    linkedTicketId?: NullableIntFieldUpdateOperationsInput | number | null
    linkedAssetId?: NullableIntFieldUpdateOperationsInput | number | null
    flags?: MailroomPackageUpdateflagsInput | string[]
    intakePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    intakeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryLocation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxyAuthorizations?: ProxyAuthorizationUncheckedUpdateManyWithoutPackageNestedInput
  }

  export type UserUpsertWithoutDeliveryEventsInput = {
    update: XOR<UserUpdateWithoutDeliveryEventsInput, UserUncheckedUpdateWithoutDeliveryEventsInput>
    create: XOR<UserCreateWithoutDeliveryEventsInput, UserUncheckedCreateWithoutDeliveryEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeliveryEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeliveryEventsInput, UserUncheckedUpdateWithoutDeliveryEventsInput>
  }

  export type UserUpdateWithoutDeliveryEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDeliveryEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUncheckedUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUncheckedUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUncheckedUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUncheckedUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUncheckedUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutProxyAuthorizationsAsRecipientInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentCreateNestedManyWithoutUserInput
    xpEvents?: XpEventCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProxyAuthorizationsAsRecipientInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingUncheckedCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentUncheckedCreateNestedManyWithoutUserInput
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventUncheckedCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyUncheckedCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyUncheckedCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryUncheckedCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProxyAuthorizationsAsRecipientInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProxyAuthorizationsAsRecipientInput, UserUncheckedCreateWithoutProxyAuthorizationsAsRecipientInput>
  }

  export type UserCreateWithoutProxyAuthorizationsAsProxyInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentCreateNestedManyWithoutUserInput
    xpEvents?: XpEventCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationCreateNestedManyWithoutRecipientInput
    vipProxiesAsVip?: VipProxyCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProxyAuthorizationsAsProxyInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingUncheckedCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentUncheckedCreateNestedManyWithoutUserInput
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventUncheckedCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedCreateNestedManyWithoutRecipientInput
    vipProxiesAsVip?: VipProxyUncheckedCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyUncheckedCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryUncheckedCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProxyAuthorizationsAsProxyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProxyAuthorizationsAsProxyInput, UserUncheckedCreateWithoutProxyAuthorizationsAsProxyInput>
  }

  export type MailroomPackageCreateWithoutProxyAuthorizationsInput = {
    trackingNumber: string
    carrier: string
    sender?: string | null
    department?: string | null
    packageType?: string | null
    status: string
    assignedLocation?: string | null
    flags?: MailroomPackageCreateflagsInput | string[]
    intakePhotoUrl?: string | null
    deliveryPhotoUrl?: string | null
    signatureUrl?: string | null
    intakeLocation?: string | null
    deliveryLocation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recipient: UserCreateNestedOneWithoutMailroomPackagesInput
    ticket?: SupportTicketCreateNestedOneWithoutMailroomPackagesInput
    asset?: InventoryAssetCreateNestedOneWithoutMailroomPackagesInput
    deliveryEvents?: DeliveryEventCreateNestedManyWithoutPackageInput
  }

  export type MailroomPackageUncheckedCreateWithoutProxyAuthorizationsInput = {
    id?: number
    trackingNumber: string
    carrier: string
    sender?: string | null
    recipientId: string
    department?: string | null
    packageType?: string | null
    status: string
    assignedLocation?: string | null
    linkedTicketId?: number | null
    linkedAssetId?: number | null
    flags?: MailroomPackageCreateflagsInput | string[]
    intakePhotoUrl?: string | null
    deliveryPhotoUrl?: string | null
    signatureUrl?: string | null
    intakeLocation?: string | null
    deliveryLocation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveryEvents?: DeliveryEventUncheckedCreateNestedManyWithoutPackageInput
  }

  export type MailroomPackageCreateOrConnectWithoutProxyAuthorizationsInput = {
    where: MailroomPackageWhereUniqueInput
    create: XOR<MailroomPackageCreateWithoutProxyAuthorizationsInput, MailroomPackageUncheckedCreateWithoutProxyAuthorizationsInput>
  }

  export type UserUpsertWithoutProxyAuthorizationsAsRecipientInput = {
    update: XOR<UserUpdateWithoutProxyAuthorizationsAsRecipientInput, UserUncheckedUpdateWithoutProxyAuthorizationsAsRecipientInput>
    create: XOR<UserCreateWithoutProxyAuthorizationsAsRecipientInput, UserUncheckedCreateWithoutProxyAuthorizationsAsRecipientInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProxyAuthorizationsAsRecipientInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProxyAuthorizationsAsRecipientInput, UserUncheckedUpdateWithoutProxyAuthorizationsAsRecipientInput>
  }

  export type UserUpdateWithoutProxyAuthorizationsAsRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProxyAuthorizationsAsRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUncheckedUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUncheckedUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUncheckedUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUncheckedUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUncheckedUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUncheckedUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutProxyAuthorizationsAsProxyInput = {
    update: XOR<UserUpdateWithoutProxyAuthorizationsAsProxyInput, UserUncheckedUpdateWithoutProxyAuthorizationsAsProxyInput>
    create: XOR<UserCreateWithoutProxyAuthorizationsAsProxyInput, UserUncheckedCreateWithoutProxyAuthorizationsAsProxyInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProxyAuthorizationsAsProxyInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProxyAuthorizationsAsProxyInput, UserUncheckedUpdateWithoutProxyAuthorizationsAsProxyInput>
  }

  export type UserUpdateWithoutProxyAuthorizationsAsProxyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUpdateManyWithoutRecipientNestedInput
    vipProxiesAsVip?: VipProxyUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProxyAuthorizationsAsProxyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUncheckedUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUncheckedUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUncheckedUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedUpdateManyWithoutRecipientNestedInput
    vipProxiesAsVip?: VipProxyUncheckedUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUncheckedUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUncheckedUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MailroomPackageUpsertWithoutProxyAuthorizationsInput = {
    update: XOR<MailroomPackageUpdateWithoutProxyAuthorizationsInput, MailroomPackageUncheckedUpdateWithoutProxyAuthorizationsInput>
    create: XOR<MailroomPackageCreateWithoutProxyAuthorizationsInput, MailroomPackageUncheckedCreateWithoutProxyAuthorizationsInput>
    where?: MailroomPackageWhereInput
  }

  export type MailroomPackageUpdateToOneWithWhereWithoutProxyAuthorizationsInput = {
    where?: MailroomPackageWhereInput
    data: XOR<MailroomPackageUpdateWithoutProxyAuthorizationsInput, MailroomPackageUncheckedUpdateWithoutProxyAuthorizationsInput>
  }

  export type MailroomPackageUpdateWithoutProxyAuthorizationsInput = {
    trackingNumber?: StringFieldUpdateOperationsInput | string
    carrier?: StringFieldUpdateOperationsInput | string
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    packageType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    assignedLocation?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: MailroomPackageUpdateflagsInput | string[]
    intakePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    intakeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryLocation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: UserUpdateOneRequiredWithoutMailroomPackagesNestedInput
    ticket?: SupportTicketUpdateOneWithoutMailroomPackagesNestedInput
    asset?: InventoryAssetUpdateOneWithoutMailroomPackagesNestedInput
    deliveryEvents?: DeliveryEventUpdateManyWithoutPackageNestedInput
  }

  export type MailroomPackageUncheckedUpdateWithoutProxyAuthorizationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackingNumber?: StringFieldUpdateOperationsInput | string
    carrier?: StringFieldUpdateOperationsInput | string
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    recipientId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    packageType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    assignedLocation?: NullableStringFieldUpdateOperationsInput | string | null
    linkedTicketId?: NullableIntFieldUpdateOperationsInput | number | null
    linkedAssetId?: NullableIntFieldUpdateOperationsInput | number | null
    flags?: MailroomPackageUpdateflagsInput | string[]
    intakePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    intakeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryLocation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryEvents?: DeliveryEventUncheckedUpdateManyWithoutPackageNestedInput
  }

  export type RITMCreateWithoutCatalogItemInput = {
    status?: string
    ticket: SupportTicketCreateNestedOneWithoutRitmsInput
  }

  export type RITMUncheckedCreateWithoutCatalogItemInput = {
    id?: number
    reqId: number
    status?: string
  }

  export type RITMCreateOrConnectWithoutCatalogItemInput = {
    where: RITMWhereUniqueInput
    create: XOR<RITMCreateWithoutCatalogItemInput, RITMUncheckedCreateWithoutCatalogItemInput>
  }

  export type RITMCreateManyCatalogItemInputEnvelope = {
    data: RITMCreateManyCatalogItemInput | RITMCreateManyCatalogItemInput[]
    skipDuplicates?: boolean
  }

  export type RITMUpsertWithWhereUniqueWithoutCatalogItemInput = {
    where: RITMWhereUniqueInput
    update: XOR<RITMUpdateWithoutCatalogItemInput, RITMUncheckedUpdateWithoutCatalogItemInput>
    create: XOR<RITMCreateWithoutCatalogItemInput, RITMUncheckedCreateWithoutCatalogItemInput>
  }

  export type RITMUpdateWithWhereUniqueWithoutCatalogItemInput = {
    where: RITMWhereUniqueInput
    data: XOR<RITMUpdateWithoutCatalogItemInput, RITMUncheckedUpdateWithoutCatalogItemInput>
  }

  export type RITMUpdateManyWithWhereWithoutCatalogItemInput = {
    where: RITMScalarWhereInput
    data: XOR<RITMUpdateManyMutationInput, RITMUncheckedUpdateManyWithoutCatalogItemInput>
  }

  export type SupportTicketCreateWithoutRitmsInput = {
    title: string
    description: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vipPriorityScore?: number | null
    vipTriggerSource?: string | null
    users_support_tickets_assigneeIdTousers?: UserCreateNestedOneWithoutSupport_tickets_support_tickets_assigneeIdTousersInput
    users_support_tickets_userIdTousers?: UserCreateNestedOneWithoutSupport_tickets_support_tickets_userIdTousersInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutTicketInput
    assetHistory?: AssetTicketHistoryCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUncheckedCreateWithoutRitmsInput = {
    id?: number
    title: string
    description: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    assigneeId?: string | null
    vipPriorityScore?: number | null
    vipTriggerSource?: string | null
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutTicketInput
    assetHistory?: AssetTicketHistoryUncheckedCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketCreateOrConnectWithoutRitmsInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutRitmsInput, SupportTicketUncheckedCreateWithoutRitmsInput>
  }

  export type RequestCatalogItemCreateWithoutRitmsInput = {
    name: string
    formSchema?: NullableJsonNullValueInput | InputJsonValue
    workflowId?: number | null
  }

  export type RequestCatalogItemUncheckedCreateWithoutRitmsInput = {
    id?: number
    name: string
    formSchema?: NullableJsonNullValueInput | InputJsonValue
    workflowId?: number | null
  }

  export type RequestCatalogItemCreateOrConnectWithoutRitmsInput = {
    where: RequestCatalogItemWhereUniqueInput
    create: XOR<RequestCatalogItemCreateWithoutRitmsInput, RequestCatalogItemUncheckedCreateWithoutRitmsInput>
  }

  export type SupportTicketUpsertWithoutRitmsInput = {
    update: XOR<SupportTicketUpdateWithoutRitmsInput, SupportTicketUncheckedUpdateWithoutRitmsInput>
    create: XOR<SupportTicketCreateWithoutRitmsInput, SupportTicketUncheckedCreateWithoutRitmsInput>
    where?: SupportTicketWhereInput
  }

  export type SupportTicketUpdateToOneWithWhereWithoutRitmsInput = {
    where?: SupportTicketWhereInput
    data: XOR<SupportTicketUpdateWithoutRitmsInput, SupportTicketUncheckedUpdateWithoutRitmsInput>
  }

  export type SupportTicketUpdateWithoutRitmsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vipPriorityScore?: NullableIntFieldUpdateOperationsInput | number | null
    vipTriggerSource?: NullableStringFieldUpdateOperationsInput | string | null
    users_support_tickets_assigneeIdTousers?: UserUpdateOneWithoutSupport_tickets_support_tickets_assigneeIdTousersNestedInput
    users_support_tickets_userIdTousers?: UserUpdateOneWithoutSupport_tickets_support_tickets_userIdTousersNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutTicketNestedInput
    assetHistory?: AssetTicketHistoryUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutRitmsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    vipPriorityScore?: NullableIntFieldUpdateOperationsInput | number | null
    vipTriggerSource?: NullableStringFieldUpdateOperationsInput | string | null
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutTicketNestedInput
    assetHistory?: AssetTicketHistoryUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type RequestCatalogItemUpsertWithoutRitmsInput = {
    update: XOR<RequestCatalogItemUpdateWithoutRitmsInput, RequestCatalogItemUncheckedUpdateWithoutRitmsInput>
    create: XOR<RequestCatalogItemCreateWithoutRitmsInput, RequestCatalogItemUncheckedCreateWithoutRitmsInput>
    where?: RequestCatalogItemWhereInput
  }

  export type RequestCatalogItemUpdateToOneWithWhereWithoutRitmsInput = {
    where?: RequestCatalogItemWhereInput
    data: XOR<RequestCatalogItemUpdateWithoutRitmsInput, RequestCatalogItemUncheckedUpdateWithoutRitmsInput>
  }

  export type RequestCatalogItemUpdateWithoutRitmsInput = {
    name?: StringFieldUpdateOperationsInput | string
    formSchema?: NullableJsonNullValueInput | InputJsonValue
    workflowId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RequestCatalogItemUncheckedUpdateWithoutRitmsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    formSchema?: NullableJsonNullValueInput | InputJsonValue
    workflowId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCreateWithoutVipProxiesAsVipInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentCreateNestedManyWithoutUserInput
    xpEvents?: XpEventCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationCreateNestedManyWithoutProxyInput
    vipProxiesAsProxy?: VipProxyCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVipProxiesAsVipInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingUncheckedCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentUncheckedCreateNestedManyWithoutUserInput
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventUncheckedCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedCreateNestedManyWithoutProxyInput
    vipProxiesAsProxy?: VipProxyUncheckedCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryUncheckedCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVipProxiesAsVipInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVipProxiesAsVipInput, UserUncheckedCreateWithoutVipProxiesAsVipInput>
  }

  export type UserCreateWithoutVipProxiesAsProxyInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentCreateNestedManyWithoutUserInput
    xpEvents?: XpEventCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyCreateNestedManyWithoutVipInput
    vipSlaHistory?: VipSlaHistoryCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVipProxiesAsProxyInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingUncheckedCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentUncheckedCreateNestedManyWithoutUserInput
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventUncheckedCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyUncheckedCreateNestedManyWithoutVipInput
    vipSlaHistory?: VipSlaHistoryUncheckedCreateNestedManyWithoutUserInput
    agentAvailability?: AgentAvailabilityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVipProxiesAsProxyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVipProxiesAsProxyInput, UserUncheckedCreateWithoutVipProxiesAsProxyInput>
  }

  export type UserUpsertWithoutVipProxiesAsVipInput = {
    update: XOR<UserUpdateWithoutVipProxiesAsVipInput, UserUncheckedUpdateWithoutVipProxiesAsVipInput>
    create: XOR<UserCreateWithoutVipProxiesAsVipInput, UserUncheckedCreateWithoutVipProxiesAsVipInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVipProxiesAsVipInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVipProxiesAsVipInput, UserUncheckedUpdateWithoutVipProxiesAsVipInput>
  }

  export type UserUpdateWithoutVipProxiesAsVipInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUpdateManyWithoutProxyNestedInput
    vipProxiesAsProxy?: VipProxyUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVipProxiesAsVipInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUncheckedUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUncheckedUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUncheckedUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedUpdateManyWithoutProxyNestedInput
    vipProxiesAsProxy?: VipProxyUncheckedUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUncheckedUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutVipProxiesAsProxyInput = {
    update: XOR<UserUpdateWithoutVipProxiesAsProxyInput, UserUncheckedUpdateWithoutVipProxiesAsProxyInput>
    create: XOR<UserCreateWithoutVipProxiesAsProxyInput, UserUncheckedCreateWithoutVipProxiesAsProxyInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVipProxiesAsProxyInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVipProxiesAsProxyInput, UserUncheckedUpdateWithoutVipProxiesAsProxyInput>
  }

  export type UserUpdateWithoutVipProxiesAsProxyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUpdateManyWithoutVipNestedInput
    vipSlaHistory?: VipSlaHistoryUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVipProxiesAsProxyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUncheckedUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUncheckedUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUncheckedUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUncheckedUpdateManyWithoutVipNestedInput
    vipSlaHistory?: VipSlaHistoryUncheckedUpdateManyWithoutUserNestedInput
    agentAvailability?: AgentAvailabilityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutVipSlaHistoryInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentCreateNestedManyWithoutUserInput
    xpEvents?: XpEventCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyCreateNestedManyWithoutProxyInput
    agentAvailability?: AgentAvailabilityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVipSlaHistoryInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingUncheckedCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentUncheckedCreateNestedManyWithoutUserInput
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventUncheckedCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyUncheckedCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyUncheckedCreateNestedManyWithoutProxyInput
    agentAvailability?: AgentAvailabilityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVipSlaHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVipSlaHistoryInput, UserUncheckedCreateWithoutVipSlaHistoryInput>
  }

  export type UserUpsertWithoutVipSlaHistoryInput = {
    update: XOR<UserUpdateWithoutVipSlaHistoryInput, UserUncheckedUpdateWithoutVipSlaHistoryInput>
    create: XOR<UserCreateWithoutVipSlaHistoryInput, UserUncheckedCreateWithoutVipSlaHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVipSlaHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVipSlaHistoryInput, UserUncheckedUpdateWithoutVipSlaHistoryInput>
  }

  export type UserUpdateWithoutVipSlaHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUpdateManyWithoutProxyNestedInput
    agentAvailability?: AgentAvailabilityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVipSlaHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUncheckedUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUncheckedUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUncheckedUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUncheckedUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUncheckedUpdateManyWithoutProxyNestedInput
    agentAvailability?: AgentAvailabilityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAgentAvailabilityInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentCreateNestedManyWithoutUserInput
    xpEvents?: XpEventCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAgentAvailabilityInput = {
    id?: string
    name?: string | null
    email: string
    passwordHash?: string | null
    disabled?: boolean
    isDefault?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: boolean
    samlNameId?: string | null
    samlSessionIndex?: string | null
    scimExternalId?: string | null
    department?: string | null
    lastSamlLogin?: Date | string | null
    isVip?: boolean
    vipLevel?: string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_assigneeIdTousersInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedCreateNestedManyWithoutUsers_support_tickets_userIdTousersInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    scimMappings?: ScimMappingUncheckedCreateNestedManyWithoutUserInput
    kbArticlesAuthored?: KbArticleUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedCreateNestedManyWithoutAuthorInput
    kbArticleComments?: KbArticleCommentUncheckedCreateNestedManyWithoutUserInput
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput
    leaderboard?: LeaderboardUncheckedCreateNestedOneWithoutUserInput
    mailroomPackages?: MailroomPackageUncheckedCreateNestedManyWithoutRecipientInput
    deliveryEvents?: DeliveryEventUncheckedCreateNestedManyWithoutUserInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedCreateNestedManyWithoutRecipientInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedCreateNestedManyWithoutProxyInput
    vipProxiesAsVip?: VipProxyUncheckedCreateNestedManyWithoutVipInput
    vipProxiesAsProxy?: VipProxyUncheckedCreateNestedManyWithoutProxyInput
    vipSlaHistory?: VipSlaHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAgentAvailabilityInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAgentAvailabilityInput, UserUncheckedCreateWithoutAgentAvailabilityInput>
  }

  export type UserUpsertWithoutAgentAvailabilityInput = {
    update: XOR<UserUpdateWithoutAgentAvailabilityInput, UserUncheckedUpdateWithoutAgentAvailabilityInput>
    create: XOR<UserCreateWithoutAgentAvailabilityInput, UserUncheckedCreateWithoutAgentAvailabilityInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAgentAvailabilityInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAgentAvailabilityInput, UserUncheckedUpdateWithoutAgentAvailabilityInput>
  }

  export type UserUpdateWithoutAgentAvailabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAgentAvailabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    twoFactorVerified?: BoolFieldUpdateOperationsInput | boolean
    samlNameId?: NullableStringFieldUpdateOperationsInput | string | null
    samlSessionIndex?: NullableStringFieldUpdateOperationsInput | string | null
    scimExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    lastSamlLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVip?: BoolFieldUpdateOperationsInput | boolean
    vipLevel?: NullableStringFieldUpdateOperationsInput | string | null
    vipSlaOverride?: NullableJsonNullValueInput | InputJsonValue
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    support_tickets_support_tickets_assigneeIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_assigneeIdTousersNestedInput
    support_tickets_support_tickets_userIdTousers?: SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_userIdTousersNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    scimMappings?: ScimMappingUncheckedUpdateManyWithoutUserNestedInput
    kbArticlesAuthored?: KbArticleUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleVersionsAuthored?: KbArticleVersionUncheckedUpdateManyWithoutAuthorNestedInput
    kbArticleComments?: KbArticleCommentUncheckedUpdateManyWithoutUserNestedInput
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput
    leaderboard?: LeaderboardUncheckedUpdateOneWithoutUserNestedInput
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutRecipientNestedInput
    deliveryEvents?: DeliveryEventUncheckedUpdateManyWithoutUserNestedInput
    proxyAuthorizationsAsRecipient?: ProxyAuthorizationUncheckedUpdateManyWithoutRecipientNestedInput
    proxyAuthorizationsAsProxy?: ProxyAuthorizationUncheckedUpdateManyWithoutProxyNestedInput
    vipProxiesAsVip?: VipProxyUncheckedUpdateManyWithoutVipNestedInput
    vipProxiesAsProxy?: VipProxyUncheckedUpdateManyWithoutProxyNestedInput
    vipSlaHistory?: VipSlaHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FeedbackCreateManyUserInput = {
    id?: number
    name?: string | null
    message?: string | null
    timestamp?: Date | string
  }

  export type LogCreateManyUserInput = {
    id?: number
    ticketId?: string | null
    name?: string | null
    email?: string | null
    title?: string | null
    system?: string | null
    urgency?: string | null
    timestamp?: Date | string
    emailStatus?: string | null
  }

  export type PasskeyCreateManyUserInput = {
    id?: number
    credentialId: string
    publicKey: string
    counter?: number
    transports?: string | null
    deviceType?: string | null
    backedUp?: boolean
    createdAt?: Date | string
    lastUsed?: Date | string | null
  }

  export type SupportTicketCreateManyUsers_support_tickets_assigneeIdTousersInput = {
    id?: number
    title: string
    description: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    vipPriorityScore?: number | null
    vipTriggerSource?: string | null
  }

  export type SupportTicketCreateManyUsers_support_tickets_userIdTousersInput = {
    id?: number
    title: string
    description: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assigneeId?: string | null
    vipPriorityScore?: number | null
    vipTriggerSource?: string | null
  }

  export type UserRoleCreateManyUserInput = {
    roleId: number
    assignedAt?: Date | string
  }

  export type ScimMappingCreateManyUserInput = {
    id?: string
    externalId?: string | null
    provider?: string | null
    syncTime?: Date | string | null
  }

  export type KbArticleCreateManyAuthorInput = {
    id?: number
    slug: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    currentVersionId?: number | null
    isPublished?: boolean
    tags?: KbArticleCreatetagsInput | string[]
  }

  export type KbArticleVersionCreateManyAuthorInput = {
    id?: number
    articleId: number
    content: string
    summary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: number
    isApproved?: boolean
  }

  export type KbArticleCommentCreateManyUserInput = {
    id?: number
    articleId: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type XpEventCreateManyUserInput = {
    id?: number
    amount: number
    reason?: string | null
    createdAt?: Date | string
  }

  export type MailroomPackageCreateManyRecipientInput = {
    id?: number
    trackingNumber: string
    carrier: string
    sender?: string | null
    department?: string | null
    packageType?: string | null
    status: string
    assignedLocation?: string | null
    linkedTicketId?: number | null
    linkedAssetId?: number | null
    flags?: MailroomPackageCreateflagsInput | string[]
    intakePhotoUrl?: string | null
    deliveryPhotoUrl?: string | null
    signatureUrl?: string | null
    intakeLocation?: string | null
    deliveryLocation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryEventCreateManyUserInput = {
    id?: number
    packageId: number
    eventType: string
    location?: string | null
    timestamp?: Date | string
    photoUrl?: string | null
    signatureBlob?: Uint8Array | null
  }

  export type ProxyAuthorizationCreateManyRecipientInput = {
    id?: number
    proxyId: string
    packageId: number
    expiration?: Date | string | null
    status: string
  }

  export type ProxyAuthorizationCreateManyProxyInput = {
    id?: number
    recipientId: string
    packageId: number
    expiration?: Date | string | null
    status: string
  }

  export type VipProxyCreateManyVipInput = {
    id?: number
    proxyId: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type VipProxyCreateManyProxyInput = {
    id?: number
    vipId: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type VipSlaHistoryCreateManyUserInput = {
    id?: number
    sla: JsonNullValueInput | InputJsonValue
    effectiveAt?: Date | string
    endedAt?: Date | string | null
  }

  export type AgentAvailabilityCreateManyUserInput = {
    id?: string
    queueName: string
    isAvailable?: boolean
    maxCapacity?: number
    currentLoad?: number
    status?: string
    lastUpdated?: Date | string
    createdAt?: Date | string
  }

  export type FeedbackUpdateWithoutUserInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUpdateWithoutUserInput = {
    ticketId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    emailStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    emailStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    emailStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasskeyUpdateWithoutUserInput = {
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    transports?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    backedUp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasskeyUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    transports?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    backedUp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasskeyUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    transports?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    backedUp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SupportTicketUpdateWithoutUsers_support_tickets_assigneeIdTousersInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vipPriorityScore?: NullableIntFieldUpdateOperationsInput | number | null
    vipTriggerSource?: NullableStringFieldUpdateOperationsInput | string | null
    users_support_tickets_userIdTousers?: UserUpdateOneWithoutSupport_tickets_support_tickets_userIdTousersNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutTicketNestedInput
    assetHistory?: AssetTicketHistoryUpdateManyWithoutTicketNestedInput
    ritms?: RITMUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutUsers_support_tickets_assigneeIdTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vipPriorityScore?: NullableIntFieldUpdateOperationsInput | number | null
    vipTriggerSource?: NullableStringFieldUpdateOperationsInput | string | null
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutTicketNestedInput
    assetHistory?: AssetTicketHistoryUncheckedUpdateManyWithoutTicketNestedInput
    ritms?: RITMUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_assigneeIdTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vipPriorityScore?: NullableIntFieldUpdateOperationsInput | number | null
    vipTriggerSource?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupportTicketUpdateWithoutUsers_support_tickets_userIdTousersInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vipPriorityScore?: NullableIntFieldUpdateOperationsInput | number | null
    vipTriggerSource?: NullableStringFieldUpdateOperationsInput | string | null
    users_support_tickets_assigneeIdTousers?: UserUpdateOneWithoutSupport_tickets_support_tickets_assigneeIdTousersNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutTicketNestedInput
    assetHistory?: AssetTicketHistoryUpdateManyWithoutTicketNestedInput
    ritms?: RITMUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutUsers_support_tickets_userIdTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    vipPriorityScore?: NullableIntFieldUpdateOperationsInput | number | null
    vipTriggerSource?: NullableStringFieldUpdateOperationsInput | string | null
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutTicketNestedInput
    assetHistory?: AssetTicketHistoryUncheckedUpdateManyWithoutTicketNestedInput
    ritms?: RITMUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateManyWithoutUsers_support_tickets_userIdTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    vipPriorityScore?: NullableIntFieldUpdateOperationsInput | number | null
    vipTriggerSource?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserRoleUpdateWithoutUserInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutUserInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateManyWithoutUserInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScimMappingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    syncTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ScimMappingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    syncTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ScimMappingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    syncTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KbArticleUpdateWithoutAuthorInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    tags?: KbArticleUpdatetagsInput | string[]
    versions?: KbArticleVersionUpdateManyWithoutArticleNestedInput
    comments?: KbArticleCommentUpdateManyWithoutArticleNestedInput
    currentVersion?: KbArticleVersionUpdateOneWithoutCurrentForArticleNestedInput
  }

  export type KbArticleUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentVersionId?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    tags?: KbArticleUpdatetagsInput | string[]
    versions?: KbArticleVersionUncheckedUpdateManyWithoutArticleNestedInput
    comments?: KbArticleCommentUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type KbArticleUncheckedUpdateManyWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentVersionId?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    tags?: KbArticleUpdatetagsInput | string[]
  }

  export type KbArticleVersionUpdateWithoutAuthorInput = {
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    article?: KbArticleUpdateOneRequiredWithoutVersionsNestedInput
    currentForArticle?: KbArticleUpdateManyWithoutCurrentVersionNestedInput
  }

  export type KbArticleVersionUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    currentForArticle?: KbArticleUncheckedUpdateManyWithoutCurrentVersionNestedInput
  }

  export type KbArticleVersionUncheckedUpdateManyWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type KbArticleCommentUpdateWithoutUserInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    article?: KbArticleUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type KbArticleCommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type KbArticleCommentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type XpEventUpdateWithoutUserInput = {
    amount?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XpEventUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XpEventUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MailroomPackageUpdateWithoutRecipientInput = {
    trackingNumber?: StringFieldUpdateOperationsInput | string
    carrier?: StringFieldUpdateOperationsInput | string
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    packageType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    assignedLocation?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: MailroomPackageUpdateflagsInput | string[]
    intakePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    intakeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryLocation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: SupportTicketUpdateOneWithoutMailroomPackagesNestedInput
    asset?: InventoryAssetUpdateOneWithoutMailroomPackagesNestedInput
    deliveryEvents?: DeliveryEventUpdateManyWithoutPackageNestedInput
    proxyAuthorizations?: ProxyAuthorizationUpdateManyWithoutPackageNestedInput
  }

  export type MailroomPackageUncheckedUpdateWithoutRecipientInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackingNumber?: StringFieldUpdateOperationsInput | string
    carrier?: StringFieldUpdateOperationsInput | string
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    packageType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    assignedLocation?: NullableStringFieldUpdateOperationsInput | string | null
    linkedTicketId?: NullableIntFieldUpdateOperationsInput | number | null
    linkedAssetId?: NullableIntFieldUpdateOperationsInput | number | null
    flags?: MailroomPackageUpdateflagsInput | string[]
    intakePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    intakeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryLocation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryEvents?: DeliveryEventUncheckedUpdateManyWithoutPackageNestedInput
    proxyAuthorizations?: ProxyAuthorizationUncheckedUpdateManyWithoutPackageNestedInput
  }

  export type MailroomPackageUncheckedUpdateManyWithoutRecipientInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackingNumber?: StringFieldUpdateOperationsInput | string
    carrier?: StringFieldUpdateOperationsInput | string
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    packageType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    assignedLocation?: NullableStringFieldUpdateOperationsInput | string | null
    linkedTicketId?: NullableIntFieldUpdateOperationsInput | number | null
    linkedAssetId?: NullableIntFieldUpdateOperationsInput | number | null
    flags?: MailroomPackageUpdateflagsInput | string[]
    intakePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    intakeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryLocation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryEventUpdateWithoutUserInput = {
    eventType?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatureBlob?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    package?: MailroomPackageUpdateOneRequiredWithoutDeliveryEventsNestedInput
  }

  export type DeliveryEventUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    packageId?: IntFieldUpdateOperationsInput | number
    eventType?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatureBlob?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type DeliveryEventUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    packageId?: IntFieldUpdateOperationsInput | number
    eventType?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatureBlob?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type ProxyAuthorizationUpdateWithoutRecipientInput = {
    expiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    proxy?: UserUpdateOneRequiredWithoutProxyAuthorizationsAsProxyNestedInput
    package?: MailroomPackageUpdateOneRequiredWithoutProxyAuthorizationsNestedInput
  }

  export type ProxyAuthorizationUncheckedUpdateWithoutRecipientInput = {
    id?: IntFieldUpdateOperationsInput | number
    proxyId?: StringFieldUpdateOperationsInput | string
    packageId?: IntFieldUpdateOperationsInput | number
    expiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ProxyAuthorizationUncheckedUpdateManyWithoutRecipientInput = {
    id?: IntFieldUpdateOperationsInput | number
    proxyId?: StringFieldUpdateOperationsInput | string
    packageId?: IntFieldUpdateOperationsInput | number
    expiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ProxyAuthorizationUpdateWithoutProxyInput = {
    expiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    recipient?: UserUpdateOneRequiredWithoutProxyAuthorizationsAsRecipientNestedInput
    package?: MailroomPackageUpdateOneRequiredWithoutProxyAuthorizationsNestedInput
  }

  export type ProxyAuthorizationUncheckedUpdateWithoutProxyInput = {
    id?: IntFieldUpdateOperationsInput | number
    recipientId?: StringFieldUpdateOperationsInput | string
    packageId?: IntFieldUpdateOperationsInput | number
    expiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ProxyAuthorizationUncheckedUpdateManyWithoutProxyInput = {
    id?: IntFieldUpdateOperationsInput | number
    recipientId?: StringFieldUpdateOperationsInput | string
    packageId?: IntFieldUpdateOperationsInput | number
    expiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type VipProxyUpdateWithoutVipInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proxy?: UserUpdateOneRequiredWithoutVipProxiesAsProxyNestedInput
  }

  export type VipProxyUncheckedUpdateWithoutVipInput = {
    id?: IntFieldUpdateOperationsInput | number
    proxyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VipProxyUncheckedUpdateManyWithoutVipInput = {
    id?: IntFieldUpdateOperationsInput | number
    proxyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VipProxyUpdateWithoutProxyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vip?: UserUpdateOneRequiredWithoutVipProxiesAsVipNestedInput
  }

  export type VipProxyUncheckedUpdateWithoutProxyInput = {
    id?: IntFieldUpdateOperationsInput | number
    vipId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VipProxyUncheckedUpdateManyWithoutProxyInput = {
    id?: IntFieldUpdateOperationsInput | number
    vipId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VipSlaHistoryUpdateWithoutUserInput = {
    sla?: JsonNullValueInput | InputJsonValue
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VipSlaHistoryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    sla?: JsonNullValueInput | InputJsonValue
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VipSlaHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    sla?: JsonNullValueInput | InputJsonValue
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AgentAvailabilityUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    queueName?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentLoad?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentAvailabilityUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    queueName?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentLoad?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentAvailabilityUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    queueName?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentLoad?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyRoleInput = {
    permissionId: number
    assignedAt?: Date | string
  }

  export type UserRoleCreateManyRoleInput = {
    userId: string
    assignedAt?: Date | string
  }

  export type RolePermissionUpdateWithoutRoleInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permission?: PermissionUpdateOneRequiredWithoutRolesNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutRoleInput = {
    permissionId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleInput = {
    permissionId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUpdateWithoutRoleInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutRoleInput = {
    userId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleInput = {
    userId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyPermissionInput = {
    roleId: number
    assignedAt?: Date | string
  }

  export type RolePermissionUpdateWithoutPermissionInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutPermissionInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigHistoryCreateManyConfigInput = {
    id?: number
    oldValue?: string | null
    newValue?: string | null
    changedBy?: string | null
    changeReason?: string | null
    createdAt?: Date | string
  }

  export type ConfigHistoryUpdateWithoutConfigInput = {
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigHistoryUncheckedUpdateWithoutConfigInput = {
    id?: IntFieldUpdateOperationsInput | number
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigHistoryUncheckedUpdateManyWithoutConfigInput = {
    id?: IntFieldUpdateOperationsInput | number
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KioskActivationCreateManyKioskInput = {
    id: string
    code: string
    qrCode: string
    expiresAt: Date | string
    used?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type KioskAssetRegistryCreateManyKioskInput = {
    id?: number
    assetId: number
    registrationDate?: Date | string
    lastCheckIn?: Date | string | null
    status?: string
    helixSyncStatus?: string
    helixLastSync?: Date | string | null
    helixErrorMessage?: string | null
    encryptedMetadata?: string | null
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type HelixSyncFailureCreateManyKioskInput = {
    id?: number
    assetId: number
    errorMessage: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: number
    nextRetryAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KioskMetadataLogCreateManyKioskInput = {
    id?: number
    metadataType: string
    encryptedMetadata?: string | null
    collectionTimestamp?: Date | string
  }

  export type KioskActivationUpdateWithoutKioskInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    qrCode?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KioskActivationUncheckedUpdateWithoutKioskInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    qrCode?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KioskActivationUncheckedUpdateManyWithoutKioskInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    qrCode?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KioskAssetRegistryUpdateWithoutKioskInput = {
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    helixSyncStatus?: StringFieldUpdateOperationsInput | string
    helixLastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    helixErrorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    asset?: InventoryAssetUpdateOneRequiredWithoutKioskRegistrationsNestedInput
  }

  export type KioskAssetRegistryUncheckedUpdateWithoutKioskInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetId?: IntFieldUpdateOperationsInput | number
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    helixSyncStatus?: StringFieldUpdateOperationsInput | string
    helixLastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    helixErrorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KioskAssetRegistryUncheckedUpdateManyWithoutKioskInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetId?: IntFieldUpdateOperationsInput | number
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    helixSyncStatus?: StringFieldUpdateOperationsInput | string
    helixLastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    helixErrorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HelixSyncFailureUpdateWithoutKioskInput = {
    errorMessage?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asset?: InventoryAssetUpdateOneRequiredWithoutSyncFailuresNestedInput
  }

  export type HelixSyncFailureUncheckedUpdateWithoutKioskInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetId?: IntFieldUpdateOperationsInput | number
    errorMessage?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelixSyncFailureUncheckedUpdateManyWithoutKioskInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetId?: IntFieldUpdateOperationsInput | number
    errorMessage?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KioskMetadataLogUpdateWithoutKioskInput = {
    metadataType?: StringFieldUpdateOperationsInput | string
    encryptedMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    collectionTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KioskMetadataLogUncheckedUpdateWithoutKioskInput = {
    id?: IntFieldUpdateOperationsInput | number
    metadataType?: StringFieldUpdateOperationsInput | string
    encryptedMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    collectionTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KioskMetadataLogUncheckedUpdateManyWithoutKioskInput = {
    id?: IntFieldUpdateOperationsInput | number
    metadataType?: StringFieldUpdateOperationsInput | string
    encryptedMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    collectionTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KbArticleVersionCreateManyArticleInput = {
    id?: number
    content: string
    summary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId?: string | null
    version?: number
    isApproved?: boolean
  }

  export type KbArticleCommentCreateManyArticleInput = {
    id?: number
    userId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type KbArticleVersionUpdateWithoutArticleInput = {
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    author?: UserUpdateOneWithoutKbArticleVersionsAuthoredNestedInput
    currentForArticle?: KbArticleUpdateManyWithoutCurrentVersionNestedInput
  }

  export type KbArticleVersionUncheckedUpdateWithoutArticleInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    currentForArticle?: KbArticleUncheckedUpdateManyWithoutCurrentVersionNestedInput
  }

  export type KbArticleVersionUncheckedUpdateManyWithoutArticleInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type KbArticleCommentUpdateWithoutArticleInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutKbArticleCommentsNestedInput
  }

  export type KbArticleCommentUncheckedUpdateWithoutArticleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type KbArticleCommentUncheckedUpdateManyWithoutArticleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type KbArticleCreateManyCurrentVersionInput = {
    id?: number
    slug: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId?: string | null
    isPublished?: boolean
    tags?: KbArticleCreatetagsInput | string[]
  }

  export type KbArticleUpdateWithoutCurrentVersionInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    tags?: KbArticleUpdatetagsInput | string[]
    author?: UserUpdateOneWithoutKbArticlesAuthoredNestedInput
    versions?: KbArticleVersionUpdateManyWithoutArticleNestedInput
    comments?: KbArticleCommentUpdateManyWithoutArticleNestedInput
  }

  export type KbArticleUncheckedUpdateWithoutCurrentVersionInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    tags?: KbArticleUpdatetagsInput | string[]
    versions?: KbArticleVersionUncheckedUpdateManyWithoutArticleNestedInput
    comments?: KbArticleCommentUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type KbArticleUncheckedUpdateManyWithoutCurrentVersionInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    tags?: KbArticleUpdatetagsInput | string[]
  }

  export type MailroomPackageCreateManyTicketInput = {
    id?: number
    trackingNumber: string
    carrier: string
    sender?: string | null
    recipientId: string
    department?: string | null
    packageType?: string | null
    status: string
    assignedLocation?: string | null
    linkedAssetId?: number | null
    flags?: MailroomPackageCreateflagsInput | string[]
    intakePhotoUrl?: string | null
    deliveryPhotoUrl?: string | null
    signatureUrl?: string | null
    intakeLocation?: string | null
    deliveryLocation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetTicketHistoryCreateManyTicketInput = {
    id?: number
    assetId: number
    relationshipType: string
    createdAt?: Date | string
    endedAt?: Date | string | null
    createdBy?: string | null
    notes?: string | null
  }

  export type RITMCreateManyTicketInput = {
    id?: number
    catalogItemId: number
    status?: string
  }

  export type MailroomPackageUpdateWithoutTicketInput = {
    trackingNumber?: StringFieldUpdateOperationsInput | string
    carrier?: StringFieldUpdateOperationsInput | string
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    packageType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    assignedLocation?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: MailroomPackageUpdateflagsInput | string[]
    intakePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    intakeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryLocation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: UserUpdateOneRequiredWithoutMailroomPackagesNestedInput
    asset?: InventoryAssetUpdateOneWithoutMailroomPackagesNestedInput
    deliveryEvents?: DeliveryEventUpdateManyWithoutPackageNestedInput
    proxyAuthorizations?: ProxyAuthorizationUpdateManyWithoutPackageNestedInput
  }

  export type MailroomPackageUncheckedUpdateWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackingNumber?: StringFieldUpdateOperationsInput | string
    carrier?: StringFieldUpdateOperationsInput | string
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    recipientId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    packageType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    assignedLocation?: NullableStringFieldUpdateOperationsInput | string | null
    linkedAssetId?: NullableIntFieldUpdateOperationsInput | number | null
    flags?: MailroomPackageUpdateflagsInput | string[]
    intakePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    intakeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryLocation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryEvents?: DeliveryEventUncheckedUpdateManyWithoutPackageNestedInput
    proxyAuthorizations?: ProxyAuthorizationUncheckedUpdateManyWithoutPackageNestedInput
  }

  export type MailroomPackageUncheckedUpdateManyWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackingNumber?: StringFieldUpdateOperationsInput | string
    carrier?: StringFieldUpdateOperationsInput | string
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    recipientId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    packageType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    assignedLocation?: NullableStringFieldUpdateOperationsInput | string | null
    linkedAssetId?: NullableIntFieldUpdateOperationsInput | number | null
    flags?: MailroomPackageUpdateflagsInput | string[]
    intakePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    intakeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryLocation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetTicketHistoryUpdateWithoutTicketInput = {
    relationshipType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    asset?: InventoryAssetUpdateOneRequiredWithoutTicketHistoryNestedInput
  }

  export type AssetTicketHistoryUncheckedUpdateWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetId?: IntFieldUpdateOperationsInput | number
    relationshipType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetTicketHistoryUncheckedUpdateManyWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetId?: IntFieldUpdateOperationsInput | number
    relationshipType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RITMUpdateWithoutTicketInput = {
    status?: StringFieldUpdateOperationsInput | string
    catalogItem?: RequestCatalogItemUpdateOneRequiredWithoutRitmsNestedInput
  }

  export type RITMUncheckedUpdateWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    catalogItemId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type RITMUncheckedUpdateManyWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    catalogItemId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type AssetStatusLogCreateManyAssetInput = {
    id?: number
    previousStatus?: string | null
    newStatus: string
    changedByUserId?: string | null
    notes?: string | null
    timestamp?: Date | string
  }

  export type AssetAssignmentCreateManyAssetInput = {
    id?: number
    userId?: string | null
    orgId?: number | null
    customerId?: number | null
    assignedBy?: string | null
    assignedDate?: Date | string
    expectedReturn?: Date | string | null
    returnDate?: Date | string | null
    managerId?: string | null
  }

  export type MailroomPackageCreateManyAssetInput = {
    id?: number
    trackingNumber: string
    carrier: string
    sender?: string | null
    recipientId: string
    department?: string | null
    packageType?: string | null
    status: string
    assignedLocation?: string | null
    linkedTicketId?: number | null
    flags?: MailroomPackageCreateflagsInput | string[]
    intakePhotoUrl?: string | null
    deliveryPhotoUrl?: string | null
    signatureUrl?: string | null
    intakeLocation?: string | null
    deliveryLocation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetTicketHistoryCreateManyAssetInput = {
    id?: number
    ticketId: number
    relationshipType: string
    createdAt?: Date | string
    endedAt?: Date | string | null
    createdBy?: string | null
    notes?: string | null
  }

  export type AssetWarrantyAlertCreateManyAssetInput = {
    id?: number
    alertType: string
    alertDate?: Date | string
    expiryDate: Date | string
    daysRemaining: number
    notificationSent?: boolean
    notificationSentAt?: Date | string | null
    dismissed?: boolean
    dismissedBy?: string | null
    dismissedAt?: Date | string | null
  }

  export type KioskAssetRegistryCreateManyAssetInput = {
    id?: number
    kioskId: string
    registrationDate?: Date | string
    lastCheckIn?: Date | string | null
    status?: string
    helixSyncStatus?: string
    helixLastSync?: Date | string | null
    helixErrorMessage?: string | null
    encryptedMetadata?: string | null
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type AssetValidationLogCreateManyAssetInput = {
    id?: number
    batchId: string
    rowNumber: number
    validationLevel: string
    fieldName?: string | null
    message: string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type HelixSyncFailureCreateManyAssetInput = {
    id?: number
    kioskId: string
    errorMessage: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: number
    nextRetryAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetStatusLogUpdateWithoutAssetInput = {
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    changedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetStatusLogUncheckedUpdateWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    changedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetStatusLogUncheckedUpdateManyWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    previousStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    changedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetAssignmentUpdateWithoutAssetInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedReturn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetAssignmentUncheckedUpdateWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedReturn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetAssignmentUncheckedUpdateManyWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orgId?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedReturn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MailroomPackageUpdateWithoutAssetInput = {
    trackingNumber?: StringFieldUpdateOperationsInput | string
    carrier?: StringFieldUpdateOperationsInput | string
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    packageType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    assignedLocation?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: MailroomPackageUpdateflagsInput | string[]
    intakePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    intakeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryLocation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: UserUpdateOneRequiredWithoutMailroomPackagesNestedInput
    ticket?: SupportTicketUpdateOneWithoutMailroomPackagesNestedInput
    deliveryEvents?: DeliveryEventUpdateManyWithoutPackageNestedInput
    proxyAuthorizations?: ProxyAuthorizationUpdateManyWithoutPackageNestedInput
  }

  export type MailroomPackageUncheckedUpdateWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackingNumber?: StringFieldUpdateOperationsInput | string
    carrier?: StringFieldUpdateOperationsInput | string
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    recipientId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    packageType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    assignedLocation?: NullableStringFieldUpdateOperationsInput | string | null
    linkedTicketId?: NullableIntFieldUpdateOperationsInput | number | null
    flags?: MailroomPackageUpdateflagsInput | string[]
    intakePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    intakeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryLocation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryEvents?: DeliveryEventUncheckedUpdateManyWithoutPackageNestedInput
    proxyAuthorizations?: ProxyAuthorizationUncheckedUpdateManyWithoutPackageNestedInput
  }

  export type MailroomPackageUncheckedUpdateManyWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackingNumber?: StringFieldUpdateOperationsInput | string
    carrier?: StringFieldUpdateOperationsInput | string
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    recipientId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    packageType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    assignedLocation?: NullableStringFieldUpdateOperationsInput | string | null
    linkedTicketId?: NullableIntFieldUpdateOperationsInput | number | null
    flags?: MailroomPackageUpdateflagsInput | string[]
    intakePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    intakeLocation?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryLocation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetTicketHistoryUpdateWithoutAssetInput = {
    relationshipType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ticket?: SupportTicketUpdateOneRequiredWithoutAssetHistoryNestedInput
  }

  export type AssetTicketHistoryUncheckedUpdateWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    relationshipType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetTicketHistoryUncheckedUpdateManyWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    relationshipType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetWarrantyAlertUpdateWithoutAssetInput = {
    alertType?: StringFieldUpdateOperationsInput | string
    alertDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    daysRemaining?: IntFieldUpdateOperationsInput | number
    notificationSent?: BoolFieldUpdateOperationsInput | boolean
    notificationSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissed?: BoolFieldUpdateOperationsInput | boolean
    dismissedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssetWarrantyAlertUncheckedUpdateWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    alertType?: StringFieldUpdateOperationsInput | string
    alertDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    daysRemaining?: IntFieldUpdateOperationsInput | number
    notificationSent?: BoolFieldUpdateOperationsInput | boolean
    notificationSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissed?: BoolFieldUpdateOperationsInput | boolean
    dismissedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssetWarrantyAlertUncheckedUpdateManyWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    alertType?: StringFieldUpdateOperationsInput | string
    alertDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    daysRemaining?: IntFieldUpdateOperationsInput | number
    notificationSent?: BoolFieldUpdateOperationsInput | boolean
    notificationSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissed?: BoolFieldUpdateOperationsInput | boolean
    dismissedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KioskAssetRegistryUpdateWithoutAssetInput = {
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    helixSyncStatus?: StringFieldUpdateOperationsInput | string
    helixLastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    helixErrorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    kiosk?: KioskUpdateOneRequiredWithoutAssetRegistryNestedInput
  }

  export type KioskAssetRegistryUncheckedUpdateWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    kioskId?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    helixSyncStatus?: StringFieldUpdateOperationsInput | string
    helixLastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    helixErrorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KioskAssetRegistryUncheckedUpdateManyWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    kioskId?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    helixSyncStatus?: StringFieldUpdateOperationsInput | string
    helixLastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    helixErrorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetValidationLogUpdateWithoutAssetInput = {
    rowNumber?: IntFieldUpdateOperationsInput | number
    validationLevel?: StringFieldUpdateOperationsInput | string
    fieldName?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: AssetImportBatchUpdateOneRequiredWithoutValidationLogsNestedInput
  }

  export type AssetValidationLogUncheckedUpdateWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    batchId?: StringFieldUpdateOperationsInput | string
    rowNumber?: IntFieldUpdateOperationsInput | number
    validationLevel?: StringFieldUpdateOperationsInput | string
    fieldName?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetValidationLogUncheckedUpdateManyWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    batchId?: StringFieldUpdateOperationsInput | string
    rowNumber?: IntFieldUpdateOperationsInput | number
    validationLevel?: StringFieldUpdateOperationsInput | string
    fieldName?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelixSyncFailureUpdateWithoutAssetInput = {
    errorMessage?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kiosk?: KioskUpdateOneRequiredWithoutSyncFailuresNestedInput
  }

  export type HelixSyncFailureUncheckedUpdateWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    kioskId?: StringFieldUpdateOperationsInput | string
    errorMessage?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelixSyncFailureUncheckedUpdateManyWithoutAssetInput = {
    id?: IntFieldUpdateOperationsInput | number
    kioskId?: StringFieldUpdateOperationsInput | string
    errorMessage?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryAssetCreateManyImportBatchInput = {
    id?: number
    assetTag: string
    typeId?: number | null
    serialNumber?: string | null
    model?: string | null
    vendorId?: number | null
    purchaseDate?: Date | string | null
    warrantyExpiry?: Date | string | null
    assignedToUserId?: string | null
    assignedToOrgId?: number | null
    assignedToCustomerId?: number | null
    department?: string | null
    status?: string | null
    locationId?: number | null
    kioskId?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serialNumberEnc?: string | null
    warrantyInfoEnc?: string | null
    purchaseInfoEnc?: string | null
    maintenanceNotesEnc?: string | null
    warrantyAlertDays?: number | null
    warrantyAlertEnabled?: boolean
    lastWarrantyAlertSent?: Date | string | null
    importSource?: string | null
    importValidated?: boolean
    validationErrors?: string | null
  }

  export type AssetValidationLogCreateManyBatchInput = {
    id?: number
    assetId?: number | null
    rowNumber: number
    validationLevel: string
    fieldName?: string | null
    message: string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type InventoryAssetUpdateWithoutImportBatchInput = {
    assetTag?: StringFieldUpdateOperationsInput | string
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToOrgId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedToCustomerId?: NullableIntFieldUpdateOperationsInput | number | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    kioskId?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serialNumberEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyAlertDays?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyAlertEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastWarrantyAlertSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importSource?: NullableStringFieldUpdateOperationsInput | string | null
    importValidated?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableStringFieldUpdateOperationsInput | string | null
    statusLogs?: AssetStatusLogUpdateManyWithoutAssetNestedInput
    assignments?: AssetAssignmentUpdateManyWithoutAssetNestedInput
    mailroomPackages?: MailroomPackageUpdateManyWithoutAssetNestedInput
    ticketHistory?: AssetTicketHistoryUpdateManyWithoutAssetNestedInput
    warrantyAlerts?: AssetWarrantyAlertUpdateManyWithoutAssetNestedInput
    kioskRegistrations?: KioskAssetRegistryUpdateManyWithoutAssetNestedInput
    validationLogs?: AssetValidationLogUpdateManyWithoutAssetNestedInput
    syncFailures?: HelixSyncFailureUpdateManyWithoutAssetNestedInput
  }

  export type InventoryAssetUncheckedUpdateWithoutImportBatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetTag?: StringFieldUpdateOperationsInput | string
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToOrgId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedToCustomerId?: NullableIntFieldUpdateOperationsInput | number | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    kioskId?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serialNumberEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyAlertDays?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyAlertEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastWarrantyAlertSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importSource?: NullableStringFieldUpdateOperationsInput | string | null
    importValidated?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableStringFieldUpdateOperationsInput | string | null
    statusLogs?: AssetStatusLogUncheckedUpdateManyWithoutAssetNestedInput
    assignments?: AssetAssignmentUncheckedUpdateManyWithoutAssetNestedInput
    mailroomPackages?: MailroomPackageUncheckedUpdateManyWithoutAssetNestedInput
    ticketHistory?: AssetTicketHistoryUncheckedUpdateManyWithoutAssetNestedInput
    warrantyAlerts?: AssetWarrantyAlertUncheckedUpdateManyWithoutAssetNestedInput
    kioskRegistrations?: KioskAssetRegistryUncheckedUpdateManyWithoutAssetNestedInput
    validationLogs?: AssetValidationLogUncheckedUpdateManyWithoutAssetNestedInput
    syncFailures?: HelixSyncFailureUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type InventoryAssetUncheckedUpdateManyWithoutImportBatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetTag?: StringFieldUpdateOperationsInput | string
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToOrgId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedToCustomerId?: NullableIntFieldUpdateOperationsInput | number | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    kioskId?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serialNumberEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseInfoEnc?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotesEnc?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyAlertDays?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyAlertEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastWarrantyAlertSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importSource?: NullableStringFieldUpdateOperationsInput | string | null
    importValidated?: BoolFieldUpdateOperationsInput | boolean
    validationErrors?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetValidationLogUpdateWithoutBatchInput = {
    rowNumber?: IntFieldUpdateOperationsInput | number
    validationLevel?: StringFieldUpdateOperationsInput | string
    fieldName?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asset?: InventoryAssetUpdateOneWithoutValidationLogsNestedInput
  }

  export type AssetValidationLogUncheckedUpdateWithoutBatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetId?: NullableIntFieldUpdateOperationsInput | number | null
    rowNumber?: IntFieldUpdateOperationsInput | number
    validationLevel?: StringFieldUpdateOperationsInput | string
    fieldName?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetValidationLogUncheckedUpdateManyWithoutBatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetId?: NullableIntFieldUpdateOperationsInput | number | null
    rowNumber?: IntFieldUpdateOperationsInput | number
    validationLevel?: StringFieldUpdateOperationsInput | string
    fieldName?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryEventCreateManyPackageInput = {
    id?: number
    eventType: string
    performedBy: string
    location?: string | null
    timestamp?: Date | string
    photoUrl?: string | null
    signatureBlob?: Uint8Array | null
  }

  export type ProxyAuthorizationCreateManyPackageInput = {
    id?: number
    recipientId: string
    proxyId: string
    expiration?: Date | string | null
    status: string
  }

  export type DeliveryEventUpdateWithoutPackageInput = {
    eventType?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatureBlob?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    user?: UserUpdateOneRequiredWithoutDeliveryEventsNestedInput
  }

  export type DeliveryEventUncheckedUpdateWithoutPackageInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventType?: StringFieldUpdateOperationsInput | string
    performedBy?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatureBlob?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type DeliveryEventUncheckedUpdateManyWithoutPackageInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventType?: StringFieldUpdateOperationsInput | string
    performedBy?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatureBlob?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type ProxyAuthorizationUpdateWithoutPackageInput = {
    expiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    recipient?: UserUpdateOneRequiredWithoutProxyAuthorizationsAsRecipientNestedInput
    proxy?: UserUpdateOneRequiredWithoutProxyAuthorizationsAsProxyNestedInput
  }

  export type ProxyAuthorizationUncheckedUpdateWithoutPackageInput = {
    id?: IntFieldUpdateOperationsInput | number
    recipientId?: StringFieldUpdateOperationsInput | string
    proxyId?: StringFieldUpdateOperationsInput | string
    expiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ProxyAuthorizationUncheckedUpdateManyWithoutPackageInput = {
    id?: IntFieldUpdateOperationsInput | number
    recipientId?: StringFieldUpdateOperationsInput | string
    proxyId?: StringFieldUpdateOperationsInput | string
    expiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type RITMCreateManyCatalogItemInput = {
    id?: number
    reqId: number
    status?: string
  }

  export type RITMUpdateWithoutCatalogItemInput = {
    status?: StringFieldUpdateOperationsInput | string
    ticket?: SupportTicketUpdateOneRequiredWithoutRitmsNestedInput
  }

  export type RITMUncheckedUpdateWithoutCatalogItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    reqId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type RITMUncheckedUpdateManyWithoutCatalogItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    reqId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}